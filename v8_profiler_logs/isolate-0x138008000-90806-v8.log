v8-version,10,2,154,26,-node.26,0
v8-platform,macos,macos
shared-library,/Users/miriam/.nvm/versions/node/v18.17.0/bin/node,0x100a7c000,0x101ddb0a4,10977280
shared-library,/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation,0x195ae98a0,0x195cd804c,359383040
shared-library,/usr/lib/libobjc.A.dylib,0x195715c00,0x19574a6b0,359383040
shared-library,/System/Library/PrivateFrameworks/CoreServicesInternal.framework/Versions/A/CoreServicesInternal,0x198bfcd78,0x198c32f70,359383040
shared-library,/usr/lib/liboah.dylib,0x1a1110e48,0x1a1115e18,359383040
shared-library,/usr/lib/libfakelink.dylib,0x1a11443dc,0x1a1145b80,359383040
shared-library,/usr/lib/libicucore.A.dylib,0x19863350c,0x198881320,359383040
shared-library,/usr/lib/libSystem.B.dylib,0x1a11414b4,0x1a1141aec,359383040
shared-library,/System/Library/PrivateFrameworks/SoftLinking.framework/Versions/A/SoftLinking,0x1a1146bd4,0x1a1146e50,359383040
shared-library,/usr/lib/libc++abi.dylib,0x195a32820,0x195a45dd8,359383040
shared-library,/usr/lib/libc++.1.dylib,0x1959cea60,0x195a26524,359383040
shared-library,/usr/lib/system/libcache.dylib,0x1a113b6a4,0x1a113e370,359383040
shared-library,/usr/lib/system/libcommonCrypto.dylib,0x1a10f7980,0x1a1102a94,359383040
shared-library,/usr/lib/system/libcompiler_rt.dylib,0x1a112199c,0x1a1124864,359383040
shared-library,/usr/lib/system/libcopyfile.dylib,0x1a1118828,0x1a111f020,359383040
shared-library,/usr/lib/system/libcorecrypto.dylib,0x195848e00,0x1958b3e38,359383040
shared-library,/usr/lib/system/libdispatch.dylib,0x1958fffd4,0x19593cdd8,359383040
shared-library,/usr/lib/system/libdyld.dylib,0x195a91510,0x195ab24a8,359383040
shared-library,/usr/lib/system/libkeymgr.dylib,0x1a1130764,0x1a1130e50,359383040
shared-library,/usr/lib/system/libmacho.dylib,0x1a10d2640,0x1a10d69bc,359383040
shared-library,/usr/lib/system/libquarantine.dylib,0x1a078fbc8,0x1a0791ba8,359383040
shared-library,/usr/lib/system/libremovefile.dylib,0x1a112e448,0x1a112fc40,359383040
shared-library,/usr/lib/system/libsystem_asl.dylib,0x19a7593c4,0x19a76e000,359383040
shared-library,/usr/lib/system/libsystem_blocks.dylib,0x1957e69a8,0x1957e98d0,359383040
shared-library,/usr/lib/system/libsystem_c.dylib,0x19594a120,0x1959c2b20,359383040
shared-library,/usr/lib/system/libsystem_collections.dylib,0x1a1125878,0x1a1129958,359383040
shared-library,/usr/lib/system/libsystem_configuration.dylib,0x19fcb054c,0x19fcb3700,359383040
shared-library,/usr/lib/system/libsystem_containermanager.dylib,0x19ed1f3fc,0x19ed486a8,359383040
shared-library,/usr/lib/system/libsystem_coreservices.dylib,0x1a0dd10d4,0x1a0dd50d8,359383040
shared-library,/usr/lib/system/libsystem_darwin.dylib,0x1988ea418,0x1988f1170,359383040
shared-library,/usr/lib/system/libsystem_dnssd.dylib,0x1a1131e2c,0x1a1137f88,359383040
shared-library,/usr/lib/system/libsystem_featureflags.dylib,0x1959469c8,0x195948a50,359383040
shared-library,/usr/lib/system/libsystem_info.dylib,0x195abccd0,0x195ae33d0,359383040
shared-library,/usr/lib/system/libsystem_m.dylib,0x1a1099080,0x1a10c0ec0,359383040
shared-library,/usr/lib/system/libsystem_malloc.dylib,0x1958d2ccc,0x1958f8060,359383040
shared-library,/usr/lib/system/libsystem_networkextension.dylib,0x19a6d9aa4,0x19a6ecaf0,359383040
shared-library,/usr/lib/system/libsystem_notify.dylib,0x198d54888,0x198d61bf0,359383040
shared-library,/usr/lib/system/libsystem_sandbox.dylib,0x19fcb5438,0x19fcb9040,359383040
shared-library,/usr/lib/system/libsystem_secinit.dylib,0x1a112ad90,0x1a112c388,359383040
shared-library,/usr/lib/system/libsystem_kernel.dylib,0x195a49be0,0x195a7be78,359383040
shared-library,/usr/lib/system/libsystem_platform.dylib,0x195ab5340,0x195abb2e4,359383040
shared-library,/usr/lib/system/libsystem_pthread.dylib,0x195a83ae4,0x195a8e8d0,359383040
shared-library,/usr/lib/system/libsystem_symptoms.dylib,0x19bf2e6b0,0x19bf342bc,359383040
shared-library,/usr/lib/system/libsystem_trace.dylib,0x19582f4a0,0x195844c10,359383040
shared-library,/usr/lib/system/libunwind.dylib,0x1a1108b44,0x1a110e3c0,359383040
shared-library,/usr/lib/system/libxpc.dylib,0x1957ebfe4,0x195822868,359383040
shared-library,/System/Library/Frameworks/IOKit.framework/Versions/A/IOKit,0x198c78668,0x198d2b370,359383040
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/CoreServices,0x1a7823fc0,0x1a7823fc0,359383040
shared-library,/usr/lib/libDiagnosticMessagesClient.dylib,0x19cd51e80,0x19cd52ad8,359383040
shared-library,/usr/lib/libenergytrace.dylib,0x19a6f26a4,0x19a6f2d28,359383040
shared-library,/usr/lib/libbsm.0.dylib,0x1a07ba950,0x1a07c8d58,359383040
shared-library,/usr/lib/libz.1.dylib,0x1a1086770,0x1a1091c10,359383040
shared-library,/usr/lib/system/libkxld.dylib,0x1a10d976c,0x1a10f1a74,359383040
shared-library,/System/Library/Frameworks/CFNetwork.framework/Versions/A/CFNetwork,0x19a317f20,0x19a58b8b0,359383040
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/FSEvents.framework/Versions/A/FSEvents,0x19d83ede4,0x19d848de0,359383040
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/CarbonCore.framework/Versions/A/CarbonCore,0x1988f8fbc,0x1989e8dd0,359383040
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/Metadata.framework/Versions/A/Metadata,0x19cd95b90,0x19ce16148,359383040
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/OSServices.framework/Versions/A/OSServices,0x1a0dd7c58,0x1a0e01e08,359383040
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/SearchKit.framework/Versions/A/SearchKit,0x1a13098c4,0x1a136afa0,359383040
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/AE.framework/Versions/A/AE,0x19beb10c0,0x19bf142d0,359383040
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/LaunchServices,0x195fc26d8,0x1961932d0,359383040
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/DictionaryServices.framework/Versions/A/DictionaryServices,0x1a1981a5c,0x1a19c8ab0,359383040
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/SharedFileList.framework/Versions/A/SharedFileList,0x19d84d010,0x19d869cf0,359383040
shared-library,/System/Library/Frameworks/Security.framework/Versions/A/Security,0x19828eed4,0x19858c378,359383040
shared-library,/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/SystemConfiguration,0x1966df72c,0x1967596e0,359383040
shared-library,/usr/lib/libapple_nghttp2.dylib,0x1a13a83e4,0x1a13b7760,359383040
shared-library,/usr/lib/libcompression.dylib,0x1a13db700,0x1a142fb40,359383040
shared-library,/usr/lib/libnetwork.dylib,0x19a315fc0,0x19a315fc0,359383040
shared-library,/usr/lib/libsqlite3.dylib,0x19bb35268,0x19bce75e0,359383040
shared-library,/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation,0x196a17e70,0x197124d10,359383040
shared-library,/System/Library/Frameworks/Network.framework/Versions/A/Network,0x19bf3749c,0x19cadc08c,359383040
shared-library,/usr/lib/libCoreEntitlements.dylib,0x21eddf3e4,0x21ede5190,359383040
shared-library,/System/Library/PrivateFrameworks/MessageSecurity.framework/Versions/A/MessageSecurity,0x20b84cfe4,0x20b86aca0,359383040
shared-library,/System/Library/PrivateFrameworks/ProtocolBuffer.framework/Versions/A/ProtocolBuffer,0x19bb1b314,0x19bb2d460,359383040
shared-library,/usr/lib/libMobileGestalt.dylib,0x19a6f4900,0x19a73e0dc,359383040
shared-library,/System/Library/PrivateFrameworks/AppleFSCompression.framework/Versions/A/AppleFSCompression,0x1a0db3640,0x1a0dbebe4,359383040
shared-library,/usr/lib/libcoretls.dylib,0x1a07a339c,0x1a07b5468,359383040
shared-library,/usr/lib/libcoretls_cfhelpers.dylib,0x1a19f0e04,0x1a19f1c00,359383040
shared-library,/usr/lib/libpam.2.dylib,0x1a13d4920,0x1a13d7cf4,359383040
shared-library,/usr/lib/libxar.1.dylib,0x1a1a59570,0x1a1a65770,359383040
shared-library,/System/Library/PrivateFrameworks/CoreAutoLayout.framework/Versions/A/CoreAutoLayout,0x19d87d8dc,0x19d8b0b00,359383040
shared-library,/System/Library/Frameworks/DiskArbitration.framework/Versions/A/DiskArbitration,0x19ce2e400,0x19ce34d80,359383040
shared-library,/usr/lib/libarchive.2.dylib,0x1a1281d8c,0x1a12f3480,359383040
shared-library,/usr/lib/libxml2.2.dylib,0x19d8c743c,0x19d98f950,359383040
shared-library,/usr/lib/liblangid.dylib,0x19fcc21e4,0x19fcc2d20,359383040
shared-library,/System/Library/Frameworks/Combine.framework/Versions/A/Combine,0x1a5777524,0x1a589dca0,359383040
shared-library,/usr/lib/swift/libswiftCore.dylib,0x1a3836660,0x1a3c8de88,359383040
shared-library,/usr/lib/swift/libswiftCoreFoundation.dylib,0x1b71457cc,0x1b714acc8,359383040
shared-library,/usr/lib/swift/libswiftDarwin.dylib,0x1b5005fac,0x1b500a0d8,359383040
shared-library,/usr/lib/swift/libswiftDispatch.dylib,0x1a8d3dce4,0x1a8d4e8d0,359383040
shared-library,/usr/lib/swift/libswiftIOKit.dylib,0x1b7165d44,0x1b7165fb0,359383040
shared-library,/usr/lib/swift/libswiftObjectiveC.dylib,0x1ab18f370,0x1ab190f30,359383040
shared-library,/usr/lib/swift/libswiftXPC.dylib,0x1b7159a1c,0x1b71629b8,359383040
shared-library,/usr/lib/swift/libswift_Concurrency.dylib,0x21fc92f7c,0x21fcdb080,359383040
shared-library,/usr/lib/swift/libswift_StringProcessing.dylib,0x21fde4dc0,0x21fe7cb40,359383040
shared-library,/usr/lib/swift/libswiftos.dylib,0x1ab193a24,0x1ab1a78f0,359383040
shared-library,/System/Library/PrivateFrameworks/AppleSystemInfo.framework/Versions/A/AppleSystemInfo,0x19fcbd7e0,0x19fcc0438,359383040
shared-library,/System/Library/PrivateFrameworks/IOMobileFramebuffer.framework/Versions/A/IOMobileFramebuffer,0x1a04969f4,0x1a04a1200,359383040
shared-library,/System/Library/Frameworks/IOSurface.framework/Versions/A/IOSurface,0x19ed51c64,0x19ed60448,359383040
shared-library,/usr/lib/libpcap.A.dylib,0x1a1147c60,0x1a11687f0,359383040
shared-library,/usr/lib/libdns_services.dylib,0x19bf24780,0x19bf2b0a8,359383040
shared-library,/usr/lib/liblzma.5.dylib,0x1a19d7670,0x1a19e9770,359383040
shared-library,/usr/lib/libbz2.1.0.dylib,0x1a0dc3cec,0x1a0dcefa0,359383040
shared-library,/usr/lib/libiconv.2.dylib,0x1a117d5c0,0x1a1192970,359383040
shared-library,/usr/lib/libcharset.1.dylib,0x1a10d0948,0x1a10d0e38,359383040
shared-library,/usr/lib/swift/libswift_RegexParser.dylib,0x21fd305fc,0x21fdc6e30,359383040
shared-library,/usr/lib/libheimdal-asn1.dylib,0x1a1e239dc,0x1a1e2cb40,359383040
shared-library,/usr/lib/libCheckFix.dylib,0x1a0795828,0x1a079fd4c,359383040
shared-library,/System/Library/PrivateFrameworks/TCC.framework/Versions/A/TCC,0x19a771bf4,0x19a7889b8,359383040
shared-library,/System/Library/PrivateFrameworks/CoreNLP.framework/Versions/A/CoreNLP,0x19fcc44b4,0x19fd954e8,359383040
shared-library,/System/Library/PrivateFrameworks/MetadataUtilities.framework/Versions/A/MetadataUtilities,0x19cd54624,0x19cd87698,359383040
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Accelerate,0x1a7ac8000,0x1a7ac8000,359383040
shared-library,/usr/lib/libmecab.dylib,0x1a07cbfa4,0x1a081acd0,359383040
shared-library,/usr/lib/libCRFSuite.dylib,0x196769588,0x196796bb8,359383040
shared-library,/usr/lib/libgermantok.dylib,0x1a08292a0,0x1a082ad40,359383040
shared-library,/usr/lib/libThaiTokenizer.dylib,0x1a1380d08,0x1a1381d50,359383040
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vImage.framework/Versions/A/vImage,0x19ce37660,0x19d155068,359383040
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/vecLib,0x1a77fb000,0x1a77fb000,359383040
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libvMisc.dylib,0x1a1a9f038,0x1a1b15110,359383040
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libvDSP.dylib,0x1a0397300,0x1a047d004,359383040
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib,0x196375390,0x196629b88,359383040
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libLAPACK.dylib,0x1a14ac994,0x1a1977bb0,359383040
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libLinearAlgebra.dylib,0x1a082c0ec,0x1a083dc40,359383040
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libSparseBLAS.dylib,0x1a13c02f8,0x1a13d1964,359383040
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libQuadrature.dylib,0x1a14a7f7c,0x1a14ab190,359383040
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBNNS.dylib,0x19fdbd040,0x1a0365f50,359383040
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libSparse.dylib,0x196677c38,0x1966d8c70,359383040
shared-library,/System/Library/PrivateFrameworks/MIL.framework/Versions/A/MIL,0x20ab86b80,0x20adec770,359383040
shared-library,/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks/CFOpenDirectory.framework/Versions/A/CFOpenDirectory,0x19d820af0,0x19d836450,359383040
shared-library,/System/Library/Frameworks/OpenDirectory.framework/Versions/A/OpenDirectory,0x19d8114d4,0x19d8182b0,359383040
shared-library,/System/Library/PrivateFrameworks/APFS.framework/Versions/A/APFS,0x1a19f37d0,0x1a1a401ec,359383040
shared-library,/System/Library/Frameworks/SecurityFoundation.framework/Versions/A/SecurityFoundation,0x1a06ce158,0x1a07131d8,359383040
shared-library,/usr/lib/libutil.dylib,0x1a1a68078,0x1a1a6a660,359383040
shared-library,/System/Library/PrivateFrameworks/InstalledContentLibrary.framework/Versions/A/InstalledContentLibrary,0x209bf9394,0x209c916e8,359383040
shared-library,/System/Library/PrivateFrameworks/CoreServicesStore.framework/Versions/A/CoreServicesStore,0x198c3b4a4,0x198c69ff0,359383040
shared-library,/usr/lib/libapp_launch_measurement.dylib,0x19d8797fc,0x19d87b750,359383040
shared-library,/System/Library/PrivateFrameworks/AppleMobileFileIntegrity.framework/Versions/A/AppleMobileFileIntegrity,0x200bf9860,0x200c01bb0,359383040
shared-library,/usr/lib/libmis.dylib,0x1b7124b34,0x1b71317c8,359383040
shared-library,/System/Library/PrivateFrameworks/MobileSystemServices.framework/Versions/A/MobileSystemServices,0x1c50879e8,0x1c5089e08,359383040
shared-library,/System/Library/PrivateFrameworks/ConfigProfileHelper.framework/Versions/A/ConfigProfileHelper,0x1df8c33f4,0x1df8c4788,359383040
shared-library,/System/Library/PrivateFrameworks/CoreAnalytics.framework/Versions/A/CoreAnalytics,0x19cd24f0c,0x19cd482b0,359383040
shared-library,/System/Library/PrivateFrameworks/AppleSauce.framework/Versions/A/AppleSauce,0x1a13831a0,0x1a13a3ab8,359383040
shared-library,/System/Library/PrivateFrameworks/LanguageModeling.framework/Versions/A/LanguageModeling,0x197450a3c,0x197591ea8,359383040
shared-library,/usr/lib/libxslt.1.dylib,0x1a1a6c3c8,0x1a1a8db7c,359383040
shared-library,/usr/lib/libcmph.dylib,0x1a126f85c,0x1a127ebf0,359383040
shared-library,/System/Library/PrivateFrameworks/CoreEmoji.framework/Versions/A/CoreEmoji,0x1a0483f74,0x1a0492a40,359383040
shared-library,/System/Library/PrivateFrameworks/LinguisticData.framework/Versions/A/LinguisticData,0x19fdb7404,0x19fdbab38,359383040
shared-library,/System/Library/PrivateFrameworks/Lexicon.framework/Versions/A/Lexicon,0x19662fa8c,0x19666ce40,359383040
shared-library,/System/Library/PrivateFrameworks/BackgroundTaskManagement.framework/Versions/A/BackgroundTaskManagement,0x1a0760a3c,0x1a0779980,359383040
shared-library,/usr/lib/libTLE.dylib,0x21ef8225c,0x21ef876b8,359383040
shared-library-end
profiler,begin,1000
new,CodeRange,0x110000000,0
tick,0x195a49fcc,2209,0,0x0,6
new,MemoryChunk,0x238034200000,262144
new,MemoryChunk,0x2edda4b00000,262144
new,MemoryChunk,0x1efde4180000,262144
new,MemoryChunk,0x1c4d73ac0000,262144
new,MemoryChunk,0x2c33bd9c0000,262144
heap-capacity,1030976
heap-available,4346312320
new,MemoryChunk,0x2da83afc0000,262144
tick,0x1011d8ad0,3750,0,0x0,6
new,MemoryChunk,0x13b39800000,262144
new,MemoryChunk,0x41ccf040000,262144
tick,0x195ab7c8c,4709,0,0x0,6
new,MemoryChunk,0x1012a3940000,262144
tick,0x195ab7c8c,5959,0,0x0,6
new,MemoryChunk,0x35d297180000,262144
tick,0x100df4018,7084,0,0x0,1
new,MemoryChunk,0x26f39880000,262144
new,MemoryChunk,0x28e4ce8c0000,262144
new,MemoryChunk,0x25dc1a840000,262144
new,MemoryChunk,0x250200ac0000,262144
tick,0x100df4018,8834,0,0x0,1
new,MemoryChunk,0x3ff6535c0000,262144
new,MemoryChunk,0x110000000,262144
new,MemoryChunk,0x201f74140000,262144
code-creation,Builtin,2,10584,0x101480000,824,DeoptimizationEntry_Eager
code-creation,Builtin,2,10584,0x101480340,824,DeoptimizationEntry_Lazy
code-creation,Builtin,2,10584,0x101480680,824,DeoptimizationEntry_Unused
code-creation,Builtin,2,10584,0x1014809c0,980,RecordWriteEmitRememberedSetSaveFP
code-creation,Builtin,2,10625,0x101480da0,352,RecordWriteOmitRememberedSetSaveFP
code-creation,Builtin,2,10625,0x101480f20,692,RecordWriteEmitRememberedSetIgnoreFP
code-creation,Builtin,2,10625,0x1014811e0,256,RecordWriteOmitRememberedSetIgnoreFP
code-creation,Builtin,2,10625,0x101481300,280,EphemeronKeyBarrierSaveFP
code-creation,Builtin,2,10625,0x101481420,184,EphemeronKeyBarrierIgnoreFP
code-creation,Builtin,2,10667,0x1014814e0,76,AdaptorWithBuiltinExitFrame
code-creation,Builtin,2,10667,0x101481540,360,CallFunction_ReceiverIsNullOrUndefined
code-creation,Builtin,2,10667,0x1014816c0,436,CallFunction_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,10667,0x101481880,476,CallFunction_ReceiverIsAny
code-creation,Builtin,2,10667,0x101481a60,232,CallBoundFunction
code-creation,Builtin,2,10709,0x101481b60,828,CallWrappedFunction
code-creation,Builtin,2,10709,0x101481ea0,192,Call_ReceiverIsNullOrUndefined
code-creation,Builtin,2,10709,0x101481f80,192,Call_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,10750,0x101482060,192,Call_ReceiverIsAny
code-creation,Builtin,2,10750,0x101482140,848,Call_ReceiverIsNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,11000,0x1014824a0,844,Call_ReceiverIsNullOrUndefined_Baseline
code-creation,Builtin,2,11042,0x101482800,996,Call_ReceiverIsNotNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,11042,0x101482c00,992,Call_ReceiverIsNotNullOrUndefined_Baseline
code-creation,Builtin,2,11042,0x101483000,996,Call_ReceiverIsAny_Baseline_Compact
code-creation,Builtin,2,11042,0x101483400,992,Call_ReceiverIsAny_Baseline
code-creation,Builtin,2,11042,0x101483800,820,Call_ReceiverIsNullOrUndefined_WithFeedback
code-creation,Builtin,2,11084,0x101483b40,820,Call_ReceiverIsNotNullOrUndefined_WithFeedback
code-creation,Builtin,2,11084,0x101483e80,820,Call_ReceiverIsAny_WithFeedback
code-creation,Builtin,2,11084,0x1014841c0,780,CallProxy
code-creation,Builtin,2,11084,0x1014844e0,156,CallVarargs
code-creation,Builtin,2,11084,0x101484580,1148,CallWithSpread
code-creation,Builtin,2,11125,0x101484a00,1928,CallWithSpread_Baseline
code-creation,Builtin,2,11125,0x1014851a0,1984,CallWithSpread_WithFeedback
code-creation,Builtin,2,11125,0x101485980,1160,CallWithArrayLike
code-creation,Builtin,2,11125,0x101485e20,1960,CallWithArrayLike_WithFeedback
code-creation,Builtin,2,11125,0x1014865e0,184,CallForwardVarargs
code-creation,Builtin,2,11167,0x1014866a0,184,CallFunctionForwardVarargs
code-creation,Builtin,2,11167,0x101486760,156,CallFunctionTemplate_CheckAccess
code-creation,Builtin,2,11167,0x101486800,240,CallFunctionTemplate_CheckCompatibleReceiver
code-creation,Builtin,2,11167,0x101486900,328,CallFunctionTemplate_CheckAccessAndCompatibleReceiver
code-creation,Builtin,2,11167,0x101486a60,24,ConstructFunction
code-creation,Builtin,2,11209,0x101486a80,236,ConstructBoundFunction
code-creation,Builtin,2,11209,0x101486b80,44,ConstructedNonConstructable
code-creation,Builtin,2,11209,0x101486bc0,88,Construct
code-creation,Builtin,2,11209,0x101486c20,156,ConstructVarargs
code-creation,Builtin,2,11250,0x101486cc0,1176,ConstructWithSpread
code-creation,Builtin,2,11250,0x101487160,1932,ConstructWithSpread_Baseline
code-creation,Builtin,2,11250,0x101487900,1912,ConstructWithSpread_WithFeedback
code-creation,Builtin,2,11250,0x101488080,1288,ConstructWithArrayLike
code-creation,Builtin,2,11292,0x1014885a0,2020,ConstructWithArrayLike_WithFeedback
code-creation,Builtin,2,11292,0x101488da0,236,ConstructForwardVarargs
code-creation,Builtin,2,11292,0x101488ea0,236,ConstructFunctionForwardVarargs
code-creation,Builtin,2,11334,0x101488fa0,732,Construct_Baseline
code-creation,Builtin,2,11334,0x101489280,736,Construct_WithFeedback
code-creation,Builtin,2,11334,0x101489580,564,JSConstructStubGeneric
code-creation,Builtin,2,11334,0x1014897c0,472,JSBuiltinsConstructStub
code-creation,Builtin,2,11334,0x1014899a0,692,FastNewObject
code-creation,Builtin,2,11375,0x101489c60,332,FastNewClosure
code-creation,Builtin,2,11375,0x101489dc0,764,ConstructProxy
code-creation,Builtin,2,11375,0x10148a0c0,264,JSEntry
code-creation,Builtin,2,11375,0x10148a1e0,264,JSConstructEntry
code-creation,Builtin,2,11375,0x10148a300,264,JSRunMicrotasksEntry
code-creation,Builtin,2,11500,0x10148a420,188,JSEntryTrampoline
code-creation,Builtin,2,11500,0x10148a4e0,188,JSConstructEntryTrampoline
code-creation,Builtin,2,11500,0x10148a5a0,380,ResumeGeneratorTrampoline
code-creation,Builtin,2,11500,0x10148a720,1636,StringFromCodePointAt
code-creation,Builtin,2,11500,0x10148ada0,592,StringEqual
code-creation,Builtin,2,11542,0x10148b000,320,StringGreaterThan
code-creation,Builtin,2,11542,0x10148b160,320,StringGreaterThanOrEqual
code-creation,Builtin,2,11542,0x10148b2c0,320,StringLessThan
code-creation,Builtin,2,11542,0x10148b420,320,StringLessThanOrEqual
code-creation,Builtin,2,11542,0x10148b580,2708,StringSubstring
code-creation,Builtin,2,11584,0x10148c020,116,OrderedHashTableHealIndex
code-creation,Builtin,2,11584,0x10148c0a0,1252,InterpreterEntryTrampoline
code-creation,Builtin,2,11584,0x10148c5a0,124,InterpreterPushArgsThenCall
code-creation,Builtin,2,11584,0x10148c620,132,InterpreterPushUndefinedAndArgsThenCall
code-creation,Builtin,2,11584,0x10148c6c0,132,InterpreterPushArgsThenCallWithFinalSpread
code-creation,Builtin,2,11625,0x10148c760,132,InterpreterPushArgsThenConstruct
code-creation,Builtin,2,11625,0x10148c800,132,InterpreterPushArgsThenConstructArrayFunction
code-creation,Builtin,2,11625,0x10148c8a0,140,InterpreterPushArgsThenConstructWithFinalSpread
code-creation,Builtin,2,11625,0x10148c940,92,InterpreterEnterAtBytecode
code-creation,Builtin,2,11667,0x10148c9a0,220,InterpreterEnterAtNextBytecode
code-creation,Builtin,2,11667,0x10148ca80,80,InterpreterOnStackReplacement
code-creation,Builtin,2,11667,0x10148cae0,596,BaselineOutOfLinePrologue
code-creation,Builtin,2,11667,0x10148cd40,76,BaselineOnStackReplacement
code-creation,Builtin,2,11667,0x10148cda0,104,BaselineLeaveFrame
code-creation,Builtin,2,11709,0x10148ce20,232,BaselineOrInterpreterEnterAtBytecode
code-creation,Builtin,2,11709,0x10148cf20,236,BaselineOrInterpreterEnterAtNextBytecode
code-creation,Builtin,2,11709,0x10148d020,208,InterpreterOnStackReplacement_ToBaseline
code-creation,Builtin,2,11709,0x10148d100,1240,CompileLazy
code-creation,Builtin,2,11750,0x10148d5e0,76,CompileLazyDeoptimizedCode
code-creation,Builtin,2,11750,0x10148d640,316,InstantiateAsmJs
code-creation,Builtin,2,11750,0x10148d780,44,NotifyDeoptimized
code-creation,Builtin,2,11750,0x10148d7c0,88,ContinueToCodeStubBuiltin
code-creation,Builtin,2,11792,0x10148d820,92,ContinueToCodeStubBuiltinWithResult
code-creation,Builtin,2,11792,0x10148d880,92,ContinueToJavaScriptBuiltin
code-creation,Builtin,2,11792,0x10148d8e0,108,ContinueToJavaScriptBuiltinWithResult
code-creation,Builtin,2,11792,0x10148d960,396,CallApiCallback
code-creation,Builtin,2,11834,0x10148db00,372,CallApiGetter
code-creation,Builtin,2,11834,0x10148dc80,8,HandleApiCall
code-creation,Builtin,2,11834,0x10148dca0,8,HandleApiCallAsFunction
code-creation,Builtin,2,11834,0x10148dcc0,8,HandleApiCallAsConstructor
code-creation,Builtin,2,11834,0x10148dce0,56,AllocateInYoungGeneration
code-creation,Builtin,2,11875,0x10148dd20,52,AllocateRegularInYoungGeneration
code-creation,Builtin,2,11875,0x10148dd60,56,AllocateInOldGeneration
code-creation,Builtin,2,11875,0x10148dda0,52,AllocateRegularInOldGeneration
code-creation,Builtin,2,11917,0x10148dde0,416,CopyFastSmiOrObjectElements
code-creation,Builtin,2,11917,0x10148dfa0,540,GrowFastDoubleElements
code-creation,Builtin,2,11917,0x10148e1c0,424,GrowFastSmiOrObjectElements
code-creation,Builtin,2,11917,0x10148e380,484,DebugBreakTrampoline
code-creation,Builtin,2,11959,0x10148e580,220,ToNumber
code-creation,Builtin,2,11959,0x10148e660,328,ToNumber_Baseline
code-creation,Builtin,2,11959,0x10148e7c0,392,ToNumeric_Baseline
code-creation,Builtin,2,11959,0x10148e960,140,PlainPrimitiveToNumber
code-creation,Builtin,2,11959,0x10148ea00,260,ToNumberConvertBigInt
code-creation,Builtin,2,12000,0x10148eb20,152,Typeof
code-creation,Builtin,2,12000,0x10148ebc0,140,BigIntToI64
code-creation,Builtin,2,12000,0x10148ec60,8,BigIntToI32Pair
code-creation,Builtin,2,12000,0x10148ec80,264,I64ToBigInt
code-creation,Builtin,2,12000,0x10148eda0,8,I32PairToBigInt
code-creation,Builtin,2,12042,0x10148edc0,136,ToBooleanLazyDeoptContinuation
code-creation,Builtin,2,12042,0x10148ee60,3944,KeyedLoadIC_PolymorphicName
code-creation,Builtin,2,12042,0x10148fde0,14344,KeyedStoreIC_Megamorphic
code-creation,Builtin,2,12042,0x101493600,11192,DefineKeyedOwnIC_Megamorphic
code-creation,Builtin,2,12042,0x1014961c0,500,LoadGlobalIC_NoFeedback
code-creation,Builtin,2,12084,0x1014963c0,84,LoadIC_FunctionPrototype
code-creation,Builtin,2,12084,0x101496420,16,LoadIC_StringLength
code-creation,Builtin,2,12084,0x101496440,20,LoadIC_StringWrapperLength
code-creation,Builtin,2,12084,0x101496460,3120,LoadIC_NoFeedback
code-creation,Builtin,2,12125,0x1014970a0,44,StoreGlobalIC_Slow
code-creation,Builtin,2,12125,0x1014970e0,5952,StoreIC_NoFeedback
code-creation,Builtin,2,12125,0x101498840,2924,DefineNamedOwnIC_NoFeedback
code-creation,Builtin,2,12125,0x1014993c0,220,KeyedLoadIC_SloppyArguments
code-creation,Builtin,2,12167,0x1014994a0,68,LoadIndexedInterceptorIC
code-creation,Builtin,2,12167,0x101499500,288,KeyedStoreIC_SloppyArguments_Standard
code-creation,Builtin,2,12167,0x101499640,288,KeyedStoreIC_SloppyArguments_GrowNoTransitionHandleCOW
code-creation,Builtin,2,12167,0x101499780,288,KeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB
code-creation,Builtin,2,12209,0x1014998c0,288,KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW
code-creation,Builtin,2,12209,0x101499a00,12112,StoreFastElementIC_Standard
code-creation,Builtin,2,12209,0x10149c960,10640,StoreFastElementIC_GrowNoTransitionHandleCOW
code-creation,Builtin,2,12209,0x10149f300,11532,StoreFastElementIC_NoTransitionIgnoreOOB
code-creation,Builtin,2,12250,0x1014a2020,5584,StoreFastElementIC_NoTransitionHandleCOW
code-creation,Builtin,2,12250,0x1014a3600,8192,ElementsTransitionAndStore_Standard
code-creation,Builtin,2,12250,0x1014a5620,21212,ElementsTransitionAndStore_GrowNoTransitionHandleCOW
code-creation,Builtin,2,12250,0x1014aa900,8192,ElementsTransitionAndStore_NoTransitionIgnoreOOB
code-creation,Builtin,2,12250,0x1014ac920,11136,ElementsTransitionAndStore_NoTransitionHandleCOW
code-creation,Builtin,2,12292,0x1014af4c0,772,KeyedHasIC_PolymorphicName
code-creation,Builtin,2,12292,0x1014af7e0,200,KeyedHasIC_SloppyArguments
code-creation,Builtin,2,12292,0x1014af8c0,68,HasIndexedInterceptorIC
code-creation,Builtin,2,12292,0x1014af920,164,EnqueueMicrotask
code-creation,Builtin,2,12334,0x1014af9e0,8,RunMicrotasksTrampoline
code-creation,Builtin,2,12334,0x1014afa00,3532,RunMicrotasks
code-creation,Builtin,2,12334,0x1014b07e0,2716,HasProperty
code-creation,Builtin,2,12334,0x1014b1280,1060,DeleteProperty
code-creation,Builtin,2,12334,0x1014b16c0,2204,CopyDataProperties
code-creation,Builtin,2,12375,0x1014b1f60,8728,SetDataProperties
code-creation,Builtin,2,12375,0x1014b4180,2964,CopyDataPropertiesWithExcludedPropertiesOnStack
code-creation,Builtin,2,12375,0x1014b4d20,76,CopyDataPropertiesWithExcludedProperties
code-creation,Builtin,2,12375,0x1014b4d80,32,Abort
code-creation,Builtin,2,12417,0x1014b4dc0,32,AbortCSADcheck
code-creation,Builtin,2,12417,0x1014b4e00,8,EmptyFunction
code-creation,Builtin,2,12417,0x1014b4e20,8,Illegal
code-creation,Builtin,2,12417,0x1014b4e40,8,StrictPoisonPillThrower
code-creation,Builtin,2,12417,0x1014b4e60,8,UnsupportedThrower
code-creation,Builtin,2,12459,0x1014b4e80,80,ReturnReceiver
code-creation,Builtin,2,12459,0x1014b4ee0,36,ArrayConstructor
code-creation,Builtin,2,12459,0x1014b4f20,460,ArrayConstructorImpl
code-creation,Builtin,2,12459,0x1014b5100,240,ArrayNoArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,12500,0x1014b5200,240,ArrayNoArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,12500,0x1014b5300,200,ArrayNoArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,12500,0x1014b53e0,200,ArrayNoArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,12500,0x1014b54c0,200,ArrayNoArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,12542,0x1014b55a0,200,ArrayNoArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,12542,0x1014b5680,204,ArrayNoArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,12542,0x1014b5760,204,ArrayNoArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,12542,0x1014b5840,500,ArraySingleArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,12584,0x1014b5a40,484,ArraySingleArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,12584,0x1014b5c40,424,ArraySingleArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,12584,0x1014b5e00,408,ArraySingleArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,12584,0x1014b5fa0,424,ArraySingleArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,12584,0x1014b6160,408,ArraySingleArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,12625,0x1014b6300,428,ArraySingleArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,12625,0x1014b64c0,412,ArraySingleArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,12625,0x1014b6660,60,ArrayNArgumentsConstructor
code-creation,Builtin,2,12625,0x1014b66a0,8,ArrayConcat
code-creation,Builtin,2,12625,0x1014b66c0,8,ArrayPrototypeFill
code-creation,Builtin,2,12667,0x1014b66e0,1040,ArrayIncludesSmiOrObject
code-creation,Builtin,2,12667,0x1014b6b00,176,ArrayIncludesPackedDoubles
code-creation,Builtin,2,12667,0x1014b6bc0,256,ArrayIncludesHoleyDoubles
code-creation,Builtin,2,12667,0x1014b6ce0,592,ArrayIncludes
code-creation,Builtin,2,12709,0x1014b6f40,944,ArrayIndexOfSmiOrObject
code-creation,Builtin,2,12709,0x1014b7300,128,ArrayIndexOfPackedDoubles
code-creation,Builtin,2,12709,0x1014b73a0,128,ArrayIndexOfHoleyDoubles
code-creation,Builtin,2,12709,0x1014b7440,592,ArrayIndexOf
code-creation,Builtin,2,12750,0x1014b76a0,8,ArrayPop
code-creation,Builtin,2,12750,0x1014b76c0,620,ArrayPrototypePop
code-creation,Builtin,2,12750,0x1014b7940,8,ArrayPrototypeGroupBy
code-creation,Builtin,2,12750,0x1014b7960,8,ArrayPrototypeGroupByToMap
code-creation,Builtin,2,12750,0x1014b7980,8,ArrayPush
code-creation,Builtin,2,12792,0x1014b79a0,2404,ArrayPrototypePush
code-creation,Builtin,2,12792,0x1014b8320,8,ArrayShift
code-creation,Builtin,2,12834,0x1014b8340,8,ArrayUnshift
code-creation,Builtin,2,12834,0x1014b8360,912,CloneFastJSArray
code-creation,Builtin,2,12834,0x1014b8700,2060,CloneFastJSArrayFillingHoles
code-creation,Builtin,2,12834,0x1014b8f20,940,ExtractFastJSArray
code-creation,Builtin,2,12875,0x1014b92e0,268,ArrayPrototypeEntries
code-creation,Builtin,2,12875,0x1014b9400,264,ArrayPrototypeKeys
code-creation,Builtin,2,12875,0x1014b9520,268,ArrayPrototypeValues
code-creation,Builtin,2,12875,0x1014b9640,4196,ArrayIteratorPrototypeNext
code-creation,Builtin,2,12917,0x1014ba6c0,4048,FlattenIntoArray
code-creation,Builtin,2,12917,0x1014bb6a0,4028,FlatMapIntoArray
code-creation,Builtin,2,12917,0x1014bc660,412,ArrayPrototypeFlat
code-creation,Builtin,2,12917,0x1014bc800,472,ArrayPrototypeFlatMap
code-creation,Builtin,2,12917,0x1014bc9e0,8,ArrayBufferConstructor
code-creation,Builtin,2,12959,0x1014bca00,8,ArrayBufferConstructor_DoNotInitialize
code-creation,Builtin,2,12959,0x1014bca20,8,ArrayBufferPrototypeSlice
code-creation,Builtin,2,13000,0x1014bca40,8,ArrayBufferPrototypeResize
code-creation,Builtin,2,13000,0x1014bca60,960,AsyncFunctionEnter
code-creation,Builtin,2,13000,0x1014bce40,96,AsyncFunctionReject
code-creation,Builtin,2,13042,0x1014bcec0,92,AsyncFunctionResolve
code-creation,Builtin,2,13042,0x1014bcf20,16,AsyncFunctionLazyDeoptContinuation
code-creation,Builtin,2,13042,0x1014bcf40,1824,AsyncFunctionAwaitCaught
code-creation,Builtin,2,13042,0x1014bd680,1824,AsyncFunctionAwaitUncaught
code-creation,Builtin,2,13084,0x1014bddc0,208,AsyncFunctionAwaitRejectClosure
code-creation,Builtin,2,13084,0x1014bdea0,208,AsyncFunctionAwaitResolveClosure
code-creation,Builtin,2,13084,0x1014bdf80,8,BigIntConstructor
code-creation,Builtin,2,13084,0x1014bdfa0,8,BigIntAsUintN
code-creation,Builtin,2,13084,0x1014bdfc0,8,BigIntAsIntN
code-creation,Builtin,2,13125,0x1014bdfe0,8,BigIntPrototypeToLocaleString
code-creation,Builtin,2,13125,0x1014be000,8,BigIntPrototypeToString
code-creation,Builtin,2,13125,0x1014be020,8,BigIntPrototypeValueOf
code-creation,Builtin,2,13125,0x1014be040,8,CallSitePrototypeGetColumnNumber
code-creation,Builtin,2,13125,0x1014be060,8,CallSitePrototypeGetEnclosingColumnNumber
code-creation,Builtin,2,13167,0x1014be080,8,CallSitePrototypeGetEnclosingLineNumber
code-creation,Builtin,2,13167,0x1014be0a0,8,CallSitePrototypeGetEvalOrigin
code-creation,Builtin,2,13167,0x1014be0c0,8,CallSitePrototypeGetFileName
code-creation,Builtin,2,13209,0x1014be0e0,8,CallSitePrototypeGetFunction
code-creation,Builtin,2,13209,0x1014be100,8,CallSitePrototypeGetFunctionName
code-creation,Builtin,2,13209,0x1014be120,8,CallSitePrototypeGetLineNumber
code-creation,Builtin,2,13209,0x1014be140,8,CallSitePrototypeGetMethodName
code-creation,Builtin,2,13209,0x1014be160,8,CallSitePrototypeGetPosition
code-creation,Builtin,2,13250,0x1014be180,8,CallSitePrototypeGetPromiseIndex
code-creation,Builtin,2,13709,0x1014be1a0,8,CallSitePrototypeGetScriptNameOrSourceURL
code-creation,Builtin,2,13709,0x1014be1c0,8,CallSitePrototypeGetThis
code-creation,Builtin,2,13709,0x1014be1e0,8,CallSitePrototypeGetTypeName
code-creation,Builtin,2,13709,0x1014be200,8,CallSitePrototypeIsAsync
code-creation,Builtin,2,13709,0x1014be220,8,CallSitePrototypeIsConstructor
code-creation,Builtin,2,13750,0x1014be240,8,CallSitePrototypeIsEval
code-creation,Builtin,2,13750,0x1014be260,8,CallSitePrototypeIsNative
code-creation,Builtin,2,13750,0x1014be280,8,CallSitePrototypeIsPromiseAll
code-creation,Builtin,2,13834,0x1014be2a0,8,CallSitePrototypeIsToplevel
code-creation,Builtin,2,13834,0x1014be2c0,8,CallSitePrototypeToString
code-creation,Builtin,2,13834,0x1014be2e0,8,ConsoleDebug
code-creation,Builtin,2,13875,0x1014be300,8,ConsoleError
code-creation,Builtin,2,13875,0x1014be320,8,ConsoleInfo
code-creation,Builtin,2,13875,0x1014be340,8,ConsoleLog
code-creation,Builtin,2,13917,0x1014be360,8,ConsoleWarn
code-creation,Builtin,2,13917,0x1014be380,8,ConsoleDir
code-creation,Builtin,2,13917,0x1014be3a0,8,ConsoleDirXml
code-creation,Builtin,2,13917,0x1014be3c0,8,ConsoleTable
code-creation,Builtin,2,13959,0x1014be3e0,8,ConsoleTrace
code-creation,Builtin,2,13959,0x1014be400,8,ConsoleGroup
code-creation,Builtin,2,13959,0x1014be420,8,ConsoleGroupCollapsed
code-creation,Builtin,2,13959,0x1014be440,8,ConsoleGroupEnd
code-creation,Builtin,2,14000,0x1014be460,8,ConsoleClear
code-creation,Builtin,2,14000,0x1014be480,8,ConsoleCount
code-creation,Builtin,2,14000,0x1014be4a0,8,ConsoleCountReset
code-creation,Builtin,2,14000,0x1014be4c0,8,ConsoleAssert
code-creation,Builtin,2,14000,0x1014be4e0,8,ConsoleProfile
code-creation,Builtin,2,14042,0x1014be500,8,ConsoleProfileEnd
code-creation,Builtin,2,14042,0x1014be520,8,ConsoleTime
code-creation,Builtin,2,14042,0x1014be540,8,ConsoleTimeLog
code-creation,Builtin,2,14042,0x1014be560,8,ConsoleTimeEnd
code-creation,Builtin,2,14084,0x1014be580,8,ConsoleTimeStamp
code-creation,Builtin,2,14084,0x1014be5a0,8,ConsoleContext
code-creation,Builtin,2,14084,0x1014be5c0,8,DataViewConstructor
code-creation,Builtin,2,14084,0x1014be5e0,8,DateConstructor
code-creation,Builtin,2,14125,0x1014be600,208,DatePrototypeGetDate
code-creation,Builtin,2,14125,0x1014be6e0,208,DatePrototypeGetDay
code-creation,Builtin,2,14125,0x1014be7c0,208,DatePrototypeGetFullYear
code-creation,Builtin,2,14167,0x1014be8a0,208,DatePrototypeGetHours
code-creation,Builtin,2,14167,0x1014be980,180,DatePrototypeGetMilliseconds
code-creation,Builtin,2,14167,0x1014bea40,208,DatePrototypeGetMinutes
code-creation,Builtin,2,14209,0x1014beb20,208,DatePrototypeGetMonth
code-creation,Builtin,2,14209,0x1014bec00,208,DatePrototypeGetSeconds
code-creation,Builtin,2,14209,0x1014bece0,144,DatePrototypeGetTime
code-creation,Builtin,2,14209,0x1014bed80,180,DatePrototypeGetTimezoneOffset
code-creation,Builtin,2,14250,0x1014bee40,180,DatePrototypeGetUTCDate
code-creation,Builtin,2,14250,0x1014bef00,180,DatePrototypeGetUTCDay
code-creation,Builtin,2,14250,0x1014befc0,180,DatePrototypeGetUTCFullYear
code-creation,Builtin,2,14250,0x1014bf080,180,DatePrototypeGetUTCHours
code-creation,Builtin,2,14292,0x1014bf140,180,DatePrototypeGetUTCMilliseconds
code-creation,Builtin,2,14292,0x1014bf200,180,DatePrototypeGetUTCMinutes
code-creation,Builtin,2,14292,0x1014bf2c0,180,DatePrototypeGetUTCMonth
code-creation,Builtin,2,14292,0x1014bf380,180,DatePrototypeGetUTCSeconds
code-creation,Builtin,2,14334,0x1014bf440,144,DatePrototypeValueOf
code-creation,Builtin,2,14334,0x1014bf4e0,380,DatePrototypeToPrimitive
code-creation,Builtin,2,14334,0x1014bf660,8,DatePrototypeGetYear
code-creation,Builtin,2,14334,0x1014bf680,8,DatePrototypeSetYear
code-creation,Builtin,2,14375,0x1014bf6a0,8,DateNow
code-creation,Builtin,2,14375,0x1014bf6c0,8,DateParse
code-creation,Builtin,2,14375,0x1014bf6e0,8,DatePrototypeSetDate
code-creation,Builtin,2,14375,0x1014bf700,8,DatePrototypeSetFullYear
code-creation,Builtin,2,14417,0x1014bf720,8,DatePrototypeSetHours
code-creation,Builtin,2,14417,0x1014bf740,8,DatePrototypeSetMilliseconds
code-creation,Builtin,2,14417,0x1014bf760,8,DatePrototypeSetMinutes
code-creation,Builtin,2,14417,0x1014bf780,8,DatePrototypeSetMonth
code-creation,Builtin,2,14459,0x1014bf7a0,8,DatePrototypeSetSeconds
code-creation,Builtin,2,14459,0x1014bf7c0,8,DatePrototypeSetTime
code-creation,Builtin,2,14459,0x1014bf7e0,8,DatePrototypeSetUTCDate
code-creation,Builtin,2,14459,0x1014bf800,8,DatePrototypeSetUTCFullYear
code-creation,Builtin,2,14500,0x1014bf820,8,DatePrototypeSetUTCHours
code-creation,Builtin,2,14500,0x1014bf840,8,DatePrototypeSetUTCMilliseconds
code-creation,Builtin,2,14500,0x1014bf860,8,DatePrototypeSetUTCMinutes
code-creation,Builtin,2,14500,0x1014bf880,8,DatePrototypeSetUTCMonth
code-creation,Builtin,2,14500,0x1014bf8a0,8,DatePrototypeSetUTCSeconds
code-creation,Builtin,2,14542,0x1014bf8c0,8,DatePrototypeToDateString
code-creation,Builtin,2,14542,0x1014bf8e0,8,DatePrototypeToISOString
code-creation,Builtin,2,14542,0x1014bf900,8,DatePrototypeToUTCString
code-creation,Builtin,2,14542,0x1014bf920,8,DatePrototypeToString
code-creation,Builtin,2,14584,0x1014bf940,8,DatePrototypeToTimeString
code-creation,Builtin,2,14584,0x1014bf960,8,DatePrototypeToJson
code-creation,Builtin,2,14584,0x1014bf980,8,DateUTC
code-creation,Builtin,2,14584,0x1014bf9a0,8,ErrorConstructor
code-creation,Builtin,2,14584,0x1014bf9c0,8,ErrorCaptureStackTrace
code-creation,Builtin,2,14625,0x1014bf9e0,8,ErrorPrototypeToString
code-creation,Builtin,2,14625,0x1014bfa00,8,FunctionConstructor
code-creation,Builtin,2,14625,0x1014bfa20,80,FunctionPrototypeApply
code-creation,Builtin,2,14625,0x1014bfa80,8,FunctionPrototypeBind
code-creation,Builtin,2,14667,0x1014bfaa0,152,FunctionPrototypeCall
code-creation,Builtin,2,14667,0x1014bfb40,8,FunctionPrototypeToString
code-creation,Builtin,2,14667,0x1014bfb60,228,CreateIterResultObject
code-creation,Builtin,2,14667,0x1014bfc60,936,CreateGeneratorObject
code-creation,Builtin,2,14709,0x1014c0020,8,GeneratorFunctionConstructor
code-creation,Builtin,2,14709,0x1014c0040,436,GeneratorPrototypeNext
code-creation,Builtin,2,14709,0x1014c0200,436,GeneratorPrototypeReturn
code-creation,Builtin,2,14709,0x1014c03c0,448,GeneratorPrototypeThrow
code-creation,Builtin,2,14750,0x1014c05a0,8,AsyncFunctionConstructor
code-creation,Builtin,2,14792,0x1014c05c0,368,SuspendGeneratorBaseline
code-creation,Builtin,2,14792,0x1014c0740,120,ResumeGeneratorBaseline
code-creation,Builtin,2,14792,0x1014c07c0,56,GetIteratorWithFeedbackLazyDeoptContinuation
code-creation,Builtin,2,14792,0x1014c0800,8,GlobalDecodeURI
code-creation,Builtin,2,14834,0x1014c0820,8,GlobalDecodeURIComponent
code-creation,Builtin,2,14834,0x1014c0840,8,GlobalEncodeURI
code-creation,Builtin,2,14834,0x1014c0860,8,GlobalEncodeURIComponent
code-creation,Builtin,2,14875,0x1014c0880,8,GlobalEscape
code-creation,Builtin,2,14875,0x1014c08a0,8,GlobalUnescape
code-creation,Builtin,2,14875,0x1014c08c0,8,GlobalEval
code-creation,Builtin,2,14875,0x1014c08e0,160,GlobalIsFinite
code-creation,Builtin,2,14875,0x1014c09a0,156,GlobalIsNaN
code-creation,Builtin,2,14875,0x1014c0a40,8,JsonParse
code-creation,Builtin,2,14917,0x1014c0a60,8,JsonStringify
code-creation,Builtin,2,14917,0x1014c0a80,4308,LoadIC
code-creation,Builtin,2,14917,0x1014c1b60,3972,LoadIC_Megamorphic
code-creation,Builtin,2,14917,0x1014c2b00,4220,LoadIC_Noninlined
code-creation,Builtin,2,14959,0x1014c3b80,48,LoadICTrampoline
code-creation,Builtin,2,14959,0x1014c3bc0,28,LoadICBaseline
code-creation,Builtin,2,14959,0x1014c3be0,48,LoadICTrampoline_Megamorphic
code-creation,Builtin,2,14959,0x1014c3c20,7184,LoadSuperIC
code-creation,Builtin,2,15000,0x1014c5840,28,LoadSuperICBaseline
code-creation,Builtin,2,15000,0x1014c5860,7904,KeyedLoadIC
code-creation,Builtin,2,15000,0x1014c7760,12584,KeyedLoadIC_Megamorphic
code-creation,Builtin,2,15000,0x1014ca8a0,48,KeyedLoadICTrampoline
code-creation,Builtin,2,15042,0x1014ca8e0,28,KeyedLoadICBaseline
code-creation,Builtin,2,15042,0x1014ca900,48,KeyedLoadICTrampoline_Megamorphic
code-creation,Builtin,2,15042,0x1014ca940,4532,StoreGlobalIC
code-creation,Builtin,2,15042,0x1014cbb00,48,StoreGlobalICTrampoline
code-creation,Builtin,2,15084,0x1014cbb40,28,StoreGlobalICBaseline
code-creation,Builtin,2,15084,0x1014cbb60,4752,StoreIC
code-creation,Builtin,2,15084,0x1014cce00,48,StoreICTrampoline
code-creation,Builtin,2,15084,0x1014cce40,28,StoreICBaseline
code-creation,Builtin,2,15084,0x1014cce60,4588,DefineNamedOwnIC
code-creation,Builtin,2,15125,0x1014ce060,48,DefineNamedOwnICTrampoline
code-creation,Builtin,2,15125,0x1014ce0a0,28,DefineNamedOwnICBaseline
code-creation,Builtin,2,15125,0x1014ce0c0,5180,KeyedStoreIC
code-creation,Builtin,2,15125,0x1014cf500,48,KeyedStoreICTrampoline
code-creation,Builtin,2,15167,0x1014cf540,28,KeyedStoreICBaseline
code-creation,Builtin,2,15167,0x1014cf560,5008,DefineKeyedOwnIC
code-creation,Builtin,2,15167,0x1014d0900,48,DefineKeyedOwnICTrampoline
code-creation,Builtin,2,15167,0x1014d0940,28,DefineKeyedOwnICBaseline
code-creation,Builtin,2,15167,0x1014d0960,436,StoreInArrayLiteralIC
code-creation,Builtin,2,15209,0x1014d0b20,28,StoreInArrayLiteralICBaseline
code-creation,Builtin,2,15209,0x1014d0b40,172,LookupContextBaseline
code-creation,Builtin,2,15250,0x1014d0c00,172,LookupContextInsideTypeofBaseline
code-creation,Builtin,2,15250,0x1014d0cc0,3108,LoadGlobalIC
code-creation,Builtin,2,15250,0x1014d1900,3092,LoadGlobalICInsideTypeof
code-creation,Builtin,2,15250,0x1014d2520,48,LoadGlobalICTrampoline
code-creation,Builtin,2,15250,0x1014d2560,28,LoadGlobalICBaseline
code-creation,Builtin,2,15292,0x1014d2580,48,LoadGlobalICInsideTypeofTrampoline
code-creation,Builtin,2,15292,0x1014d25c0,28,LoadGlobalICInsideTypeofBaseline
code-creation,Builtin,2,15292,0x1014d25e0,164,LookupGlobalICBaseline
code-creation,Builtin,2,15292,0x1014d26a0,164,LookupGlobalICInsideTypeofBaseline
code-creation,Builtin,2,15334,0x1014d2760,1952,CloneObjectIC
code-creation,Builtin,2,15334,0x1014d2f20,28,CloneObjectICBaseline
code-creation,Builtin,2,15334,0x1014d2f40,2236,CloneObjectIC_Slow
code-creation,Builtin,2,15334,0x1014d3800,2548,KeyedHasIC
code-creation,Builtin,2,15375,0x1014d4200,28,KeyedHasICBaseline
code-creation,Builtin,2,15375,0x1014d4220,2716,KeyedHasIC_Megamorphic
code-creation,Builtin,2,15375,0x1014d4cc0,1400,IterableToList
code-creation,Builtin,2,15375,0x1014d5240,1212,IterableToFixedArray
code-creation,Builtin,2,15417,0x1014d5700,840,IterableToListWithSymbolLookup
code-creation,Builtin,2,15417,0x1014d5a60,64,IterableToFixedArrayWithSymbolLookupSlow
code-creation,Builtin,2,15417,0x1014d5ac0,148,IterableToListMayPreserveHoles
code-creation,Builtin,2,15459,0x1014d5b60,1020,IterableToFixedArrayForWasm
code-creation,Builtin,2,15459,0x1014d5f60,1504,StringListFromIterable
code-creation,Builtin,2,15459,0x1014d6560,1204,FindOrderedHashMapEntry
code-creation,Builtin,2,15584,0x1014d6a20,4248,MapConstructor
code-creation,Builtin,2,15584,0x1014d7ac0,1968,MapPrototypeSet
code-creation,Builtin,2,15584,0x1014d8280,1520,MapPrototypeDelete
code-creation,Builtin,2,15584,0x1014d8880,236,MapPrototypeGet
code-creation,Builtin,2,15625,0x1014d8980,192,MapPrototypeHas
code-creation,Builtin,2,15625,0x1014d8a60,8,MapPrototypeClear
code-creation,Builtin,2,15625,0x1014d8a80,300,MapPrototypeEntries
code-creation,Builtin,2,15625,0x1014d8bc0,160,MapPrototypeGetSize
code-creation,Builtin,2,15625,0x1014d8c80,536,MapPrototypeForEach
code-creation,Builtin,2,15667,0x1014d8ea0,300,MapPrototypeKeys
code-creation,Builtin,2,15667,0x1014d8fe0,300,MapPrototypeValues
code-creation,Builtin,2,15667,0x1014d9120,1020,MapIteratorPrototypeNext
code-creation,Builtin,2,15667,0x1014d9520,1108,MapIteratorToList
code-creation,Builtin,2,15709,0x1014d9980,8,NumberPrototypeToExponential
code-creation,Builtin,2,15709,0x1014d99a0,8,NumberPrototypeToFixed
code-creation,Builtin,2,15709,0x1014d99c0,8,NumberPrototypeToLocaleString
code-creation,Builtin,2,15709,0x1014d99e0,8,NumberPrototypeToPrecision
code-creation,Builtin,2,15750,0x1014d9a00,324,SameValue
code-creation,Builtin,2,15750,0x1014d9b60,184,SameValueNumbersOnly
code-creation,Builtin,2,15750,0x1014d9c20,784,Add_Baseline
code-creation,Builtin,2,15750,0x1014d9f40,616,AddSmi_Baseline
code-creation,Builtin,2,15792,0x1014da1c0,848,Subtract_Baseline
code-creation,Builtin,2,15792,0x1014da520,684,SubtractSmi_Baseline
code-creation,Builtin,2,15792,0x1014da7e0,832,Multiply_Baseline
code-creation,Builtin,2,15792,0x1014dab40,756,MultiplySmi_Baseline
code-creation,Builtin,2,15834,0x1014dae40,840,Divide_Baseline
code-creation,Builtin,2,15834,0x1014db1a0,840,DivideSmi_Baseline
code-creation,Builtin,2,15834,0x1014db500,700,Modulus_Baseline
code-creation,Builtin,2,15834,0x1014db7c0,672,ModulusSmi_Baseline
code-creation,Builtin,2,15875,0x1014dba80,724,Exponentiate_Baseline
code-creation,Builtin,2,15875,0x1014dbd60,632,ExponentiateSmi_Baseline
code-creation,Builtin,2,15875,0x1014dbfe0,672,BitwiseAnd_Baseline
code-creation,Builtin,2,15875,0x1014dc2a0,352,BitwiseAndSmi_Baseline
code-creation,Builtin,2,15875,0x1014dc420,672,BitwiseOr_Baseline
code-creation,Builtin,2,15917,0x1014dc6e0,352,BitwiseOrSmi_Baseline
code-creation,Builtin,2,15917,0x1014dc860,672,BitwiseXor_Baseline
code-creation,Builtin,2,15917,0x1014dcb20,352,BitwiseXorSmi_Baseline
code-creation,Builtin,2,15917,0x1014dcca0,672,ShiftLeft_Baseline
code-creation,Builtin,2,15959,0x1014dcf60,376,ShiftLeftSmi_Baseline
code-creation,Builtin,2,15959,0x1014dd0e0,672,ShiftRight_Baseline
code-creation,Builtin,2,15959,0x1014dd3a0,364,ShiftRightSmi_Baseline
code-creation,Builtin,2,15959,0x1014dd520,800,ShiftRightLogical_Baseline
code-creation,Builtin,2,15959,0x1014dd860,632,ShiftRightLogicalSmi_Baseline
code-creation,Builtin,2,16000,0x1014ddae0,696,Add_WithFeedback
code-creation,Builtin,2,16000,0x1014ddda0,784,Subtract_WithFeedback
code-creation,Builtin,2,16000,0x1014de0c0,784,Multiply_WithFeedback
code-creation,Builtin,2,16000,0x1014de3e0,792,Divide_WithFeedback
code-creation,Builtin,2,16042,0x1014de700,652,Modulus_WithFeedback
code-creation,Builtin,2,16042,0x1014de9a0,676,Exponentiate_WithFeedback
code-creation,Builtin,2,16042,0x1014dec60,660,BitwiseAnd_WithFeedback
code-creation,Builtin,2,16042,0x1014def00,660,BitwiseOr_WithFeedback
code-creation,Builtin,2,16042,0x1014df1a0,660,BitwiseXor_WithFeedback
code-creation,Builtin,2,16084,0x1014df440,660,ShiftLeft_WithFeedback
code-creation,Builtin,2,16084,0x1014df6e0,660,ShiftRight_WithFeedback
tick,0x1011d911c,16125,0,0x0,6
tick,0x195a4df24,16125,0,0x0,6
tick,0x195a4df24,16167,0,0x0,6
tick,0x195a4df24,16167,0,0x0,6
code-creation,Builtin,2,16709,0x1014df980,784,ShiftRightLogical_WithFeedback
code-creation,Builtin,2,16709,0x1014dfca0,1712,Equal_Baseline
code-creation,Builtin,2,16792,0x1014e0360,788,StrictEqual_Baseline
code-creation,Builtin,2,16792,0x1014e0680,1232,LessThan_Baseline
code-creation,Builtin,2,16792,0x1014e0b60,1232,GreaterThan_Baseline
code-creation,Builtin,2,16834,0x1014e1040,1232,LessThanOrEqual_Baseline
code-creation,Builtin,2,16834,0x1014e1520,1232,GreaterThanOrEqual_Baseline
code-creation,Builtin,2,16834,0x1014e1a00,1732,Equal_WithFeedback
code-creation,Builtin,2,16834,0x1014e20e0,808,StrictEqual_WithFeedback
code-creation,Builtin,2,16875,0x1014e2420,1208,LessThan_WithFeedback
code-creation,Builtin,2,16875,0x1014e28e0,1208,GreaterThan_WithFeedback
code-creation,Builtin,2,16875,0x1014e2da0,1208,LessThanOrEqual_WithFeedback
code-creation,Builtin,2,16875,0x1014e3260,1208,GreaterThanOrEqual_WithFeedback
code-creation,Builtin,2,16875,0x1014e3720,312,BitwiseNot_Baseline
code-creation,Builtin,2,16917,0x1014e3860,460,Decrement_Baseline
code-creation,Builtin,2,16917,0x1014e3a40,460,Increment_Baseline
code-creation,Builtin,2,16917,0x1014e3c20,476,Negate_Baseline
code-creation,Builtin,2,16917,0x1014e3e00,292,BitwiseNot_WithFeedback
code-creation,Builtin,2,16959,0x1014e3f40,440,Decrement_WithFeedback
code-creation,Builtin,2,16959,0x1014e4100,440,Increment_WithFeedback
code-creation,Builtin,2,16959,0x1014e42c0,460,Negate_WithFeedback
code-creation,Builtin,2,16959,0x1014e44a0,292,ObjectAssign
code-creation,Builtin,2,16959,0x1014e45e0,860,ObjectCreate
code-creation,Builtin,2,16959,0x1014e4940,8,ObjectDefineGetter
code-creation,Builtin,2,17000,0x1014e4960,8,ObjectDefineProperties
code-creation,Builtin,2,17000,0x1014e4980,8,ObjectDefineProperty
code-creation,Builtin,2,17000,0x1014e49a0,8,ObjectDefineSetter
code-creation,Builtin,2,17000,0x1014e49c0,1508,ObjectEntries
code-creation,Builtin,2,17000,0x1014e4fc0,8,ObjectFreeze
code-creation,Builtin,2,17000,0x1014e4fe0,5568,ObjectGetOwnPropertyDescriptor
code-creation,Builtin,2,17042,0x1014e65c0,8,ObjectGetOwnPropertyDescriptors
code-creation,Builtin,2,17042,0x1014e65e0,632,ObjectGetOwnPropertyNames
code-creation,Builtin,2,17042,0x1014e6860,8,ObjectGetOwnPropertySymbols
code-creation,Builtin,2,17042,0x1014e6880,208,ObjectHasOwn
code-creation,Builtin,2,17084,0x1014e6960,388,ObjectIs
code-creation,Builtin,2,17084,0x1014e6b00,8,ObjectIsFrozen
code-creation,Builtin,2,17084,0x1014e6b20,8,ObjectIsSealed
code-creation,Builtin,2,17084,0x1014e6b40,572,ObjectKeys
code-creation,Builtin,2,17084,0x1014e6d80,8,ObjectLookupGetter
code-creation,Builtin,2,17125,0x1014e6da0,8,ObjectLookupSetter
code-creation,Builtin,2,17125,0x1014e6dc0,2312,ObjectPrototypeHasOwnProperty
code-creation,Builtin,2,17125,0x1014e76e0,268,ObjectPrototypeIsPrototypeOf
code-creation,Builtin,2,17125,0x1014e7800,8,ObjectPrototypePropertyIsEnumerable
code-creation,Builtin,2,17167,0x1014e7820,8,ObjectPrototypeGetProto
code-creation,Builtin,2,17167,0x1014e7840,8,ObjectPrototypeSetProto
code-creation,Builtin,2,17167,0x1014e7860,8,ObjectSeal
code-creation,Builtin,2,17167,0x1014e7880,1108,ObjectToString
code-creation,Builtin,2,17209,0x1014e7ce0,1256,ObjectValues
code-creation,Builtin,2,17209,0x1014e81e0,412,OrdinaryHasInstance
code-creation,Builtin,2,17209,0x1014e8380,432,InstanceOf
code-creation,Builtin,2,17209,0x1014e8540,660,InstanceOf_WithFeedback
code-creation,Builtin,2,17250,0x1014e87e0,676,InstanceOf_Baseline
code-creation,Builtin,2,17250,0x1014e8aa0,304,ForInEnumerate
code-creation,Builtin,2,17250,0x1014e8be0,144,ForInPrepare
code-creation,Builtin,2,17250,0x1014e8c80,2696,ForInFilter
code-creation,Builtin,2,17292,0x1014e9720,68,ReflectApply
code-creation,Builtin,2,17292,0x1014e9780,72,ReflectConstruct
code-creation,Builtin,2,17292,0x1014e97e0,8,ReflectDefineProperty
code-creation,Builtin,2,17292,0x1014e9800,8,ReflectGetOwnPropertyDescriptor
code-creation,Builtin,2,17292,0x1014e9820,8,ReflectOwnKeys
code-creation,Builtin,2,17334,0x1014e9840,8,ReflectSet
code-creation,Builtin,2,17334,0x1014e9860,8,RegExpCapture1Getter
code-creation,Builtin,2,17334,0x1014e9880,8,RegExpCapture2Getter
code-creation,Builtin,2,17375,0x1014e98a0,8,RegExpCapture3Getter
code-creation,Builtin,2,17375,0x1014e98c0,8,RegExpCapture4Getter
code-creation,Builtin,2,17375,0x1014e98e0,8,RegExpCapture5Getter
code-creation,Builtin,2,17375,0x1014e9900,8,RegExpCapture6Getter
code-creation,Builtin,2,17375,0x1014e9920,8,RegExpCapture7Getter
code-creation,Builtin,2,17417,0x1014e9940,8,RegExpCapture8Getter
code-creation,Builtin,2,17417,0x1014e9960,8,RegExpCapture9Getter
code-creation,Builtin,2,17417,0x1014e9980,2156,RegExpConstructor
code-creation,Builtin,2,17417,0x1014ea200,8,RegExpInputGetter
code-creation,Builtin,2,17459,0x1014ea220,8,RegExpInputSetter
code-creation,Builtin,2,17459,0x1014ea240,8,RegExpLastMatchGetter
code-creation,Builtin,2,17459,0x1014ea260,8,RegExpLastParenGetter
code-creation,Builtin,2,17459,0x1014ea280,8,RegExpLeftContextGetter
code-creation,Builtin,2,17459,0x1014ea2a0,832,RegExpPrototypeCompile
code-creation,Builtin,2,17500,0x1014ea600,8,RegExpPrototypeToString
code-creation,Builtin,2,17500,0x1014ea620,8,RegExpRightContextGetter
code-creation,Builtin,2,17500,0x1014ea640,240,RegExpExecAtom
code-creation,Builtin,2,17500,0x1014ea740,984,RegExpExecInternal
code-creation,Builtin,2,17542,0x1014eab20,8,RegExpInterpreterTrampoline
code-creation,Builtin,2,17542,0x1014eab40,8,RegExpExperimentalTrampoline
code-creation,Builtin,2,17542,0x1014eab60,2780,SetConstructor
code-creation,Builtin,2,17542,0x1014eb640,1276,SetPrototypeHas
code-creation,Builtin,2,17584,0x1014ebb40,1760,SetPrototypeAdd
code-creation,Builtin,2,17584,0x1014ec240,1472,SetPrototypeDelete
code-creation,Builtin,2,17584,0x1014ec820,8,SetPrototypeClear
code-creation,Builtin,2,17584,0x1014ec840,300,SetPrototypeEntries
code-creation,Builtin,2,17584,0x1014ec980,160,SetPrototypeGetSize
code-creation,Builtin,2,17625,0x1014eca40,500,SetPrototypeForEach
code-creation,Builtin,2,17625,0x1014ecc40,300,SetPrototypeValues
code-creation,Builtin,2,17625,0x1014ecd80,952,SetIteratorPrototypeNext
code-creation,Builtin,2,17625,0x1014ed140,1068,SetOrSetIteratorToList
code-creation,Builtin,2,17625,0x1014ed580,8,ShadowRealmConstructor
code-creation,Builtin,2,17667,0x1014ed5a0,664,ShadowRealmGetWrappedValue
code-creation,Builtin,2,17667,0x1014ed840,8,ShadowRealmPrototypeEvaluate
code-creation,Builtin,2,17667,0x1014ed860,8,ShadowRealmPrototypeImportValue
code-creation,Builtin,2,17667,0x1014ed880,8,SharedArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,17709,0x1014ed8a0,8,SharedArrayBufferPrototypeSlice
code-creation,Builtin,2,17709,0x1014ed8c0,8,SharedArrayBufferPrototypeGrow
code-creation,Builtin,2,17709,0x1014ed8e0,1340,AtomicsLoad
code-creation,Builtin,2,17709,0x1014ede20,1072,AtomicsStore
code-creation,Builtin,2,17750,0x1014ee260,1776,AtomicsExchange
code-creation,Builtin,2,17750,0x1014ee960,2128,AtomicsCompareExchange
code-creation,Builtin,2,17750,0x1014ef1c0,1768,AtomicsAdd
code-creation,Builtin,2,17750,0x1014ef8c0,1768,AtomicsSub
code-creation,Builtin,2,17750,0x1014effc0,1768,AtomicsAnd
code-creation,Builtin,2,17792,0x1014f06c0,1768,AtomicsOr
code-creation,Builtin,2,17792,0x1014f0dc0,1768,AtomicsXor
code-creation,Builtin,2,17792,0x1014f14c0,8,AtomicsNotify
code-creation,Builtin,2,17792,0x1014f14e0,8,AtomicsIsLockFree
code-creation,Builtin,2,17792,0x1014f1500,8,AtomicsWait
code-creation,Builtin,2,17834,0x1014f1520,8,AtomicsWaitAsync
code-creation,Builtin,2,17834,0x1014f1540,8,StringFromCodePoint
code-creation,Builtin,2,17834,0x1014f1560,1452,StringFromCharCode
code-creation,Builtin,2,17834,0x1014f1b20,8,StringPrototypeLastIndexOf
code-creation,Builtin,2,17834,0x1014f1b40,4188,StringPrototypeMatchAll
code-creation,Builtin,2,17875,0x1014f2ba0,8,StringPrototypeLocaleCompare
code-creation,Builtin,2,17875,0x1014f2bc0,1260,StringPrototypeReplace
code-creation,Builtin,2,17875,0x1014f30c0,2676,StringPrototypeSplit
code-creation,Builtin,2,17875,0x1014f3b40,8,StringRaw
code-creation,Builtin,2,17917,0x1014f3b60,8,SymbolConstructor
code-creation,Builtin,2,17917,0x1014f3b80,8,SymbolFor
code-creation,Builtin,2,17917,0x1014f3ba0,8,SymbolKeyFor
code-creation,Builtin,2,17917,0x1014f3bc0,96,TypedArrayBaseConstructor
code-creation,Builtin,2,17959,0x1014f3c40,320,TypedArrayConstructor
code-creation,Builtin,2,17959,0x1014f3da0,8,TypedArrayPrototypeBuffer
code-creation,Builtin,2,17959,0x1014f3dc0,884,TypedArrayPrototypeByteLength
code-creation,Builtin,2,18000,0x1014f4140,336,TypedArrayPrototypeByteOffset
code-creation,Builtin,2,18000,0x1014f42a0,596,TypedArrayPrototypeLength
code-creation,Builtin,2,18000,0x1014f4500,8,TypedArrayPrototypeCopyWithin
code-creation,Builtin,2,18000,0x1014f4520,8,TypedArrayPrototypeFill
code-creation,Builtin,2,18042,0x1014f4540,8,TypedArrayPrototypeIncludes
code-creation,Builtin,2,18042,0x1014f4560,8,TypedArrayPrototypeIndexOf
code-creation,Builtin,2,18042,0x1014f4580,8,TypedArrayPrototypeLastIndexOf
code-creation,Builtin,2,18042,0x1014f45a0,8,TypedArrayPrototypeReverse
code-creation,Builtin,2,18084,0x1014f45c0,316,TypedArrayPrototypeToStringTag
code-creation,Builtin,2,18084,0x1014f4700,21764,TypedArrayPrototypeMap
code-creation,Builtin,2,18084,0x1014f9c20,4,GenericJSToWasmWrapper
code-creation,Builtin,2,18084,0x1014f9c40,4,WasmReturnPromiseOnSuspend
code-creation,Builtin,2,18125,0x1014f9c60,4,WasmSuspend
code-creation,Builtin,2,18125,0x1014f9c80,4,WasmResume
code-creation,Builtin,2,18125,0x1014f9ca0,132,WasmCompileLazy
code-creation,Builtin,2,18125,0x1014f9d40,260,WasmDebugBreak
code-creation,Builtin,2,18167,0x1014f9e60,4,WasmOnStackReplace
code-creation,Builtin,2,18167,0x1014f9e80,160,WasmFloat32ToNumber
code-creation,Builtin,2,18167,0x1014f9f40,164,WasmFloat64ToNumber
code-creation,Builtin,2,18167,0x1014fa000,8,WasmI32AtomicWait32
code-creation,Builtin,2,18167,0x1014fa020,8,WasmI64AtomicWait32
code-creation,Builtin,2,18209,0x1014fa040,24,JSToWasmLazyDeoptContinuation
code-creation,Builtin,2,18209,0x1014fa060,4392,WeakMapConstructor
code-creation,Builtin,2,18209,0x1014fb1a0,216,WeakMapLookupHashIndex
code-creation,Builtin,2,18209,0x1014fb280,244,WeakMapGet
code-creation,Builtin,2,18209,0x1014fb380,204,WeakMapPrototypeHas
code-creation,Builtin,2,18250,0x1014fb460,236,WeakMapPrototypeSet
code-creation,Builtin,2,18250,0x1014fb560,176,WeakMapPrototypeDelete
code-creation,Builtin,2,18250,0x1014fb620,2956,WeakSetConstructor
code-creation,Builtin,2,18250,0x1014fc1c0,204,WeakSetPrototypeHas
code-creation,Builtin,2,18292,0x1014fc2a0,236,WeakSetPrototypeAdd
code-creation,Builtin,2,18292,0x1014fc3a0,176,WeakSetPrototypeDelete
code-creation,Builtin,2,18292,0x1014fc460,428,WeakCollectionDelete
code-creation,Builtin,2,18292,0x1014fc620,720,WeakCollectionSet
code-creation,Builtin,2,18334,0x1014fc900,8,SharedStructTypeConstructor
code-creation,Builtin,2,18334,0x1014fc920,8,SharedStructConstructor
code-creation,Builtin,2,18334,0x1014fc940,316,AsyncGeneratorResolve
code-creation,Builtin,2,18334,0x1014fca80,108,AsyncGeneratorReject
code-creation,Builtin,2,18375,0x1014fcb00,1900,AsyncGeneratorYield
code-creation,Builtin,2,18375,0x1014fd280,2004,AsyncGeneratorReturn
code-creation,Builtin,2,18375,0x1014fda60,308,AsyncGeneratorResumeNext
code-creation,Builtin,2,18417,0x1014fdba0,8,AsyncGeneratorFunctionConstructor
code-creation,Builtin,2,18417,0x1014fdbc0,988,AsyncGeneratorPrototypeNext
code-creation,Builtin,2,18417,0x1014fdfa0,980,AsyncGeneratorPrototypeReturn
code-creation,Builtin,2,18417,0x1014fe380,980,AsyncGeneratorPrototypeThrow
code-creation,Builtin,2,18417,0x1014fe760,1856,AsyncGeneratorAwaitCaught
code-creation,Builtin,2,18459,0x1014feec0,1856,AsyncGeneratorAwaitUncaught
code-creation,Builtin,2,18459,0x1014ff620,188,AsyncGeneratorAwaitResolveClosure
code-creation,Builtin,2,18459,0x1014ff6e0,192,AsyncGeneratorAwaitRejectClosure
code-creation,Builtin,2,18459,0x1014ff7c0,128,AsyncGeneratorYieldResolveClosure
code-creation,Builtin,2,18500,0x1014ff860,128,AsyncGeneratorReturnClosedResolveClosure
code-creation,Builtin,2,18500,0x1014ff900,124,AsyncGeneratorReturnClosedRejectClosure
code-creation,Builtin,2,18542,0x1014ff980,192,AsyncGeneratorReturnResolveClosure
code-creation,Builtin,2,18542,0x1014ffa60,1680,AsyncFromSyncIteratorPrototypeNext
code-creation,Builtin,2,18542,0x101500100,1792,AsyncFromSyncIteratorPrototypeThrow
code-creation,Builtin,2,18584,0x101500820,1816,AsyncFromSyncIteratorPrototypeReturn
code-creation,Builtin,2,18584,0x101500f40,128,AsyncIteratorValueUnwrap
code-creation,Builtin,2,18584,0x101500fe0,304,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,18625,0x101501120,304,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,18625,0x101501260,284,CEntry_Return1_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,18625,0x101501380,400,CEntry_Return1_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,18625,0x101501520,400,CEntry_Return1_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,18625,0x1015016c0,304,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,18667,0x101501800,304,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,18667,0x101501940,284,CEntry_Return2_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,18667,0x101501a60,400,CEntry_Return2_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,18667,0x101501c00,400,CEntry_Return2_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,18709,0x101501da0,16,DirectCEntry
code-creation,Builtin,2,18709,0x101501dc0,1204,StringAdd_CheckNone
code-creation,Builtin,2,18709,0x101502280,2696,SubString
code-creation,Builtin,2,18709,0x101502d20,12,StackCheck
code-creation,Builtin,2,18709,0x101502d40,80,DoubleToI
code-creation,Builtin,2,18750,0x101502da0,2420,GetProperty
code-creation,Builtin,2,18750,0x101503720,2604,GetPropertyWithReceiver
code-creation,Builtin,2,18750,0x101504160,14432,SetProperty
code-creation,Builtin,2,18750,0x1015079e0,12388,CreateDataProperty
code-creation,Builtin,2,18792,0x10150aa60,4,MemCopyUint8Uint8
code-creation,Builtin,2,19292,0x10150aa80,4,MemMove
code-creation,Builtin,2,19292,0x10150aaa0,8,IsTraceCategoryEnabled
code-creation,Builtin,2,19292,0x10150aac0,8,Trace
code-creation,Builtin,2,19334,0x10150aae0,8,FinalizationRegistryUnregister
code-creation,Builtin,2,19334,0x10150ab00,440,AsyncModuleEvaluate
code-creation,Builtin,2,19334,0x10150acc0,8,CallAsyncModuleFulfilled
code-creation,Builtin,2,19334,0x10150ace0,8,CallAsyncModuleRejected
code-creation,Builtin,2,19334,0x10150ad00,8,TemporalNowTimeZone
code-creation,Builtin,2,19375,0x10150ad20,8,TemporalNowInstant
code-creation,Builtin,2,19375,0x10150ad40,8,TemporalNowPlainDateTime
code-creation,Builtin,2,19375,0x10150ad60,8,TemporalNowPlainDateTimeISO
code-creation,Builtin,2,19417,0x10150ad80,8,TemporalNowZonedDateTime
code-creation,Builtin,2,19417,0x10150ada0,8,TemporalNowZonedDateTimeISO
code-creation,Builtin,2,19417,0x10150adc0,8,TemporalNowPlainDate
code-creation,Builtin,2,19459,0x10150ade0,8,TemporalNowPlainDateISO
code-creation,Builtin,2,19459,0x10150ae00,8,TemporalNowPlainTimeISO
code-creation,Builtin,2,19459,0x10150ae20,8,TemporalPlainDateConstructor
code-creation,Builtin,2,19459,0x10150ae40,8,TemporalPlainDateFrom
code-creation,Builtin,2,19500,0x10150ae60,8,TemporalPlainDateCompare
code-creation,Builtin,2,19500,0x10150ae80,8,TemporalPlainDatePrototypeCalendar
code-creation,Builtin,2,19500,0x10150aea0,8,TemporalPlainDatePrototypeYear
code-creation,Builtin,2,19500,0x10150aec0,8,TemporalPlainDatePrototypeMonth
code-creation,Builtin,2,19542,0x10150aee0,8,TemporalPlainDatePrototypeMonthCode
code-creation,Builtin,2,19542,0x10150af00,8,TemporalPlainDatePrototypeDay
code-creation,Builtin,2,19542,0x10150af20,8,TemporalPlainDatePrototypeDayOfWeek
code-creation,Builtin,2,19542,0x10150af40,8,TemporalPlainDatePrototypeDayOfYear
code-creation,Builtin,2,19584,0x10150af60,8,TemporalPlainDatePrototypeWeekOfYear
code-creation,Builtin,2,19584,0x10150af80,8,TemporalPlainDatePrototypeDaysInWeek
code-creation,Builtin,2,19584,0x10150afa0,8,TemporalPlainDatePrototypeDaysInMonth
code-creation,Builtin,2,19584,0x10150afc0,8,TemporalPlainDatePrototypeDaysInYear
code-creation,Builtin,2,19625,0x10150afe0,8,TemporalPlainDatePrototypeMonthsInYear
code-creation,Builtin,2,19625,0x10150b000,8,TemporalPlainDatePrototypeInLeapYear
code-creation,Builtin,2,19667,0x10150b020,8,TemporalPlainDatePrototypeToPlainYearMonth
code-creation,Builtin,2,19667,0x10150b040,8,TemporalPlainDatePrototypeToPlainMonthDay
code-creation,Builtin,2,19667,0x10150b060,8,TemporalPlainDatePrototypeGetISOFields
code-creation,Builtin,2,19667,0x10150b080,8,TemporalPlainDatePrototypeAdd
code-creation,Builtin,2,19709,0x10150b0a0,8,TemporalPlainDatePrototypeSubtract
code-creation,Builtin,2,19709,0x10150b0c0,8,TemporalPlainDatePrototypeWith
code-creation,Builtin,2,19709,0x10150b0e0,8,TemporalPlainDatePrototypeWithCalendar
code-creation,Builtin,2,19750,0x10150b100,8,TemporalPlainDatePrototypeUntil
code-creation,Builtin,2,19750,0x10150b120,8,TemporalPlainDatePrototypeSince
code-creation,Builtin,2,19750,0x10150b140,8,TemporalPlainDatePrototypeEquals
code-creation,Builtin,2,19750,0x10150b160,8,TemporalPlainDatePrototypeToPlainDateTime
code-creation,Builtin,2,19792,0x10150b180,8,TemporalPlainDatePrototypeToZonedDateTime
code-creation,Builtin,2,19792,0x10150b1a0,8,TemporalPlainDatePrototypeToString
code-creation,Builtin,2,19834,0x10150b1c0,8,TemporalPlainDatePrototypeToJSON
code-creation,Builtin,2,19834,0x10150b1e0,8,TemporalPlainDatePrototypeValueOf
code-creation,Builtin,2,19834,0x10150b200,8,TemporalPlainTimeConstructor
code-creation,Builtin,2,19834,0x10150b220,8,TemporalPlainTimeFrom
code-creation,Builtin,2,19875,0x10150b240,8,TemporalPlainTimeCompare
code-creation,Builtin,2,19875,0x10150b260,8,TemporalPlainTimePrototypeCalendar
code-creation,Builtin,2,19875,0x10150b280,8,TemporalPlainTimePrototypeHour
code-creation,Builtin,2,19875,0x10150b2a0,8,TemporalPlainTimePrototypeMinute
code-creation,Builtin,2,19917,0x10150b2c0,8,TemporalPlainTimePrototypeSecond
code-creation,Builtin,2,19917,0x10150b2e0,8,TemporalPlainTimePrototypeMillisecond
code-creation,Builtin,2,19917,0x10150b300,8,TemporalPlainTimePrototypeMicrosecond
code-creation,Builtin,2,19917,0x10150b320,8,TemporalPlainTimePrototypeNanosecond
code-creation,Builtin,2,19959,0x10150b340,8,TemporalPlainTimePrototypeAdd
code-creation,Builtin,2,19959,0x10150b360,8,TemporalPlainTimePrototypeSubtract
code-creation,Builtin,2,19959,0x10150b380,8,TemporalPlainTimePrototypeWith
code-creation,Builtin,2,20000,0x10150b3a0,8,TemporalPlainTimePrototypeUntil
code-creation,Builtin,2,20000,0x10150b3c0,8,TemporalPlainTimePrototypeSince
code-creation,Builtin,2,20000,0x10150b3e0,8,TemporalPlainTimePrototypeRound
code-creation,Builtin,2,20000,0x10150b400,8,TemporalPlainTimePrototypeEquals
code-creation,Builtin,2,20042,0x10150b420,8,TemporalPlainTimePrototypeToPlainDateTime
code-creation,Builtin,2,20042,0x10150b440,8,TemporalPlainTimePrototypeToZonedDateTime
code-creation,Builtin,2,20042,0x10150b460,8,TemporalPlainTimePrototypeGetISOFields
code-creation,Builtin,2,20084,0x10150b480,8,TemporalPlainTimePrototypeToString
code-creation,Builtin,2,20084,0x10150b4a0,8,TemporalPlainTimePrototypeToJSON
code-creation,Builtin,2,20084,0x10150b4c0,8,TemporalPlainTimePrototypeValueOf
code-creation,Builtin,2,20125,0x10150b4e0,8,TemporalPlainDateTimeConstructor
code-creation,Builtin,2,20125,0x10150b500,8,TemporalPlainDateTimeFrom
code-creation,Builtin,2,20125,0x10150b520,8,TemporalPlainDateTimeCompare
code-creation,Builtin,2,20125,0x10150b540,8,TemporalPlainDateTimePrototypeCalendar
code-creation,Builtin,2,20167,0x10150b560,8,TemporalPlainDateTimePrototypeYear
code-creation,Builtin,2,20167,0x10150b580,8,TemporalPlainDateTimePrototypeMonth
code-creation,Builtin,2,20167,0x10150b5a0,8,TemporalPlainDateTimePrototypeMonthCode
code-creation,Builtin,2,20209,0x10150b5c0,8,TemporalPlainDateTimePrototypeDay
code-creation,Builtin,2,20209,0x10150b5e0,8,TemporalPlainDateTimePrototypeHour
code-creation,Builtin,2,20250,0x10150b600,8,TemporalPlainDateTimePrototypeMinute
code-creation,Builtin,2,20250,0x10150b620,8,TemporalPlainDateTimePrototypeSecond
code-creation,Builtin,2,20250,0x10150b640,8,TemporalPlainDateTimePrototypeMillisecond
code-creation,Builtin,2,20292,0x10150b660,8,TemporalPlainDateTimePrototypeMicrosecond
code-creation,Builtin,2,20292,0x10150b680,8,TemporalPlainDateTimePrototypeNanosecond
code-creation,Builtin,2,20334,0x10150b6a0,8,TemporalPlainDateTimePrototypeDayOfWeek
code-creation,Builtin,2,20334,0x10150b6c0,8,TemporalPlainDateTimePrototypeDayOfYear
code-creation,Builtin,2,20334,0x10150b6e0,8,TemporalPlainDateTimePrototypeWeekOfYear
code-creation,Builtin,2,20334,0x10150b700,8,TemporalPlainDateTimePrototypeDaysInWeek
code-creation,Builtin,2,20417,0x10150b720,8,TemporalPlainDateTimePrototypeDaysInMonth
tick,0x195a4df24,20459,0,0x0,6
tick,0x195a4df24,20500,0,0x0,6
tick,0x1959fede4,20542,0,0x0,6
code-creation,Builtin,2,20542,0x10150b740,8,TemporalPlainDateTimePrototypeDaysInYear
code-creation,Builtin,2,20584,0x10150b760,8,TemporalPlainDateTimePrototypeMonthsInYear
code-creation,Builtin,2,20584,0x10150b780,8,TemporalPlainDateTimePrototypeInLeapYear
code-creation,Builtin,2,20584,0x10150b7a0,8,TemporalPlainDateTimePrototypeWith
code-creation,Builtin,2,20584,0x10150b7c0,8,TemporalPlainDateTimePrototypeWithPlainTime
code-creation,Builtin,2,20625,0x10150b7e0,8,TemporalPlainDateTimePrototypeWithPlainDate
code-creation,Builtin,2,20625,0x10150b800,8,TemporalPlainDateTimePrototypeWithCalendar
code-creation,Builtin,2,20625,0x10150b820,8,TemporalPlainDateTimePrototypeAdd
code-creation,Builtin,2,20667,0x10150b840,8,TemporalPlainDateTimePrototypeSubtract
code-creation,Builtin,2,20667,0x10150b860,8,TemporalPlainDateTimePrototypeUntil
code-creation,Builtin,2,20667,0x10150b880,8,TemporalPlainDateTimePrototypeSince
code-creation,Builtin,2,20709,0x10150b8a0,8,TemporalPlainDateTimePrototypeRound
code-creation,Builtin,2,20709,0x10150b8c0,8,TemporalPlainDateTimePrototypeEquals
code-creation,Builtin,2,20709,0x10150b8e0,8,TemporalPlainDateTimePrototypeToString
code-creation,Builtin,2,20750,0x10150b900,8,TemporalPlainDateTimePrototypeToJSON
code-creation,Builtin,2,20750,0x10150b920,8,TemporalPlainDateTimePrototypeValueOf
code-creation,Builtin,2,20750,0x10150b940,8,TemporalPlainDateTimePrototypeToZonedDateTime
code-creation,Builtin,2,20750,0x10150b960,8,TemporalPlainDateTimePrototypeToPlainDate
code-creation,Builtin,2,20792,0x10150b980,8,TemporalPlainDateTimePrototypeToPlainYearMonth
code-creation,Builtin,2,20792,0x10150b9a0,8,TemporalPlainDateTimePrototypeToPlainMonthDay
code-creation,Builtin,2,20792,0x10150b9c0,8,TemporalPlainDateTimePrototypeToPlainTime
code-creation,Builtin,2,20792,0x10150b9e0,8,TemporalPlainDateTimePrototypeGetISOFields
code-creation,Builtin,2,20792,0x10150ba00,8,TemporalZonedDateTimeConstructor
code-creation,Builtin,2,20834,0x10150ba20,8,TemporalZonedDateTimeFrom
code-creation,Builtin,2,20834,0x10150ba40,8,TemporalZonedDateTimeCompare
code-creation,Builtin,2,20834,0x10150ba60,8,TemporalZonedDateTimePrototypeCalendar
code-creation,Builtin,2,20875,0x10150ba80,8,TemporalZonedDateTimePrototypeTimeZone
code-creation,Builtin,2,20875,0x10150baa0,8,TemporalZonedDateTimePrototypeYear
code-creation,Builtin,2,20875,0x10150bac0,8,TemporalZonedDateTimePrototypeMonth
code-creation,Builtin,2,20875,0x10150bae0,8,TemporalZonedDateTimePrototypeMonthCode
code-creation,Builtin,2,20917,0x10150bb00,8,TemporalZonedDateTimePrototypeDay
code-creation,Builtin,2,20917,0x10150bb20,8,TemporalZonedDateTimePrototypeHour
code-creation,Builtin,2,20917,0x10150bb40,8,TemporalZonedDateTimePrototypeMinute
code-creation,Builtin,2,20917,0x10150bb60,8,TemporalZonedDateTimePrototypeSecond
code-creation,Builtin,2,20959,0x10150bb80,8,TemporalZonedDateTimePrototypeMillisecond
code-creation,Builtin,2,20959,0x10150bba0,8,TemporalZonedDateTimePrototypeMicrosecond
code-creation,Builtin,2,21000,0x10150bbc0,8,TemporalZonedDateTimePrototypeNanosecond
code-creation,Builtin,2,21000,0x10150bbe0,8,TemporalZonedDateTimePrototypeEpochSeconds
code-creation,Builtin,2,21000,0x10150bc00,8,TemporalZonedDateTimePrototypeEpochMilliseconds
code-creation,Builtin,2,21000,0x10150bc20,8,TemporalZonedDateTimePrototypeEpochMicroseconds
code-creation,Builtin,2,21042,0x10150bc40,8,TemporalZonedDateTimePrototypeEpochNanoseconds
code-creation,Builtin,2,21042,0x10150bc60,8,TemporalZonedDateTimePrototypeDayOfWeek
code-creation,Builtin,2,21084,0x10150bc80,8,TemporalZonedDateTimePrototypeDayOfYear
code-creation,Builtin,2,21084,0x10150bca0,8,TemporalZonedDateTimePrototypeWeekOfYear
code-creation,Builtin,2,21084,0x10150bcc0,8,TemporalZonedDateTimePrototypeHoursInDay
code-creation,Builtin,2,21084,0x10150bce0,8,TemporalZonedDateTimePrototypeDaysInWeek
code-creation,Builtin,2,21125,0x10150bd00,8,TemporalZonedDateTimePrototypeDaysInMonth
code-creation,Builtin,2,21125,0x10150bd20,8,TemporalZonedDateTimePrototypeDaysInYear
code-creation,Builtin,2,21125,0x10150bd40,8,TemporalZonedDateTimePrototypeMonthsInYear
code-creation,Builtin,2,21167,0x10150bd60,8,TemporalZonedDateTimePrototypeInLeapYear
code-creation,Builtin,2,21167,0x10150bd80,8,TemporalZonedDateTimePrototypeOffsetNanoseconds
code-creation,Builtin,2,21167,0x10150bda0,8,TemporalZonedDateTimePrototypeOffset
code-creation,Builtin,2,21209,0x10150bdc0,8,TemporalZonedDateTimePrototypeWith
code-creation,Builtin,2,21209,0x10150bde0,8,TemporalZonedDateTimePrototypeWithPlainTime
code-creation,Builtin,2,21209,0x10150be00,8,TemporalZonedDateTimePrototypeWithPlainDate
code-creation,Builtin,2,21250,0x10150be20,8,TemporalZonedDateTimePrototypeWithTimeZone
code-creation,Builtin,2,21292,0x10150be40,8,TemporalZonedDateTimePrototypeWithCalendar
code-creation,Builtin,2,21292,0x10150be60,8,TemporalZonedDateTimePrototypeAdd
code-creation,Builtin,2,21334,0x10150be80,8,TemporalZonedDateTimePrototypeSubtract
code-creation,Builtin,2,21334,0x10150bea0,8,TemporalZonedDateTimePrototypeUntil
code-creation,Builtin,2,21375,0x10150bec0,8,TemporalZonedDateTimePrototypeSince
code-creation,Builtin,2,21417,0x10150bee0,8,TemporalZonedDateTimePrototypeRound
code-creation,Builtin,2,21417,0x10150bf00,8,TemporalZonedDateTimePrototypeEquals
code-creation,Builtin,2,21459,0x10150bf20,8,TemporalZonedDateTimePrototypeToString
code-creation,Builtin,2,21500,0x10150bf40,8,TemporalZonedDateTimePrototypeToJSON
code-creation,Builtin,2,21500,0x10150bf60,8,TemporalZonedDateTimePrototypeValueOf
code-creation,Builtin,2,21542,0x10150bf80,8,TemporalZonedDateTimePrototypeStartOfDay
code-creation,Builtin,2,21584,0x10150bfa0,8,TemporalZonedDateTimePrototypeToInstant
code-creation,Builtin,2,21625,0x10150bfc0,8,TemporalZonedDateTimePrototypeToPlainDate
code-creation,Builtin,2,21625,0x10150bfe0,8,TemporalZonedDateTimePrototypeToPlainTime
code-creation,Builtin,2,21667,0x10150c000,8,TemporalZonedDateTimePrototypeToPlainDateTime
code-creation,Builtin,2,21709,0x10150c020,8,TemporalZonedDateTimePrototypeToPlainYearMonth
code-creation,Builtin,2,21750,0x10150c040,8,TemporalZonedDateTimePrototypeToPlainMonthDay
code-creation,Builtin,2,21792,0x10150c060,8,TemporalZonedDateTimePrototypeGetISOFields
code-creation,Builtin,2,21792,0x10150c080,8,TemporalDurationConstructor
code-creation,Builtin,2,21834,0x10150c0a0,8,TemporalDurationFrom
code-creation,Builtin,2,21875,0x10150c0c0,8,TemporalDurationCompare
code-creation,Builtin,2,21875,0x10150c0e0,8,TemporalDurationPrototypeYears
code-creation,Builtin,2,21917,0x10150c100,8,TemporalDurationPrototypeMonths
code-creation,Builtin,2,21959,0x10150c120,8,TemporalDurationPrototypeWeeks
code-creation,Builtin,2,21959,0x10150c140,8,TemporalDurationPrototypeDays
code-creation,Builtin,2,22000,0x10150c160,8,TemporalDurationPrototypeHours
code-creation,Builtin,2,22000,0x10150c180,8,TemporalDurationPrototypeMinutes
code-creation,Builtin,2,22042,0x10150c1a0,8,TemporalDurationPrototypeSeconds
code-creation,Builtin,2,22042,0x10150c1c0,8,TemporalDurationPrototypeMilliseconds
code-creation,Builtin,2,22125,0x10150c1e0,8,TemporalDurationPrototypeMicroseconds
code-creation,Builtin,2,22125,0x10150c200,8,TemporalDurationPrototypeNanoseconds
code-creation,Builtin,2,22167,0x10150c220,8,TemporalDurationPrototypeSign
code-creation,Builtin,2,22209,0x10150c240,8,TemporalDurationPrototypeBlank
code-creation,Builtin,2,22209,0x10150c260,8,TemporalDurationPrototypeWith
code-creation,Builtin,2,22250,0x10150c280,8,TemporalDurationPrototypeNegated
code-creation,Builtin,2,22334,0x10150c2a0,8,TemporalDurationPrototypeAbs
code-creation,Builtin,2,22334,0x10150c2c0,8,TemporalDurationPrototypeAdd
code-creation,Builtin,2,22375,0x10150c2e0,8,TemporalDurationPrototypeSubtract
code-creation,Builtin,2,22375,0x10150c300,8,TemporalDurationPrototypeRound
code-creation,Builtin,2,22417,0x10150c320,8,TemporalDurationPrototypeTotal
code-creation,Builtin,2,22417,0x10150c340,8,TemporalDurationPrototypeToString
code-creation,Builtin,2,22459,0x10150c360,8,TemporalDurationPrototypeToJSON
code-creation,Builtin,2,22500,0x10150c380,8,TemporalDurationPrototypeValueOf
code-creation,Builtin,2,22542,0x10150c3a0,8,TemporalInstantConstructor
code-creation,Builtin,2,22542,0x10150c3c0,8,TemporalInstantFrom
code-creation,Builtin,2,22584,0x10150c3e0,8,TemporalInstantFromEpochSeconds
code-creation,Builtin,2,22625,0x10150c400,8,TemporalInstantFromEpochMilliseconds
code-creation,Builtin,2,22667,0x10150c420,8,TemporalInstantFromEpochMicroseconds
code-creation,Builtin,2,22667,0x10150c440,8,TemporalInstantFromEpochNanoseconds
code-creation,Builtin,2,22667,0x10150c460,8,TemporalInstantCompare
code-creation,Builtin,2,22709,0x10150c480,8,TemporalInstantPrototypeEpochSeconds
code-creation,Builtin,2,22709,0x10150c4a0,8,TemporalInstantPrototypeEpochMilliseconds
code-creation,Builtin,2,22709,0x10150c4c0,8,TemporalInstantPrototypeEpochMicroseconds
code-creation,Builtin,2,22750,0x10150c4e0,8,TemporalInstantPrototypeEpochNanoseconds
code-creation,Builtin,2,22750,0x10150c500,8,TemporalInstantPrototypeAdd
code-creation,Builtin,2,22750,0x10150c520,8,TemporalInstantPrototypeSubtract
code-creation,Builtin,2,22792,0x10150c540,8,TemporalInstantPrototypeUntil
code-creation,Builtin,2,22792,0x10150c560,8,TemporalInstantPrototypeSince
code-creation,Builtin,2,22834,0x10150c580,8,TemporalInstantPrototypeRound
code-creation,Builtin,2,22834,0x10150c5a0,8,TemporalInstantPrototypeEquals
code-creation,Builtin,2,22834,0x10150c5c0,8,TemporalInstantPrototypeToString
code-creation,Builtin,2,22875,0x10150c5e0,8,TemporalInstantPrototypeToJSON
code-creation,Builtin,2,22875,0x10150c600,8,TemporalInstantPrototypeValueOf
code-creation,Builtin,2,22875,0x10150c620,8,TemporalInstantPrototypeToZonedDateTime
code-creation,Builtin,2,22875,0x10150c640,8,TemporalInstantPrototypeToZonedDateTimeISO
code-creation,Builtin,2,22917,0x10150c660,8,TemporalPlainYearMonthConstructor
code-creation,Builtin,2,22917,0x10150c680,8,TemporalPlainYearMonthFrom
code-creation,Builtin,2,22917,0x10150c6a0,8,TemporalPlainYearMonthCompare
code-creation,Builtin,2,22917,0x10150c6c0,8,TemporalPlainYearMonthPrototypeCalendar
code-creation,Builtin,2,22917,0x10150c6e0,8,TemporalPlainYearMonthPrototypeYear
code-creation,Builtin,2,22959,0x10150c700,8,TemporalPlainYearMonthPrototypeMonth
code-creation,Builtin,2,22959,0x10150c720,8,TemporalPlainYearMonthPrototypeMonthCode
code-creation,Builtin,2,22959,0x10150c740,8,TemporalPlainYearMonthPrototypeDaysInYear
code-creation,Builtin,2,22959,0x10150c760,8,TemporalPlainYearMonthPrototypeDaysInMonth
code-creation,Builtin,2,23000,0x10150c780,8,TemporalPlainYearMonthPrototypeMonthsInYear
code-creation,Builtin,2,23000,0x10150c7a0,8,TemporalPlainYearMonthPrototypeInLeapYear
code-creation,Builtin,2,23000,0x10150c7c0,8,TemporalPlainYearMonthPrototypeWith
code-creation,Builtin,2,23000,0x10150c7e0,8,TemporalPlainYearMonthPrototypeAdd
code-creation,Builtin,2,23000,0x10150c800,8,TemporalPlainYearMonthPrototypeSubtract
code-creation,Builtin,2,23042,0x10150c820,8,TemporalPlainYearMonthPrototypeUntil
code-creation,Builtin,2,23042,0x10150c840,8,TemporalPlainYearMonthPrototypeSince
code-creation,Builtin,2,23042,0x10150c860,8,TemporalPlainYearMonthPrototypeEquals
code-creation,Builtin,2,23084,0x10150c880,8,TemporalPlainYearMonthPrototypeToString
code-creation,Builtin,2,23084,0x10150c8a0,8,TemporalPlainYearMonthPrototypeToJSON
code-creation,Builtin,2,23084,0x10150c8c0,8,TemporalPlainYearMonthPrototypeValueOf
code-creation,Builtin,2,23084,0x10150c8e0,8,TemporalPlainYearMonthPrototypeToPlainDate
code-creation,Builtin,2,23084,0x10150c900,8,TemporalPlainYearMonthPrototypeGetISOFields
code-creation,Builtin,2,23125,0x10150c920,8,TemporalPlainMonthDayConstructor
code-creation,Builtin,2,23167,0x10150c940,8,TemporalPlainMonthDayFrom
code-creation,Builtin,2,23167,0x10150c960,8,TemporalPlainMonthDayPrototypeCalendar
code-creation,Builtin,2,23167,0x10150c980,8,TemporalPlainMonthDayPrototypeMonthCode
code-creation,Builtin,2,23167,0x10150c9a0,8,TemporalPlainMonthDayPrototypeDay
code-creation,Builtin,2,23167,0x10150c9c0,8,TemporalPlainMonthDayPrototypeWith
code-creation,Builtin,2,23209,0x10150c9e0,8,TemporalPlainMonthDayPrototypeEquals
code-creation,Builtin,2,23209,0x10150ca00,8,TemporalPlainMonthDayPrototypeToString
code-creation,Builtin,2,23209,0x10150ca20,8,TemporalPlainMonthDayPrototypeToJSON
code-creation,Builtin,2,23209,0x10150ca40,8,TemporalPlainMonthDayPrototypeValueOf
code-creation,Builtin,2,23250,0x10150ca60,8,TemporalPlainMonthDayPrototypeToPlainDate
code-creation,Builtin,2,23250,0x10150ca80,8,TemporalPlainMonthDayPrototypeGetISOFields
code-creation,Builtin,2,23250,0x10150caa0,8,TemporalTimeZoneConstructor
code-creation,Builtin,2,23250,0x10150cac0,8,TemporalTimeZoneFrom
code-creation,Builtin,2,23292,0x10150cae0,8,TemporalTimeZonePrototypeId
code-creation,Builtin,2,23292,0x10150cb00,8,TemporalTimeZonePrototypeGetOffsetNanosecondsFor
code-creation,Builtin,2,23292,0x10150cb20,8,TemporalTimeZonePrototypeGetOffsetStringFor
code-creation,Builtin,2,23292,0x10150cb40,8,TemporalTimeZonePrototypeGetPlainDateTimeFor
code-creation,Builtin,2,23292,0x10150cb60,8,TemporalTimeZonePrototypeGetInstantFor
code-creation,Builtin,2,23334,0x10150cb80,8,TemporalTimeZonePrototypeGetPossibleInstantsFor
code-creation,Builtin,2,23334,0x10150cba0,8,TemporalTimeZonePrototypeGetNextTransition
code-creation,Builtin,2,23334,0x10150cbc0,8,TemporalTimeZonePrototypeGetPreviousTransition
code-creation,Builtin,2,23375,0x10150cbe0,8,TemporalTimeZonePrototypeToString
code-creation,Builtin,2,23375,0x10150cc00,8,TemporalTimeZonePrototypeToJSON
code-creation,Builtin,2,23375,0x10150cc20,8,TemporalCalendarConstructor
code-creation,Builtin,2,23375,0x10150cc40,8,TemporalCalendarFrom
code-creation,Builtin,2,23375,0x10150cc60,8,TemporalCalendarPrototypeId
code-creation,Builtin,2,23375,0x10150cc80,8,TemporalCalendarPrototypeDateFromFields
code-creation,Builtin,2,23417,0x10150cca0,8,TemporalCalendarPrototypeYearMonthFromFields
code-creation,Builtin,2,23417,0x10150ccc0,8,TemporalCalendarPrototypeMonthDayFromFields
code-creation,Builtin,2,23459,0x10150cce0,8,TemporalCalendarPrototypeDateAdd
code-creation,Builtin,2,23459,0x10150cd00,8,TemporalCalendarPrototypeDateUntil
code-creation,Builtin,2,23459,0x10150cd20,8,TemporalCalendarPrototypeYear
code-creation,Builtin,2,23459,0x10150cd40,8,TemporalCalendarPrototypeMonth
code-creation,Builtin,2,23500,0x10150cd60,8,TemporalCalendarPrototypeMonthCode
code-creation,Builtin,2,23500,0x10150cd80,8,TemporalCalendarPrototypeDay
code-creation,Builtin,2,23500,0x10150cda0,8,TemporalCalendarPrototypeDayOfWeek
code-creation,Builtin,2,23500,0x10150cdc0,8,TemporalCalendarPrototypeDayOfYear
code-creation,Builtin,2,23542,0x10150cde0,8,TemporalCalendarPrototypeWeekOfYear
code-creation,Builtin,2,23542,0x10150ce00,8,TemporalCalendarPrototypeDaysInWeek
code-creation,Builtin,2,23542,0x10150ce20,8,TemporalCalendarPrototypeDaysInMonth
code-creation,Builtin,2,23584,0x10150ce40,8,TemporalCalendarPrototypeDaysInYear
code-creation,Builtin,2,23584,0x10150ce60,8,TemporalCalendarPrototypeMonthsInYear
code-creation,Builtin,2,23584,0x10150ce80,8,TemporalCalendarPrototypeInLeapYear
code-creation,Builtin,2,23625,0x10150cea0,8,TemporalCalendarPrototypeFields
code-creation,Builtin,2,23625,0x10150cec0,8,TemporalCalendarPrototypeMergeFields
code-creation,Builtin,2,23625,0x10150cee0,8,TemporalCalendarPrototypeToString
code-creation,Builtin,2,23667,0x10150cf00,8,TemporalCalendarPrototypeToJSON
code-creation,Builtin,2,23667,0x10150cf20,1556,StringFixedArrayFromIterable
code-creation,Builtin,2,23667,0x10150d540,1540,TemporalInstantFixedArrayFromIterable
code-creation,Builtin,2,23709,0x10150db60,312,AggregateErrorConstructor
code-creation,Builtin,2,23709,0x10150dca0,828,ArrayPrototypeAt
code-creation,Builtin,2,23750,0x10150dfe0,644,ArrayPrototypeConcat
code-creation,Builtin,2,23750,0x10150e280,5000,ArrayPrototypeCopyWithin
code-creation,Builtin,2,23750,0x10150f620,240,ArrayEveryLoopEagerDeoptContinuation
code-creation,Builtin,2,23792,0x10150f720,576,ArrayEveryLoopLazyDeoptContinuation
code-creation,Builtin,2,23792,0x10150f980,3376,ArrayEveryLoopContinuation
code-creation,Builtin,2,23792,0x1015106c0,1496,ArrayEvery
code-creation,Builtin,2,23834,0x101510ca0,296,ArrayFilterLoopEagerDeoptContinuation
code-creation,Builtin,2,23834,0x101510de0,864,ArrayFilterLoopLazyDeoptContinuation
code-creation,Builtin,2,23834,0x101511160,3596,ArrayFilterLoopContinuation
code-creation,Builtin,2,23834,0x101511f80,4172,ArrayFilter
code-creation,Builtin,2,23875,0x101512fe0,232,ArrayFindLoopEagerDeoptContinuation
code-creation,Builtin,2,23875,0x1015130e0,52,ArrayFindLoopLazyDeoptContinuation
code-creation,Builtin,2,23875,0x101513120,352,ArrayFindLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,23917,0x1015132a0,524,ArrayFindLoopContinuation
code-creation,Builtin,2,23917,0x1015134c0,1480,ArrayPrototypeFind
code-creation,Builtin,2,23917,0x101513aa0,232,ArrayFindIndexLoopEagerDeoptContinuation
code-creation,Builtin,2,23959,0x101513ba0,52,ArrayFindIndexLoopLazyDeoptContinuation
code-creation,Builtin,2,23959,0x101513be0,352,ArrayFindIndexLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,23959,0x101513d60,516,ArrayFindIndexLoopContinuation
code-creation,Builtin,2,24000,0x101513f80,1476,ArrayPrototypeFindIndex
code-creation,Builtin,2,24000,0x101514560,472,ArrayFindLastLoopContinuation
code-creation,Builtin,2,24000,0x101514740,1580,ArrayPrototypeFindLast
code-creation,Builtin,2,24000,0x101514d80,464,ArrayFindLastIndexLoopContinuation
code-creation,Builtin,2,24042,0x101514f60,1576,ArrayPrototypeFindLastIndex
code-creation,Builtin,2,24042,0x1015155a0,240,ArrayForEachLoopEagerDeoptContinuation
code-creation,Builtin,2,24042,0x1015156a0,240,ArrayForEachLoopLazyDeoptContinuation
code-creation,Builtin,2,24042,0x1015157a0,3268,ArrayForEachLoopContinuation
code-creation,Builtin,2,24084,0x101516480,1332,ArrayForEach
code-creation,Builtin,2,24084,0x1015169c0,3664,ArrayFrom
code-creation,Builtin,2,24084,0x101517820,192,ArrayIsArray
code-creation,Builtin,2,24084,0x101517900,400,LoadJoinElement_DictionaryElements_0
code-creation,Builtin,2,24125,0x101517aa0,64,LoadJoinElement_FastSmiOrObjectElements_0
code-creation,Builtin,2,24125,0x101517b00,172,LoadJoinElement_FastDoubleElements_0
code-creation,Builtin,2,24125,0x101517bc0,372,ConvertToLocaleString
code-creation,Builtin,2,24125,0x101517d40,812,JoinStackPush
code-creation,Builtin,2,24167,0x101518080,312,JoinStackPop
code-creation,Builtin,2,24167,0x1015181c0,6356,ArrayPrototypeJoin
code-creation,Builtin,2,24167,0x101519aa0,5180,ArrayPrototypeToLocaleString
code-creation,Builtin,2,24209,0x10151aee0,280,ArrayPrototypeToString
code-creation,Builtin,2,24209,0x10151b000,6176,TypedArrayPrototypeJoin
code-creation,Builtin,2,24209,0x10151c840,4988,TypedArrayPrototypeToLocaleString
code-creation,Builtin,2,24209,0x10151dbc0,3472,ArrayPrototypeLastIndexOf
code-creation,Builtin,2,24250,0x10151e960,260,ArrayMapPreLoopLazyDeoptContinuation
code-creation,Builtin,2,24250,0x10151ea80,260,ArrayMapLoopEagerDeoptContinuation
code-creation,Builtin,2,24250,0x10151eba0,480,ArrayMapLoopLazyDeoptContinuation
code-creation,Builtin,2,24250,0x10151eda0,3256,ArrayMapLoopContinuation
code-creation,Builtin,2,24292,0x10151fa60,3764,ArrayMap
code-creation,Builtin,2,24292,0x101520920,852,ArrayOf
code-creation,Builtin,2,24292,0x101520c80,416,ArrayReduceRightPreLoopEagerDeoptContinuation
code-creation,Builtin,2,24292,0x101520e40,232,ArrayReduceRightLoopEagerDeoptContinuation
code-creation,Builtin,2,24334,0x101520f40,232,ArrayReduceRightLoopLazyDeoptContinuation
code-creation,Builtin,2,24334,0x101521040,3300,ArrayReduceRightLoopContinuation
code-creation,Builtin,2,24334,0x101521d40,1832,ArrayReduceRight
code-creation,Builtin,2,24375,0x101522480,208,ArrayReducePreLoopEagerDeoptContinuation
code-creation,Builtin,2,24417,0x101522560,232,ArrayReduceLoopEagerDeoptContinuation
code-creation,Builtin,2,24417,0x101522660,232,ArrayReduceLoopLazyDeoptContinuation
code-creation,Builtin,2,24417,0x101522760,3348,ArrayReduceLoopContinuation
code-creation,Builtin,2,24417,0x101523480,1540,ArrayReduce
code-creation,Builtin,2,24417,0x101523aa0,2992,ArrayPrototypeReverse
code-creation,Builtin,2,24459,0x101524660,3224,ArrayPrototypeShift
code-creation,Builtin,2,24459,0x101525300,4920,ArrayPrototypeSlice
code-creation,Builtin,2,24459,0x101526640,240,ArraySomeLoopEagerDeoptContinuation
code-creation,Builtin,2,24459,0x101526740,568,ArraySomeLoopLazyDeoptContinuation
code-creation,Builtin,2,24459,0x101526980,3368,ArraySomeLoopContinuation
code-creation,Builtin,2,24459,0x1015276c0,1488,ArraySome
code-creation,Builtin,2,24500,0x101527ca0,12208,ArrayPrototypeSplice
code-creation,Builtin,2,24500,0x10152ac60,2908,ArrayPrototypeUnshift
code-creation,Builtin,2,24500,0x10152b7c0,316,ArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,24500,0x10152b900,440,ArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,24500,0x10152bac0,228,ArrayBufferPrototypeGetResizable
code-creation,Builtin,2,24542,0x10152bbc0,316,SharedArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,24542,0x10152bd00,228,SharedArrayBufferPrototypeGetGrowable
code-creation,Builtin,2,24542,0x10152be00,128,ArrayBufferIsView
code-creation,Builtin,2,24542,0x10152bea0,228,ToInteger
code-creation,Builtin,2,24542,0x10152bfa0,3908,FastCreateDataProperty
code-creation,Builtin,2,24584,0x10152cf00,648,CheckSameObject
code-creation,Builtin,2,24584,0x10152d1a0,948,BooleanConstructor
code-creation,Builtin,2,24584,0x10152d560,184,BooleanPrototypeToString
code-creation,Builtin,2,24584,0x10152d620,180,BooleanPrototypeValueOf
tick,0x195a4df24,24625,0,0x0,6
tick,0x195a4df24,24667,0,0x0,6
tick,0x195a4df24,24667,0,0x0,6
code-creation,Builtin,2,24750,0x10152d6e0,1048,BigIntAddNoThrow
code-creation,Builtin,2,24792,0x10152db00,1148,BigIntAdd
code-creation,Builtin,2,24792,0x10152df80,1048,BigIntSubtractNoThrow
code-creation,Builtin,2,24834,0x10152e3a0,1148,BigIntSubtract
code-creation,Builtin,2,24834,0x10152e820,336,BigIntUnaryMinus
code-creation,Builtin,2,24875,0x10152e980,1372,ToString
code-creation,Builtin,2,24875,0x10152eee0,176,StringPrototypeToString
code-creation,Builtin,2,24917,0x10152efa0,176,StringPrototypeValueOf
code-creation,Builtin,2,24959,0x10152f060,2404,StringToList
code-creation,Builtin,2,25042,0x10152f9e0,1016,StringPrototypeCharAt
code-creation,Builtin,2,25042,0x10152fde0,696,StringPrototypeCharCodeAt
code-creation,Builtin,2,25084,0x1015300a0,1216,StringPrototypeCodePointAt
code-creation,Builtin,2,25084,0x101530580,436,StringPrototypeConcat
code-creation,Builtin,2,25125,0x101530740,1008,StringConstructor
code-creation,Builtin,2,25125,0x101530b40,1424,StringAddConvertLeft
code-creation,Builtin,2,25125,0x1015310e0,1468,StringAddConvertRight
code-creation,Builtin,2,25125,0x1015316a0,888,StringCharAt
code-creation,Builtin,2,25167,0x101531a20,20,FastNewClosureBaseline
code-creation,Builtin,2,25167,0x101531a40,232,FastNewFunctionContextEval
code-creation,Builtin,2,25167,0x101531b40,232,FastNewFunctionContextFunction
code-creation,Builtin,2,25167,0x101531c40,308,CreateRegExpLiteral
code-creation,Builtin,2,25209,0x101531d80,1032,CreateShallowArrayLiteral
code-creation,Builtin,2,25209,0x1015321a0,516,CreateEmptyArrayLiteral
code-creation,Builtin,2,25209,0x1015323c0,1704,CreateShallowObjectLiteral
code-creation,Builtin,2,25209,0x101532a80,440,ObjectConstructor
code-creation,Builtin,2,25250,0x101532c40,204,CreateEmptyLiteralObject
code-creation,Builtin,2,25250,0x101532d20,592,NumberConstructor
code-creation,Builtin,2,25250,0x101532f80,92,GenericLazyDeoptContinuation
code-creation,Builtin,2,25250,0x101532fe0,84,StringToNumber
code-creation,Builtin,2,25292,0x101533040,240,NonNumberToNumber
code-creation,Builtin,2,25292,0x101533140,288,NonNumberToNumeric
code-creation,Builtin,2,25292,0x101533280,60,ToNumeric
code-creation,Builtin,2,25334,0x1015332c0,1440,NumberToString
code-creation,Builtin,2,25334,0x101533880,128,ToBoolean
code-creation,Builtin,2,25334,0x101533920,128,ToBooleanForBaselineJump
code-creation,Builtin,2,25375,0x1015339c0,564,ToLength
code-creation,Builtin,2,25375,0x101533c00,1336,ToName
code-creation,Builtin,2,25375,0x101534140,800,ToObject
code-creation,Builtin,2,25375,0x101534480,276,NonPrimitiveToPrimitive_Default
code-creation,Builtin,2,25417,0x1015345a0,276,NonPrimitiveToPrimitive_Number
code-creation,Builtin,2,25417,0x1015346c0,276,NonPrimitiveToPrimitive_String
code-creation,Builtin,2,25417,0x1015347e0,412,OrdinaryToPrimitive_Number
code-creation,Builtin,2,25459,0x101534980,412,OrdinaryToPrimitive_String
code-creation,Builtin,2,25459,0x101534b20,272,FastConsoleAssert
code-creation,Builtin,2,25459,0x101534c40,180,DataViewPrototypeGetBuffer
code-creation,Builtin,2,25459,0x101534d00,700,DataViewPrototypeGetByteLength
code-creation,Builtin,2,25500,0x101534fc0,412,DataViewPrototypeGetByteOffset
code-creation,Builtin,2,25500,0x101535160,716,DataViewPrototypeGetUint8
code-creation,Builtin,2,25500,0x101535440,716,DataViewPrototypeGetInt8
code-creation,Builtin,2,25500,0x101535720,824,DataViewPrototypeGetUint16
code-creation,Builtin,2,25542,0x101535a60,820,DataViewPrototypeGetInt16
code-creation,Builtin,2,25542,0x101535da0,968,DataViewPrototypeGetUint32
code-creation,Builtin,2,25542,0x101536180,852,DataViewPrototypeGetInt32
code-creation,Builtin,2,25542,0x1015364e0,988,DataViewPrototypeGetFloat32
code-creation,Builtin,2,25542,0x1015368c0,1064,DataViewPrototypeGetFloat64
code-creation,Builtin,2,25584,0x101536d00,1148,DataViewPrototypeGetBigUint64
code-creation,Builtin,2,25584,0x101537180,1176,DataViewPrototypeGetBigInt64
code-creation,Builtin,2,25584,0x101537620,1096,DataViewPrototypeSetUint8
code-creation,Builtin,2,25625,0x101537a80,1096,DataViewPrototypeSetInt8
code-creation,Builtin,2,25625,0x101537ee0,1168,DataViewPrototypeSetUint16
code-creation,Builtin,2,25625,0x101538380,1168,DataViewPrototypeSetInt16
code-creation,Builtin,2,25625,0x101538820,1200,DataViewPrototypeSetUint32
code-creation,Builtin,2,25667,0x101538ce0,1200,DataViewPrototypeSetInt32
code-creation,Builtin,2,25667,0x1015391a0,1204,DataViewPrototypeSetFloat32
code-creation,Builtin,2,25667,0x101539660,1264,DataViewPrototypeSetFloat64
code-creation,Builtin,2,25667,0x101539b60,1152,DataViewPrototypeSetBigUint64
code-creation,Builtin,2,25709,0x10153a000,1152,DataViewPrototypeSetBigInt64
code-creation,Builtin,2,25709,0x10153a4a0,860,FinalizationRegistryConstructor
code-creation,Builtin,2,25709,0x10153a800,992,FinalizationRegistryRegister
code-creation,Builtin,2,25709,0x10153ac00,660,FinalizationRegistryPrototypeCleanupSome
code-creation,Builtin,2,25750,0x10153aea0,356,FunctionPrototypeHasInstance
code-creation,Builtin,2,25750,0x10153b020,932,FastFunctionPrototypeBind
code-creation,Builtin,2,25750,0x10153b3e0,100,IncBlockCounter
code-creation,Builtin,2,25792,0x10153b460,308,GetTemplateObject
code-creation,Builtin,2,25792,0x10153b5a0,132,ForInNext
code-creation,Builtin,2,25792,0x10153b640,180,GetImportMetaObjectBaseline
code-creation,Builtin,2,25792,0x10153b700,128,GetIteratorWithFeedback
code-creation,Builtin,2,25834,0x10153b7a0,124,GetIteratorBaseline
code-creation,Builtin,2,25834,0x10153b820,292,CreateAsyncFromSyncIteratorBaseline
code-creation,Builtin,2,25834,0x10153b960,1092,CallIteratorWithFeedback
code-creation,Builtin,2,25834,0x10153bdc0,296,MathAbs
code-creation,Builtin,2,25875,0x10153bf00,260,MathCeil
code-creation,Builtin,2,25875,0x10153c020,260,MathFloor
code-creation,Builtin,2,25875,0x10153c140,284,MathRound
code-creation,Builtin,2,25875,0x10153c260,260,MathTrunc
code-creation,Builtin,2,25875,0x10153c380,368,MathPow
code-creation,Builtin,2,25917,0x10153c500,404,MathMax
code-creation,Builtin,2,25917,0x10153c6a0,404,MathMin
code-creation,Builtin,2,25917,0x10153c840,296,MathAcos
code-creation,Builtin,2,25917,0x10153c980,296,MathAcosh
code-creation,Builtin,2,25959,0x10153cac0,296,MathAsin
code-creation,Builtin,2,25959,0x10153cc00,296,MathAsinh
code-creation,Builtin,2,26125,0x10153cd40,296,MathAtan
code-creation,Builtin,2,26167,0x10153ce80,372,MathAtan2
code-creation,Builtin,2,26167,0x10153d000,296,MathAtanh
code-creation,Builtin,2,26167,0x10153d140,296,MathCbrt
code-creation,Builtin,2,26167,0x10153d280,156,MathClz32
code-creation,Builtin,2,26167,0x10153d320,296,MathCos
code-creation,Builtin,2,26167,0x10153d460,296,MathCosh
code-creation,Builtin,2,26209,0x10153d5a0,296,MathExp
code-creation,Builtin,2,26209,0x10153d6e0,296,MathExpm1
code-creation,Builtin,2,26209,0x10153d820,268,MathFround
code-creation,Builtin,2,26209,0x10153d940,228,MathImul
code-creation,Builtin,2,26250,0x10153da40,296,MathLog
code-creation,Builtin,2,26250,0x10153db80,296,MathLog1p
code-creation,Builtin,2,26250,0x10153dcc0,296,MathLog10
code-creation,Builtin,2,26250,0x10153de00,296,MathLog2
code-creation,Builtin,2,26250,0x10153df40,296,MathSin
code-creation,Builtin,2,26292,0x10153e080,180,MathSign
code-creation,Builtin,2,26292,0x10153e140,296,MathSinh
code-creation,Builtin,2,26292,0x10153e280,264,MathSqrt
code-creation,Builtin,2,26292,0x10153e3a0,296,MathTan
code-creation,Builtin,2,26334,0x10153e4e0,296,MathTanh
code-creation,Builtin,2,26334,0x10153e620,1064,MathHypot
code-creation,Builtin,2,26334,0x10153ea60,332,MathRandom
code-creation,Builtin,2,26334,0x10153ebc0,2892,NumberPrototypeToString
code-creation,Builtin,2,26375,0x10153f720,172,NumberIsFinite
code-creation,Builtin,2,26375,0x10153f7e0,156,NumberIsInteger
code-creation,Builtin,2,26375,0x10153f880,152,NumberIsNaN
code-creation,Builtin,2,26375,0x10153f920,184,NumberIsSafeInteger
code-creation,Builtin,2,26417,0x10153f9e0,180,NumberPrototypeValueOf
code-creation,Builtin,2,26417,0x10153faa0,224,NumberParseFloat
code-creation,Builtin,2,26417,0x10153fba0,196,ParseInt
code-creation,Builtin,2,26417,0x10153fc80,108,NumberParseInt
code-creation,Builtin,2,26459,0x10153fd00,756,Add
code-creation,Builtin,2,26459,0x101540000,416,Subtract
code-creation,Builtin,2,26459,0x1015401c0,576,Multiply
code-creation,Builtin,2,26500,0x101540420,488,Divide
code-creation,Builtin,2,26500,0x101540620,540,Modulus
code-creation,Builtin,2,26500,0x101540840,508,Exponentiate
code-creation,Builtin,2,26500,0x101540a40,324,Negate
code-creation,Builtin,2,26542,0x101540ba0,120,BitwiseNot
code-creation,Builtin,2,26542,0x101540c20,120,Decrement
code-creation,Builtin,2,26542,0x101540ca0,120,Increment
code-creation,Builtin,2,26542,0x101540d20,396,ShiftLeft
code-creation,Builtin,2,26542,0x101540ec0,396,ShiftRight
code-creation,Builtin,2,26584,0x101541060,492,ShiftRightLogical
code-creation,Builtin,2,26584,0x101541260,396,BitwiseAnd
code-creation,Builtin,2,26584,0x101541400,396,BitwiseOr
code-creation,Builtin,2,26584,0x1015415a0,396,BitwiseXor
code-creation,Builtin,2,26625,0x101541740,868,LessThan
code-creation,Builtin,2,26625,0x101541ac0,868,LessThanOrEqual
code-creation,Builtin,2,26625,0x101541e40,868,GreaterThan
code-creation,Builtin,2,26625,0x1015421c0,868,GreaterThanOrEqual
code-creation,Builtin,2,26667,0x101542540,924,Equal
code-creation,Builtin,2,26667,0x1015428e0,352,StrictEqual
code-creation,Builtin,2,26667,0x101542a60,3408,ObjectFromEntries
code-creation,Builtin,2,26667,0x1015437c0,844,CreateObjectWithoutProperties
code-creation,Builtin,2,26667,0x101543b20,176,ObjectIsExtensible
code-creation,Builtin,2,26709,0x101543be0,180,ObjectPreventExtensions
code-creation,Builtin,2,26709,0x101543ca0,184,ObjectGetPrototypeOf
code-creation,Builtin,2,26709,0x101543d60,312,ObjectSetPrototypeOf
code-creation,Builtin,2,26709,0x101543ea0,92,ObjectPrototypeToString
code-creation,Builtin,2,26750,0x101543f00,116,ObjectPrototypeValueOf
code-creation,Builtin,2,26750,0x101543f80,196,ObjectPrototypeToLocaleString
code-creation,Builtin,2,26750,0x101544060,804,FulfillPromise
code-creation,Builtin,2,26750,0x1015443a0,920,RejectPromise
code-creation,Builtin,2,26792,0x101544740,2644,NewPromiseCapability
code-creation,Builtin,2,26792,0x1015451a0,204,PromiseCapabilityDefaultReject
code-creation,Builtin,2,26792,0x101545280,188,PromiseCapabilityDefaultResolve
code-creation,Builtin,2,26792,0x101545340,1348,PerformPromiseThen
code-creation,Builtin,2,26834,0x1015458a0,692,PromiseReject
code-creation,Builtin,2,26834,0x101545b60,300,PromiseGetCapabilitiesExecutor
code-creation,Builtin,2,26834,0x101545ca0,140,PromiseConstructorLazyDeoptContinuation
code-creation,Builtin,2,26834,0x101545d40,4688,PromiseAll
code-creation,Builtin,2,26875,0x101546fa0,5084,PromiseAllSettled
code-creation,Builtin,2,26875,0x101548380,1132,PromiseAllResolveElementClosure
code-creation,Builtin,2,26875,0x101548800,1424,PromiseAllSettledResolveElementClosure
tick,0x100d33940,26917,0,0x0,6
tick,0x195a4df24,26917,0,0x0,6
code-creation,Builtin,2,26959,0x101548da0,1432,PromiseAllSettledRejectElementClosure
code-creation,Builtin,2,26959,0x101549340,1204,PromiseAnyRejectElementClosure
code-creation,Builtin,2,26959,0x101549800,2656,PromiseAny
code-creation,Builtin,2,26959,0x10154a280,3116,PromiseConstructor
code-creation,Builtin,2,26959,0x10154aec0,380,PromisePrototypeCatch
code-creation,Builtin,2,27000,0x10154b040,108,PromiseValueThunkFinally
code-creation,Builtin,2,27000,0x10154b0c0,108,PromiseThrowerFinally
code-creation,Builtin,2,27000,0x10154b140,1072,PromiseCatchFinally
code-creation,Builtin,2,27000,0x10154b580,1072,PromiseThenFinally
code-creation,Builtin,2,27042,0x10154b9c0,1836,PromisePrototypeFinally
code-creation,Builtin,2,27042,0x10154c100,1532,PromiseRace
code-creation,Builtin,2,27042,0x10154c700,336,PromiseFulfillReactionJob
code-creation,Builtin,2,27042,0x10154c860,432,PromiseRejectReactionJob
code-creation,Builtin,2,27084,0x10154ca20,172,PromiseResolveTrampoline
code-creation,Builtin,2,27084,0x10154cae0,720,PromiseResolve
code-creation,Builtin,2,27084,0x10154cdc0,816,ResolvePromise
code-creation,Builtin,2,27084,0x10154d100,2344,PromisePrototypeThen
code-creation,Builtin,2,27125,0x10154da40,1376,PromiseResolveThenableJob
code-creation,Builtin,2,27125,0x10154dfc0,448,ProxyConstructor
code-creation,Builtin,2,27125,0x10154e1a0,1760,ProxyDeleteProperty
code-creation,Builtin,2,27125,0x10154e8a0,2072,ProxyGetProperty
code-creation,Builtin,2,27167,0x10154f0c0,1028,ProxyGetPrototypeOf
code-creation,Builtin,2,27167,0x10154f4e0,1704,ProxyHasProperty
code-creation,Builtin,2,27167,0x10154fba0,788,ProxyIsExtensible
code-creation,Builtin,2,27167,0x10154fec0,816,ProxyPreventExtensions
code-creation,Builtin,2,27209,0x101550200,1204,ProxyRevocable
code-creation,Builtin,2,27209,0x1015506c0,144,ProxyRevoke
code-creation,Builtin,2,27209,0x101550760,2204,ProxySetProperty
code-creation,Builtin,2,27209,0x101551000,1252,ProxySetPrototypeOf
code-creation,Builtin,2,27209,0x101551500,228,ReflectIsExtensible
code-creation,Builtin,2,27250,0x101551600,232,ReflectPreventExtensions
code-creation,Builtin,2,27250,0x101551700,208,ReflectGetPrototypeOf
code-creation,Builtin,2,27250,0x1015517e0,296,ReflectSetPrototypeOf
code-creation,Builtin,2,27250,0x101551920,316,ReflectGet
code-creation,Builtin,2,27292,0x101551a60,176,ReflectDeleteProperty
code-creation,Builtin,2,27292,0x101551b20,164,ReflectHas
code-creation,Builtin,2,27292,0x101551be0,4764,RegExpPrototypeExecSlow
code-creation,Builtin,2,27292,0x101552e80,4816,RegExpPrototypeExec
code-creation,Builtin,2,27334,0x101554160,2228,RegExpPrototypeMatchAll
code-creation,Builtin,2,27334,0x101554a20,8892,RegExpStringIteratorPrototypeNext
code-creation,Builtin,2,27334,0x101556ce0,8356,RegExpMatchFast
code-creation,Builtin,2,27334,0x101558da0,3504,RegExpPrototypeMatch
code-creation,Builtin,2,27334,0x101559b60,6044,RegExpReplace
code-creation,Builtin,2,27375,0x10155b300,540,RegExpPrototypeReplace
code-creation,Builtin,2,27375,0x10155b520,1332,RegExpSearchFast
code-creation,Builtin,2,27375,0x10155ba60,1576,RegExpPrototypeSearch
code-creation,Builtin,2,27375,0x10155c0a0,212,RegExpPrototypeSourceGetter
code-creation,Builtin,2,27417,0x10155c180,5352,RegExpSplit
code-creation,Builtin,2,27417,0x10155d680,508,RegExpPrototypeSplit
code-creation,Builtin,2,27417,0x10155d880,2164,RegExpPrototypeTest
code-creation,Builtin,2,27417,0x10155e100,1256,RegExpPrototypeTestFast
code-creation,Builtin,2,27459,0x10155e600,236,RegExpPrototypeGlobalGetter
code-creation,Builtin,2,27500,0x10155e700,244,RegExpPrototypeIgnoreCaseGetter
code-creation,Builtin,2,27500,0x10155e800,244,RegExpPrototypeMultilineGetter
code-creation,Builtin,2,27500,0x10155e900,244,RegExpPrototypeHasIndicesGetter
code-creation,Builtin,2,27500,0x10155ea00,244,RegExpPrototypeLinearGetter
code-creation,Builtin,2,27500,0x10155eb00,244,RegExpPrototypeDotAllGetter
code-creation,Builtin,2,27542,0x10155ec00,272,RegExpPrototypeStickyGetter
code-creation,Builtin,2,27542,0x10155ed20,272,RegExpPrototypeUnicodeGetter
code-creation,Builtin,2,27542,0x10155ee40,2244,RegExpPrototypeFlagsGetter
code-creation,Builtin,2,27542,0x10155f720,1392,StringPrototypeAt
code-creation,Builtin,2,27584,0x10155fca0,3392,StringPrototypeEndsWith
code-creation,Builtin,2,27584,0x101560a00,468,CreateHTML
code-creation,Builtin,2,27584,0x101560be0,180,StringPrototypeAnchor
code-creation,Builtin,2,27625,0x101560ca0,152,StringPrototypeBig
code-creation,Builtin,2,27625,0x101560d40,152,StringPrototypeBlink
code-creation,Builtin,2,27625,0x101560de0,152,StringPrototypeBold
code-creation,Builtin,2,27625,0x101560e80,188,StringPrototypeFontcolor
tick,0x195a4df24,27625,0,0x0,6
code-creation,Builtin,2,27667,0x101560f40,188,StringPrototypeFontsize
code-creation,Builtin,2,27709,0x101561000,152,StringPrototypeFixed
code-creation,Builtin,2,27750,0x1015610a0,152,StringPrototypeItalics
code-creation,Builtin,2,27750,0x101561140,188,StringPrototypeLink
code-creation,Builtin,2,27792,0x101561200,152,StringPrototypeSmall
code-creation,Builtin,2,27792,0x1015612a0,152,StringPrototypeStrike
code-creation,Builtin,2,27834,0x101561340,152,StringPrototypeSub
code-creation,Builtin,2,27875,0x1015613e0,152,StringPrototypeSup
code-creation,Builtin,2,27875,0x101561480,1004,StringPrototypeIncludes
code-creation,Builtin,2,27875,0x101561880,584,StringPrototypeIndexOf
code-creation,Builtin,2,27917,0x101561ae0,356,StringPrototypeIterator
code-creation,Builtin,2,27959,0x101561c60,1964,StringIteratorPrototypeNext
code-creation,Builtin,2,27959,0x101562420,1336,StringPrototypeMatch
code-creation,Builtin,2,28000,0x101562960,1336,StringPrototypeSearch
code-creation,Builtin,2,28000,0x101562ea0,804,StringPrototypePadStart
code-creation,Builtin,2,28042,0x1015631e0,808,StringPrototypePadEnd
code-creation,Builtin,2,28042,0x101563520,132,StringRepeat
code-creation,Builtin,2,28084,0x1015635c0,400,StringPrototypeRepeat
code-creation,Builtin,2,28084,0x101563760,10652,StringPrototypeReplaceAll
code-creation,Builtin,2,28125,0x101566100,3200,StringPrototypeSlice
code-creation,Builtin,2,28167,0x101566da0,3396,StringPrototypeStartsWith
code-creation,Builtin,2,28167,0x101567b00,3168,StringPrototypeSubstr
code-creation,Builtin,2,28209,0x101568780,3104,StringPrototypeSubstring
code-creation,Builtin,2,28209,0x1015693c0,7180,StringPrototypeTrim
code-creation,Builtin,2,28250,0x10156afe0,6520,StringPrototypeTrimStart
code-creation,Builtin,2,28250,0x10156c960,6072,StringPrototypeTrimEnd
code-creation,Builtin,2,28292,0x10156e120,184,SymbolPrototypeDescriptionGetter
code-creation,Builtin,2,28292,0x10156e1e0,192,SymbolPrototypeToPrimitive
code-creation,Builtin,2,28334,0x10156e2c0,204,SymbolPrototypeToString
code-creation,Builtin,2,28334,0x10156e3a0,180,SymbolPrototypeValueOf
code-creation,Builtin,2,28375,0x10156e460,1064,TypedArrayPrototypeAt
code-creation,Builtin,2,28375,0x10156e8a0,9152,CreateTypedArray
code-creation,Builtin,2,28417,0x101570c80,1680,TypedArrayPrototypeEvery
code-creation,Builtin,2,28417,0x101571320,428,TypedArrayPrototypeEntries
code-creation,Builtin,2,28417,0x1015714e0,4028,TypedArrayPrototypeFilter
code-creation,Builtin,2,28459,0x1015724a0,1672,TypedArrayPrototypeFind
code-creation,Builtin,2,28459,0x101572b40,1672,TypedArrayPrototypeFindIndex
code-creation,Builtin,2,28500,0x1015731e0,1652,TypedArrayPrototypeFindLast
code-creation,Builtin,2,28500,0x101573860,1652,TypedArrayPrototypeFindLastIndex
code-creation,Builtin,2,28542,0x101573ee0,1544,TypedArrayPrototypeForEach
code-creation,Builtin,2,28584,0x101574500,2080,TypedArrayFrom
code-creation,Builtin,2,28584,0x101574d40,424,TypedArrayPrototypeKeys
code-creation,Builtin,2,28667,0x101574f00,924,TypedArrayOf
code-creation,Builtin,2,28709,0x1015752a0,1648,TypedArrayPrototypeReduce
code-creation,Builtin,2,28709,0x101575920,1636,TypedArrayPrototypeReduceRight
code-creation,Builtin,2,28750,0x101575fa0,3104,TypedArrayPrototypeSet
code-creation,Builtin,2,28750,0x101576be0,3500,TypedArrayPrototypeSlice
code-creation,Builtin,2,28792,0x1015779a0,1664,TypedArrayPrototypeSome
code-creation,Builtin,2,28792,0x101578040,1032,TypedArrayMergeSort
code-creation,Builtin,2,28792,0x101578460,2208,TypedArrayPrototypeSort
code-creation,Builtin,2,28792,0x101578d20,2904,TypedArrayPrototypeSubArray
code-creation,Builtin,2,28834,0x101579880,428,TypedArrayPrototypeValues
code-creation,Builtin,2,28834,0x101579a40,956,WeakRefConstructor
code-creation,Builtin,2,28834,0x101579e00,212,WeakRefDeref
code-creation,Builtin,2,28834,0x101579ee0,768,NewSloppyArgumentsElements
code-creation,Builtin,2,28834,0x10157a200,360,NewStrictArgumentsElements
code-creation,Builtin,2,28875,0x10157a380,392,NewRestArgumentsElements
code-creation,Builtin,2,28917,0x10157a520,1696,FastNewSloppyArguments
code-creation,Builtin,2,28917,0x10157abe0,588,FastNewStrictArguments
code-creation,Builtin,2,28917,0x10157ae40,640,FastNewRestArguments
code-creation,Builtin,2,28959,0x10157b0e0,640,StringSlowFlatten
code-creation,Builtin,2,28959,0x10157b380,2108,StringIndexOf
code-creation,Builtin,2,29000,0x10157bbc0,1340,TestTurbofanType
code-creation,Builtin,2,29000,0x10157c100,208,CheckTurbofanType
code-creation,Builtin,2,29042,0x10157c1e0,8,GenericBuiltinTest_JSAny_0
code-creation,Builtin,2,29042,0x10157c200,16,TestHelperPlus1
code-creation,Builtin,2,29084,0x10157c220,16,TestHelperPlus2
code-creation,Builtin,2,29084,0x10157c240,120,NewSmiBox
code-creation,Builtin,2,29125,0x10157c2c0,20,ReturnTwoValues
code-creation,Builtin,2,29125,0x10157c2e0,44,Load_FastSmiElements_0
code-creation,Builtin,2,29167,0x10157c320,44,Load_FastObjectElements_0
code-creation,Builtin,2,29209,0x10157c360,172,Load_FastDoubleElements_0
code-creation,Builtin,2,29209,0x10157c420,48,Store_FastSmiElements_0
code-creation,Builtin,2,29250,0x10157c460,108,Store_FastObjectElements_0
code-creation,Builtin,2,29250,0x10157c4e0,56,Store_FastDoubleElements_0
code-creation,Builtin,2,29292,0x10157c520,52,Delete_FastSmiElements_0
code-creation,Builtin,2,29334,0x10157c560,52,Delete_FastObjectElements_0
code-creation,Builtin,2,29334,0x10157c5a0,52,Delete_FastDoubleElements_0
code-creation,Builtin,2,29375,0x10157c5e0,268,SortCompareDefault
code-creation,Builtin,2,29375,0x10157c700,128,SortCompareUserFn
code-creation,Builtin,2,29375,0x10157c7a0,12,CanUseSameAccessor_GenericElementsAccessor_0
code-creation,Builtin,2,29417,0x10157c7c0,324,Copy
code-creation,Builtin,2,29417,0x10157c920,5448,MergeAt
code-creation,Builtin,2,29459,0x10157de80,848,GallopLeft
code-creation,Builtin,2,29459,0x10157e1e0,884,GallopRight
code-creation,Builtin,2,29500,0x10157e560,3728,ArrayTimSort
code-creation,Builtin,2,29500,0x10157f400,1872,ArrayPrototypeSort
code-creation,Builtin,2,29542,0x10157fb60,3904,StringFastLocaleCompare
code-creation,Builtin,2,29542,0x101580ac0,116,WasmInt32ToHeapNumber
code-creation,Builtin,2,29584,0x101580b40,32,WasmFuncRefToJS
code-creation,Builtin,2,29584,0x101580b80,84,WasmTaggedNonSmiToInt32
code-creation,Builtin,2,29625,0x101580be0,96,WasmTaggedToFloat64
code-creation,Builtin,2,29625,0x101580c60,96,WasmMemoryGrow
code-creation,Builtin,2,29667,0x101580ce0,112,WasmTableInit
code-creation,Builtin,2,29667,0x101580d60,112,WasmTableCopy
code-creation,Builtin,2,29709,0x101580de0,96,WasmTableFill
code-creation,Builtin,2,29709,0x101580e60,76,WasmTableGrow
code-creation,Builtin,2,29750,0x101580ec0,192,WasmTableGet
code-creation,Builtin,2,29792,0x101580fa0,268,WasmTableSet
code-creation,Builtin,2,29792,0x1015810c0,112,WasmRefFunc
code-creation,Builtin,2,29792,0x101581140,184,WasmAllocateFixedArray
code-creation,Builtin,2,29792,0x101581200,40,WasmThrow
code-creation,Builtin,2,29792,0x101581240,56,WasmRethrow
code-creation,Builtin,2,29834,0x101581280,48,WasmRethrowExplicitContext
code-creation,Builtin,2,29834,0x1015812c0,44,WasmTriggerTierUp
code-creation,Builtin,2,29834,0x101581300,28,WasmStackGuard
code-creation,Builtin,2,29834,0x101581320,28,WasmStackOverflow
code-creation,Builtin,2,29875,0x101581340,40,WasmTraceMemory
code-creation,Builtin,2,29875,0x101581380,28,WasmTraceEnter
code-creation,Builtin,2,29875,0x1015813a0,40,WasmTraceExit
code-creation,Builtin,2,29875,0x1015813e0,372,WasmAllocateJSArray
code-creation,Builtin,2,29875,0x101581560,148,WasmAllocateStructWithRtt
code-creation,Builtin,2,29875,0x101581600,184,WasmAllocateArray_Uninitialized
code-creation,Builtin,2,29917,0x1015816c0,232,WasmAllocateArray_InitZero
code-creation,Builtin,2,29917,0x1015817c0,232,WasmAllocateArray_InitNull
code-creation,Builtin,2,29917,0x1015818c0,68,WasmArrayInitFromData
code-creation,Builtin,2,29917,0x101581920,160,WasmArrayCopyWithChecks
code-creation,Builtin,2,29917,0x1015819e0,80,WasmArrayCopy
code-creation,Builtin,2,29917,0x101581a40,276,WasmAllocateObjectWrapper
code-creation,Builtin,2,29959,0x101581b60,84,WasmSubtypeCheck
code-creation,Builtin,2,29959,0x101581bc0,12,WasmInt32ToNumber
code-creation,Builtin,2,29959,0x101581be0,132,WasmUint32ToNumber
code-creation,Builtin,2,29959,0x101581c80,136,UintPtr53ToNumber
code-creation,Builtin,2,29959,0x101581d20,120,WasmAtomicNotify
code-creation,Builtin,2,30000,0x101581da0,136,WasmI32AtomicWait64
code-creation,Builtin,2,30000,0x101581e40,136,WasmI64AtomicWait64
code-creation,Builtin,2,30000,0x101581ee0,1408,CallRefIC
code-creation,Builtin,2,30000,0x101582480,604,WasmGetOwnProperty
code-creation,Builtin,2,30042,0x1015826e0,40,WasmTrap
code-creation,Builtin,2,30042,0x101582720,12,ThrowWasmTrapUnreachable
code-creation,Builtin,2,30042,0x101582740,12,ThrowWasmTrapMemOutOfBounds
code-creation,Builtin,2,30042,0x101582760,12,ThrowWasmTrapUnalignedAccess
code-creation,Builtin,2,30042,0x101582780,12,ThrowWasmTrapDivByZero
code-creation,Builtin,2,30084,0x1015827a0,12,ThrowWasmTrapDivUnrepresentable
code-creation,Builtin,2,30084,0x1015827c0,12,ThrowWasmTrapRemByZero
code-creation,Builtin,2,30084,0x1015827e0,12,ThrowWasmTrapFloatUnrepresentable
code-creation,Builtin,2,30084,0x101582800,12,ThrowWasmTrapFuncSigMismatch
code-creation,Builtin,2,30125,0x101582820,12,ThrowWasmTrapDataSegmentOutOfBounds
code-creation,Builtin,2,30125,0x101582840,12,ThrowWasmTrapElemSegmentDropped
code-creation,Builtin,2,30125,0x101582860,12,ThrowWasmTrapTableOutOfBounds
code-creation,Builtin,2,30125,0x101582880,12,ThrowWasmTrapRethrowNull
code-creation,Builtin,2,30167,0x1015828a0,12,ThrowWasmTrapNullDereference
code-creation,Builtin,2,30167,0x1015828c0,12,ThrowWasmTrapIllegalCast
code-creation,Builtin,2,30167,0x1015828e0,12,ThrowWasmTrapArrayOutOfBounds
code-creation,Builtin,2,30167,0x101582900,12,ThrowWasmTrapArrayTooLarge
code-creation,Builtin,2,30209,0x101582920,164,LoadJoinElement_GenericElementsAccessor_0
code-creation,Builtin,2,30209,0x1015829e0,28,LoadJoinTypedElement_Int32Elements_0
code-creation,Builtin,2,30209,0x101582a00,132,LoadJoinTypedElement_Float32Elements_0
code-creation,Builtin,2,30209,0x101582aa0,128,LoadJoinTypedElement_Float64Elements_0
code-creation,Builtin,2,30250,0x101582b40,28,LoadJoinTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,30250,0x101582b60,248,LoadJoinTypedElement_BigUint64Elements_0
code-creation,Builtin,2,30250,0x101582c60,280,LoadJoinTypedElement_BigInt64Elements_0
code-creation,Builtin,2,30250,0x101582d80,28,LoadJoinTypedElement_Uint8Elements_0
code-creation,Builtin,2,30250,0x101582da0,28,LoadJoinTypedElement_Int8Elements_0
code-creation,Builtin,2,30292,0x101582dc0,28,LoadJoinTypedElement_Uint16Elements_0
code-creation,Builtin,2,30292,0x101582de0,28,LoadJoinTypedElement_Int16Elements_0
code-creation,Builtin,2,30292,0x101582e00,148,LoadJoinTypedElement_Uint32Elements_0
code-creation,Builtin,2,30292,0x101582ea0,12,GenericBuiltinTest_Smi_0
code-creation,Builtin,2,30292,0x101582ec0,52,CanUseSameAccessor_FastDoubleElements_0
code-creation,Builtin,2,30334,0x101582f00,52,CanUseSameAccessor_FastSmiElements_0
code-creation,Builtin,2,30334,0x101582f40,52,CanUseSameAccessor_FastObjectElements_0
code-creation,Builtin,2,30334,0x101582f80,2812,Load_GenericElementsAccessor_0
code-creation,Builtin,2,30334,0x101583a80,44,Store_GenericElementsAccessor_0
code-creation,Builtin,2,30375,0x101583ac0,48,Delete_GenericElementsAccessor_0
code-creation,Builtin,2,30375,0x101583b00,28,LoadTypedElement_Int32Elements_0
code-creation,Builtin,2,30375,0x101583b20,180,StoreTypedElementNumeric_Int32Elements_0
code-creation,Builtin,2,30375,0x101583be0,184,StoreTypedElementJSAny_Int32Elements_0
code-creation,Builtin,2,30417,0x101583ca0,132,LoadTypedElement_Float32Elements_0
code-creation,Builtin,2,30417,0x101583d40,36,StoreTypedElementNumeric_Float32Elements_0
code-creation,Builtin,2,30417,0x101583d80,188,StoreTypedElementJSAny_Float32Elements_0
code-creation,Builtin,2,30417,0x101583e40,128,LoadTypedElement_Float64Elements_0
code-creation,Builtin,2,30417,0x101583ee0,32,StoreTypedElementNumeric_Float64Elements_0
code-creation,Builtin,2,30459,0x101583f20,184,StoreTypedElementJSAny_Float64Elements_0
code-creation,Builtin,2,30459,0x101583fe0,28,LoadTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,30459,0x101584000,32,StoreTypedElementNumeric_Uint8ClampedElements_0
code-creation,Builtin,2,30459,0x101584040,264,StoreTypedElementJSAny_Uint8ClampedElements_0
code-creation,Builtin,2,30500,0x101584160,248,LoadTypedElement_BigUint64Elements_0
code-creation,Builtin,2,30500,0x101584260,72,StoreTypedElementNumeric_BigUint64Elements_0
code-creation,Builtin,2,30500,0x1015842c0,228,StoreTypedElementJSAny_BigUint64Elements_0
code-creation,Builtin,2,30500,0x1015843c0,280,LoadTypedElement_BigInt64Elements_0
code-creation,Builtin,2,30500,0x1015844e0,72,StoreTypedElementNumeric_BigInt64Elements_0
code-creation,Builtin,2,30500,0x101584540,228,StoreTypedElementJSAny_BigInt64Elements_0
code-creation,Builtin,2,30542,0x101584640,28,LoadTypedElement_Uint8Elements_0
code-creation,Builtin,2,30542,0x101584660,32,StoreTypedElementNumeric_Uint8Elements_0
code-creation,Builtin,2,30542,0x1015846a0,184,StoreTypedElementJSAny_Uint8Elements_0
code-creation,Builtin,2,30542,0x101584760,28,LoadTypedElement_Int8Elements_0
code-creation,Builtin,2,30584,0x101584780,32,StoreTypedElementNumeric_Int8Elements_0
code-creation,Builtin,2,30584,0x1015847c0,184,StoreTypedElementJSAny_Int8Elements_0
code-creation,Builtin,2,30584,0x101584880,28,LoadTypedElement_Uint16Elements_0
code-creation,Builtin,2,30584,0x1015848a0,32,StoreTypedElementNumeric_Uint16Elements_0
code-creation,Builtin,2,30584,0x1015848e0,184,StoreTypedElementJSAny_Uint16Elements_0
code-creation,Builtin,2,30625,0x1015849a0,28,LoadTypedElement_Int16Elements_0
code-creation,Builtin,2,30625,0x1015849c0,32,StoreTypedElementNumeric_Int16Elements_0
code-creation,Builtin,2,30625,0x101584a00,184,StoreTypedElementJSAny_Int16Elements_0
code-creation,Builtin,2,30625,0x101584ac0,148,LoadTypedElement_Uint32Elements_0
code-creation,Builtin,2,30625,0x101584b60,180,StoreTypedElementNumeric_Uint32Elements_0
code-creation,Builtin,2,30667,0x101584c20,184,StoreTypedElementJSAny_Uint32Elements_0
code-creation,Builtin,2,30667,0x101584ce0,8,CollatorConstructor
code-creation,Builtin,2,30667,0x101584d00,8,CollatorInternalCompare
code-creation,Builtin,2,30667,0x101584d20,8,CollatorPrototypeCompare
code-creation,Builtin,2,30667,0x101584d40,8,CollatorSupportedLocalesOf
code-creation,Builtin,2,30709,0x101584d60,8,CollatorPrototypeResolvedOptions
code-creation,Builtin,2,30709,0x101584d80,8,DatePrototypeToLocaleDateString
code-creation,Builtin,2,30709,0x101584da0,8,DatePrototypeToLocaleString
code-creation,Builtin,2,30709,0x101584dc0,8,DatePrototypeToLocaleTimeString
code-creation,Builtin,2,30709,0x101584de0,8,DateTimeFormatConstructor
code-creation,Builtin,2,30750,0x101584e00,8,DateTimeFormatInternalFormat
code-creation,Builtin,2,30750,0x101584e20,8,DateTimeFormatPrototypeFormat
code-creation,Builtin,2,30750,0x101584e40,8,DateTimeFormatPrototypeFormatRange
code-creation,Builtin,2,30750,0x101584e60,8,DateTimeFormatPrototypeFormatRangeToParts
code-creation,Builtin,2,30792,0x101584e80,8,DateTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,30792,0x101584ea0,8,DateTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,30792,0x101584ec0,8,DateTimeFormatSupportedLocalesOf
code-creation,Builtin,2,30792,0x101584ee0,8,DisplayNamesConstructor
code-creation,Builtin,2,30834,0x101584f00,8,DisplayNamesPrototypeOf
code-creation,Builtin,2,30834,0x101584f20,8,DisplayNamesPrototypeResolvedOptions
code-creation,Builtin,2,30834,0x101584f40,8,DisplayNamesSupportedLocalesOf
code-creation,Builtin,2,30834,0x101584f60,8,IntlGetCanonicalLocales
code-creation,Builtin,2,30875,0x101584f80,8,IntlSupportedValuesOf
code-creation,Builtin,2,30875,0x101584fa0,8,ListFormatConstructor
code-creation,Builtin,2,30875,0x101584fc0,248,ListFormatPrototypeFormat
code-creation,Builtin,2,30875,0x1015850c0,248,ListFormatPrototypeFormatToParts
code-creation,Builtin,2,30875,0x1015851c0,8,ListFormatPrototypeResolvedOptions
code-creation,Builtin,2,30875,0x1015851e0,8,ListFormatSupportedLocalesOf
code-creation,Builtin,2,30917,0x101585200,8,LocaleConstructor
code-creation,Builtin,2,30917,0x101585220,8,LocalePrototypeBaseName
code-creation,Builtin,2,30917,0x101585240,8,LocalePrototypeCalendar
code-creation,Builtin,2,30917,0x101585260,8,LocalePrototypeCalendars
code-creation,Builtin,2,30959,0x101585280,8,LocalePrototypeCaseFirst
code-creation,Builtin,2,30959,0x1015852a0,8,LocalePrototypeCollation
code-creation,Builtin,2,30959,0x1015852c0,8,LocalePrototypeCollations
code-creation,Builtin,2,30959,0x1015852e0,8,LocalePrototypeHourCycle
code-creation,Builtin,2,30959,0x101585300,8,LocalePrototypeHourCycles
code-creation,Builtin,2,31000,0x101585320,8,LocalePrototypeLanguage
code-creation,Builtin,2,31000,0x101585340,8,LocalePrototypeMaximize
code-creation,Builtin,2,31000,0x101585360,8,LocalePrototypeMinimize
code-creation,Builtin,2,31000,0x101585380,8,LocalePrototypeNumeric
code-creation,Builtin,2,31000,0x1015853a0,8,LocalePrototypeNumberingSystem
code-creation,Builtin,2,31000,0x1015853c0,8,LocalePrototypeNumberingSystems
code-creation,Builtin,2,31042,0x1015853e0,8,LocalePrototypeRegion
code-creation,Builtin,2,31042,0x101585400,8,LocalePrototypeScript
code-creation,Builtin,2,31042,0x101585420,8,LocalePrototypeTextInfo
code-creation,Builtin,2,31042,0x101585440,8,LocalePrototypeTimeZones
code-creation,Builtin,2,31042,0x101585460,8,LocalePrototypeToString
code-creation,Builtin,2,31084,0x101585480,8,LocalePrototypeWeekInfo
code-creation,Builtin,2,31084,0x1015854a0,8,NumberFormatConstructor
code-creation,Builtin,2,31084,0x1015854c0,8,NumberFormatInternalFormatNumber
code-creation,Builtin,2,31084,0x1015854e0,8,NumberFormatPrototypeFormatNumber
code-creation,Builtin,2,31084,0x101585500,8,NumberFormatPrototypeFormatRange
code-creation,Builtin,2,31125,0x101585520,8,NumberFormatPrototypeFormatRangeToParts
code-creation,Builtin,2,31125,0x101585540,8,NumberFormatPrototypeFormatToParts
code-creation,Builtin,2,31125,0x101585560,8,NumberFormatPrototypeResolvedOptions
code-creation,Builtin,2,31125,0x101585580,8,NumberFormatSupportedLocalesOf
code-creation,Builtin,2,31125,0x1015855a0,8,PluralRulesConstructor
code-creation,Builtin,2,31167,0x1015855c0,8,PluralRulesPrototypeResolvedOptions
code-creation,Builtin,2,31167,0x1015855e0,8,PluralRulesPrototypeSelect
code-creation,Builtin,2,31167,0x101585600,8,PluralRulesPrototypeSelectRange
code-creation,Builtin,2,31167,0x101585620,8,PluralRulesSupportedLocalesOf
code-creation,Builtin,2,31209,0x101585640,8,RelativeTimeFormatConstructor
code-creation,Builtin,2,31209,0x101585660,8,RelativeTimeFormatPrototypeFormat
code-creation,Builtin,2,31209,0x101585680,8,RelativeTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,31209,0x1015856a0,8,RelativeTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,31209,0x1015856c0,8,RelativeTimeFormatSupportedLocalesOf
code-creation,Builtin,2,31250,0x1015856e0,8,SegmenterConstructor
code-creation,Builtin,2,31250,0x101585700,8,SegmenterPrototypeResolvedOptions
code-creation,Builtin,2,31250,0x101585720,8,SegmenterPrototypeSegment
code-creation,Builtin,2,31250,0x101585740,8,SegmenterSupportedLocalesOf
code-creation,Builtin,2,31250,0x101585760,8,SegmentIteratorPrototypeNext
code-creation,Builtin,2,31292,0x101585780,8,SegmentsPrototypeContaining
code-creation,Builtin,2,31292,0x1015857a0,8,SegmentsPrototypeIterator
code-creation,Builtin,2,31292,0x1015857c0,8,StringPrototypeNormalizeIntl
code-creation,Builtin,2,31292,0x1015857e0,8,StringPrototypeToLocaleLowerCase
code-creation,Builtin,2,31334,0x101585800,8,StringPrototypeToLocaleUpperCase
code-creation,Builtin,2,31334,0x101585820,216,StringPrototypeToLowerCaseIntl
code-creation,Builtin,2,31334,0x101585900,8,StringPrototypeToUpperCaseIntl
code-creation,Builtin,2,31334,0x101585920,716,StringToLowerCaseIntl
code-creation,Builtin,2,31375,0x101585c00,8,TemporalCalendarPrototypeEra
code-creation,Builtin,2,31375,0x101585c20,8,TemporalCalendarPrototypeEraYear
code-creation,Builtin,2,31375,0x101585c40,8,TemporalDurationPrototypeToLocaleString
code-creation,Builtin,2,31375,0x101585c60,8,TemporalInstantPrototypeToLocaleString
code-creation,Builtin,2,31417,0x101585c80,8,TemporalPlainDatePrototypeEra
code-creation,Builtin,2,31417,0x101585ca0,8,TemporalPlainDatePrototypeEraYear
code-creation,Builtin,2,31417,0x101585cc0,8,TemporalPlainDatePrototypeToLocaleString
code-creation,Builtin,2,31417,0x101585ce0,8,TemporalPlainDateTimePrototypeEra
code-creation,Builtin,2,31459,0x101585d00,8,TemporalPlainDateTimePrototypeEraYear
code-creation,Builtin,2,31459,0x101585d20,8,TemporalPlainDateTimePrototypeToLocaleString
code-creation,Builtin,2,31459,0x101585d40,8,TemporalPlainMonthDayPrototypeToLocaleString
code-creation,Builtin,2,31459,0x101585d60,8,TemporalPlainTimePrototypeToLocaleString
code-creation,Builtin,2,31500,0x101585d80,8,TemporalPlainYearMonthPrototypeEra
code-creation,Builtin,2,31500,0x101585da0,8,TemporalPlainYearMonthPrototypeEraYear
code-creation,Builtin,2,31500,0x101585dc0,8,TemporalPlainYearMonthPrototypeToLocaleString
code-creation,Builtin,2,31542,0x101585de0,8,TemporalZonedDateTimePrototypeEra
code-creation,Builtin,2,31542,0x101585e00,8,TemporalZonedDateTimePrototypeEraYear
code-creation,Builtin,2,31542,0x101585e20,8,TemporalZonedDateTimePrototypeToLocaleString
code-creation,Builtin,2,31542,0x101585e40,8,V8BreakIteratorConstructor
code-creation,Builtin,2,31542,0x101585e60,8,V8BreakIteratorInternalAdoptText
code-creation,Builtin,2,31584,0x101585e80,8,V8BreakIteratorInternalBreakType
code-creation,Builtin,2,31584,0x101585ea0,8,V8BreakIteratorInternalCurrent
code-creation,Builtin,2,31584,0x101585ec0,8,V8BreakIteratorInternalFirst
code-creation,Builtin,2,31584,0x101585ee0,8,V8BreakIteratorInternalNext
code-creation,Builtin,2,31584,0x101585f00,8,V8BreakIteratorPrototypeAdoptText
code-creation,Builtin,2,31625,0x101585f20,8,V8BreakIteratorPrototypeBreakType
code-creation,Builtin,2,31625,0x101585f40,8,V8BreakIteratorPrototypeCurrent
code-creation,Builtin,2,31625,0x101585f60,8,V8BreakIteratorPrototypeFirst
code-creation,Builtin,2,31625,0x101585f80,8,V8BreakIteratorPrototypeNext
code-creation,Builtin,2,31667,0x101585fa0,8,V8BreakIteratorPrototypeResolvedOptions
code-creation,Builtin,2,31667,0x101585fc0,8,V8BreakIteratorSupportedLocalesOf
code-creation,BytecodeHandler,0,31667,0x101585fe0,28,Wide
code-creation,BytecodeHandler,0,31667,0x101586000,28,ExtraWide
code-creation,BytecodeHandler,0,31709,0x101586020,124,DebugBreakWide
code-creation,BytecodeHandler,0,31709,0x1015860a0,124,DebugBreakExtraWide
code-creation,BytecodeHandler,0,31709,0x101586120,188,DebugBreak0
code-creation,BytecodeHandler,0,31709,0x1015861e0,124,DebugBreak1
code-creation,BytecodeHandler,0,31750,0x101586260,124,DebugBreak2
code-creation,BytecodeHandler,0,31750,0x1015862e0,124,DebugBreak3
code-creation,BytecodeHandler,0,31750,0x101586360,124,DebugBreak4
code-creation,BytecodeHandler,0,31750,0x1015863e0,124,DebugBreak5
code-creation,BytecodeHandler,0,31792,0x101586460,124,DebugBreak6
code-creation,BytecodeHandler,0,31792,0x1015864e0,44,Ldar
code-creation,BytecodeHandler,0,31792,0x101586520,76,LdaZero
code-creation,BytecodeHandler,0,31792,0x101586580,84,LdaSmi
code-creation,BytecodeHandler,0,31792,0x1015865e0,76,LdaUndefined
code-creation,BytecodeHandler,0,31834,0x101586640,76,LdaNull
code-creation,BytecodeHandler,0,31834,0x1015866a0,76,LdaTheHole
code-creation,BytecodeHandler,0,31834,0x101586700,28,LdaTrue
code-creation,BytecodeHandler,0,31834,0x101586720,28,LdaFalse
code-creation,BytecodeHandler,0,31875,0x101586740,92,LdaConstant
code-creation,BytecodeHandler,0,31875,0x1015867a0,168,LdaContextSlot
code-creation,BytecodeHandler,0,31875,0x101586860,168,LdaImmutableContextSlot
code-creation,BytecodeHandler,0,31875,0x101586920,112,LdaCurrentContextSlot
code-creation,BytecodeHandler,0,31917,0x1015869a0,112,LdaImmutableCurrentContextSlot
code-creation,BytecodeHandler,0,31917,0x101586a20,44,Star
code-creation,BytecodeHandler,0,31917,0x101586a60,60,Mov
code-creation,BytecodeHandler,0,31917,0x101586aa0,52,PushContext
code-creation,BytecodeHandler,0,31917,0x101586ae0,48,PopContext
code-creation,BytecodeHandler,0,31959,0x101586b20,64,TestReferenceEqual
code-creation,BytecodeHandler,0,31959,0x101586b80,64,TestUndetectable
code-creation,BytecodeHandler,0,32209,0x101586be0,52,TestNull
code-creation,BytecodeHandler,0,32250,0x101586c20,52,TestUndefined
code-creation,BytecodeHandler,0,32250,0x101586c60,388,TestTypeOf
code-creation,BytecodeHandler,0,32292,0x101586e00,5880,LdaGlobal
code-creation,BytecodeHandler,0,32292,0x101588500,4420,LdaGlobalInsideTypeof
code-creation,BytecodeHandler,0,32459,0x101589660,184,StaGlobal
code-creation,BytecodeHandler,0,32459,0x101589720,184,StaContextSlot
code-creation,BytecodeHandler,0,32459,0x1015897e0,128,StaCurrentContextSlot
code-creation,BytecodeHandler,0,32459,0x101589880,152,LdaLookupSlot
code-creation,BytecodeHandler,0,32500,0x101589920,308,LdaLookupContextSlot
code-creation,BytecodeHandler,0,32500,0x101589a60,4744,LdaLookupGlobalSlot
code-creation,BytecodeHandler,0,32500,0x10158ad00,152,LdaLookupSlotInsideTypeof
code-creation,BytecodeHandler,0,32500,0x10158ada0,308,LdaLookupContextSlotInsideTypeof
code-creation,BytecodeHandler,0,32542,0x10158aee0,4676,LdaLookupGlobalSlotInsideTypeof
code-creation,BytecodeHandler,0,32542,0x10158c140,256,StaLookupSlot
code-creation,BytecodeHandler,0,32542,0x10158c260,5112,GetNamedProperty
code-creation,BytecodeHandler,0,32542,0x10158d660,208,GetNamedPropertyFromSuper
code-creation,BytecodeHandler,0,32584,0x10158d740,232,GetKeyedProperty
code-creation,BytecodeHandler,0,32584,0x10158d840,216,LdaModuleVariable
code-creation,BytecodeHandler,0,32584,0x10158d920,340,StaModuleVariable
code-creation,BytecodeHandler,0,32584,0x10158da80,200,SetNamedProperty
code-creation,BytecodeHandler,0,32584,0x10158db60,200,DefineNamedOwnProperty
code-creation,BytecodeHandler,0,32584,0x10158dc40,192,SetKeyedProperty
code-creation,BytecodeHandler,0,32625,0x10158dd20,192,DefineKeyedOwnProperty
code-creation,BytecodeHandler,0,32625,0x10158de00,192,StaInArrayLiteral
code-creation,BytecodeHandler,0,32625,0x10158dee0,228,DefineKeyedOwnPropertyInLiteral
code-creation,BytecodeHandler,0,32625,0x10158dfe0,188,CollectTypeProfile
code-creation,BytecodeHandler,0,32625,0x10158e0a0,996,Add
code-creation,BytecodeHandler,0,32667,0x10158e4a0,1036,Sub
code-creation,BytecodeHandler,0,32667,0x10158e8c0,992,Mul
code-creation,BytecodeHandler,0,32667,0x10158ecc0,940,Div
code-creation,BytecodeHandler,0,32667,0x10158f080,840,Mod
code-creation,BytecodeHandler,0,32667,0x10158f3e0,888,Exp
code-creation,BytecodeHandler,0,32667,0x10158f760,880,BitwiseOr
code-creation,BytecodeHandler,0,32709,0x10158fae0,880,BitwiseXor
code-creation,BytecodeHandler,0,32709,0x10158fe60,880,BitwiseAnd
code-creation,BytecodeHandler,0,32709,0x1015901e0,880,ShiftLeft
code-creation,BytecodeHandler,0,32709,0x101590560,880,ShiftRight
code-creation,BytecodeHandler,0,32709,0x1015908e0,996,ShiftRightLogical
code-creation,BytecodeHandler,0,32750,0x101590ce0,968,AddSmi
code-creation,BytecodeHandler,0,32750,0x1015910c0,1004,SubSmi
code-creation,BytecodeHandler,0,32750,0x1015914c0,912,MulSmi
code-creation,BytecodeHandler,0,32750,0x101591860,996,DivSmi
code-creation,BytecodeHandler,0,32792,0x101591c60,792,ModSmi
code-creation,BytecodeHandler,0,32792,0x101591f80,800,ExpSmi
code-creation,BytecodeHandler,0,32834,0x1015922c0,472,BitwiseOrSmi
code-creation,BytecodeHandler,0,32834,0x1015924a0,472,BitwiseXorSmi
code-creation,BytecodeHandler,0,32834,0x101592680,472,BitwiseAndSmi
code-creation,BytecodeHandler,0,32834,0x101592860,496,ShiftLeftSmi
code-creation,BytecodeHandler,0,32834,0x101592a60,484,ShiftRightSmi
code-creation,BytecodeHandler,0,32875,0x101592c60,800,ShiftRightLogicalSmi
code-creation,BytecodeHandler,0,32875,0x101592fa0,664,Inc
code-creation,BytecodeHandler,0,32875,0x101593240,664,Dec
code-creation,BytecodeHandler,0,32875,0x1015934e0,632,Negate
code-creation,BytecodeHandler,0,32875,0x101593760,452,BitwiseNot
code-creation,BytecodeHandler,0,32917,0x101593940,144,ToBooleanLogicalNot
code-creation,BytecodeHandler,0,32917,0x1015939e0,44,LogicalNot
code-creation,BytecodeHandler,0,32917,0x101593a20,220,TypeOf
code-creation,BytecodeHandler,0,32917,0x101593b00,136,DeletePropertyStrict
code-creation,BytecodeHandler,0,32917,0x101593ba0,136,DeletePropertySloppy
code-creation,BytecodeHandler,0,32917,0x101593c40,52,GetSuperConstructor
code-creation,BytecodeHandler,0,32959,0x101593c80,920,CallAnyReceiver
code-creation,BytecodeHandler,0,32959,0x101594020,920,CallProperty
code-creation,BytecodeHandler,0,32959,0x1015943c0,932,CallProperty0
code-creation,BytecodeHandler,0,32959,0x101594780,944,CallProperty1
code-creation,BytecodeHandler,0,33000,0x101594b40,964,CallProperty2
code-creation,BytecodeHandler,0,33000,0x101594f20,916,CallUndefinedReceiver
code-creation,BytecodeHandler,0,33000,0x1015952c0,908,CallUndefinedReceiver0
code-creation,BytecodeHandler,0,33000,0x101595660,920,CallUndefinedReceiver1
code-creation,BytecodeHandler,0,33000,0x101595a00,940,CallUndefinedReceiver2
code-creation,BytecodeHandler,0,33000,0x101595dc0,920,CallWithSpread
code-creation,BytecodeHandler,0,33000,0x101596160,144,CallRuntime
code-creation,BytecodeHandler,0,33000,0x101596200,188,CallRuntimeForPair
code-creation,BytecodeHandler,0,33042,0x1015962c0,104,CallJSRuntime
code-creation,BytecodeHandler,0,33042,0x101596340,1448,InvokeIntrinsic
code-creation,BytecodeHandler,0,33042,0x101596900,956,Construct
code-creation,BytecodeHandler,0,33042,0x101596cc0,500,ConstructWithSpread
code-creation,BytecodeHandler,0,33042,0x101596ec0,1964,TestEqual
code-creation,BytecodeHandler,0,33084,0x101597680,928,TestEqualStrict
code-creation,BytecodeHandler,0,33084,0x101597a40,1608,TestLessThan
code-creation,BytecodeHandler,0,33084,0x1015980a0,1608,TestGreaterThan
code-creation,BytecodeHandler,0,33084,0x101598700,1608,TestLessThanOrEqual
code-creation,BytecodeHandler,0,33125,0x101598d60,1608,TestGreaterThanOrEqual
code-creation,BytecodeHandler,0,33125,0x1015993c0,848,TestInstanceOf
code-creation,BytecodeHandler,0,33125,0x101599720,176,TestIn
code-creation,BytecodeHandler,0,33125,0x1015997e0,132,ToName
code-creation,BytecodeHandler,0,33125,0x101599880,236,ToNumber
code-creation,BytecodeHandler,0,33125,0x101599980,256,ToNumeric
code-creation,BytecodeHandler,0,33125,0x101599aa0,132,ToObject
code-creation,BytecodeHandler,0,33167,0x101599b40,156,ToString
code-creation,BytecodeHandler,0,33167,0x101599be0,460,CreateRegExpLiteral
code-creation,BytecodeHandler,0,33167,0x101599dc0,1428,CreateArrayLiteral
code-creation,BytecodeHandler,0,33167,0x10159a360,108,CreateArrayFromIterable
code-creation,BytecodeHandler,0,33167,0x10159a3e0,832,CreateEmptyArrayLiteral
code-creation,BytecodeHandler,0,33167,0x10159a740,2132,CreateObjectLiteral
code-creation,BytecodeHandler,0,33209,0x10159afa0,252,CreateEmptyObjectLiteral
code-creation,BytecodeHandler,0,33209,0x10159b0a0,192,CloneObject
code-creation,BytecodeHandler,0,33209,0x10159b180,240,GetTemplateObject
code-creation,BytecodeHandler,0,33209,0x10159b280,380,CreateClosure
code-creation,BytecodeHandler,0,33209,0x10159b400,140,CreateBlockContext
code-creation,BytecodeHandler,0,33209,0x10159b4a0,152,CreateCatchContext
code-creation,BytecodeHandler,0,33209,0x10159b540,308,CreateFunctionContext
code-creation,BytecodeHandler,0,33250,0x10159b680,308,CreateEvalContext
code-creation,BytecodeHandler,0,33250,0x10159b7c0,152,CreateWithContext
code-creation,BytecodeHandler,0,33292,0x10159b860,1984,CreateMappedArguments
code-creation,BytecodeHandler,0,33292,0x10159c040,668,CreateUnmappedArguments
code-creation,BytecodeHandler,0,33292,0x10159c2e0,720,CreateRestParameter
code-creation,BytecodeHandler,0,33292,0x10159c5c0,524,JumpLoop
code-creation,BytecodeHandler,0,33334,0x10159c7e0,60,Jump
code-creation,BytecodeHandler,0,33334,0x10159c820,80,JumpConstant
code-creation,BytecodeHandler,0,33334,0x10159c880,112,JumpIfNullConstant
code-creation,BytecodeHandler,0,33334,0x10159c900,112,JumpIfNotNullConstant
code-creation,BytecodeHandler,0,33334,0x10159c980,112,JumpIfUndefinedConstant
code-creation,BytecodeHandler,0,33375,0x10159ca00,112,JumpIfNotUndefinedConstant
code-creation,BytecodeHandler,0,33375,0x10159ca80,124,JumpIfUndefinedOrNullConstant
code-creation,BytecodeHandler,0,33375,0x10159cb00,112,JumpIfTrueConstant
code-creation,BytecodeHandler,0,33375,0x10159cb80,112,JumpIfFalseConstant
code-creation,BytecodeHandler,0,33417,0x10159cc00,120,JumpIfJSReceiverConstant
code-creation,BytecodeHandler,0,33417,0x10159cc80,208,JumpIfToBooleanTrueConstant
code-creation,BytecodeHandler,0,33417,0x10159cd60,208,JumpIfToBooleanFalseConstant
code-creation,BytecodeHandler,0,33417,0x10159ce40,188,JumpIfToBooleanTrue
code-creation,BytecodeHandler,0,33417,0x10159cf00,188,JumpIfToBooleanFalse
code-creation,BytecodeHandler,0,33459,0x10159cfc0,92,JumpIfTrue
code-creation,BytecodeHandler,0,33459,0x10159d020,92,JumpIfFalse
code-creation,BytecodeHandler,0,33459,0x10159d080,92,JumpIfNull
code-creation,BytecodeHandler,0,33459,0x10159d0e0,92,JumpIfNotNull
code-creation,BytecodeHandler,0,33459,0x10159d140,92,JumpIfUndefined
code-creation,BytecodeHandler,0,33459,0x10159d1a0,92,JumpIfNotUndefined
code-creation,BytecodeHandler,0,33500,0x10159d200,104,JumpIfUndefinedOrNull
code-creation,BytecodeHandler,0,33500,0x10159d280,100,JumpIfJSReceiver
code-creation,BytecodeHandler,0,33500,0x10159d300,140,SwitchOnSmiNoFeedback
code-creation,BytecodeHandler,0,33500,0x10159d3a0,556,ForInEnumerate
code-creation,BytecodeHandler,0,33542,0x10159d5e0,268,ForInPrepare
code-creation,BytecodeHandler,0,33542,0x10159d700,76,ForInContinue
code-creation,BytecodeHandler,0,33542,0x10159d760,304,ForInNext
code-creation,BytecodeHandler,0,33542,0x10159d8a0,48,ForInStep
code-creation,BytecodeHandler,0,33542,0x10159d8e0,36,SetPendingMessage
code-creation,BytecodeHandler,0,33584,0x10159d920,132,Throw
code-creation,BytecodeHandler,0,33584,0x10159d9c0,132,ReThrow
code-creation,BytecodeHandler,0,33584,0x10159da60,132,Return
code-creation,BytecodeHandler,0,33584,0x10159db00,232,ThrowReferenceErrorIfHole
code-creation,BytecodeHandler,0,33625,0x10159dc00,152,ThrowSuperNotCalledIfHole
code-creation,BytecodeHandler,0,33625,0x10159dca0,152,ThrowSuperAlreadyCalledIfNotHole
code-creation,BytecodeHandler,0,33625,0x10159dd40,176,ThrowIfNotSuperConstructor
code-creation,BytecodeHandler,0,33875,0x10159de00,148,SwitchOnGeneratorState
code-creation,BytecodeHandler,0,33875,0x10159dea0,516,SuspendGenerator
code-creation,BytecodeHandler,0,33917,0x10159e0c0,172,ResumeGenerator
code-creation,BytecodeHandler,0,33917,0x10159e180,180,GetIterator
code-creation,BytecodeHandler,0,33917,0x10159e240,128,Debugger
code-creation,BytecodeHandler,0,33917,0x10159e2e0,136,IncBlockCounter
code-creation,BytecodeHandler,0,33917,0x10159e380,76,Abort
code-creation,BytecodeHandler,0,33959,0x10159e3e0,44,Star0
code-creation,BytecodeHandler,0,33959,0x10159e420,72,Illegal
code-creation,BytecodeHandler,0,33959,0x10159e480,128,DebugBreak1.Wide
code-creation,BytecodeHandler,0,33959,0x10159e520,128,DebugBreak2.Wide
code-creation,BytecodeHandler,0,33959,0x10159e5c0,128,DebugBreak3.Wide
code-creation,BytecodeHandler,0,34000,0x10159e660,128,DebugBreak4.Wide
code-creation,BytecodeHandler,0,34000,0x10159e700,128,DebugBreak5.Wide
code-creation,BytecodeHandler,0,34000,0x10159e7a0,128,DebugBreak6.Wide
code-creation,BytecodeHandler,0,34000,0x10159e840,44,Ldar.Wide
code-creation,BytecodeHandler,0,34000,0x10159e880,40,LdaSmi.Wide
code-creation,BytecodeHandler,0,34000,0x10159e8c0,48,LdaConstant.Wide
code-creation,BytecodeHandler,0,34042,0x10159e900,128,LdaContextSlot.Wide
code-creation,BytecodeHandler,0,34042,0x10159e9a0,128,LdaImmutableContextSlot.Wide
code-creation,BytecodeHandler,0,34042,0x10159ea40,72,LdaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,34042,0x10159eaa0,72,LdaImmutableCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,34084,0x10159eb00,44,Star.Wide
code-creation,BytecodeHandler,0,34084,0x10159eb40,60,Mov.Wide
code-creation,BytecodeHandler,0,34084,0x10159eb80,52,PushContext.Wide
code-creation,BytecodeHandler,0,34084,0x10159ebc0,48,PopContext.Wide
code-creation,BytecodeHandler,0,34125,0x10159ec00,64,TestReferenceEqual.Wide
code-creation,BytecodeHandler,0,34125,0x10159ec60,4572,LdaGlobal.Wide
code-creation,BytecodeHandler,0,34125,0x10159fe40,4484,LdaGlobalInsideTypeof.Wide
code-creation,BytecodeHandler,0,34125,0x1015a0fe0,188,StaGlobal.Wide
code-creation,BytecodeHandler,0,34125,0x1015a10a0,184,StaContextSlot.Wide
code-creation,BytecodeHandler,0,34167,0x1015a1160,128,StaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,34167,0x1015a1200,156,LdaLookupSlot.Wide
code-creation,BytecodeHandler,0,34167,0x1015a12a0,312,LdaLookupContextSlot.Wide
code-creation,BytecodeHandler,0,34167,0x1015a13e0,4816,LdaLookupGlobalSlot.Wide
code-creation,BytecodeHandler,0,34167,0x1015a26c0,156,LdaLookupSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,34209,0x1015a2760,312,LdaLookupContextSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,34209,0x1015a28a0,4744,LdaLookupGlobalSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,34209,0x1015a3b40,252,StaLookupSlot.Wide
code-creation,BytecodeHandler,0,34250,0x1015a3c40,5144,GetNamedProperty.Wide
code-creation,BytecodeHandler,0,34250,0x1015a5060,212,GetNamedPropertyFromSuper.Wide
code-creation,BytecodeHandler,0,34250,0x1015a5140,180,GetKeyedProperty.Wide
code-creation,BytecodeHandler,0,34250,0x1015a5200,216,LdaModuleVariable.Wide
code-creation,BytecodeHandler,0,34250,0x1015a52e0,344,StaModuleVariable.Wide
code-creation,BytecodeHandler,0,34292,0x1015a5440,204,SetNamedProperty.Wide
code-creation,BytecodeHandler,0,34292,0x1015a5520,204,DefineNamedOwnProperty.Wide
code-creation,BytecodeHandler,0,34292,0x1015a5600,196,SetKeyedProperty.Wide
code-creation,BytecodeHandler,0,34292,0x1015a56e0,196,DefineKeyedOwnProperty.Wide
code-creation,BytecodeHandler,0,34292,0x1015a57c0,196,StaInArrayLiteral.Wide
code-creation,BytecodeHandler,0,34334,0x1015a58a0,232,DefineKeyedOwnPropertyInLiteral.Wide
code-creation,BytecodeHandler,0,34334,0x1015a59a0,192,CollectTypeProfile.Wide
code-creation,BytecodeHandler,0,34334,0x1015a5a80,948,Add.Wide
code-creation,BytecodeHandler,0,34334,0x1015a5e40,992,Sub.Wide
code-creation,BytecodeHandler,0,34334,0x1015a6240,940,Mul.Wide
code-creation,BytecodeHandler,0,34375,0x1015a6600,944,Div.Wide
code-creation,BytecodeHandler,0,34375,0x1015a69c0,848,Mod.Wide
code-creation,BytecodeHandler,0,34375,0x1015a6d20,908,Exp.Wide
code-creation,BytecodeHandler,0,34375,0x1015a70c0,896,BitwiseOr.Wide
code-creation,BytecodeHandler,0,34375,0x1015a7460,896,BitwiseXor.Wide
code-creation,BytecodeHandler,0,34375,0x1015a7800,896,BitwiseAnd.Wide
code-creation,BytecodeHandler,0,34417,0x1015a7ba0,896,ShiftLeft.Wide
code-creation,BytecodeHandler,0,34417,0x1015a7f40,896,ShiftRight.Wide
code-creation,BytecodeHandler,0,34417,0x1015a82e0,1012,ShiftRightLogical.Wide
code-creation,BytecodeHandler,0,34417,0x1015a86e0,920,AddSmi.Wide
code-creation,BytecodeHandler,0,34417,0x1015a8a80,960,SubSmi.Wide
code-creation,BytecodeHandler,0,34459,0x1015a8e60,912,MulSmi.Wide
code-creation,BytecodeHandler,0,34459,0x1015a9200,996,DivSmi.Wide
code-creation,BytecodeHandler,0,34459,0x1015a9600,792,ModSmi.Wide
code-creation,BytecodeHandler,0,34459,0x1015a9920,800,ExpSmi.Wide
code-creation,BytecodeHandler,0,34500,0x1015a9c60,480,BitwiseOrSmi.Wide
code-creation,BytecodeHandler,0,34500,0x1015a9e60,480,BitwiseXorSmi.Wide
code-creation,BytecodeHandler,0,34500,0x1015aa060,480,BitwiseAndSmi.Wide
code-creation,BytecodeHandler,0,34542,0x1015aa260,504,ShiftLeftSmi.Wide
code-creation,BytecodeHandler,0,34542,0x1015aa460,492,ShiftRightSmi.Wide
code-creation,BytecodeHandler,0,34542,0x1015aa660,808,ShiftRightLogicalSmi.Wide
code-creation,BytecodeHandler,0,34542,0x1015aa9a0,624,Inc.Wide
code-creation,BytecodeHandler,0,34584,0x1015aac20,624,Dec.Wide
code-creation,BytecodeHandler,0,34584,0x1015aaea0,640,Negate.Wide
code-creation,BytecodeHandler,0,34584,0x1015ab140,460,BitwiseNot.Wide
code-creation,BytecodeHandler,0,34584,0x1015ab320,140,DeletePropertyStrict.Wide
code-creation,BytecodeHandler,0,34625,0x1015ab3c0,140,DeletePropertySloppy.Wide
code-creation,BytecodeHandler,0,34625,0x1015ab460,52,GetSuperConstructor.Wide
code-creation,BytecodeHandler,0,34625,0x1015ab4a0,924,CallAnyReceiver.Wide
code-creation,BytecodeHandler,0,34625,0x1015ab840,924,CallProperty.Wide
code-creation,BytecodeHandler,0,34625,0x1015abbe0,936,CallProperty0.Wide
code-creation,BytecodeHandler,0,34667,0x1015abfa0,948,CallProperty1.Wide
code-creation,BytecodeHandler,0,34667,0x1015ac360,968,CallProperty2.Wide
code-creation,BytecodeHandler,0,34667,0x1015ac740,920,CallUndefinedReceiver.Wide
code-creation,BytecodeHandler,0,34667,0x1015acae0,912,CallUndefinedReceiver0.Wide
code-creation,BytecodeHandler,0,34709,0x1015ace80,924,CallUndefinedReceiver1.Wide
code-creation,BytecodeHandler,0,34709,0x1015ad220,944,CallUndefinedReceiver2.Wide
code-creation,BytecodeHandler,0,34709,0x1015ad5e0,924,CallWithSpread.Wide
code-creation,BytecodeHandler,0,34709,0x1015ad980,148,CallRuntime.Wide
code-creation,BytecodeHandler,0,34750,0x1015ada20,196,CallRuntimeForPair.Wide
code-creation,BytecodeHandler,0,34750,0x1015adb00,108,CallJSRuntime.Wide
code-creation,BytecodeHandler,0,34750,0x1015adb80,1452,InvokeIntrinsic.Wide
code-creation,BytecodeHandler,0,34750,0x1015ae140,904,Construct.Wide
code-creation,BytecodeHandler,0,34750,0x1015ae4e0,448,ConstructWithSpread.Wide
code-creation,BytecodeHandler,0,34750,0x1015ae6c0,1996,TestEqual.Wide
code-creation,BytecodeHandler,0,34792,0x1015aeea0,936,TestEqualStrict.Wide
code-creation,BytecodeHandler,0,34792,0x1015af260,1592,TestLessThan.Wide
code-creation,BytecodeHandler,0,34792,0x1015af8a0,1592,TestGreaterThan.Wide
code-creation,BytecodeHandler,0,34834,0x1015afee0,1592,TestLessThanOrEqual.Wide
code-creation,BytecodeHandler,0,34834,0x1015b0520,1592,TestGreaterThanOrEqual.Wide
code-creation,BytecodeHandler,0,34834,0x1015b0b60,856,TestInstanceOf.Wide
code-creation,BytecodeHandler,0,34834,0x1015b0ec0,180,TestIn.Wide
code-creation,BytecodeHandler,0,34834,0x1015b0f80,136,ToName.Wide
code-creation,BytecodeHandler,0,34875,0x1015b1020,240,ToNumber.Wide
code-creation,BytecodeHandler,0,34875,0x1015b1120,260,ToNumeric.Wide
code-creation,BytecodeHandler,0,34875,0x1015b1240,136,ToObject.Wide
code-creation,BytecodeHandler,0,34875,0x1015b12e0,464,CreateRegExpLiteral.Wide
code-creation,BytecodeHandler,0,34917,0x1015b14c0,1336,CreateArrayLiteral.Wide
code-creation,BytecodeHandler,0,34917,0x1015b1a00,832,CreateEmptyArrayLiteral.Wide
code-creation,BytecodeHandler,0,34917,0x1015b1d60,2040,CreateObjectLiteral.Wide
code-creation,BytecodeHandler,0,34917,0x1015b2560,196,CloneObject.Wide
code-creation,BytecodeHandler,0,34959,0x1015b2640,188,GetTemplateObject.Wide
code-creation,BytecodeHandler,0,34959,0x1015b2700,376,CreateClosure.Wide
code-creation,BytecodeHandler,0,34959,0x1015b2880,144,CreateBlockContext.Wide
code-creation,BytecodeHandler,0,34959,0x1015b2920,156,CreateCatchContext.Wide
code-creation,BytecodeHandler,0,35000,0x1015b29c0,308,CreateFunctionContext.Wide
code-creation,BytecodeHandler,0,35000,0x1015b2b00,308,CreateEvalContext.Wide
code-creation,BytecodeHandler,0,35000,0x1015b2c40,156,CreateWithContext.Wide
code-creation,BytecodeHandler,0,35000,0x1015b2ce0,536,JumpLoop.Wide
code-creation,BytecodeHandler,0,35042,0x1015b2f00,60,Jump.Wide
code-creation,BytecodeHandler,0,35042,0x1015b2f40,80,JumpConstant.Wide
code-creation,BytecodeHandler,0,35042,0x1015b2fa0,112,JumpIfNullConstant.Wide
code-creation,BytecodeHandler,0,35042,0x1015b3020,112,JumpIfNotNullConstant.Wide
code-creation,BytecodeHandler,0,35042,0x1015b30a0,112,JumpIfUndefinedConstant.Wide
code-creation,BytecodeHandler,0,35084,0x1015b3120,112,JumpIfNotUndefinedConstant.Wide
code-creation,BytecodeHandler,0,35084,0x1015b31a0,124,JumpIfUndefinedOrNullConstant.Wide
code-creation,BytecodeHandler,0,35084,0x1015b3220,112,JumpIfTrueConstant.Wide
code-creation,BytecodeHandler,0,35125,0x1015b32a0,112,JumpIfFalseConstant.Wide
code-creation,BytecodeHandler,0,35125,0x1015b3320,120,JumpIfJSReceiverConstant.Wide
code-creation,BytecodeHandler,0,35125,0x1015b33a0,208,JumpIfToBooleanTrueConstant.Wide
code-creation,BytecodeHandler,0,35125,0x1015b3480,208,JumpIfToBooleanFalseConstant.Wide
code-creation,BytecodeHandler,0,35125,0x1015b3560,188,JumpIfToBooleanTrue.Wide
code-creation,BytecodeHandler,0,35167,0x1015b3620,188,JumpIfToBooleanFalse.Wide
code-creation,BytecodeHandler,0,35167,0x1015b36e0,92,JumpIfTrue.Wide
code-creation,BytecodeHandler,0,35167,0x1015b3740,92,JumpIfFalse.Wide
code-creation,BytecodeHandler,0,35167,0x1015b37a0,92,JumpIfNull.Wide
code-creation,BytecodeHandler,0,35209,0x1015b3800,92,JumpIfNotNull.Wide
code-creation,BytecodeHandler,0,35209,0x1015b3860,92,JumpIfUndefined.Wide
code-creation,BytecodeHandler,0,35209,0x1015b38c0,92,JumpIfNotUndefined.Wide
code-creation,BytecodeHandler,0,35209,0x1015b3920,104,JumpIfUndefinedOrNull.Wide
code-creation,BytecodeHandler,0,35250,0x1015b39a0,100,JumpIfJSReceiver.Wide
code-creation,BytecodeHandler,0,35292,0x1015b3a20,140,SwitchOnSmiNoFeedback.Wide
code-creation,BytecodeHandler,0,35292,0x1015b3ac0,560,ForInEnumerate.Wide
code-creation,BytecodeHandler,0,35292,0x1015b3d00,268,ForInPrepare.Wide
code-creation,BytecodeHandler,0,35292,0x1015b3e20,76,ForInContinue.Wide
code-creation,BytecodeHandler,0,35334,0x1015b3e80,308,ForInNext.Wide
code-creation,BytecodeHandler,0,35334,0x1015b3fc0,48,ForInStep.Wide
code-creation,BytecodeHandler,0,35334,0x1015b4000,192,ThrowReferenceErrorIfHole.Wide
code-creation,BytecodeHandler,0,35334,0x1015b40e0,180,ThrowIfNotSuperConstructor.Wide
code-creation,BytecodeHandler,0,35334,0x1015b41a0,148,SwitchOnGeneratorState.Wide
code-creation,BytecodeHandler,0,35334,0x1015b4240,520,SuspendGenerator.Wide
code-creation,BytecodeHandler,0,35334,0x1015b4460,172,ResumeGenerator.Wide
code-creation,BytecodeHandler,0,35375,0x1015b4520,184,GetIterator.Wide
code-creation,BytecodeHandler,0,35375,0x1015b45e0,140,IncBlockCounter.Wide
code-creation,BytecodeHandler,0,35375,0x1015b4680,80,Abort.Wide
code-creation,BytecodeHandler,0,35375,0x1015b46e0,128,DebugBreak1.ExtraWide
code-creation,BytecodeHandler,0,35417,0x1015b4780,128,DebugBreak2.ExtraWide
code-creation,BytecodeHandler,0,35417,0x1015b4820,128,DebugBreak3.ExtraWide
code-creation,BytecodeHandler,0,35459,0x1015b48c0,128,DebugBreak4.ExtraWide
code-creation,BytecodeHandler,0,35459,0x1015b4960,128,DebugBreak5.ExtraWide
code-creation,BytecodeHandler,0,35500,0x1015b4a00,128,DebugBreak6.ExtraWide
code-creation,BytecodeHandler,0,35500,0x1015b4aa0,44,Ldar.ExtraWide
code-creation,BytecodeHandler,0,35542,0x1015b4ae0,40,LdaSmi.ExtraWide
code-creation,BytecodeHandler,0,35542,0x1015b4b20,48,LdaConstant.ExtraWide
code-creation,BytecodeHandler,0,35584,0x1015b4b60,128,LdaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,35625,0x1015b4c00,128,LdaImmutableContextSlot.ExtraWide
code-creation,BytecodeHandler,0,35625,0x1015b4ca0,72,LdaCurrentContextSlot.ExtraWide
tick,0x195a4df24,35667,0,0x0,6
tick,0x19596cddc,35667,0,0x0,6
tick,0x195a4df24,35667,0,0x0,6
tick,0x195a4df24,35667,0,0x0,6
tick,0x195a4df24,35667,0,0x0,6
code-creation,BytecodeHandler,0,35750,0x1015b4d00,72,LdaImmutableCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,35750,0x1015b4d60,44,Star.ExtraWide
code-creation,BytecodeHandler,0,35750,0x1015b4da0,60,Mov.ExtraWide
code-creation,BytecodeHandler,0,35792,0x1015b4de0,52,PushContext.ExtraWide
code-creation,BytecodeHandler,0,35792,0x1015b4e20,48,PopContext.ExtraWide
code-creation,BytecodeHandler,0,35792,0x1015b4e60,64,TestReferenceEqual.ExtraWide
code-creation,BytecodeHandler,0,35834,0x1015b4ec0,4572,LdaGlobal.ExtraWide
code-creation,BytecodeHandler,0,35834,0x1015b60a0,4484,LdaGlobalInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,35834,0x1015b7240,188,StaGlobal.ExtraWide
code-creation,BytecodeHandler,0,35834,0x1015b7300,184,StaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,35834,0x1015b73c0,128,StaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,35875,0x1015b7460,156,LdaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,35875,0x1015b7500,312,LdaLookupContextSlot.ExtraWide
code-creation,BytecodeHandler,0,35875,0x1015b7640,4816,LdaLookupGlobalSlot.ExtraWide
code-creation,BytecodeHandler,0,35875,0x1015b8920,156,LdaLookupSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,35917,0x1015b89c0,312,LdaLookupContextSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,35917,0x1015b8b00,4744,LdaLookupGlobalSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,35917,0x1015b9da0,252,StaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,35917,0x1015b9ea0,5144,GetNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,35917,0x1015bb2c0,212,GetNamedPropertyFromSuper.ExtraWide
code-creation,BytecodeHandler,0,35959,0x1015bb3a0,180,GetKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,35959,0x1015bb460,216,LdaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,35959,0x1015bb540,344,StaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,35959,0x1015bb6a0,204,SetNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,35959,0x1015bb780,204,DefineNamedOwnProperty.ExtraWide
code-creation,BytecodeHandler,0,36000,0x1015bb860,196,SetKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,36000,0x1015bb940,196,DefineKeyedOwnProperty.ExtraWide
code-creation,BytecodeHandler,0,36000,0x1015bba20,196,StaInArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,36042,0x1015bbb00,232,DefineKeyedOwnPropertyInLiteral.ExtraWide
code-creation,BytecodeHandler,0,36042,0x1015bbc00,192,CollectTypeProfile.ExtraWide
code-creation,BytecodeHandler,0,36042,0x1015bbce0,948,Add.ExtraWide
code-creation,BytecodeHandler,0,36042,0x1015bc0a0,992,Sub.ExtraWide
code-creation,BytecodeHandler,0,36042,0x1015bc4a0,940,Mul.ExtraWide
code-creation,BytecodeHandler,0,36084,0x1015bc860,944,Div.ExtraWide
code-creation,BytecodeHandler,0,36084,0x1015bcc20,848,Mod.ExtraWide
code-creation,BytecodeHandler,0,36084,0x1015bcf80,908,Exp.ExtraWide
code-creation,BytecodeHandler,0,36084,0x1015bd320,896,BitwiseOr.ExtraWide
code-creation,BytecodeHandler,0,36084,0x1015bd6c0,896,BitwiseXor.ExtraWide
code-creation,BytecodeHandler,0,36125,0x1015bda60,896,BitwiseAnd.ExtraWide
code-creation,BytecodeHandler,0,36125,0x1015bde00,896,ShiftLeft.ExtraWide
code-creation,BytecodeHandler,0,36125,0x1015be1a0,896,ShiftRight.ExtraWide
code-creation,BytecodeHandler,0,36125,0x1015be540,1012,ShiftRightLogical.ExtraWide
code-creation,BytecodeHandler,0,36167,0x1015be940,920,AddSmi.ExtraWide
code-creation,BytecodeHandler,0,36167,0x1015bece0,960,SubSmi.ExtraWide
code-creation,BytecodeHandler,0,36167,0x1015bf0c0,912,MulSmi.ExtraWide
code-creation,BytecodeHandler,0,36167,0x1015bf460,996,DivSmi.ExtraWide
code-creation,BytecodeHandler,0,36209,0x1015bf860,792,ModSmi.ExtraWide
code-creation,BytecodeHandler,0,36209,0x1015bfb80,800,ExpSmi.ExtraWide
code-creation,BytecodeHandler,0,36209,0x1015bfec0,480,BitwiseOrSmi.ExtraWide
code-creation,BytecodeHandler,0,36209,0x1015c00c0,480,BitwiseXorSmi.ExtraWide
code-creation,BytecodeHandler,0,36250,0x1015c02c0,480,BitwiseAndSmi.ExtraWide
code-creation,BytecodeHandler,0,36250,0x1015c04c0,504,ShiftLeftSmi.ExtraWide
code-creation,BytecodeHandler,0,36250,0x1015c06c0,492,ShiftRightSmi.ExtraWide
code-creation,BytecodeHandler,0,36250,0x1015c08c0,808,ShiftRightLogicalSmi.ExtraWide
code-creation,BytecodeHandler,0,36250,0x1015c0c00,624,Inc.ExtraWide
code-creation,BytecodeHandler,0,36292,0x1015c0e80,624,Dec.ExtraWide
code-creation,BytecodeHandler,0,36292,0x1015c1100,640,Negate.ExtraWide
code-creation,BytecodeHandler,0,36292,0x1015c13a0,460,BitwiseNot.ExtraWide
code-creation,BytecodeHandler,0,36292,0x1015c1580,140,DeletePropertyStrict.ExtraWide
code-creation,BytecodeHandler,0,36334,0x1015c1620,140,DeletePropertySloppy.ExtraWide
code-creation,BytecodeHandler,0,36334,0x1015c16c0,52,GetSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,36417,0x1015c1700,924,CallAnyReceiver.ExtraWide
code-creation,BytecodeHandler,0,36417,0x1015c1aa0,924,CallProperty.ExtraWide
code-creation,BytecodeHandler,0,36417,0x1015c1e40,936,CallProperty0.ExtraWide
code-creation,BytecodeHandler,0,36459,0x1015c2200,948,CallProperty1.ExtraWide
code-creation,BytecodeHandler,0,36459,0x1015c25c0,968,CallProperty2.ExtraWide
code-creation,BytecodeHandler,0,36459,0x1015c29a0,920,CallUndefinedReceiver.ExtraWide
code-creation,BytecodeHandler,0,36500,0x1015c2d40,912,CallUndefinedReceiver0.ExtraWide
code-creation,BytecodeHandler,0,36500,0x1015c30e0,924,CallUndefinedReceiver1.ExtraWide
code-creation,BytecodeHandler,0,36500,0x1015c3480,944,CallUndefinedReceiver2.ExtraWide
code-creation,BytecodeHandler,0,36500,0x1015c3840,924,CallWithSpread.ExtraWide
code-creation,BytecodeHandler,0,36500,0x1015c3be0,148,CallRuntime.ExtraWide
code-creation,BytecodeHandler,0,36542,0x1015c3c80,196,CallRuntimeForPair.ExtraWide
code-creation,BytecodeHandler,0,36542,0x1015c3d60,108,CallJSRuntime.ExtraWide
code-creation,BytecodeHandler,0,36542,0x1015c3de0,1452,InvokeIntrinsic.ExtraWide
code-creation,BytecodeHandler,0,36542,0x1015c43a0,904,Construct.ExtraWide
code-creation,BytecodeHandler,0,36584,0x1015c4740,448,ConstructWithSpread.ExtraWide
code-creation,BytecodeHandler,0,36584,0x1015c4920,1996,TestEqual.ExtraWide
code-creation,BytecodeHandler,0,36584,0x1015c5100,936,TestEqualStrict.ExtraWide
code-creation,BytecodeHandler,0,36584,0x1015c54c0,1592,TestLessThan.ExtraWide
code-creation,BytecodeHandler,0,36625,0x1015c5b00,1592,TestGreaterThan.ExtraWide
code-creation,BytecodeHandler,0,36625,0x1015c6140,1592,TestLessThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,36625,0x1015c6780,1592,TestGreaterThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,36625,0x1015c6dc0,856,TestInstanceOf.ExtraWide
code-creation,BytecodeHandler,0,36667,0x1015c7120,180,TestIn.ExtraWide
code-creation,BytecodeHandler,0,36667,0x1015c71e0,136,ToName.ExtraWide
code-creation,BytecodeHandler,0,36667,0x1015c7280,240,ToNumber.ExtraWide
code-creation,BytecodeHandler,0,36709,0x1015c7380,260,ToNumeric.ExtraWide
code-creation,BytecodeHandler,0,36709,0x1015c74a0,136,ToObject.ExtraWide
code-creation,BytecodeHandler,0,36709,0x1015c7540,464,CreateRegExpLiteral.ExtraWide
code-creation,BytecodeHandler,0,36709,0x1015c7720,1336,CreateArrayLiteral.ExtraWide
tick,0x195a4df24,36709,0,0x0,6
code-creation,BytecodeHandler,0,36750,0x1015c7c60,832,CreateEmptyArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,36750,0x1015c7fc0,2040,CreateObjectLiteral.ExtraWide
code-creation,BytecodeHandler,0,36750,0x1015c87c0,196,CloneObject.ExtraWide
code-creation,BytecodeHandler,0,36750,0x1015c88a0,188,GetTemplateObject.ExtraWide
code-creation,BytecodeHandler,0,36750,0x1015c8960,376,CreateClosure.ExtraWide
code-creation,BytecodeHandler,0,36750,0x1015c8ae0,144,CreateBlockContext.ExtraWide
code-creation,BytecodeHandler,0,36792,0x1015c8b80,156,CreateCatchContext.ExtraWide
code-creation,BytecodeHandler,0,36792,0x1015c8c20,308,CreateFunctionContext.ExtraWide
code-creation,BytecodeHandler,0,36792,0x1015c8d60,308,CreateEvalContext.ExtraWide
code-creation,BytecodeHandler,0,36792,0x1015c8ea0,156,CreateWithContext.ExtraWide
code-creation,BytecodeHandler,0,36792,0x1015c8f40,536,JumpLoop.ExtraWide
code-creation,BytecodeHandler,0,36792,0x1015c9160,60,Jump.ExtraWide
code-creation,BytecodeHandler,0,36792,0x1015c91a0,80,JumpConstant.ExtraWide
code-creation,BytecodeHandler,0,36792,0x1015c9200,112,JumpIfNullConstant.ExtraWide
code-creation,BytecodeHandler,0,36792,0x1015c9280,112,JumpIfNotNullConstant.ExtraWide
code-creation,BytecodeHandler,0,36834,0x1015c9300,112,JumpIfUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,36834,0x1015c9380,112,JumpIfNotUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,36834,0x1015c9400,124,JumpIfUndefinedOrNullConstant.ExtraWide
code-creation,BytecodeHandler,0,36834,0x1015c9480,112,JumpIfTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,36834,0x1015c9500,112,JumpIfFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,38625,0x1015c9580,120,JumpIfJSReceiverConstant.ExtraWide
code-creation,BytecodeHandler,0,38625,0x1015c9600,208,JumpIfToBooleanTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,38667,0x1015c96e0,208,JumpIfToBooleanFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,38667,0x1015c97c0,188,JumpIfToBooleanTrue.ExtraWide
code-creation,BytecodeHandler,0,38667,0x1015c9880,188,JumpIfToBooleanFalse.ExtraWide
code-creation,BytecodeHandler,0,38667,0x1015c9940,92,JumpIfTrue.ExtraWide
code-creation,BytecodeHandler,0,38709,0x1015c99a0,92,JumpIfFalse.ExtraWide
code-creation,BytecodeHandler,0,38709,0x1015c9a00,92,JumpIfNull.ExtraWide
code-creation,BytecodeHandler,0,38709,0x1015c9a60,92,JumpIfNotNull.ExtraWide
code-creation,BytecodeHandler,0,38709,0x1015c9ac0,92,JumpIfUndefined.ExtraWide
code-creation,BytecodeHandler,0,38709,0x1015c9b20,92,JumpIfNotUndefined.ExtraWide
code-creation,BytecodeHandler,0,38750,0x1015c9b80,104,JumpIfUndefinedOrNull.ExtraWide
code-creation,BytecodeHandler,0,38750,0x1015c9c00,100,JumpIfJSReceiver.ExtraWide
code-creation,BytecodeHandler,0,38792,0x1015c9c80,140,SwitchOnSmiNoFeedback.ExtraWide
code-creation,BytecodeHandler,0,38792,0x1015c9d20,560,ForInEnumerate.ExtraWide
code-creation,BytecodeHandler,0,38792,0x1015c9f60,268,ForInPrepare.ExtraWide
code-creation,BytecodeHandler,0,38834,0x1015ca080,76,ForInContinue.ExtraWide
code-creation,BytecodeHandler,0,38834,0x1015ca0e0,308,ForInNext.ExtraWide
code-creation,BytecodeHandler,0,38834,0x1015ca220,48,ForInStep.ExtraWide
code-creation,BytecodeHandler,0,38834,0x1015ca260,192,ThrowReferenceErrorIfHole.ExtraWide
code-creation,BytecodeHandler,0,38917,0x1015ca340,180,ThrowIfNotSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,38959,0x1015ca400,148,SwitchOnGeneratorState.ExtraWide
code-creation,BytecodeHandler,0,38959,0x1015ca4a0,520,SuspendGenerator.ExtraWide
code-creation,BytecodeHandler,0,38959,0x1015ca6c0,172,ResumeGenerator.ExtraWide
code-creation,BytecodeHandler,0,38959,0x1015ca780,184,GetIterator.ExtraWide
code-creation,BytecodeHandler,0,38959,0x1015ca840,140,IncBlockCounter.ExtraWide
code-creation,BytecodeHandler,0,39000,0x1015ca8e0,80,Abort.ExtraWide
tick,0x195a4df24,39125,0,0x0,6
new,MemoryChunk,0x30b515080000,262144
new,MemoryChunk,0x2b072d780000,262144
new,MemoryChunk,0x12324f080000,262144
new,MemoryChunk,0x176e57340000,262144
tick,0x100e4dcfc,41250,0,0x0,5
tick,0x1011d8244,41584,0,0x0,5
new,MemoryChunk,0x202f02840000,262144
code-creation,Eval,10,43000,0x202f02876108,5, node:internal/main/run_main_module:1:1,0x202f02875fc0,~
script-source,446,node:internal/main/run_main_module,'use strict';\n\nconst { RegExpPrototypeExec } = primordials;\n\nconst {\n  prepareMainThreadExecution\x2C\n  markBootstrapComplete\x2C\n} = require('internal/process/pre_execution');\n\nprepareMainThreadExecution(true);\n\nmarkBootstrapComplete();\n\n// Necessary to reset RegExp statics before user code runs.\nRegExpPrototypeExec(/^/\x2C '');\n\n// Note: this loads the module through the ESM loader if the module is\n// determined to be an ES module. This hangs from the CJS module loader\n// because we currently allow monkey-patching of the module loaders\n// in the preloaded scripts through require('module').\n// runMain here might be monkey-patched by users in --require.\n// XXX: the monkey-patchability here should probably be deprecated.\nrequire('internal/modules/cjs/loader').Module.runMain(process.argv[1]);\n
code-source-info,0x202f02876108,446,0,793,C0O0C4O793,,
code-creation,Function,10,43042,0x202f028761d0,81, node:internal/main/run_main_module:1:1,0x202f02876080,~
code-source-info,0x202f028761d0,446,0,793,C0O23C5O128C8O128C13O71C18O101C23O172C25O172C29O207C32O293C40O293C45O721C48O721C53O759C58O766C63O783C70O787C74O767C80O792,,
tick,0x195a4a050,43250,0,0x0,6
code-creation,Eval,10,43417,0x202f02877358,5, node:internal/process/pre_execution:1:1,0x202f02876f00,~
script-source,447,node:internal/process/pre_execution,'use strict';\n\nconst {\n  NumberParseInt\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  StringPrototypeStartsWith\x2C\n  globalThis\x2C\n} = primordials;\n\nconst {\n  getOptionValue\x2C\n  getEmbedderOptions\x2C\n  refreshOptions\x2C\n} = require('internal/options');\nconst { reconnectZeroFillToggle } = require('internal/buffer');\nconst {\n  defineOperation\x2C\n  exposeInterface\x2C\n  setupCoverageHooks\x2C\n} = require('internal/util');\n\nconst {\n  ERR_MANIFEST_ASSERT_INTEGRITY\x2C\n} = require('internal/errors').codes;\nconst assert = require('internal/assert');\n\nconst {\n  addSerializeCallback\x2C\n  isBuildingSnapshot\x2C\n} = require('v8').startupSnapshot;\n\nfunction prepareMainThreadExecution(expandArgv1 = false\x2C initializeModules = true) {\n  prepareExecution({\n    expandArgv1\x2C\n    initializeModules\x2C\n    isMainThread: true\x2C\n  });\n}\n\nfunction prepareWorkerThreadExecution() {\n  prepareExecution({\n    expandArgv1: false\x2C\n    initializeModules: false\x2C  // Will need to initialize it after policy setup\n    isMainThread: false\x2C\n  });\n}\n\nfunction prepareExecution(options) {\n  const { expandArgv1\x2C initializeModules\x2C isMainThread } = options;\n\n  refreshRuntimeOptions();\n  reconnectZeroFillToggle();\n\n  // Patch the process object with legacy properties and normalizations\n  patchProcessObject(expandArgv1);\n  setupTraceCategoryState();\n  setupPerfHooks();\n  setupInspectorHooks();\n  setupWarningHandler();\n  setupFetch();\n  setupWebCrypto();\n  setupCustomEvent();\n  setupCodeCoverage();\n  setupDebugEnv();\n  // Process initial diagnostic reporting configuration\x2C if present.\n  initializeReport();\n  initializeSourceMapsHandlers();\n  initializeDeprecations();\n  require('internal/dns/utils').initializeDns();\n\n  if (isMainThread) {\n    assert(internalBinding('worker').isMainThread);\n    // Worker threads will get the manifest in the message handler.\n    const policy = readPolicyFromDisk();\n    if (policy) {\n      require('internal/process/policy')\n        .setup(policy.manifestSrc\x2C policy.manifestURL);\n    }\n\n    // Print stack trace on `SIGINT` if option `--trace-sigint` presents.\n    setupStacktracePrinterOnSigint();\n    initializeReportSignalHandlers();  // Main-thread-only.\n    initializeHeapSnapshotSignalHandlers();\n    // If the process is spawned with env NODE_CHANNEL_FD\x2C it's probably\n    // spawned by our child_process module\x2C then initialize IPC.\n    // This attaches some internal event listeners and creates:\n    // process.send()\x2C process.channel\x2C process.connected\x2C\n    // process.disconnect().\n    setupChildProcessIpcChannel();\n    // If this is a worker in cluster mode\x2C start up the communication\n    // channel. This needs to be done before any user code gets executed\n    // (including preload modules).\n    initializeClusterIPC();\n\n    // TODO(joyeecheung): do this for worker threads as well.\n    require('internal/v8/startup_snapshot').runDeserializeCallbacks();\n  } else {\n    assert(!internalBinding('worker').isMainThread);\n    // The setup should be called in LOAD_SCRIPT message handler.\n    assert(!initializeModules);\n  }\n\n  if (initializeModules) {\n    setupUserModules();\n  }\n}\n\nfunction setupUserModules() {\n  initializeCJSLoader();\n  initializeESMLoader();\n  const CJSLoader = require('internal/modules/cjs/loader');\n  assert(!CJSLoader.hasLoadedAnyUserCJSModule);\n  loadPreloadModules();\n  // Need to be done after --require setup.\n  initializeFrozenIntrinsics();\n}\n\nfunction refreshRuntimeOptions() {\n  refreshOptions();\n}\n\nfunction patchProcessObject(expandArgv1) {\n  const binding = internalBinding('process_methods');\n  binding.patchProcessObject(process);\n\n  require('internal/process/per_thread').refreshHrtimeBuffer();\n\n  ObjectDefineProperty(process\x2C 'argv0'\x2C {\n    __proto__: null\x2C\n    enumerable: true\x2C\n    // Only set it to true during snapshot building.\n    configurable: getOptionValue('--build-snapshot')\x2C\n    value: process.argv[0]\x2C\n  });\n\n  process.exitCode = undefined;\n  process._exiting = false;\n  process.argv[0] = process.execPath;\n\n  if (expandArgv1 && process.argv[1] &&\n      !StringPrototypeStartsWith(process.argv[1]\x2C '-')) {\n    // Expand process.argv[1] into a full path.\n    const path = require('path');\n    try {\n      process.argv[1] = path.resolve(process.argv[1]);\n    } catch {\n      // Continue regardless of error.\n    }\n  }\n\n  // We need to initialize the global console here again with process.stdout\n  // and friends for snapshot deserialization.\n  const globalConsole = require('internal/console/global');\n  const { initializeGlobalConsole } = require('internal/console/constructor');\n  initializeGlobalConsole(globalConsole);\n\n  // TODO(joyeecheung): most of these should be deprecated and removed\x2C\n  // except some that we need to be able to mutate during run time.\n  addReadOnlyProcessAlias('_eval'\x2C '--eval');\n  addReadOnlyProcessAlias('_print_eval'\x2C '--print');\n  addReadOnlyProcessAlias('_syntax_check_only'\x2C '--check');\n  addReadOnlyProcessAlias('_forceRepl'\x2C '--interactive');\n  addReadOnlyProcessAlias('_preload_modules'\x2C '--require');\n  addReadOnlyProcessAlias('noDeprecation'\x2C '--no-deprecation');\n  addReadOnlyProcessAlias('noProcessWarnings'\x2C '--no-warnings');\n  addReadOnlyProcessAlias('traceProcessWarnings'\x2C '--trace-warnings');\n  addReadOnlyProcessAlias('throwDeprecation'\x2C '--throw-deprecation');\n  addReadOnlyProcessAlias('profProcess'\x2C '--prof-process');\n  addReadOnlyProcessAlias('traceDeprecation'\x2C '--trace-deprecation');\n  addReadOnlyProcessAlias('_breakFirstLine'\x2C '--inspect-brk'\x2C false);\n  addReadOnlyProcessAlias('_breakNodeFirstLine'\x2C '--inspect-brk-node'\x2C false);\n}\n\nfunction addReadOnlyProcessAlias(name\x2C option\x2C enumerable = true) {\n  const value = getOptionValue(option);\n  if (value) {\n    ObjectDefineProperty(process\x2C name\x2C {\n      __proto__: null\x2C\n      writable: false\x2C\n      configurable: true\x2C\n      enumerable\x2C\n      value\x2C\n    });\n  }\n}\n\nfunction setupWarningHandler() {\n  const {\n    onWarning\x2C\n    resetForSerialization\x2C\n  } = require('internal/process/warning');\n  if (getOptionValue('--warnings') &&\n    process.env.NODE_NO_WARNINGS !== '1') {\n    process.on('warning'\x2C onWarning);\n\n    // The code above would add the listener back during deserialization\x2C\n    // if applicable.\n    if (isBuildingSnapshot()) {\n      addSerializeCallback(() => {\n        process.removeListener('warning'\x2C onWarning);\n        resetForSerialization();\n      });\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/\nfunction setupFetch() {\n  if (process.config.variables.node_no_browser_globals ||\n      getOptionValue('--no-experimental-fetch')) {\n    return;\n  }\n\n  let undici;\n  function lazyUndici() {\n    if (undici) {\n      return undici;\n    }\n\n    undici = require('internal/deps/undici/undici');\n    return undici;\n  }\n\n  async function fetch(input\x2C init = undefined) {\n    return lazyUndici().fetch(input\x2C init);\n  }\n\n  defineOperation(globalThis\x2C 'fetch'\x2C fetch);\n\n  function lazyInterface(name) {\n    return {\n      configurable: true\x2C\n      enumerable: false\x2C\n      get() {\n        return lazyUndici()[name];\n      }\x2C\n      set(value) {\n        exposeInterface(globalThis\x2C name\x2C value);\n      }\x2C\n    };\n  }\n\n  ObjectDefineProperties(globalThis\x2C {\n    FormData: lazyInterface('FormData')\x2C\n    Headers: lazyInterface('Headers')\x2C\n    Request: lazyInterface('Request')\x2C\n    Response: lazyInterface('Response')\x2C\n  });\n\n  // The WebAssembly Web API: https://webassembly.github.io/spec/web-api\n  const { wasmStreamingCallback } = require('internal/wasm_web_api');\n  internalBinding('wasm_web_api').setImplementation(wasmStreamingCallback);\n}\n\n// TODO(aduh95): move this to internal/bootstrap/browser when the CLI flag is\n//               removed.\nfunction setupWebCrypto() {\n  if (process.config.variables.node_no_browser_globals ||\n      !getOptionValue('--experimental-global-webcrypto')) {\n    return;\n  }\n\n  let webcrypto;\n  ObjectDefineProperty(globalThis\x2C 'crypto'\x2C\n                       { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor({\n                         get crypto() {\n                           webcrypto ??= require('internal/crypto/webcrypto');\n                           return webcrypto.crypto;\n                         }\x2C\n                       }\x2C 'crypto') });\n  if (internalBinding('config').hasOpenSSL) {\n    webcrypto ??= require('internal/crypto/webcrypto');\n    exposeInterface(globalThis\x2C 'Crypto'\x2C webcrypto.Crypto);\n    exposeInterface(globalThis\x2C 'CryptoKey'\x2C webcrypto.CryptoKey);\n    exposeInterface(globalThis\x2C 'SubtleCrypto'\x2C webcrypto.SubtleCrypto);\n  }\n}\n\nfunction setupCodeCoverage() {\n  // Resolve the coverage directory to an absolute path\x2C and\n  // overwrite process.env so that the original path gets passed\n  // to child processes even when they switch cwd. Don't do anything if the\n  // --experimental-test-coverage flag is present\x2C as the test runner will\n  // handle coverage.\n  if (process.env.NODE_V8_COVERAGE &&\n      !getOptionValue('--experimental-test-coverage')) {\n    process.env.NODE_V8_COVERAGE =\n      setupCoverageHooks(process.env.NODE_V8_COVERAGE);\n  }\n}\n\n// TODO(daeyeon): move this to internal/bootstrap/browser when the CLI flag is\n//                removed.\nfunction setupCustomEvent() {\n  if (process.config.variables.node_no_browser_globals ||\n      !getOptionValue('--experimental-global-customevent')) {\n    return;\n  }\n  const { CustomEvent } = require('internal/event_target');\n  exposeInterface(globalThis\x2C 'CustomEvent'\x2C CustomEvent);\n}\n\nfunction setupStacktracePrinterOnSigint() {\n  if (!getOptionValue('--trace-sigint')) {\n    return;\n  }\n  const { SigintWatchdog } = require('internal/watchdog');\n\n  const watchdog = new SigintWatchdog();\n  watchdog.start();\n}\n\nfunction initializeReport() {\n  const { report } = require('internal/process/report');\n  ObjectDefineProperty(process\x2C 'report'\x2C {\n    __proto__: null\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    get() {\n      return report;\n    }\x2C\n  });\n}\n\nfunction setupDebugEnv() {\n  require('internal/util/debuglog').initializeDebugEnv(process.env.NODE_DEBUG);\n  if (getOptionValue('--expose-internals')) {\n    require('internal/bootstrap/loaders').BuiltinModule.exposeInternals();\n  }\n}\n\n// This has to be called after initializeReport() is called\nfunction initializeReportSignalHandlers() {\n  const { addSignalHandler } = require('internal/process/report');\n\n  addSignalHandler();\n}\n\nfunction initializeHeapSnapshotSignalHandlers() {\n  const signal = getOptionValue('--heapsnapshot-signal');\n\n  if (!signal)\n    return;\n\n  require('internal/validators').validateSignalName(signal);\n  const { writeHeapSnapshot } = require('v8');\n\n  function doWriteHeapSnapshot() {\n    writeHeapSnapshot();\n  }\n  process.on(signal\x2C doWriteHeapSnapshot);\n\n  // The code above would add the listener back during deserialization\x2C\n  // if applicable.\n  if (isBuildingSnapshot()) {\n    addSerializeCallback(() => {\n      process.removeListener(signal\x2C doWriteHeapSnapshot);\n    });\n  }\n}\n\nfunction setupTraceCategoryState() {\n  const { isTraceCategoryEnabled } = internalBinding('trace_events');\n  const { toggleTraceCategoryState } = require('internal/process/per_thread');\n  toggleTraceCategoryState(isTraceCategoryEnabled('node.async_hooks'));\n}\n\nfunction setupPerfHooks() {\n  require('internal/perf/performance').refreshTimeOrigin();\n  require('internal/perf/utils').refreshTimeOrigin();\n}\n\nfunction setupInspectorHooks() {\n  // If Debugger.setAsyncCallStackDepth is sent during bootstrap\x2C\n  // we cannot immediately call into JS to enable the hooks\x2C which could\n  // interrupt the JS execution of bootstrap. So instead we save the\n  // notification in the inspector agent if it's sent in the middle of\n  // bootstrap\x2C and process the notification later here.\n  if (internalBinding('config').hasInspector) {\n    const {\n      enable\x2C\n      disable\x2C\n    } = require('internal/inspector_async_hook');\n    internalBinding('inspector').registerAsyncHook(enable\x2C disable);\n  }\n}\n\n// In general deprecations are initialized wherever the APIs are implemented\x2C\n// this is used to deprecate APIs implemented in C++ where the deprecation\n// utilities are not easily accessible.\nfunction initializeDeprecations() {\n  const { deprecate } = require('internal/util');\n  const pendingDeprecation = getOptionValue('--pending-deprecation');\n\n  // DEP0103: access to `process.binding('util').isX` type checkers\n  // TODO(addaleax): Turn into a full runtime deprecation.\n  const utilBinding = internalBinding('util');\n  const types = require('internal/util/types');\n  for (const name of [\n    'isArrayBuffer'\x2C\n    'isArrayBufferView'\x2C\n    'isAsyncFunction'\x2C\n    'isDataView'\x2C\n    'isDate'\x2C\n    'isExternal'\x2C\n    'isMap'\x2C\n    'isMapIterator'\x2C\n    'isNativeError'\x2C\n    'isPromise'\x2C\n    'isRegExp'\x2C\n    'isSet'\x2C\n    'isSetIterator'\x2C\n    'isTypedArray'\x2C\n    'isUint8Array'\x2C\n    'isAnyArrayBuffer'\x2C\n  ]) {\n    utilBinding[name] = pendingDeprecation ?\n      deprecate(types[name]\x2C\n                'Accessing native typechecking bindings of Node ' +\n                'directly is deprecated. ' +\n                `Please use \\`util.types.${name}\\` instead.`\x2C\n                'DEP0103') :\n      types[name];\n  }\n\n  // TODO(joyeecheung): this is a legacy property exposed to process.\n  // Now that we use the config binding to carry this information\x2C remove\n  // it from the process. We may consider exposing it properly in\n  // process.features.\n  const { noBrowserGlobals } = internalBinding('config');\n  if (noBrowserGlobals) {\n    ObjectDefineProperty(process\x2C '_noBrowserGlobals'\x2C {\n      __proto__: null\x2C\n      writable: false\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      value: noBrowserGlobals\x2C\n    });\n  }\n\n  if (pendingDeprecation) {\n    process.binding = deprecate(process.binding\x2C\n                                'process.binding() is deprecated. ' +\n                                'Please use public APIs instead.'\x2C 'DEP0111');\n\n    process._tickCallback = deprecate(process._tickCallback\x2C\n                                      'process._tickCallback() is deprecated'\x2C\n                                      'DEP0134');\n  }\n}\n\nfunction setupChildProcessIpcChannel() {\n  if (process.env.NODE_CHANNEL_FD) {\n    const assert = require('internal/assert');\n\n    const fd = NumberParseInt(process.env.NODE_CHANNEL_FD\x2C 10);\n    assert(fd >= 0);\n\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_CHANNEL_FD;\n\n    const serializationMode =\n      process.env.NODE_CHANNEL_SERIALIZATION_MODE || 'json';\n    delete process.env.NODE_CHANNEL_SERIALIZATION_MODE;\n\n    require('child_process')._forkChild(fd\x2C serializationMode);\n    assert(process.send);\n  }\n}\n\nfunction initializeClusterIPC() {\n  if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n    const cluster = require('cluster');\n    cluster._setupWorker();\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_UNIQUE_ID;\n  }\n}\n\nfunction readPolicyFromDisk() {\n  const experimentalPolicy = getOptionValue('--experimental-policy');\n  if (experimentalPolicy) {\n    process.emitWarning('Policies are experimental.'\x2C\n                        'ExperimentalWarning');\n    const { pathToFileURL\x2C URL } = require('internal/url');\n    // URL here as it is slightly different parsing\n    // no bare specifiers for now\n    let manifestURL;\n    if (require('path').isAbsolute(experimentalPolicy)) {\n      manifestURL = new URL(`file://${experimentalPolicy}`);\n    } else {\n      const cwdURL = pathToFileURL(process.cwd());\n      cwdURL.pathname += '/';\n      manifestURL = new URL(experimentalPolicy\x2C cwdURL);\n    }\n    const fs = require('fs');\n    const src = fs.readFileSync(manifestURL\x2C 'utf8');\n    const experimentalPolicyIntegrity = getOptionValue('--policy-integrity');\n    if (experimentalPolicyIntegrity) {\n      const SRI = require('internal/policy/sri');\n      const { createHash\x2C timingSafeEqual } = require('crypto');\n      const realIntegrities = new SafeMap();\n      const integrityEntries = SRI.parse(experimentalPolicyIntegrity);\n      let foundMatch = false;\n      for (let i = 0; i < integrityEntries.length; i++) {\n        const {\n          algorithm\x2C\n          value: expected\x2C\n        } = integrityEntries[i];\n        const hash = createHash(algorithm);\n        hash.update(src);\n        const digest = hash.digest();\n        if (digest.length === expected.length &&\n          timingSafeEqual(digest\x2C expected)) {\n          foundMatch = true;\n          break;\n        }\n        realIntegrities.set(algorithm\x2C digest.toString('base64'));\n      }\n      if (!foundMatch) {\n        throw new ERR_MANIFEST_ASSERT_INTEGRITY(manifestURL\x2C realIntegrities);\n      }\n    }\n    return {\n      manifestSrc: src\x2C manifestURL: manifestURL.href\x2C\n    };\n  }\n}\n\nfunction initializeCJSLoader() {\n  const CJSLoader = require('internal/modules/cjs/loader');\n  if (!getEmbedderOptions().noGlobalSearchPaths) {\n    CJSLoader.Module._initPaths();\n  }\n  // TODO(joyeecheung): deprecate this in favor of a proper hook?\n  CJSLoader.Module.runMain =\n    require('internal/modules/run_main').executeUserEntryPoint;\n}\n\nfunction initializeESMLoader() {\n  // Create this WeakMap in js-land because V8 has no C++ API for WeakMap.\n  internalBinding('module_wrap').callbackMap = new SafeWeakMap();\n\n  if (getEmbedderOptions().shouldNotRegisterESMLoader) return;\n\n  const {\n    setImportModuleDynamicallyCallback\x2C\n    setInitializeImportMetaObjectCallback\x2C\n  } = internalBinding('module_wrap');\n  const esm = require('internal/process/esm_loader');\n  // Setup per-isolate callbacks that locate data or callbacks that we keep\n  // track of for different ESM modules.\n  setInitializeImportMetaObjectCallback(esm.initializeImportMetaObject);\n  setImportModuleDynamicallyCallback(esm.importModuleDynamicallyCallback);\n\n  // Patch the vm module when --experimental-vm-modules is on.\n  // Please update the comments in vm.js when this block changes.\n  if (getOptionValue('--experimental-vm-modules')) {\n    const {\n      Module\x2C SourceTextModule\x2C SyntheticModule\x2C\n    } = require('internal/vm/module');\n    const vm = require('vm');\n    vm.Module = Module;\n    vm.SourceTextModule = SourceTextModule;\n    vm.SyntheticModule = SyntheticModule;\n  }\n}\n\nfunction initializeSourceMapsHandlers() {\n  const { setSourceMapsEnabled\x2C getSourceMapsEnabled } =\n    require('internal/source_map/source_map_cache');\n  process.setSourceMapsEnabled = setSourceMapsEnabled;\n  // Initialize the environment flag of source maps.\n  getSourceMapsEnabled();\n}\n\nfunction initializeFrozenIntrinsics() {\n  if (getOptionValue('--frozen-intrinsics')) {\n    process.emitWarning('The --frozen-intrinsics flag is experimental'\x2C\n                        'ExperimentalWarning');\n    require('internal/freeze_intrinsics')();\n  }\n}\n\nfunction loadPreloadModules() {\n  // For user code\x2C we preload modules if `-r` is passed\n  const preloadModules = getOptionValue('--require');\n  if (preloadModules && preloadModules.length > 0) {\n    const {\n      Module: {\n        _preloadModules\x2C\n      }\x2C\n    } = require('internal/modules/cjs/loader');\n    _preloadModules(preloadModules);\n  }\n}\n\nfunction markBootstrapComplete() {\n  internalBinding('performance').markBootstrapComplete();\n}\n\nmodule.exports = {\n  setupUserModules\x2C\n  prepareMainThreadExecution\x2C\n  prepareWorkerThreadExecution\x2C\n  markBootstrapComplete\x2C\n};\n
code-source-info,0x202f02877358,447,0,19338,C0O0C4O19338,,
code-creation,Function,10,44584,0x202f02878058,473, node:internal/process/pre_execution:1:1,0x202f028772d0,~
code-source-info,0x202f02878058,447,0,19338,C0O0C251O25C257O43C263O69C269O93C275O127C281O138C287O153C293O182C299O282C305O282C310O222C316O240C322O262C328O347C334O347C339O319C345O447C351O447C356O385C362O404C368O423C374O519C380O519C385O545C390O484C396O568C402O568C406O568C408O655C414O655C419O668C424O607C430O631C436O19209C443O19230C449O19250C455O19280C461O19312C467O19224C472O19337,,
code-creation,LazyCompile,10,44750,0x202f02879db0,46,prepareMainThreadExecution node:internal/process/pre_execution:36:36,0x202f02877388,~
code-source-info,0x202f02879db0,447,722,864,C20O774C30O797C36O814C40O774C45O863,,
code-creation,LazyCompile,10,44834,0x202f0287b4b0,301,prepareExecution node:internal/process/pre_execution:52:26,0x202f02877428,~
code-source-info,0x202f0287b4b0,447,1092,3150,C0O1114C5O1127C10O1146C15O1175C18O1175C21O1202C26O1202C29O1304C32O1304C36O1339C39O1339C42O1368C45O1368C48O1388C51O1388C54O1413C57O1413C60O1438C63O1438C66O1454C69O1454C72O1474C75O1474C78O1496C81O1496C84O1519C87O1519C90O1607C93O1607C96O1629C99O1629C102O1663C105O1663C108O1691C114O1691C119O1720C124O1721C128O1741C132O1765C143O1772C148O1797C153O1765C157O1900C160O1900C164O1926C166O1946C172O1946C177O1989C182O2003C187O2023C192O1990C198O2122C201O2122C204O2160C207O2160C210O2220C213O2220C216O2554C219O2554C222O2769C225O2769C228O2860C234O2860C239O2899C244O2900C250O2942C261O2950C266O2975C272O2942C276O3061C283O3069C285O3061C289O3096C293O3125C296O3125C300O3149,,
code-creation,LazyCompile,10,44875,0x202f0287b790,10,refreshRuntimeOptions node:internal/process/pre_execution:122:31,0x202f028774c8,~
code-source-info,0x202f0287b790,447,3473,3499,C0O3480C5O3480C9O3498,,
code-creation,LazyCompile,10,44875,0x202f0287b880,22,refreshOptions node:internal/options:39:24,0x25dc1a859c40,~
script-source,88,node:internal/options,'use strict';\n\nconst {\n  getCLIOptions\x2C\n  getEmbedderOptions: getEmbedderOptionsFromBinding\x2C\n} = internalBinding('options');\n\nlet warnOnAllowUnauthorized = true;\n\nlet optionsMap;\nlet aliasesMap;\nlet embedderOptions;\n\n// getCLIOptions() would serialize the option values from C++ land.\n// It would error if the values are queried before bootstrap is\n// complete so that we don't accidentally include runtime-dependent\n// states into a runtime-independent snapshot.\nfunction getCLIOptionsFromBinding() {\n  if (!optionsMap) {\n    ({ options: optionsMap } = getCLIOptions());\n  }\n  return optionsMap;\n}\n\nfunction getAliasesFromBinding() {\n  if (!aliasesMap) {\n    ({ aliases: aliasesMap } = getCLIOptions());\n  }\n  return aliasesMap;\n}\n\nfunction getEmbedderOptions() {\n  if (!embedderOptions) {\n    embedderOptions = getEmbedderOptionsFromBinding();\n  }\n  return embedderOptions;\n}\n\nfunction refreshOptions() {\n  optionsMap = undefined;\n  aliasesMap = undefined;\n}\n\nfunction getOptionValue(optionName) {\n  const options = getCLIOptionsFromBinding();\n  if (optionName.startsWith('--no-')) {\n    const option = options.get('--' + optionName.slice(5));\n    return option && !option.value;\n  }\n  return options.get(optionName)?.value;\n}\n\nfunction getAllowUnauthorized() {\n  const allowUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0';\n\n  if (allowUnauthorized && warnOnAllowUnauthorized) {\n    warnOnAllowUnauthorized = false;\n    process.emitWarning(\n      'Setting the NODE_TLS_REJECT_UNAUTHORIZED ' +\n      'environment variable to \\'0\\' makes TLS connections ' +\n      'and HTTPS requests insecure by disabling ' +\n      'certificate verification.');\n  }\n  return allowUnauthorized;\n}\n\nmodule.exports = {\n  get options() {\n    return getCLIOptionsFromBinding();\n  }\x2C\n  get aliases() {\n    return getAliasesFromBinding();\n  }\x2C\n  getOptionValue\x2C\n  getAllowUnauthorized\x2C\n  getEmbedderOptions\x2C\n  refreshOptions\x2C\n};\n
code-source-info,0x202f0287b880,88,902,960,C0O909C4O920C10O935C14O946C21O959,,
code-creation,LazyCompile,10,45000,0x202f0287bbe8,19,reconnectZeroFillToggle node:internal/buffer:1074:33,0x35d29718c428,~
script-source,31,node:internal/buffer,'use strict';\n\nconst {\n  BigInt\x2C\n  Float32Array\x2C\n  Float64Array\x2C\n  MathFloor\x2C\n  Number\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  ERR_BUFFER_OUT_OF_BOUNDS\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_OUT_OF_RANGE\x2C\n} = require('internal/errors').codes;\nconst { validateNumber } = require('internal/validators');\nconst {\n  asciiSlice\x2C\n  base64Slice\x2C\n  base64urlSlice\x2C\n  latin1Slice\x2C\n  hexSlice\x2C\n  ucs2Slice\x2C\n  utf8Slice\x2C\n  asciiWrite\x2C\n  base64Write\x2C\n  base64urlWrite\x2C\n  latin1Write\x2C\n  hexWrite\x2C\n  ucs2Write\x2C\n  utf8Write\x2C\n  getZeroFillToggle\x2C\n} = internalBinding('buffer');\n\nconst {\n  privateSymbols: {\n    untransferable_object_private_symbol\x2C\n  }\x2C\n} = internalBinding('util');\n\n// Temporary buffers to convert numbers.\nconst float32Array = new Float32Array(1);\nconst uInt8Float32Array = new Uint8Array(float32Array.buffer);\nconst float64Array = new Float64Array(1);\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer);\n\n// Check endianness.\nfloat32Array[0] = -1; // 0xBF800000\n// Either it is [0\x2C 0\x2C 128\x2C 191] or [191\x2C 128\x2C 0\x2C 0]. It is not possible to\n// check this with `os.endianness()` because that is determined at compile time.\nconst bigEndian = uInt8Float32Array[3] === 0;\n\nfunction checkBounds(buf\x2C offset\x2C byteLength) {\n  validateNumber(offset\x2C 'offset');\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined)\n    boundsError(offset\x2C buf.length - (byteLength + 1));\n}\n\nfunction checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : '';\n    let range;\n    if (byteLength > 3) {\n      if (min === 0 || min === 0n) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` +\n                `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`;\n    }\n    throw new ERR_OUT_OF_RANGE('value'\x2C range\x2C value);\n  }\n  checkBounds(buf\x2C offset\x2C byteLength);\n}\n\nfunction boundsError(value\x2C length\x2C type) {\n  if (MathFloor(value) !== value) {\n    validateNumber(value\x2C type);\n    throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C 'an integer'\x2C value);\n  }\n\n  if (length < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n  throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C\n                             `>= ${type ? 1 : 0} and <= ${length}`\x2C\n                             value);\n}\n\n// Read integers.\nfunction readBigUInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24;\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n\n  return BigInt(lo) + (BigInt(hi) << 32n);\n}\n\nfunction readBigUInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n\n  return (BigInt(hi) << 32n) + BigInt(lo);\n}\n\nfunction readBigInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24); // Overflow\n  return (BigInt(val) << 32n) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24);\n}\n\nfunction readBigInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n  return (BigInt(val) << 32n) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last);\n}\n\nfunction readUIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32LE(offset);\n  if (byteLength === 2)\n    return this.readUInt16LE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    (buf[++offset] + last * 2 ** 8) * 2 ** 32;\n}\n\nfunction readUInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    last * 2 ** 32;\n}\n\nfunction readUInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n}\n\nfunction readUInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n}\n\nfunction readUInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first + last * 2 ** 8;\n}\n\nfunction readUInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val;\n}\n\nfunction readUIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32BE(offset);\n  if (byteLength === 2)\n    return this.readUInt16BE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n}\n\nfunction readUInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first * 2 ** 8 + last;\n}\n\nfunction readIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32LE(offset);\n  if (byteLength === 2)\n    return this.readInt16LE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[offset + 4] + last * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    (last << 24); // Overflow\n}\n\nfunction readInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first + last * 2 ** 8;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\nfunction readInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val | (val & 2 ** 7) * 0x1fffffe;\n}\n\nfunction readIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32BE(offset);\n  if (byteLength === 2)\n    return this.readInt16BE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[++offset] + first * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first * 2 ** 8 + last;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\n// Read floats\nfunction readFloatBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[3] = first;\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[0] = last;\n  return float32Array[0];\n}\n\nfunction readFloatForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[0] = first;\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[3] = last;\n  return float32Array[0];\n}\n\nfunction readDoubleBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[7] = first;\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[0] = last;\n  return float64Array[0];\n}\n\nfunction readDoubleForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[0] = first;\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[7] = last;\n  return float64Array[0];\n}\n\n// Write integers.\nfunction writeBigU_Int64LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  return offset;\n}\n\nfunction writeBigUInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigU_Int64BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset + 7] = lo;\n  lo = lo >> 8;\n  buf[offset + 6] = lo;\n  lo = lo >> 8;\n  buf[offset + 5] = lo;\n  lo = lo >> 8;\n  buf[offset + 4] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset + 3] = hi;\n  hi = hi >> 8;\n  buf[offset + 2] = hi;\n  hi = hi >> 8;\n  buf[offset + 1] = hi;\n  hi = hi >> 8;\n  buf[offset] = hi;\n  return offset + 8;\n}\n\nfunction writeBigUInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeBigInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeUIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = newVal;\n  buf[offset++] = (newVal >>> 8);\n  return offset;\n}\n\nfunction writeU_Int40LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  const newVal = value;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = MathFloor(newVal * 2 ** -32);\n  return offset;\n}\n\nfunction writeU_Int32LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeU_Int16LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = value;\n  buf[offset++] = (value >>> 8);\n  return offset;\n}\n\nfunction writeUInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeU_Int8(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  // `checkInt()` can not be used here because it checks two entries.\n  validateNumber(offset\x2C 'offset');\n  if (value > max || value < min) {\n    throw new ERR_OUT_OF_RANGE('value'\x2C `>= ${min} and <= ${max}`\x2C value);\n  }\n  if (buf[offset] === undefined)\n    boundsError(offset\x2C buf.length - 1);\n\n  buf[offset] = value;\n  return offset + 1;\n}\n\nfunction writeUInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n}\n\nfunction writeUIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = (newVal >>> 8);\n  buf[offset++] = newVal;\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int40BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  buf[offset++] = MathFloor(value * 2 ** -32);\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int32BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeUInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 3;\n}\n\nfunction writeU_Int16BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = (value >>> 8);\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\nfunction writeInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n}\n\nfunction writeIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\n// Write floats.\nfunction writeDoubleForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[0];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[7];\n  return offset;\n}\n\nfunction writeDoubleBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[7];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[0];\n  return offset;\n}\n\nfunction writeFloatForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[0];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[3];\n  return offset;\n}\n\nfunction writeFloatBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[3];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[0];\n  return offset;\n}\n\nclass FastBuffer extends Uint8Array {\n  // Using an explicit constructor here is necessary to avoid relying on\n  // `Array.prototype[Symbol.iterator]`\x2C which can be mutated by users.\n  // eslint-disable-next-line no-useless-constructor\n  constructor(bufferOrLength\x2C byteOffset\x2C length) {\n    super(bufferOrLength\x2C byteOffset\x2C length);\n  }\n}\n\nfunction addBufferPrototypeMethods(proto) {\n  proto.readBigUInt64LE = readBigUInt64LE;\n  proto.readBigUInt64BE = readBigUInt64BE;\n  proto.readBigUint64LE = readBigUInt64LE;\n  proto.readBigUint64BE = readBigUInt64BE;\n  proto.readBigInt64LE = readBigInt64LE;\n  proto.readBigInt64BE = readBigInt64BE;\n  proto.writeBigUInt64LE = writeBigUInt64LE;\n  proto.writeBigUInt64BE = writeBigUInt64BE;\n  proto.writeBigUint64LE = writeBigUInt64LE;\n  proto.writeBigUint64BE = writeBigUInt64BE;\n  proto.writeBigInt64LE = writeBigInt64LE;\n  proto.writeBigInt64BE = writeBigInt64BE;\n\n  proto.readUIntLE = readUIntLE;\n  proto.readUInt32LE = readUInt32LE;\n  proto.readUInt16LE = readUInt16LE;\n  proto.readUInt8 = readUInt8;\n  proto.readUIntBE = readUIntBE;\n  proto.readUInt32BE = readUInt32BE;\n  proto.readUInt16BE = readUInt16BE;\n  proto.readUintLE = readUIntLE;\n  proto.readUint32LE = readUInt32LE;\n  proto.readUint16LE = readUInt16LE;\n  proto.readUint8 = readUInt8;\n  proto.readUintBE = readUIntBE;\n  proto.readUint32BE = readUInt32BE;\n  proto.readUint16BE = readUInt16BE;\n  proto.readIntLE = readIntLE;\n  proto.readInt32LE = readInt32LE;\n  proto.readInt16LE = readInt16LE;\n  proto.readInt8 = readInt8;\n  proto.readIntBE = readIntBE;\n  proto.readInt32BE = readInt32BE;\n  proto.readInt16BE = readInt16BE;\n\n  proto.writeUIntLE = writeUIntLE;\n  proto.writeUInt32LE = writeUInt32LE;\n  proto.writeUInt16LE = writeUInt16LE;\n  proto.writeUInt8 = writeUInt8;\n  proto.writeUIntBE = writeUIntBE;\n  proto.writeUInt32BE = writeUInt32BE;\n  proto.writeUInt16BE = writeUInt16BE;\n  proto.writeUintLE = writeUIntLE;\n  proto.writeUint32LE = writeUInt32LE;\n  proto.writeUint16LE = writeUInt16LE;\n  proto.writeUint8 = writeUInt8;\n  proto.writeUintBE = writeUIntBE;\n  proto.writeUint32BE = writeUInt32BE;\n  proto.writeUint16BE = writeUInt16BE;\n  proto.writeIntLE = writeIntLE;\n  proto.writeInt32LE = writeInt32LE;\n  proto.writeInt16LE = writeInt16LE;\n  proto.writeInt8 = writeInt8;\n  proto.writeIntBE = writeIntBE;\n  proto.writeInt32BE = writeInt32BE;\n  proto.writeInt16BE = writeInt16BE;\n\n  proto.readFloatLE = bigEndian ? readFloatBackwards : readFloatForwards;\n  proto.readFloatBE = bigEndian ? readFloatForwards : readFloatBackwards;\n  proto.readDoubleLE = bigEndian ? readDoubleBackwards : readDoubleForwards;\n  proto.readDoubleBE = bigEndian ? readDoubleForwards : readDoubleBackwards;\n  proto.writeFloatLE = bigEndian ? writeFloatBackwards : writeFloatForwards;\n  proto.writeFloatBE = bigEndian ? writeFloatForwards : writeFloatBackwards;\n  proto.writeDoubleLE = bigEndian ? writeDoubleBackwards : writeDoubleForwards;\n  proto.writeDoubleBE = bigEndian ? writeDoubleForwards : writeDoubleBackwards;\n\n  proto.asciiSlice = asciiSlice;\n  proto.base64Slice = base64Slice;\n  proto.base64urlSlice = base64urlSlice;\n  proto.latin1Slice = latin1Slice;\n  proto.hexSlice = hexSlice;\n  proto.ucs2Slice = ucs2Slice;\n  proto.utf8Slice = utf8Slice;\n  proto.asciiWrite = asciiWrite;\n  proto.base64Write = base64Write;\n  proto.base64urlWrite = base64urlWrite;\n  proto.latin1Write = latin1Write;\n  proto.hexWrite = hexWrite;\n  proto.ucs2Write = ucs2Write;\n  proto.utf8Write = utf8Write;\n}\n\n// This would better be placed in internal/worker/io.js\x2C but that doesn't work\n// because Buffer needs this and that would introduce a cyclic dependency.\nfunction markAsUntransferable(obj) {\n  if ((typeof obj !== 'object' && typeof obj !== 'function') || obj === null)\n    return;  // This object is a primitive and therefore already untransferable.\n  obj[untransferable_object_private_symbol] = true;\n}\n\n// A toggle used to access the zero fill setting of the array buffer allocator\n// in C++.\n// |zeroFill| can be undefined when running inside an isolate where we\n// do not own the ArrayBuffer allocator.  Zero fill is always on in that case.\nlet zeroFill = getZeroFillToggle();\nfunction createUnsafeBuffer(size) {\n  zeroFill[0] = 0;\n  try {\n    return new FastBuffer(size);\n  } finally {\n    zeroFill[0] = 1;\n  }\n}\n\n// The connection between the JS land zero fill toggle and the\n// C++ one in the NodeArrayBufferAllocator gets lost if the toggle\n// is deserialized from the snapshot\x2C because V8 owns the underlying\n// memory of this toggle. This resets the connection.\nfunction reconnectZeroFillToggle() {\n  zeroFill = getZeroFillToggle();\n}\n\nmodule.exports = {\n  FastBuffer\x2C\n  addBufferPrototypeMethods\x2C\n  markAsUntransferable\x2C\n  createUnsafeBuffer\x2C\n  readUInt16BE\x2C\n  readUInt32BE\x2C\n  reconnectZeroFillToggle\x2C\n};\n
code-source-info,0x202f0287bbe8,31,30714,30754,C0O30721C5O30732C11O30730C18O30753,,
code-creation,LazyCompile,10,46542,0x202f0287e4e8,460,patchProcessObject node:internal/process/pre_execution:126:28,0x202f02877518,~
code-source-info,0x202f0287e4e8,447,3528,5612,C0O3562C6O3562C11O3608C19O3608C24O3640C30O3640C35O3678C40O3679C44O3705C55O3726C62O3860C68O3860C79O3915C85O3919C92O3705C97O3933C101O3950C105O3965C109O3982C113O3993C116O4001C126O4019C130O4009C134O4032C141O4059C148O4063C155O4077C161O4111C168O4115C175O4077C182O4193C188O4193C196O4226C199O4234C207O4249C215O4265C222O4269C226O4249C231O4242C241O4487C247O4487C252O4561C258O4561C263O4533C268O4604C272O4787C281O4787C286O4833C295O4833C300O4886C309O4886C314O4946C323O4946C328O5004C337O5004C342O5064C351O5064C356O5128C365O5128C370O5193C379O5193C384O5264C393O5264C398O5334C407O5334C412O5394C421O5394C426O5464C437O5464C442O5534C453O5534C459O5611,,
code-creation,LazyCompile,10,46625,0x202f0287ea48,82,getOptionValue node:internal/options:44:24,0x25dc1a859c90,~
code-source-info,0x202f0287ea48,88,985,1228,C0O1018C3O1018C7O1063C15O1063C22O1113C30O1135C38O1135C43O1122C47O1113C53O1150C55O1175C60O1181C61O1203C66O1203C74O1218C81O1226,,
code-creation,LazyCompile,10,46667,0x202f0287eba8,33,getCLIOptionsFromBinding node:internal/options:18:34,0x25dc1a859a78,~
code-source-info,0x202f0287eba8,88,497,598,C0O504C6O527C11O554C15O539C28O578C32O596,,
tick,0x100ab9244,46667,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x41ccf059307,0x202f028761d8
tick,0x19596ce58,46709,0,0x0,3,0x0,0x202f0287b4ca,0x202f02879dd8,0x202f028761e9
new,MemoryChunk,0x30e767700000,262144
code-creation,LazyCompile,10,46959,0x202f0287ed90,188,resolve node:path:1091:10,0x28e4ce8cd0d0,~
script-source,74,node:path,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n} = primordials;\n\nconst {\n  CHAR_UPPERCASE_A\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_UPPERCASE_Z\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_DOT\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\x2C\n  CHAR_QUESTION_MARK\x2C\n} = require('internal/constants');\nconst {\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst platformIsWin32 = (process.platform === 'win32');\n\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n  return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n         (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path\x2C allowAboveRoot\x2C separator\x2C isPathSeparator) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = StringPrototypeCharCodeAt(path\x2C i);\n    else if (isPathSeparator(code))\n      break;\n    else\n      code = CHAR_FORWARD_SLASH;\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 1) !== CHAR_DOT ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = StringPrototypeLastIndexOf(res\x2C separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = StringPrototypeSlice(res\x2C 0\x2C lastSlashIndex);\n              lastSegmentLength =\n                res.length - 1 - StringPrototypeLastIndexOf(res\x2C separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += `${separator}${StringPrototypeSlice(path\x2C lastSlash + 1\x2C i)}`;\n        else\n          res = StringPrototypeSlice(path\x2C lastSlash + 1\x2C i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\n/**\n * @param {string} sep\n * @param {{\n *  dir?: string;\n *  root?: string;\n *  base?: string;\n *  name?: string;\n *  ext?: string;\n *  }} pathObject\n * @returns {string}\n */\nfunction _format(sep\x2C pathObject) {\n  validateObject(pathObject\x2C 'pathObject');\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base ||\n    `${pathObject.name || ''}${pathObject.ext || ''}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nconst win32 = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedDevice = '';\n    let resolvedTail = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1; i--) {\n      let path;\n      if (i >= 0) {\n        path = args[i];\n        validateString(path\x2C `paths[${i}]`);\n\n        // Skip empty entries\n        if (path.length === 0) {\n          continue;\n        }\n      } else if (resolvedDevice.length === 0) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path\x2C get cwd for that drive\x2C or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points\x2C because UNC paths are always absolute.\n        path = process.env[`=${resolvedDevice}`] || process.cwd();\n\n        // Verify that a cwd was found and that it actually points\n        // to our drive. If not\x2C default to the drive's root.\n        if (path === undefined ||\n            (StringPrototypeToLowerCase(StringPrototypeSlice(path\x2C 0\x2C 2)) !==\n            StringPrototypeToLowerCase(resolvedDevice) &&\n            StringPrototypeCharCodeAt(path\x2C 2) === CHAR_BACKWARD_SLASH)) {\n          path = `${resolvedDevice}\\\\`;\n        }\n      }\n\n      const len = path.length;\n      let rootEnd = 0;\n      let device = '';\n      let isAbsolute = false;\n      const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n      // Try to match a root\n      if (len === 1) {\n        if (isPathSeparator(code)) {\n          // `path` contains just a path separator\n          rootEnd = 1;\n          isAbsolute = true;\n        }\n      } else if (isPathSeparator(code)) {\n        // Possible UNC root\n\n        // If we started with a separator\x2C we know we at least have an\n        // absolute path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n          // Matched double path separator at beginning\n          let j = 2;\n          let last = j;\n          // Match 1 or more non-path separators\n          while (j < len &&\n                 !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            while (j < len &&\n                   isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              while (j < len &&\n                     !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n                j++;\n              }\n              if (j === len || j !== last) {\n                // We matched a UNC root\n                device =\n                  `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code) &&\n                  StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n        // Possible device root\n        device = StringPrototypeSlice(path\x2C 0\x2C 2);\n        rootEnd = 2;\n        if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n          // Treat separator following drive name as an absolute path\n          // indicator\n          isAbsolute = true;\n          rootEnd = 3;\n        }\n      }\n\n      if (device.length > 0) {\n        if (resolvedDevice.length > 0) {\n          if (StringPrototypeToLowerCase(device) !==\n              StringPrototypeToLowerCase(resolvedDevice))\n            // This path points to another device so it is not applicable\n            continue;\n        } else {\n          resolvedDevice = device;\n        }\n      }\n\n      if (resolvedAbsolute) {\n        if (resolvedDevice.length > 0)\n          break;\n      } else {\n        resolvedTail =\n          `${StringPrototypeSlice(path\x2C rootEnd)}\\\\${resolvedTail}`;\n        resolvedAbsolute = isAbsolute;\n        if (isAbsolute && resolvedDevice.length > 0) {\n          break;\n        }\n      }\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n\n    // Normalize the tail path\n    resolvedTail = normalizeString(resolvedTail\x2C !resolvedAbsolute\x2C '\\\\'\x2C\n                                   isPathSeparator);\n\n    return resolvedAbsolute ?\n      `${resolvedDevice}\\\\${resolvedTail}` :\n      `${resolvedDevice}${resolvedTail}` || '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = 0;\n    let device;\n    let isAbsolute = false;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    // Try to match a root\n    if (len === 1) {\n      // `path` contains just a single char\x2C exit early to avoid\n      // unnecessary work\n      return isPosixPathSeparator(code) ? '\\\\' : path;\n    }\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      // If we started with a separator\x2C we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n              return `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last)}\\\\`;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n              device =\n                `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      device = StringPrototypeSlice(path\x2C 0\x2C 2);\n      rootEnd = 2;\n      if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        // Treat separator following drive name as an absolute path\n        // indicator\n        isAbsolute = true;\n        rootEnd = 3;\n      }\n    }\n\n    let tail = rootEnd < len ?\n      normalizeString(StringPrototypeSlice(path\x2C rootEnd)\x2C\n                      !isAbsolute\x2C '\\\\'\x2C isPathSeparator) :\n      '';\n    if (tail.length === 0 && !isAbsolute)\n      tail = '.';\n    if (tail.length > 0 &&\n        isPathSeparator(StringPrototypeCharCodeAt(path\x2C len - 1)))\n      tail += '\\\\';\n    if (device === undefined) {\n      return isAbsolute ? `\\\\${tail}` : tail;\n    }\n    return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return false;\n\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n    return isPathSeparator(code) ||\n      // Possible device root\n      (len > 2 &&\n      isWindowsDeviceRoot(code) &&\n      StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n      isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)));\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n\n    let joined;\n    let firstPart;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = firstPart = arg;\n        else\n          joined += `\\\\${arg}`;\n      }\n    }\n\n    if (joined === undefined)\n      return '.';\n\n    // Make sure that the joined path doesn't start with two slashes\x2C because\n    // normalize() will mistake it for a UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at a UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as a UNC path it needs to\n    // have at least 2 components\x2C so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server'\x2C 'share') -> '\\\\\\\\server\\\\share\\\\')\n    let needsReplace = true;\n    let slashCount = 0;\n    if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 0))) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen > 1 &&\n          isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 2)))\n            ++slashCount;\n          else {\n            // We matched a UNC path in the first part\n            needsReplace = false;\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      while (slashCount < joined.length &&\n             isPathSeparator(StringPrototypeCharCodeAt(joined\x2C slashCount))) {\n        slashCount++;\n      }\n\n      // Replace the slashes if needed\n      if (slashCount >= 2)\n        joined = `\\\\${StringPrototypeSlice(joined\x2C slashCount)}`;\n    }\n\n    return win32.normalize(joined);\n  }\x2C\n\n  /**\n   * It will solve the relative path from `from` to `to`\x2C for instance\n   * from = 'C:\\\\orandea\\\\test\\\\aaa'\n   * to = 'C:\\\\orandea\\\\impl\\\\bbb'\n   * The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    const fromOrig = win32.resolve(from);\n    const toOrig = win32.resolve(to);\n\n    if (fromOrig === toOrig)\n      return '';\n\n    from = StringPrototypeToLowerCase(fromOrig);\n    to = StringPrototypeToLowerCase(toOrig);\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    let fromStart = 0;\n    while (fromStart < from.length &&\n           StringPrototypeCharCodeAt(from\x2C fromStart) === CHAR_BACKWARD_SLASH) {\n      fromStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let fromEnd = from.length;\n    while (\n      fromEnd - 1 > fromStart &&\n      StringPrototypeCharCodeAt(from\x2C fromEnd - 1) === CHAR_BACKWARD_SLASH\n    ) {\n      fromEnd--;\n    }\n    const fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    let toStart = 0;\n    while (toStart < to.length &&\n           StringPrototypeCharCodeAt(to\x2C toStart) === CHAR_BACKWARD_SLASH) {\n      toStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let toEnd = to.length;\n    while (toEnd - 1 > toStart &&\n           StringPrototypeCharCodeAt(to\x2C toEnd - 1) === CHAR_BACKWARD_SLASH) {\n      toEnd--;\n    }\n    const toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_BACKWARD_SLASH)\n        lastCommonSep = i;\n    }\n\n    // We found a mismatch before the first common path separator was seen\x2C so\n    // return the original `to`.\n    if (i !== length) {\n      if (lastCommonSep === -1)\n        return toOrig;\n    } else {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n          return StringPrototypeSlice(toOrig\x2C toStart + i + 1);\n        }\n        if (i === 2) {\n          // We get here if `from` is the device root.\n          // For example: from='C:\\\\'; to='C:\\\\foo'\n          return StringPrototypeSlice(toOrig\x2C toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n          lastCommonSep = i;\n        } else if (i === 2) {\n          // We get here if `to` is the device root.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n          lastCommonSep = 3;\n        }\n      }\n      if (lastCommonSep === -1)\n        lastCommonSep = 0;\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to` and\n    // `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_BACKWARD_SLASH) {\n        out += out.length === 0 ? '..' : '\\\\..';\n      }\n    }\n\n    toStart += lastCommonSep;\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return `${out}${StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd)}`;\n\n    if (StringPrototypeCharCodeAt(toOrig\x2C toStart) === CHAR_BACKWARD_SLASH)\n      ++toStart;\n    return StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string' || path.length === 0)\n      return path;\n\n    const resolvedPath = win32.resolve(path);\n\n    if (resolvedPath.length <= 2)\n      return path;\n\n    if (StringPrototypeCharCodeAt(resolvedPath\x2C 0) === CHAR_BACKWARD_SLASH) {\n      // Possible UNC root\n      if (StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_BACKWARD_SLASH) {\n        const code = StringPrototypeCharCodeAt(resolvedPath\x2C 2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          // Matched non-long UNC root\x2C convert the path to a long UNC path\n          return `\\\\\\\\?\\\\UNC\\\\${StringPrototypeSlice(resolvedPath\x2C 2)}`;\n        }\n      }\n    } else if (\n      isWindowsDeviceRoot(StringPrototypeCharCodeAt(resolvedPath\x2C 0)) &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_COLON &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 2) === CHAR_BACKWARD_SLASH\n    ) {\n      // Matched device root\x2C convert the path to a long UNC path\n      return `\\\\\\\\?\\\\${resolvedPath}`;\n    }\n\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = -1;\n    let offset = 0;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      // `path` contains just a path separator\x2C exit early to avoid\n      // unnecessary work or a dot.\n      return isPathSeparator(code) ? path : '.';\n    }\n\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = offset = 1;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a "normal root" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    // Possible device root\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      rootEnd =\n        len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)) ? 3 : 2;\n      offset = rootEnd;\n    }\n\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      if (rootEnd === -1)\n        return '.';\n\n      end = rootEnd;\n    }\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [suffix]\n   * @returns {string}\n   */\n  basename(path\x2C suffix) {\n    if (suffix !== undefined)\n      validateString(suffix\x2C 'ext');\n    validateString(path\x2C 'path');\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2 &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0)) &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      start = 2;\n    }\n\n    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n      if (suffix === path)\n        return '';\n      let extIdx = suffix.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= start; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (isPathSeparator(code)) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(suffix\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= start; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let start = 0;\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n\n    if (path.length >= 2 &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0))) {\n      start = startPart = 2;\n    }\n\n    for (let i = path.length - 1; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '\\\\')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *  dir: string;\n   *  root: string;\n   *  base: string;\n   *  name: string;\n   *  ext: string;\n   *  }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n\n    const len = path.length;\n    let rootEnd = 0;\n    let code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      if (isPathSeparator(code)) {\n        // `path` contains just a path separator\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      ret.base = ret.name = path;\n      return ret;\n    }\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = 1;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              rootEnd = j;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      if (len <= 2) {\n        // `path` contains just a drive root\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      rootEnd = 2;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        if (len === 3) {\n          // `path` contains just a drive root\x2C exit early to avoid\n          // unnecessary work\n          ret.root = ret.dir = path;\n          return ret;\n        }\n        rootEnd = 3;\n      }\n    }\n    if (rootEnd > 0)\n      ret.root = StringPrototypeSlice(path\x2C 0\x2C rootEnd);\n\n    let startDot = -1;\n    let startPart = rootEnd;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= rootEnd; --i) {\n      code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n           startDot === end - 1 &&\n           startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C startPart\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C startPart\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C startPart\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    // If the directory is the root\x2C use the entire root as the `dir` including\n    // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise\x2C strip out the\n    // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n    if (startPart > 0 && startPart !== rootEnd)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else\n      ret.dir = ret.root;\n\n    return ret;\n  }\x2C\n\n  sep: '\\\\'\x2C\n  delimiter: ';'\x2C\n  win32: null\x2C\n  posix: null\x2C\n};\n\nconst posixCwd = (() => {\n  if (platformIsWin32) {\n    // Converts Windows' backslash path separators to POSIX forward slashes\n    // and truncates any drive indicator\n    const regexp = /\\\\/g;\n    return () => {\n      const cwd = StringPrototypeReplace(process.cwd()\x2C regexp\x2C '/');\n      return StringPrototypeSlice(cwd\x2C StringPrototypeIndexOf(cwd\x2C '/'));\n    };\n  }\n\n  // We're already on POSIX\x2C no need for any transformations\n  return () => process.cwd();\n})();\n\nconst posix = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? args[i] : posixCwd();\n      validateString(path\x2C `paths[${i}]`);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute =\n        StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath\x2C !resolvedAbsolute\x2C '/'\x2C\n                                   isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n\n    if (path.length === 0)\n      return '.';\n\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator =\n      StringPrototypeCharCodeAt(path\x2C path.length - 1) === CHAR_FORWARD_SLASH;\n\n    // Normalize the path\n    path = normalizeString(path\x2C !isAbsolute\x2C '/'\x2C isPosixPathSeparator);\n\n    if (path.length === 0) {\n      if (isAbsolute)\n        return '/';\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator)\n      path += '/';\n\n    return isAbsolute ? `/${path}` : path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    return path.length > 0 &&\n           StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n    let joined;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += `/${arg}`;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  }\x2C\n\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    // Trim leading forward slashes.\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to)\n      return '';\n\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = (fromLen < toLen ? fromLen : toLen);\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_FORWARD_SLASH)\n        lastCommonSep = i;\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return StringPrototypeSlice(to\x2C toStart + i + 1);\n        }\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return StringPrototypeSlice(to\x2C toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`.\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n    return `${out}${StringPrototypeSlice(to\x2C toStart + lastCommonSep)}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Non-op on posix systems\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    if (path.length === 0)\n      return '.';\n    const hasRoot = StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1)\n      return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1)\n      return '//';\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [suffix]\n   * @returns {string}\n   */\n  basename(path\x2C suffix) {\n    if (suffix !== undefined)\n      validateString(suffix\x2C 'ext');\n    validateString(path\x2C 'path');\n\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n      if (suffix === path)\n        return '';\n      let extIdx = suffix.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= 0; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(suffix\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= 0; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '/')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *   dir: string;\n   *   root: string;\n   *   base: string;\n   *   name: string;\n   *   ext: string;\n   *   }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n          startDot === end - 1 &&\n          startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C start\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C start\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C start\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    if (startPart > 0)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else if (isAbsolute)\n      ret.dir = '/';\n\n    return ret;\n  }\x2C\n\n  sep: '/'\x2C\n  delimiter: ':'\x2C\n  win32: null\x2C\n  posix: null\x2C\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\n// Legacy internal API\x2C docs-only deprecated: DEP0080\nwin32._makeLong = win32.toNamespacedPath;\nposix._makeLong = posix.toNamespacedPath;\n\nmodule.exports = platformIsWin32 ? win32 : posix;\n
code-source-info,0x202f0287ed90,74,33819,34735,C0O33819C3O33854C6O33885C8O33915C12O33922C16O33935C18O33929C25O33939C27O33983C28O33985C35O33996C42O34002C45O34002C49O34020C59O34050C70O34020C75O34101C81O34108C86O34125C88O34150C100O34176C105O34198C112O34225C120O34264C122O34260C126O33958C131O33897C134O34480C139O34526C150O34495C156O34612C160O34642C165O34653C169O34668C170O34699C176O34706C187O34731,,
tick,0x195a4df24,50042,0,0x0,3,0x0,0x202f0287e5ca,0x202f0287b4d0,0x202f02879dd8,0x202f028761e9
tick,0x195a4aa2c,50042,0,0x0,3,0x0,0x202f0287e5ca,0x202f0287b4d0,0x202f02879dd8,0x202f028761e9
tick,0x195a4df24,50042,0,0x0,3,0x0,0x202f0287e5ca,0x202f0287b4d0,0x202f02879dd8,0x202f028761e9
code-creation,LazyCompile,10,50084,0x30e767704360,442,normalizeString node:path:66:25,0x28e4ce8cccc0,~
code-source-info,0x30e767704360,74,2161,4085,C0O2226C3O2256C5O2277C8O2294C10O2310C12O2328C14O2341C18O2333C23O2373C27O2366C32O2387C37O2394C45O2443C51O2472C53O2494C58O2530C64O2561C66O2581C69O2575C76O2593C83O2631C85O2640C90O2665C97O2672C104O2697C111O2718C114O2753C118O2760C122O2718C130O2769C132O2765C139O2793C142O2828C146O2835C150O2793C158O2844C160O2840C165O2874C172O2881C177O2923C182O2923C188O2979C190O2998C195O3022C198O3046C202O3104C215O3110C221O3210C225O3217C231O3223C234O3223C239O3221C243O3293C246O3320C248O3342C250O3377C256O3384C261O3405C264O3427C266O3462C269O3489C271O3511C273O3551C277O3594C283O3601C293O3610C308O3642C313O3706C319O3713C324O3728C326O3738C330O3750C335O3787C345O3750C363O3821C370O3864C380O3827C386O3881C388O3903C391O3915C395O3934C398O3955C402O3976C404O3989C406O3985C413O4006C418O4022C425O4049C428O2351C433O2315C439O4072C441O4083,,
code-creation,LazyCompile,10,50209,0x30e7677046e8,8,isPosixPathSeparator node:path:56:30,0x28e4ce8ccc20,~
code-source-info,0x30e7677046e8,74,1854,1902,C0O1865C2O1881C4O1877C7O1900,,
code-creation,LazyCompile,10,50334,0x30e767704ce0,385,initializeGlobalConsole node:internal/console/constructor:691:33,0x250200ad9480,~
script-source,111,node:internal/console/constructor,'use strict';\n\n// The Console constructor is not actually used to construct the global\n// console. It's exported for backwards compatibility.\n\nconst {\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeUnshift\x2C\n  Boolean\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeBind\x2C\n  MathFloor\x2C\n  Number\x2C\n  NumberPrototypeToFixed\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectValues\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  ReflectOwnKeys\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  SafeSet\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypePadStart\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  Symbol\x2C\n  SymbolHasInstance\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst { trace } = internalBinding('trace_events');\nconst {\n  isStackOverflowError\x2C\n  codes: {\n    ERR_CONSOLE_WRITABLE_STREAM\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INCOMPATIBLE_OPTION_PAIR\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateInteger\x2C\n  validateObject\x2C\n} = require('internal/validators');\nconst { previewEntries } = internalBinding('util');\nconst { Buffer: { isBuffer } } = require('buffer');\nconst {\n  inspect\x2C\n  formatWithOptions\x2C\n} = require('internal/util/inspect');\nconst {\n  isTypedArray\x2C isSet\x2C isMap\x2C isSetIterator\x2C isMapIterator\x2C\n} = require('internal/util/types');\nconst {\n  CHAR_LOWERCASE_B: kTraceBegin\x2C\n  CHAR_LOWERCASE_E: kTraceEnd\x2C\n  CHAR_LOWERCASE_N: kTraceInstant\x2C\n  CHAR_UPPERCASE_C: kTraceCount\x2C\n} = require('internal/constants');\nconst kCounts = Symbol('counts');\n\nconst kTraceConsoleCategory = 'node\x2Cnode.console';\n\nconst kSecond = 1000;\nconst kMinute = 60 * kSecond;\nconst kHour = 60 * kMinute;\nconst kMaxGroupIndentation = 1000;\n\n// Lazy loaded for startup performance.\nlet cliTable;\n\nlet utilColors;\nfunction lazyUtilColors() {\n  utilColors ??= require('internal/util/colors');\n  return utilColors;\n}\n\n// Track amount of indentation required via `console.group()`.\nconst kGroupIndent = Symbol('kGroupIndent');\nconst kGroupIndentationWidth = Symbol('kGroupIndentWidth');\nconst kFormatForStderr = Symbol('kFormatForStderr');\nconst kFormatForStdout = Symbol('kFormatForStdout');\nconst kGetInspectOptions = Symbol('kGetInspectOptions');\nconst kColorMode = Symbol('kColorMode');\nconst kIsConsole = Symbol('kIsConsole');\nconst kWriteToConsole = Symbol('kWriteToConsole');\nconst kBindProperties = Symbol('kBindProperties');\nconst kBindStreamsEager = Symbol('kBindStreamsEager');\nconst kBindStreamsLazy = Symbol('kBindStreamsLazy');\nconst kUseStdout = Symbol('kUseStdout');\nconst kUseStderr = Symbol('kUseStderr');\n\nconst optionsMap = new SafeWeakMap();\nfunction Console(options /* or: stdout\x2C stderr\x2C ignoreErrors = true */) {\n  // We have to test new.target here to see if this function is called\n  // with new\x2C because we need to define a custom instanceof to accommodate\n  // the global console.\n  if (new.target === undefined) {\n    return ReflectConstruct(Console\x2C arguments);\n  }\n\n  if (!options || typeof options.write === 'function') {\n    options = {\n      stdout: options\x2C\n      stderr: arguments[1]\x2C\n      ignoreErrors: arguments[2]\x2C\n    };\n  }\n\n  const {\n    stdout\x2C\n    stderr = stdout\x2C\n    ignoreErrors = true\x2C\n    colorMode = 'auto'\x2C\n    inspectOptions\x2C\n    groupIndentation\x2C\n  } = options;\n\n  if (!stdout || typeof stdout.write !== 'function') {\n    throw new ERR_CONSOLE_WRITABLE_STREAM('stdout');\n  }\n  if (!stderr || typeof stderr.write !== 'function') {\n    throw new ERR_CONSOLE_WRITABLE_STREAM('stderr');\n  }\n\n  if (typeof colorMode !== 'boolean' && colorMode !== 'auto')\n    throw new ERR_INVALID_ARG_VALUE('colorMode'\x2C colorMode);\n\n  if (groupIndentation !== undefined) {\n    validateInteger(groupIndentation\x2C 'groupIndentation'\x2C\n                    0\x2C kMaxGroupIndentation);\n  }\n\n  if (inspectOptions !== undefined) {\n    validateObject(inspectOptions\x2C 'options.inspectOptions');\n\n    if (inspectOptions.colors !== undefined &&\n        options.colorMode !== undefined) {\n      throw new ERR_INCOMPATIBLE_OPTION_PAIR(\n        'options.inspectOptions.color'\x2C 'colorMode');\n    }\n    optionsMap.set(this\x2C inspectOptions);\n  }\n\n  // Bind the prototype functions to this Console instance\n  ArrayPrototypeForEach(ObjectKeys(Console.prototype)\x2C (key) => {\n    // We have to bind the methods grabbed from the instance instead of from\n    // the prototype so that users extending the Console can override them\n    // from the prototype chain of the subclass.\n    this[key] = FunctionPrototypeBind(this[key]\x2C this);\n    ObjectDefineProperty(this[key]\x2C 'name'\x2C {\n      __proto__: null\x2C\n      value: key\x2C\n    });\n  });\n\n  this[kBindStreamsEager](stdout\x2C stderr);\n  this[kBindProperties](ignoreErrors\x2C colorMode\x2C groupIndentation);\n}\n\nconst consolePropAttributes = {\n  writable: true\x2C\n  enumerable: false\x2C\n  configurable: true\x2C\n};\n\n// Fixup global.console instanceof global.console.Console\nObjectDefineProperty(Console\x2C SymbolHasInstance\x2C {\n  __proto__: null\x2C\n  value(instance) {\n    return instance[kIsConsole];\n  }\x2C\n});\n\nconst kColorInspectOptions = { colors: true };\nconst kNoColorInspectOptions = {};\n\nObjectDefineProperties(Console.prototype\x2C {\n  [kBindStreamsEager]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    // Eager version for the Console constructor\n    value: function(stdout\x2C stderr) {\n      ObjectDefineProperties(this\x2C {\n        '_stdout': { __proto__: null\x2C ...consolePropAttributes\x2C value: stdout }\x2C\n        '_stderr': { __proto__: null\x2C ...consolePropAttributes\x2C value: stderr }\x2C\n      });\n    }\x2C\n  }\x2C\n  [kBindStreamsLazy]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    // Lazily load the stdout and stderr from an object so we don't\n    // create the stdio streams when they are not even accessed\n    value: function(object) {\n      let stdout;\n      let stderr;\n      ObjectDefineProperties(this\x2C {\n        '_stdout': {\n          __proto__: null\x2C\n          enumerable: false\x2C\n          configurable: true\x2C\n          get() {\n            if (!stdout) stdout = object.stdout;\n            return stdout;\n          }\x2C\n          set(value) { stdout = value; }\x2C\n        }\x2C\n        '_stderr': {\n          __proto__: null\x2C\n          enumerable: false\x2C\n          configurable: true\x2C\n          get() {\n            if (!stderr) { stderr = object.stderr; }\n            return stderr;\n          }\x2C\n          set(value) { stderr = value; }\x2C\n        }\x2C\n      });\n    }\x2C\n  }\x2C\n  [kBindProperties]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(ignoreErrors\x2C colorMode\x2C groupIndentation = 2) {\n      ObjectDefineProperties(this\x2C {\n        '_stdoutErrorHandler': {\n          __proto__: null\x2C\n          ...consolePropAttributes\x2C\n          value: createWriteErrorHandler(this\x2C kUseStdout)\x2C\n        }\x2C\n        '_stderrErrorHandler': {\n          ...consolePropAttributes\x2C\n          __proto__: null\x2C\n          value: createWriteErrorHandler(this\x2C kUseStderr)\x2C\n        }\x2C\n        '_ignoreErrors': {\n          __proto__: null\x2C\n          ...consolePropAttributes\x2C\n          value: Boolean(ignoreErrors)\x2C\n        }\x2C\n        '_times': { __proto__: null\x2C ...consolePropAttributes\x2C value: new SafeMap() }\x2C\n        // Corresponds to https://console.spec.whatwg.org/#count-map\n        [kCounts]: { __proto__: null\x2C ...consolePropAttributes\x2C value: new SafeMap() }\x2C\n        [kColorMode]: { __proto__: null\x2C ...consolePropAttributes\x2C value: colorMode }\x2C\n        [kIsConsole]: { __proto__: null\x2C ...consolePropAttributes\x2C value: true }\x2C\n        [kGroupIndent]: { __proto__: null\x2C ...consolePropAttributes\x2C value: '' }\x2C\n        [kGroupIndentationWidth]: {\n          __proto__: null\x2C\n          ...consolePropAttributes\x2C\n          value: groupIndentation\x2C\n        }\x2C\n        [SymbolToStringTag]: {\n          __proto__: null\x2C\n          writable: false\x2C\n          enumerable: false\x2C\n          configurable: true\x2C\n          value: 'console'\x2C\n        }\x2C\n      });\n    }\x2C\n  }\x2C\n  [kWriteToConsole]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(streamSymbol\x2C string) {\n      const ignoreErrors = this._ignoreErrors;\n      const groupIndent = this[kGroupIndent];\n\n      const useStdout = streamSymbol === kUseStdout;\n      const stream = useStdout ? this._stdout : this._stderr;\n      const errorHandler = useStdout ?\n        this._stdoutErrorHandler : this._stderrErrorHandler;\n\n      if (groupIndent.length !== 0) {\n        if (StringPrototypeIncludes(string\x2C '\\n')) {\n          string = RegExpPrototypeSymbolReplace(/\\n/g\x2C string\x2C `\\n${groupIndent}`);\n        }\n        string = groupIndent + string;\n      }\n      string += '\\n';\n\n      if (ignoreErrors === false) return stream.write(string);\n\n      // There may be an error occurring synchronously (e.g. for files or TTYs\n      // on POSIX systems) or asynchronously (e.g. pipes on POSIX systems)\x2C so\n      // handle both situations.\n      try {\n        // Add and later remove a noop error handler to catch synchronous\n        // errors.\n        if (stream.listenerCount('error') === 0)\n          stream.once('error'\x2C noop);\n\n        stream.write(string\x2C errorHandler);\n      } catch (e) {\n        // Console is a debugging utility\x2C so it swallowing errors is not\n        // desirable even in edge cases such as low stack space.\n        if (isStackOverflowError(e))\n          throw e;\n        // Sorry\x2C there's no proper way to pass along the error here.\n      } finally {\n        stream.removeListener('error'\x2C noop);\n      }\n    }\x2C\n  }\x2C\n  [kGetInspectOptions]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(stream) {\n      let color = this[kColorMode];\n      if (color === 'auto') {\n        color = lazyUtilColors().shouldColorize(stream);\n      }\n\n      const options = optionsMap.get(this);\n      if (options) {\n        if (options.colors === undefined) {\n          options.colors = color;\n        }\n        return options;\n      }\n\n      return color ? kColorInspectOptions : kNoColorInspectOptions;\n    }\x2C\n  }\x2C\n  [kFormatForStdout]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(args) {\n      const opts = this[kGetInspectOptions](this._stdout);\n      ArrayPrototypeUnshift(args\x2C opts);\n      return ReflectApply(formatWithOptions\x2C null\x2C args);\n    }\x2C\n  }\x2C\n  [kFormatForStderr]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(args) {\n      const opts = this[kGetInspectOptions](this._stderr);\n      ArrayPrototypeUnshift(args\x2C opts);\n      return ReflectApply(formatWithOptions\x2C null\x2C args);\n    }\x2C\n  }\x2C\n});\n\n// Make a function that can serve as the callback passed to `stream.write()`.\nfunction createWriteErrorHandler(instance\x2C streamSymbol) {\n  return (err) => {\n    // This conditional evaluates to true if and only if there was an error\n    // that was not already emitted (which happens when the _write callback\n    // is invoked asynchronously).\n    const stream = streamSymbol === kUseStdout ?\n      instance._stdout : instance._stderr;\n    if (err !== null && !stream._writableState.errorEmitted) {\n      // If there was an error\x2C it will be emitted on `stream` as\n      // an `error` event. Adding a `once` listener will keep that error\n      // from becoming an uncaught exception\x2C but since the handler is\n      // removed after the event\x2C non-console.* writes won't be affected.\n      // we are only adding noop if there is no one else listening for 'error'\n      if (stream.listenerCount('error') === 0) {\n        stream.once('error'\x2C noop);\n      }\n    }\n  };\n}\n\nconst consoleMethods = {\n  log(...args) {\n    this[kWriteToConsole](kUseStdout\x2C this[kFormatForStdout](args));\n  }\x2C\n\n\n  warn(...args) {\n    this[kWriteToConsole](kUseStderr\x2C this[kFormatForStderr](args));\n  }\x2C\n\n\n  dir(object\x2C options) {\n    this[kWriteToConsole](kUseStdout\x2C inspect(object\x2C {\n      customInspect: false\x2C\n      ...this[kGetInspectOptions](this._stdout)\x2C\n      ...options\x2C\n    }));\n  }\x2C\n\n  time(label = 'default') {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    if (this._times.has(label)) {\n      process.emitWarning(`Label '${label}' already exists for console.time()`);\n      return;\n    }\n    trace(kTraceBegin\x2C kTraceConsoleCategory\x2C `time::${label}`\x2C 0);\n    this._times.set(label\x2C process.hrtime());\n  }\x2C\n\n  timeEnd(label = 'default') {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    const found = timeLogImpl(this\x2C 'timeEnd'\x2C label);\n    trace(kTraceEnd\x2C kTraceConsoleCategory\x2C `time::${label}`\x2C 0);\n    if (found) {\n      this._times.delete(label);\n    }\n  }\x2C\n\n  timeLog(label = 'default'\x2C ...data) {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    timeLogImpl(this\x2C 'timeLog'\x2C label\x2C data);\n    trace(kTraceInstant\x2C kTraceConsoleCategory\x2C `time::${label}`\x2C 0);\n  }\x2C\n\n  trace: function trace(...args) {\n    const err = {\n      name: 'Trace'\x2C\n      message: this[kFormatForStderr](args)\x2C\n    };\n    ErrorCaptureStackTrace(err\x2C trace);\n    this.error(err.stack);\n  }\x2C\n\n  assert(expression\x2C ...args) {\n    if (!expression) {\n      args[0] = `Assertion failed${args.length === 0 ? '' : `: ${args[0]}`}`;\n      // The arguments will be formatted in warn() again\n      ReflectApply(this.warn\x2C this\x2C args);\n    }\n  }\x2C\n\n  // Defined by: https://console.spec.whatwg.org/#clear\n  clear() {\n    // It only makes sense to clear if _stdout is a TTY.\n    // Otherwise\x2C do nothing.\n    if (this._stdout.isTTY && process.env.TERM !== 'dumb') {\n      // The require is here intentionally to avoid readline being\n      // required too early when console is first loaded.\n      const {\n        cursorTo\x2C\n        clearScreenDown\x2C\n      } = require('internal/readline/callbacks');\n      cursorTo(this._stdout\x2C 0\x2C 0);\n      clearScreenDown(this._stdout);\n    }\n  }\x2C\n\n  // Defined by: https://console.spec.whatwg.org/#count\n  count(label = 'default') {\n    // Ensures that label is a string\x2C and only things that can be\n    // coerced to strings. e.g. Symbol is not allowed\n    label = `${label}`;\n    const counts = this[kCounts];\n    let count = counts.get(label);\n    if (count === undefined)\n      count = 1;\n    else\n      count++;\n    counts.set(label\x2C count);\n    trace(kTraceCount\x2C kTraceConsoleCategory\x2C `count::${label}`\x2C 0\x2C count);\n    this.log(`${label}: ${count}`);\n  }\x2C\n\n  // Defined by: https://console.spec.whatwg.org/#countreset\n  countReset(label = 'default') {\n    const counts = this[kCounts];\n    if (!counts.has(label)) {\n      process.emitWarning(`Count for '${label}' does not exist`);\n      return;\n    }\n    trace(kTraceCount\x2C kTraceConsoleCategory\x2C `count::${label}`\x2C 0\x2C 0);\n    counts.delete(`${label}`);\n  }\x2C\n\n  group(...data) {\n    if (data.length > 0) {\n      ReflectApply(this.log\x2C this\x2C data);\n    }\n    this[kGroupIndent] +=\n      StringPrototypeRepeat(' '\x2C this[kGroupIndentationWidth]);\n  }\x2C\n\n  groupEnd() {\n    this[kGroupIndent] = StringPrototypeSlice(\n      this[kGroupIndent]\x2C\n      0\x2C\n      this[kGroupIndent].length - this[kGroupIndentationWidth]\x2C\n    );\n  }\x2C\n\n  // https://console.spec.whatwg.org/#table\n  table(tabularData\x2C properties) {\n    if (properties !== undefined)\n      validateArray(properties\x2C 'properties');\n\n    if (tabularData === null || typeof tabularData !== 'object')\n      return this.log(tabularData);\n\n    cliTable ??= require('internal/cli_table');\n    const final = (k\x2C v) => this.log(cliTable(k\x2C v));\n\n    const _inspect = (v) => {\n      const depth = v !== null &&\n                    typeof v === 'object' &&\n                    !isArray(v) &&\n                    ObjectKeys(v).length > 2 ? -1 : 0;\n      const opt = {\n        depth\x2C\n        maxArrayLength: 3\x2C\n        breakLength: Infinity\x2C\n        ...this[kGetInspectOptions](this._stdout)\x2C\n      };\n      return inspect(v\x2C opt);\n    };\n    const getIndexArray = (length) => ArrayFrom(\n      { length }\x2C (_\x2C i) => _inspect(i));\n\n    const mapIter = isMapIterator(tabularData);\n    let isKeyValue = false;\n    let i = 0;\n    if (mapIter) {\n      const res = previewEntries(tabularData\x2C true);\n      tabularData = res[0];\n      isKeyValue = res[1];\n    }\n\n    if (isKeyValue || isMap(tabularData)) {\n      const keys = [];\n      const values = [];\n      let length = 0;\n      if (mapIter) {\n        for (; i < tabularData.length / 2; ++i) {\n          ArrayPrototypePush(keys\x2C _inspect(tabularData[i * 2]));\n          ArrayPrototypePush(values\x2C _inspect(tabularData[i * 2 + 1]));\n          length++;\n        }\n      } else {\n        for (const { 0: k\x2C 1: v } of tabularData) {\n          ArrayPrototypePush(keys\x2C _inspect(k));\n          ArrayPrototypePush(values\x2C _inspect(v));\n          length++;\n        }\n      }\n      return final([\n        iterKey\x2C keyKey\x2C valuesKey\x2C\n      ]\x2C [\n        getIndexArray(length)\x2C\n        keys\x2C\n        values\x2C\n      ]);\n    }\n\n    const setIter = isSetIterator(tabularData);\n    if (setIter)\n      tabularData = previewEntries(tabularData);\n\n    const setlike = setIter || mapIter || isSet(tabularData);\n    if (setlike) {\n      const values = [];\n      let length = 0;\n      for (const v of tabularData) {\n        ArrayPrototypePush(values\x2C _inspect(v));\n        length++;\n      }\n      return final([iterKey\x2C valuesKey]\x2C [getIndexArray(length)\x2C values]);\n    }\n\n    const map = ObjectCreate(null);\n    let hasPrimitives = false;\n    const valuesKeyArray = [];\n    const indexKeyArray = ObjectKeys(tabularData);\n\n    for (; i < indexKeyArray.length; i++) {\n      const item = tabularData[indexKeyArray[i]];\n      const primitive = item === null ||\n          (typeof item !== 'function' && typeof item !== 'object');\n      if (properties === undefined && primitive) {\n        hasPrimitives = true;\n        valuesKeyArray[i] = _inspect(item);\n      } else {\n        const keys = properties || ObjectKeys(item);\n        for (const key of keys) {\n          map[key] ??= [];\n          if ((primitive && properties) ||\n               !ObjectPrototypeHasOwnProperty(item\x2C key))\n            map[key][i] = '';\n          else\n            map[key][i] = _inspect(item[key]);\n        }\n      }\n    }\n\n    const keys = ObjectKeys(map);\n    const values = ObjectValues(map);\n    if (hasPrimitives) {\n      ArrayPrototypePush(keys\x2C valuesKey);\n      ArrayPrototypePush(values\x2C valuesKeyArray);\n    }\n    ArrayPrototypeUnshift(keys\x2C indexKey);\n    ArrayPrototypeUnshift(values\x2C indexKeyArray);\n\n    return final(keys\x2C values);\n  }\x2C\n};\n\n// Returns true if label was found\nfunction timeLogImpl(self\x2C name\x2C label\x2C data) {\n  const time = self._times.get(label);\n  if (time === undefined) {\n    process.emitWarning(`No such label '${label}' for console.${name}()`);\n    return false;\n  }\n  const duration = process.hrtime(time);\n  const ms = duration[0] * 1000 + duration[1] / 1e6;\n\n  const formatted = formatTime(ms);\n\n  if (data === undefined) {\n    self.log('%s: %s'\x2C label\x2C formatted);\n  } else {\n    self.log('%s: %s'\x2C label\x2C formatted\x2C ...new SafeArrayIterator(data));\n  }\n  return true;\n}\n\nfunction pad(value) {\n  return StringPrototypePadStart(`${value}`\x2C 2\x2C '0');\n}\n\nfunction formatTime(ms) {\n  let hours = 0;\n  let minutes = 0;\n  let seconds = 0;\n\n  if (ms >= kSecond) {\n    if (ms >= kMinute) {\n      if (ms >= kHour) {\n        hours = MathFloor(ms / kHour);\n        ms = ms % kHour;\n      }\n      minutes = MathFloor(ms / kMinute);\n      ms = ms % kMinute;\n    }\n    seconds = ms / kSecond;\n  }\n\n  if (hours !== 0 || minutes !== 0) {\n    ({ 0: seconds\x2C 1: ms } = StringPrototypeSplit(\n      NumberPrototypeToFixed(seconds\x2C 3)\x2C\n      '.'\x2C\n    ));\n    const res = hours !== 0 ? `${hours}:${pad(minutes)}` : minutes;\n    return `${res}:${pad(seconds)}.${ms} (${hours !== 0 ? 'h:m' : ''}m:ss.mmm)`;\n  }\n\n  if (seconds !== 0) {\n    return `${NumberPrototypeToFixed(seconds\x2C 3)}s`;\n  }\n\n  return `${Number(NumberPrototypeToFixed(ms\x2C 3))}ms`;\n}\n\nconst keyKey = 'Key';\nconst valuesKey = 'Values';\nconst indexKey = '(index)';\nconst iterKey = '(iteration index)';\n\nconst isArray = (v) => ArrayIsArray(v) || isTypedArray(v) || isBuffer(v);\n\nfunction noop() {}\n\nfor (const method of ReflectOwnKeys(consoleMethods))\n  Console.prototype[method] = consoleMethods[method];\n\nConsole.prototype.debug = Console.prototype.log;\nConsole.prototype.info = Console.prototype.log;\nConsole.prototype.dirxml = Console.prototype.log;\nConsole.prototype.error = Console.prototype.warn;\nConsole.prototype.groupCollapsed = Console.prototype.group;\n\nfunction initializeGlobalConsole(globalConsole) {\n  globalConsole[kBindStreamsLazy](process);\n  globalConsole[kBindProperties](true\x2C 'auto');\n\n  const {\n    addSerializeCallback\x2C\n    isBuildingSnapshot\x2C\n  } = require('v8').startupSnapshot;\n\n  if (!internalBinding('config').hasInspector || !isBuildingSnapshot()) {\n    return;\n  }\n  const { console: consoleFromVM } = internalBinding('inspector');\n  const nodeConsoleKeys = ObjectKeys(Console.prototype);\n  const vmConsoleKeys = ObjectKeys(consoleFromVM);\n  const originalKeys = new SafeSet(vmConsoleKeys.concat(nodeConsoleKeys));\n  const inspectorConsoleKeys = new SafeSet();\n  for (const key of ObjectKeys(globalConsole)) {\n    if (!originalKeys.has(key)) {\n      inspectorConsoleKeys.add(key);\n    }\n  }\n  // During deserialization these should be reinstalled to console by\n  // V8 when the inspector client is created.\n  addSerializeCallback(() => {\n    for (const key of inspectorConsoleKeys) {\n      globalConsole[key] = undefined;\n    }\n  });\n}\n\nmodule.exports = {\n  Console\x2C\n  kBindStreamsLazy\x2C\n  kBindProperties\x2C\n  initializeGlobalConsole\x2C\n  formatTime\x2C // exported for tests\n};\n
code-source-info,0x30e767704ce0,111,20472,21441,C0O20472C12O20492C19O20506C21O20505C30O20523C35O20536C42O20550C44O20549C53O20566C59O20649C67O20649C72O20662C77O20597C82O20623C87O20683C95O20688C100O20713C106O20731C111O20759C112O20766C113O20808C121O20808C126O20790C131O20864C143O20883C148O20864C153O20919C160O20919C165O20969C172O20995C177O20995C185O20969C191O21052C198O21052C203O21052C205O21087C215O21087C244O21080C274O21080C277O21138C283O21138C293O21156C297O21177C303O21177C308O21069C374O21315C379O21315C384O21440,,
code-creation,LazyCompile,10,51584,0x30e7677069c0,94,value node:internal/console/constructor:206:20,0x250200ad8ad8,~
code-source-info,0x30e7677069c0,111,5856,6493,C0O5856C15O5877C16O5877C18O5895C19O5895C21O5909C33O5959C38O6057C46O6164C60O6226C65O6324C73O6435C87O5909C93O6492,,
tick,0x195a84c24,51625,0,0x0,3,0x0,0x202f0287e5f4,0x202f0287b4d0,0x202f02879dd8,0x202f028761e9
code-creation,LazyCompile,10,51667,0x30e767707088,414,value node:internal/console/constructor:236:20,0x250200ad8b98,~
code-source-info,0x30e767707088,111,6593,7993,C17O6649C27O6711C34O6753C52O6823C55O6793C73O6893C86O6990C89O6960C104O7039C111O7081C126O7121C129O7121C144O7173C151O7195C166O7229C169O7225C187O7320C191O7330C198O7352C213O7386C216O7382C235O7408C239O7421C246O7443C261O7473C275O7495C279O7508C286O7530C300O7560C314O7577C318O7592C325O7614C340O7644C354O7659C358O7684C365O7726C380O7766C394O7804C398O7824C407O6649C413O7992,,
code-creation,LazyCompile,10,51709,0x30e7677074f8,18,createWriteErrorHandler node:internal/console/constructor:358:33,0x250200ad8e40,~
code-source-info,0x30e7677074f8,111,10710,11567,C0O10710C13O10739C17O11565,,
code-creation,LazyCompile,10,51750,0x30e767707710,25,isBuildingSnapshot node:internal/v8/startup_snapshot:19:28,0x25dc1a856390,~
script-source,85,node:internal/v8/startup_snapshot,'use strict';\n\nconst {\n  validateFunction\x2C\n} = require('internal/validators');\nconst {\n  codes: {\n    ERR_NOT_BUILDING_SNAPSHOT\x2C\n    ERR_DUPLICATE_STARTUP_SNAPSHOT_MAIN_FUNCTION\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  setSerializeCallback\x2C\n  setDeserializeCallback\x2C\n  setDeserializeMainFunction: _setDeserializeMainFunction\x2C\n} = internalBinding('mksnapshot');\n\nfunction isBuildingSnapshot() {\n  // For now this is the only way to build a snapshot.\n  return require('internal/options').getOptionValue('--build-snapshot');\n}\n\nfunction throwIfNotBuildingSnapshot() {\n  if (!isBuildingSnapshot()) {\n    throw new ERR_NOT_BUILDING_SNAPSHOT();\n  }\n}\n\nconst deserializeCallbacks = [];\nlet deserializeCallbackIsSet = false;\nfunction runDeserializeCallbacks() {\n  while (deserializeCallbacks.length > 0) {\n    const { 0: callback\x2C 1: data } = deserializeCallbacks.shift();\n    callback(data);\n  }\n}\n\nfunction addDeserializeCallback(callback\x2C data) {\n  throwIfNotBuildingSnapshot();\n  validateFunction(callback\x2C 'callback');\n  if (!deserializeCallbackIsSet) {\n    // TODO(joyeecheung): when the main function handling is done in JS\x2C\n    // the deserialize callbacks can always be invoked. For now only\n    // store it in C++ when it's actually used to avoid unnecessary\n    // C++ -> JS costs.\n    setDeserializeCallback(runDeserializeCallbacks);\n    deserializeCallbackIsSet = true;\n  }\n  deserializeCallbacks.push([callback\x2C data]);\n}\n\nconst serializeCallbacks = [];\nfunction runSerializeCallbacks() {\n  while (serializeCallbacks.length > 0) {\n    const { 0: callback\x2C 1: data } = serializeCallbacks.shift();\n    callback(data);\n  }\n}\n\nfunction addSerializeCallback(callback\x2C data) {\n  throwIfNotBuildingSnapshot();\n  validateFunction(callback\x2C 'callback');\n  serializeCallbacks.push([callback\x2C data]);\n}\n\nfunction initializeCallbacks() {\n  // Only run the serialize callbacks in snapshot building mode\x2C otherwise\n  // they throw.\n  if (isBuildingSnapshot()) {\n    setSerializeCallback(runSerializeCallbacks);\n  }\n}\n\nlet deserializeMainIsSet = false;\nfunction setDeserializeMainFunction(callback\x2C data) {\n  throwIfNotBuildingSnapshot();\n  // TODO(joyeecheung): In lib/internal/bootstrap/node.js\x2C create a default\n  // main function to run the lib/internal/main scripts and make sure that\n  // the main function set in the snapshot building process takes precedence.\n  validateFunction(callback\x2C 'callback');\n  if (deserializeMainIsSet) {\n    throw new ERR_DUPLICATE_STARTUP_SNAPSHOT_MAIN_FUNCTION();\n  }\n  deserializeMainIsSet = true;\n\n  _setDeserializeMainFunction(function deserializeMain() {\n    const {\n      prepareMainThreadExecution\x2C\n      markBootstrapComplete\x2C\n    } = require('internal/process/pre_execution');\n\n    // This should be in sync with run_main_module.js until we make that\n    // a built-in main function.\n    // TODO(joyeecheung): make a copy of argv[0] and insert it as argv[1].\n    prepareMainThreadExecution(false);\n    markBootstrapComplete();\n    callback(data);\n  });\n}\n\nmodule.exports = {\n  initializeCallbacks\x2C\n  runDeserializeCallbacks\x2C\n  // Exposed to require('v8').startupSnapshot\n  namespace: {\n    addDeserializeCallback\x2C\n    addSerializeCallback\x2C\n    setDeserializeMainFunction\x2C\n    isBuildingSnapshot\x2C\n  }\x2C\n};\n
code-source-info,0x30e767707710,85,397,531,C0O459C6O466C11O493C19O494C24O529,,
code-creation,LazyCompile,10,51917,0x30e767707c18,63,addReadOnlyProcessAlias node:internal/process/pre_execution:178:33,0x202f02877568,~
code-source-info,0x30e767707c18,447,5646,5895,C16O5698C21O5698C26O5724C28O5741C36O5771C43O5857C49O5875C56O5741C62O5894,,
code-creation,LazyCompile,10,51959,0x30e767707e58,46,setupTraceCategoryState node:internal/process/pre_execution:366:33,0x202f028779b0,~
code-source-info,0x30e767707e58,447,10980,11207,C0O11022C6O11022C11O10995C16O11094C22O11094C27O11065C32O11136C35O11161C40O11136C45O11206,,
code-creation,LazyCompile,10,52000,0x30e767707ff0,77,toggleTraceCategoryState node:internal/process/per_thread:409:34,0x35d297199ec0,~
script-source,37,node:internal/process/per_thread,'use strict';\n\n// This files contains process bootstrappers that can be\n// run when setting up each thread\x2C including the main\n// thread and the worker threads.\n\nconst {\n  ArrayPrototypeEvery\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSplice\x2C\n  BigUint64Array\x2C\n  Float64Array\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  ObjectFreeze\x2C\n  ObjectDefineProperty\x2C\n  ReflectApply\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  Set\x2C\n  SetPrototypeEntries\x2C\n  SetPrototypeValues\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolIterator\x2C\n  Uint32Array\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n  codes: {\n    ERR_ASSERTION\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\x2C\n  }\x2C\n} = require('internal/errors');\nconst format = require('internal/util/inspect').format;\nconst {\n  validateArray\x2C\n  validateNumber\x2C\n  validateObject\x2C\n} = require('internal/validators');\nconst constants = internalBinding('constants').os.signals;\n\nconst {\n  handleProcessExit\x2C\n} = require('internal/modules/esm/handle_process_exit');\n\nconst kInternal = Symbol('internal properties');\n\nfunction assert(x\x2C msg) {\n  if (!x) throw new ERR_ASSERTION(msg || 'assertion error');\n}\n\nconst binding = internalBinding('process_methods');\n\nlet hrValues;\nlet hrBigintValues;\n\nfunction refreshHrtimeBuffer() {\n  // The 3 entries filled in by the original process.hrtime contains\n  // the upper/lower 32 bits of the second part of the value\x2C\n  // and the remaining nanoseconds of the value.\n  hrValues = new Uint32Array(binding.hrtimeBuffer);\n  // Use a BigUint64Array in the closure because this is actually a bit\n  // faster than simply returning a BigInt from C++ in V8 7.1.\n  hrBigintValues = new BigUint64Array(binding.hrtimeBuffer\x2C 0\x2C 1);\n}\n\n// Create the buffers.\nrefreshHrtimeBuffer();\n\nfunction hrtime(time) {\n  binding.hrtime();\n\n  if (time !== undefined) {\n    validateArray(time\x2C 'time');\n    if (time.length !== 2) {\n      throw new ERR_OUT_OF_RANGE('time'\x2C 2\x2C time.length);\n    }\n\n    const sec = (hrValues[0] * 0x100000000 + hrValues[1]) - time[0];\n    const nsec = hrValues[2] - time[1];\n    const needsBorrow = nsec < 0;\n    return [needsBorrow ? sec - 1 : sec\x2C needsBorrow ? nsec + 1e9 : nsec];\n  }\n\n  return [\n    hrValues[0] * 0x100000000 + hrValues[1]\x2C\n    hrValues[2]\x2C\n  ];\n}\n\nfunction hrtimeBigInt() {\n  binding.hrtimeBigInt();\n  return hrBigintValues[0];\n}\n\nfunction nop() {}\n\n// The execution of this function itself should not cause any side effects.\nfunction wrapProcessMethods(binding) {\n  const {\n    cpuUsage: _cpuUsage\x2C\n    memoryUsage: _memoryUsage\x2C\n    rss\x2C\n    resourceUsage: _resourceUsage\x2C\n  } = binding;\n\n  function _rawDebug(...args) {\n    binding._rawDebug(ReflectApply(format\x2C null\x2C args));\n  }\n\n  // Create the argument array that will be passed to the native function.\n  const cpuValues = new Float64Array(2);\n\n  // Replace the native function with the JS version that calls the native\n  // function.\n  function cpuUsage(prevValue) {\n    // If a previous value was passed in\x2C ensure it has the correct shape.\n    if (prevValue) {\n      if (!previousValueIsValid(prevValue.user)) {\n        validateObject(prevValue\x2C 'prevValue');\n\n        validateNumber(prevValue.user\x2C 'prevValue.user');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.user'\x2C\n                                                   prevValue.user);\n      }\n\n      if (!previousValueIsValid(prevValue.system)) {\n        validateNumber(prevValue.system\x2C 'prevValue.system');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.system'\x2C\n                                                   prevValue.system);\n      }\n    }\n\n    // Call the native function to get the current values.\n    _cpuUsage(cpuValues);\n\n    // If a previous value was passed in\x2C return diff of current from previous.\n    if (prevValue) {\n      return {\n        user: cpuValues[0] - prevValue.user\x2C\n        system: cpuValues[1] - prevValue.system\x2C\n      };\n    }\n\n    // If no previous value passed in\x2C return current value.\n    return {\n      user: cpuValues[0]\x2C\n      system: cpuValues[1]\x2C\n    };\n  }\n\n  // Ensure that a previously passed in value is valid. Currently\x2C the native\n  // implementation always returns numbers <= Number.MAX_SAFE_INTEGER.\n  function previousValueIsValid(num) {\n    return typeof num === 'number' &&\n        num <= NumberMAX_SAFE_INTEGER &&\n        num >= 0;\n  }\n\n  const memValues = new Float64Array(5);\n  function memoryUsage() {\n    _memoryUsage(memValues);\n    return {\n      rss: memValues[0]\x2C\n      heapTotal: memValues[1]\x2C\n      heapUsed: memValues[2]\x2C\n      external: memValues[3]\x2C\n      arrayBuffers: memValues[4]\x2C\n    };\n  }\n\n  memoryUsage.rss = rss;\n\n  function exit(code) {\n    process.off('exit'\x2C handleProcessExit);\n\n    if (code || code === 0)\n      process.exitCode = code;\n\n    if (!process._exiting) {\n      process._exiting = true;\n      process.emit('exit'\x2C process.exitCode || 0);\n    }\n    // FIXME(joyeecheung): This is an undocumented API that gets monkey-patched\n    // in the user land. Either document it\x2C or deprecate it in favor of a\n    // better public alternative.\n    process.reallyExit(process.exitCode || 0);\n\n    // If this is a worker\x2C v8::Isolate::TerminateExecution() is called above.\n    // That function spoofs the stack pointer to cause the stack guard\n    // check to throw the termination exception. Because v8 performs\n    // stack guard check upon every function call\x2C we give it a chance.\n    //\n    // Without this\x2C user code after `process.exit()` would take effect.\n    // test/parallel/test-worker-voluntarily-exit-followed-by-addition.js\n    // test/parallel/test-worker-voluntarily-exit-followed-by-throw.js\n    nop();\n  }\n\n  function kill(pid\x2C sig) {\n    let err;\n\n    // eslint-disable-next-line eqeqeq\n    if (pid != (pid | 0)) {\n      throw new ERR_INVALID_ARG_TYPE('pid'\x2C 'number'\x2C pid);\n    }\n\n    // Preserve null signal\n    if (sig === (sig | 0)) {\n      // XXX(joyeecheung): we have to use process._kill here because\n      // it's monkey-patched by tests.\n      err = process._kill(pid\x2C sig);\n    } else {\n      sig = sig || 'SIGTERM';\n      if (constants[sig]) {\n        err = process._kill(pid\x2C constants[sig]);\n      } else {\n        throw new ERR_UNKNOWN_SIGNAL(sig);\n      }\n    }\n\n    if (err)\n      throw errnoException(err\x2C 'kill');\n\n    return true;\n  }\n\n  const resourceValues = new Float64Array(16);\n  function resourceUsage() {\n    _resourceUsage(resourceValues);\n    return {\n      userCPUTime: resourceValues[0]\x2C\n      systemCPUTime: resourceValues[1]\x2C\n      maxRSS: resourceValues[2]\x2C\n      sharedMemorySize: resourceValues[3]\x2C\n      unsharedDataSize: resourceValues[4]\x2C\n      unsharedStackSize: resourceValues[5]\x2C\n      minorPageFault: resourceValues[6]\x2C\n      majorPageFault: resourceValues[7]\x2C\n      swappedOut: resourceValues[8]\x2C\n      fsRead: resourceValues[9]\x2C\n      fsWrite: resourceValues[10]\x2C\n      ipcSent: resourceValues[11]\x2C\n      ipcReceived: resourceValues[12]\x2C\n      signalsCount: resourceValues[13]\x2C\n      voluntaryContextSwitches: resourceValues[14]\x2C\n      involuntaryContextSwitches: resourceValues[15]\x2C\n    };\n  }\n\n\n  return {\n    _rawDebug\x2C\n    cpuUsage\x2C\n    resourceUsage\x2C\n    memoryUsage\x2C\n    kill\x2C\n    exit\x2C\n  };\n}\n\nconst replaceUnderscoresRegex = /_/g;\nconst leadingDashesRegex = /^--?/;\nconst trailingValuesRegex = /=.*$/;\n\n// This builds the initial process.allowedNodeEnvironmentFlags\n// from data in the config binding.\nfunction buildAllowedFlags() {\n  const {\n    envSettings: { kAllowedInEnvvar }\x2C\n    types: { kBoolean }\x2C\n  } = internalBinding('options');\n  const { options\x2C aliases } = require('internal/options');\n\n  const allowedNodeEnvironmentFlags = [];\n  for (const { 0: name\x2C 1: info } of options) {\n    if (info.envVarSettings === kAllowedInEnvvar) {\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C name);\n      if (info.type === kBoolean) {\n        const negatedName = `--no-${name.slice(2)}`;\n        ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C negatedName);\n      }\n    }\n  }\n\n  function isAccepted(to) {\n    if (!StringPrototypeStartsWith(to\x2C '-') || to === '--') return true;\n    const recursiveExpansion = aliases.get(to);\n    if (recursiveExpansion) {\n      if (recursiveExpansion[0] === to)\n        ArrayPrototypeSplice(recursiveExpansion\x2C 0\x2C 1);\n      return ArrayPrototypeEvery(recursiveExpansion\x2C isAccepted);\n    }\n    return options.get(to).envVarSettings === kAllowedInEnvvar;\n  }\n  for (const { 0: from\x2C 1: expansion } of aliases) {\n    if (ArrayPrototypeEvery(expansion\x2C isAccepted)) {\n      let canonical = from;\n      if (StringPrototypeEndsWith(canonical\x2C '='))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 1);\n      if (StringPrototypeEndsWith(canonical\x2C ' <arg>'))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 4);\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C canonical);\n    }\n  }\n\n  const trimLeadingDashes =\n    (flag) => StringPrototypeReplace(flag\x2C leadingDashesRegex\x2C '');\n\n  // Save these for comparison against flags provided to\n  // process.allowedNodeEnvironmentFlags.has() which lack leading dashes.\n  const nodeFlags = ArrayPrototypeMap(allowedNodeEnvironmentFlags\x2C\n                                      trimLeadingDashes);\n\n  class NodeEnvironmentFlagsSet extends Set {\n    constructor(array) {\n      super();\n      this[kInternal] = { array };\n    }\n\n    add() {\n      // No-op\x2C `Set` API compatible\n      return this;\n    }\n\n    delete() {\n      // No-op\x2C `Set` API compatible\n      return false;\n    }\n\n    clear() {\n      // No-op\x2C `Set` API compatible\n    }\n\n    has(key) {\n      // This will return `true` based on various possible\n      // permutations of a flag\x2C including present/missing leading\n      // dash(es) and/or underscores-for-dashes.\n      // Strips any values after `=`\x2C inclusive.\n      // TODO(addaleax): It might be more flexible to run the option parser\n      // on a dummy option set and see whether it rejects the argument or\n      // not.\n      if (typeof key === 'string') {\n        key = StringPrototypeReplace(key\x2C replaceUnderscoresRegex\x2C '-');\n        if (RegExpPrototypeExec(leadingDashesRegex\x2C key) !== null) {\n          key = StringPrototypeReplace(key\x2C trailingValuesRegex\x2C '');\n          return ArrayPrototypeIncludes(this[kInternal].array\x2C key);\n        }\n        return ArrayPrototypeIncludes(nodeFlags\x2C key);\n      }\n      return false;\n    }\n\n    entries() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeEntries(this[kInternal].set);\n    }\n\n    forEach(callback\x2C thisArg = undefined) {\n      ArrayPrototypeForEach(\n        this[kInternal].array\x2C\n        (v) => ReflectApply(callback\x2C thisArg\x2C [v\x2C v\x2C this])\x2C\n      );\n    }\n\n    get size() {\n      return this[kInternal].array.length;\n    }\n\n    values() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeValues(this[kInternal].set);\n    }\n  }\n  const flagSetValues = NodeEnvironmentFlagsSet.prototype.values;\n  ObjectDefineProperty(NodeEnvironmentFlagsSet.prototype\x2C SymbolIterator\x2C {\n    __proto__: null\x2C\n    value: flagSetValues\x2C\n  });\n  ObjectDefineProperty(NodeEnvironmentFlagsSet.prototype\x2C 'keys'\x2C {\n    __proto__: null\x2C\n    value: flagSetValues\x2C\n  });\n\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype.constructor);\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype);\n\n  return ObjectFreeze(new NodeEnvironmentFlagsSet(\n    allowedNodeEnvironmentFlags\x2C\n  ));\n}\n\n// Lazy load internal/trace_events_async_hooks only if the async_hooks\n// trace event category is enabled.\nlet traceEventsAsyncHook;\n// Dynamically enable/disable the traceEventsAsyncHook\nfunction toggleTraceCategoryState(asyncHooksEnabled) {\n  if (asyncHooksEnabled) {\n    if (!traceEventsAsyncHook) {\n      traceEventsAsyncHook =\n        require('internal/trace_events_async_hooks').createHook();\n    }\n    traceEventsAsyncHook.enable();\n  } else if (traceEventsAsyncHook) {\n    traceEventsAsyncHook.disable();\n  }\n}\n\nmodule.exports = {\n  toggleTraceCategoryState\x2C\n  assert\x2C\n  buildAllowedFlags\x2C\n  wrapProcessMethods\x2C\n  hrtime\x2C\n  hrtimeBigInt\x2C\n  refreshHrtimeBuffer\x2C\n};\n
code-source-info,0x30e767707ff0,37,11907,12204,C0O11931C4O11960C10O11995C16O12026C21O12070C26O12071C33O12016C39O12095C44O12116C49O12116C55O12135C61O12167C66O12188C71O12188C76O12203,,
code-creation,LazyCompile,10,52542,0x30e767708f20,42,setupPerfHooks node:internal/process/pre_execution:372:24,0x202f02877a00,~
code-source-info,0x30e767708f20,447,11232,11352,C0O11239C6O11239C11O11275C16O11276C20O11299C26O11299C31O11329C36O11330C41O11351,,
tick,0x1959c2b88,52584,0,0x0,3,0x0,0x30e767707e80,0x202f0287b4d7,0x202f02879dd8,0x202f028761e9
new,MemoryChunk,0x110040000,262144
code-creation,Function,11,52625,0x110048060,768,requireBuiltin node:internal/bootstrap/loaders:357:24,0x41ccf059250,^
script-source,15,node:internal/bootstrap/loaders,// This file creates the internal module & binding loaders used by built-in\n// modules. In contrast\x2C user land modules are loaded using\n// lib/internal/modules/cjs/loader.js (CommonJS Modules) or\n// lib/internal/modules/esm/* (ES Modules).\n//\n// This file is compiled and run by node.cc before bootstrap/node.js\n// was called\x2C therefore the loaders are bootstrapped before we start to\n// actually bootstrap Node.js. It creates the following objects:\n//\n// C++ binding loaders:\n// - process.binding(): the legacy C++ binding loader\x2C accessible from user land\n//   because it is an object attached to the global process object.\n//   These C++ bindings are created using NODE_BUILTIN_MODULE_CONTEXT_AWARE()\n//   and have their nm_flags set to NM_F_BUILTIN. We do not make any guarantees\n//   about the stability of these bindings\x2C but still have to take care of\n//   compatibility issues caused by them from time to time.\n// - process._linkedBinding(): intended to be used by embedders to add\n//   additional C++ bindings in their applications. These C++ bindings\n//   can be created using NODE_BINDING_CONTEXT_AWARE_CPP() with the flag\n//   NM_F_LINKED.\n// - internalBinding(): the private internal C++ binding loader\x2C inaccessible\n//   from user land unless through `require('internal/test/binding')`.\n//   These C++ bindings are created using NODE_BINDING_CONTEXT_AWARE_INTERNAL()\n//   and have their nm_flags set to NM_F_INTERNAL.\n//\n// Internal JavaScript module loader:\n// - BuiltinModule: a minimal module system used to load the JavaScript core\n//   modules found in lib/**/*.js and deps/**/*.js. All core modules are\n//   compiled into the node binary via node_javascript.cc generated by js2c.py\x2C\n//   so they can be loaded faster without the cost of I/O. This class makes the\n//   lib/internal/*\x2C deps/internal/* modules and internalBinding() available by\n//   default to core modules\x2C and lets the core modules require itself via\n//   require('internal/bootstrap/loaders') even when this file is not written in\n//   CommonJS style.\n//\n// Other objects:\n// - process.moduleLoadList: an array recording the bindings and the modules\n//   loaded in the process and the order in which they are loaded.\n\n'use strict';\n\n// This file is compiled as if it's wrapped in a function with arguments\n// passed by node::RunBootstrapping()\n/* global process\x2C getLinkedBinding\x2C getInternalBinding\x2C primordials */\n\nconst {\n  ArrayFrom\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  Error\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectGet\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeStartsWith\x2C\n  TypeError\x2C\n} = primordials;\n\n// Set up process.moduleLoadList.\nconst moduleLoadList = [];\nObjectDefineProperty(process\x2C 'moduleLoadList'\x2C {\n  __proto__: null\x2C\n  value: moduleLoadList\x2C\n  configurable: true\x2C\n  enumerable: true\x2C\n  writable: false\x2C\n});\n\n\n// internalBindingAllowlist contains the name of internalBinding modules\n// that are allowed for access via process.binding()... This is used\n// to provide a transition path for modules that are being moved over to\n// internalBinding.\nconst internalBindingAllowlist = new SafeSet([\n  'async_wrap'\x2C\n  'buffer'\x2C\n  'cares_wrap'\x2C\n  'config'\x2C\n  'constants'\x2C\n  'contextify'\x2C\n  'crypto'\x2C\n  'fs'\x2C\n  'fs_event_wrap'\x2C\n  'http_parser'\x2C\n  'icu'\x2C\n  'inspector'\x2C\n  'js_stream'\x2C\n  'natives'\x2C\n  'os'\x2C\n  'pipe_wrap'\x2C\n  'process_wrap'\x2C\n  'signal_wrap'\x2C\n  'spawn_sync'\x2C\n  'stream_wrap'\x2C\n  'tcp_wrap'\x2C\n  'tls_wrap'\x2C\n  'tty_wrap'\x2C\n  'udp_wrap'\x2C\n  'url'\x2C\n  'util'\x2C\n  'uv'\x2C\n  'v8'\x2C\n  'zlib'\x2C\n]);\n\nconst runtimeDeprecatedList = new SafeSet([\n  'async_wrap'\x2C\n  'crypto'\x2C\n  'http_parser'\x2C\n  'signal_wrap'\x2C\n  'url'\x2C\n  'v8'\x2C\n]);\n\nconst legacyWrapperList = new SafeSet([\n  'util'\x2C\n]);\n\n// Modules that can only be imported via the node: scheme.\nconst schemelessBlockList = new SafeSet([\n  'test'\x2C\n  'test/reporters'\x2C\n]);\n\n// Set up process.binding() and process._linkedBinding().\n{\n  const bindingObj = ObjectCreate(null);\n\n  process.binding = function binding(module) {\n    module = String(module);\n    // Deprecated specific process.binding() modules\x2C but not all\x2C allow\n    // selective fallback to internalBinding for the deprecated ones.\n    if (internalBindingAllowlist.has(module)) {\n      if (runtimeDeprecatedList.has(module)) {\n        runtimeDeprecatedList.delete(module);\n        process.emitWarning(\n          `Access to process.binding('${module}') is deprecated.`\x2C\n          'DeprecationWarning'\x2C\n          'DEP0111');\n      }\n      if (legacyWrapperList.has(module)) {\n        return requireBuiltin('internal/legacy/processbinding')[module]();\n      }\n      return internalBinding(module);\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    throw new Error(`No such module: ${module}`);\n  };\n\n  process._linkedBinding = function _linkedBinding(module) {\n    module = String(module);\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object')\n      mod = bindingObj[module] = getLinkedBinding(module);\n    return mod;\n  };\n}\n\n// Set up internalBinding() in the closure.\n/**\n * @type {InternalBinding}\n */\nlet internalBinding;\n{\n  const bindingObj = ObjectCreate(null);\n  // eslint-disable-next-line no-global-assign\n  internalBinding = function internalBinding(module) {\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object') {\n      mod = bindingObj[module] = getInternalBinding(module);\n      ArrayPrototypePush(moduleLoadList\x2C `Internal Binding ${module}`);\n    }\n    return mod;\n  };\n}\n\nconst loaderId = 'internal/bootstrap/loaders';\nconst {\n  builtinIds\x2C\n  compileFunction\x2C\n} = internalBinding('builtins');\n\nconst getOwn = (target\x2C property\x2C receiver) => {\n  return ObjectPrototypeHasOwnProperty(target\x2C property) ?\n    ReflectGet(target\x2C property\x2C receiver) :\n    undefined;\n};\n\n/**\n * An internal abstraction for the built-in JavaScript modules of Node.js.\n * Be careful not to expose this to user land unless --expose-internals is\n * used\x2C in which case there is no compatibility guarantee about this class.\n */\nclass BuiltinModule {\n  /**\n   * A map from the module IDs to the module instances.\n   * @type {Map<string\x2C BuiltinModule>}\n   */\n  static map = new SafeMap(\n    ArrayPrototypeMap(builtinIds\x2C (id) => [id\x2C new BuiltinModule(id)])\x2C\n  );\n\n  constructor(id) {\n    this.filename = `${id}.js`;\n    this.id = id;\n    this.canBeRequiredByUsers = !StringPrototypeStartsWith(id\x2C 'internal/');\n\n    // The CJS exports object of the module.\n    this.exports = {};\n    // States used to work around circular dependencies.\n    this.loaded = false;\n    this.loading = false;\n\n    // The following properties are used by the ESM implementation and only\n    // initialized when the built-in module is loaded by users.\n    /**\n     * The C++ ModuleWrap binding used to interface with the ESM implementation.\n     * @type {ModuleWrap|undefined}\n     */\n    this.module = undefined;\n    /**\n     * Exported names for the ESM imports.\n     * @type {string[]|undefined}\n     */\n    this.exportKeys = undefined;\n  }\n\n  // To be called during pre-execution when --expose-internals is on.\n  // Enables the user-land module loader to access internal modules.\n  static exposeInternals() {\n    for (const { 0: id\x2C 1: mod } of BuiltinModule.map) {\n      // Do not expose this to user land even with --expose-internals.\n      if (id !== loaderId) {\n        mod.canBeRequiredByUsers = true;\n      }\n    }\n  }\n\n  static exists(id) {\n    return BuiltinModule.map.has(id);\n  }\n\n  static canBeRequiredByUsers(id) {\n    const mod = BuiltinModule.map.get(id);\n    return mod && mod.canBeRequiredByUsers;\n  }\n\n  // Determine if a core module can be loaded without the node: prefix. This\n  // function does not validate if the module actually exists.\n  static canBeRequiredWithoutScheme(id) {\n    return !schemelessBlockList.has(id);\n  }\n\n  static getSchemeOnlyModuleNames() {\n    return ArrayFrom(schemelessBlockList);\n  }\n\n  // Used by user-land module loaders to compile and load builtins.\n  compileForPublicLoader() {\n    if (!this.canBeRequiredByUsers) {\n      // No code because this is an assertion against bugs\n      // eslint-disable-next-line no-restricted-syntax\n      throw new Error(`Should not compile ${this.id} for public use`);\n    }\n    this.compileForInternalLoader();\n    if (!this.exportKeys) {\n      // When using --expose-internals\x2C we do not want to reflect the named\n      // exports from core modules as this can trigger unnecessary getters.\n      const internal = StringPrototypeStartsWith(this.id\x2C 'internal/');\n      this.exportKeys = internal ? [] : ObjectKeys(this.exports);\n    }\n    this.getESMFacade();\n    this.syncExports();\n    return this.exports;\n  }\n\n  getESMFacade() {\n    if (this.module) return this.module;\n    const { ModuleWrap } = internalBinding('module_wrap');\n    // TODO(aduh95): move this to C++\x2C alongside the initialization of the class.\n    ObjectSetPrototypeOf(ModuleWrap.prototype\x2C null);\n    const url = `node:${this.id}`;\n    const builtin = this;\n    const exportsKeys = ArrayPrototypeSlice(this.exportKeys);\n    ArrayPrototypePush(exportsKeys\x2C 'default');\n    this.module = new ModuleWrap(\n      url\x2C undefined\x2C exportsKeys\x2C\n      function() {\n        builtin.syncExports();\n        this.setExport('default'\x2C builtin.exports);\n      });\n    // Ensure immediate sync execution to capture exports now\n    this.module.instantiate();\n    this.module.evaluate(-1\x2C false);\n    return this.module;\n  }\n\n  // Provide named exports for all builtin libraries so that the libraries\n  // may be imported in a nicer way for ESM users. The default export is left\n  // as the entire namespace (module.exports) and updates when this function is\n  // called so that APMs and other behavior are supported.\n  syncExports() {\n    const names = this.exportKeys;\n    if (this.module) {\n      for (let i = 0; i < names.length; i++) {\n        const exportName = names[i];\n        if (exportName === 'default') continue;\n        this.module.setExport(exportName\x2C\n                              getOwn(this.exports\x2C exportName\x2C this.exports));\n      }\n    }\n  }\n\n  compileForInternalLoader() {\n    if (this.loaded || this.loading) {\n      return this.exports;\n    }\n\n    const id = this.id;\n    this.loading = true;\n\n    try {\n      const requireFn = StringPrototypeStartsWith(this.id\x2C 'internal/deps/') ?\n        requireWithFallbackInDeps : requireBuiltin;\n\n      const fn = compileFunction(id);\n      // Arguments must match the parameters specified in\n      // BuiltinLoader::LookupAndCompile().\n      fn(this.exports\x2C requireFn\x2C this\x2C process\x2C internalBinding\x2C primordials);\n\n      this.loaded = true;\n    } finally {\n      this.loading = false;\n    }\n\n    // "NativeModule" is a legacy name of "BuiltinModule". We keep it\n    // here to avoid breaking users who parse process.moduleLoadList.\n    ArrayPrototypePush(moduleLoadList\x2C `NativeModule ${id}`);\n    return this.exports;\n  }\n}\n\n// Think of this as module.exports in this file even though it is not\n// written in CommonJS style.\nconst loaderExports = {\n  internalBinding\x2C\n  BuiltinModule\x2C\n  require: requireBuiltin\x2C\n};\n\nfunction requireBuiltin(id) {\n  if (id === loaderId) {\n    return loaderExports;\n  }\n\n  const mod = BuiltinModule.map.get(id);\n  // Can't load the internal errors module from here\x2C have to use a raw error.\n  // eslint-disable-next-line no-restricted-syntax\n  if (!mod) throw new TypeError(`Missing internal module '${id}'`);\n  return mod.compileForInternalLoader();\n}\n\n// Allow internal modules from dependencies to require\n// other modules from dependencies by providing fallbacks.\nfunction requireWithFallbackInDeps(request) {\n  if (!BuiltinModule.map.has(request)) {\n    request = `internal/deps/${request}`;\n  }\n  return requireBuiltin(request);\n}\n\n// Pass the exports back to C++ land for C++ internals to use.\nreturn loaderExports;\n
code-source-info,0x110048060,15,11178,11522,,,
code-creation,Function,11,53167,0x1100483c0,152,isPosixPathSeparator node:path:56:30,0x28e4ce8ccc20,^
code-source-info,0x1100483c0,74,1854,1902,,,
code-creation,Function,11,53209,0x1100484c0,3616,normalizeString node:path:66:25,0x28e4ce8cccc0,^
code-source-info,0x1100484c0,74,2161,4085,,,
code-creation,Function,11,53250,0x110049340,664,getOptionValue node:internal/options:44:24,0x25dc1a859c90,^
code-source-info,0x110049340,88,985,1228,,,
code-creation,LazyCompile,10,53292,0x30e767709e68,42,refreshTimeOrigin node:internal/perf/performance:227:27,0x250200ae79c8,~
script-source,119,node:internal/perf/performance,'use strict';\n\nconst {\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n    ERR_MISSING_ARGS\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  EventTarget\x2C\n  Event\x2C\n  kTrustEvent\x2C\n} = require('internal/event_target');\n\nconst { now } = require('internal/perf/utils');\n\nconst { markResourceTiming } = require('internal/perf/resource_timing');\n\nconst {\n  mark\x2C\n  measure\x2C\n  clearMarkTimings\x2C\n} = require('internal/perf/usertiming');\nconst {\n  clearEntriesFromBuffer\x2C\n  filterBufferMapByNameAndType\x2C\n  setResourceTimingBufferSize\x2C\n  setDispatchBufferFull\x2C\n} = require('internal/perf/observe');\n\nconst eventLoopUtilization = require('internal/perf/event_loop_utilization');\nconst nodeTiming = require('internal/perf/nodetiming');\nconst timerify = require('internal/perf/timerify');\nconst { customInspectSymbol: kInspect } = require('internal/util');\nconst { inspect } = require('util');\n\nconst {\n  getTimeOriginTimestamp\x2C\n} = internalBinding('performance');\n\nclass Performance extends EventTarget {\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0) return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\x2C\n    };\n\n    return `Performance ${inspect({\n      nodeTiming: this.nodeTiming\x2C\n      timeOrigin: this.timeOrigin\x2C\n    }\x2C opts)}`;\n  }\n}\n\nfunction toJSON() {\n  return {\n    nodeTiming: this.nodeTiming\x2C\n    timeOrigin: this.timeOrigin\x2C\n    eventLoopUtilization: this.eventLoopUtilization()\x2C\n  };\n}\n\nfunction clearMarks(name) {\n  if (name !== undefined) {\n    name = `${name}`;\n  }\n  clearMarkTimings(name);\n  clearEntriesFromBuffer('mark'\x2C name);\n}\n\nfunction clearMeasures(name) {\n  if (name !== undefined) {\n    name = `${name}`;\n  }\n  clearEntriesFromBuffer('measure'\x2C name);\n}\n\nfunction clearResourceTimings(name) {\n  if (name !== undefined) {\n    name = `${name}`;\n  }\n  clearEntriesFromBuffer('resource'\x2C name);\n}\n\nfunction getEntries() {\n  return filterBufferMapByNameAndType();\n}\n\nfunction getEntriesByName(name) {\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('name');\n  }\n  name = `${name}`;\n  return filterBufferMapByNameAndType(name\x2C undefined);\n}\n\nfunction getEntriesByType(type) {\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('type');\n  }\n  type = `${type}`;\n  return filterBufferMapByNameAndType(undefined\x2C type);\n}\n\nclass InternalPerformance extends EventTarget {}\nInternalPerformance.prototype.constructor = Performance.prototype.constructor;\nObjectSetPrototypeOf(InternalPerformance.prototype\x2C Performance.prototype);\n\nObjectDefineProperties(Performance.prototype\x2C {\n  clearMarks: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: clearMarks\x2C\n  }\x2C\n  clearMeasures: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: clearMeasures\x2C\n  }\x2C\n  clearResourceTimings: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: clearResourceTimings\x2C\n  }\x2C\n  eventLoopUtilization: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: eventLoopUtilization\x2C\n  }\x2C\n  getEntries: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntries\x2C\n  }\x2C\n  getEntriesByName: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntriesByName\x2C\n  }\x2C\n  getEntriesByType: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntriesByType\x2C\n  }\x2C\n  mark: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: mark\x2C\n  }\x2C\n  measure: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: measure\x2C\n  }\x2C\n  nodeTiming: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: nodeTiming\x2C\n  }\x2C\n  // In the browser\x2C this function is not public.  However\x2C it must be used inside fetch\n  // which is a Node.js dependency\x2C not a internal module\n  markResourceTiming: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: markResourceTiming\x2C\n  }\x2C\n  now: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: now\x2C\n  }\x2C\n  setResourceTimingBufferSize: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: setResourceTimingBufferSize\x2C\n  }\x2C\n  timerify: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: timerify\x2C\n  }\x2C\n  // This would be updated during pre-execution in case\n  // the process is launched from a snapshot.\n  // TODO(joyeecheung): we may want to warn about access to\n  // this during snapshot building.\n  timeOrigin: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: getTimeOriginTimestamp()\x2C\n  }\x2C\n  toJSON: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: toJSON\x2C\n  }\x2C\n});\n\nfunction refreshTimeOrigin() {\n  ObjectDefineProperty(Performance.prototype\x2C 'timeOrigin'\x2C {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: getTimeOriginTimestamp()\x2C\n  });\n}\n\nconst performance = new InternalPerformance();\n\nfunction dispatchBufferFull(type) {\n  const event = new Event(type\x2C {\n    [kTrustEvent]: true\x2C\n  });\n  performance.dispatchEvent(event);\n}\nsetDispatchBufferFull(dispatchBufferFull);\n\nmodule.exports = {\n  Performance\x2C\n  performance\x2C\n  refreshTimeOrigin\x2C\n};\n
code-source-info,0x30e767709e68,119,4985,5163,C0O4992C7O5013C10O5025C25O5130C28O5130C35O4992C41O5162,,
code-creation,LazyCompile,10,53584,0x30e76770a7a8,19,refreshTimeOrigin node:internal/perf/utils:25:27,0x26f3988d048,~
script-source,53,node:internal/perf/utils,'use strict';\n\nconst binding = internalBinding('performance');\nconst {\n  milestones\x2C\n  getTimeOrigin\x2C\n} = binding;\n\n// TODO(joyeecheung): we may want to warn about access to\n// this during snapshot building.\nlet timeOrigin = getTimeOrigin();\n\nfunction now() {\n  const hr = process.hrtime();\n  return (hr[0] * 1000 + hr[1] / 1e6) - timeOrigin;\n}\n\nfunction getMilestoneTimestamp(milestoneIdx) {\n  const ns = milestones[milestoneIdx];\n  if (ns === -1)\n    return ns;\n  return ns / 1e6 - timeOrigin;\n}\n\nfunction refreshTimeOrigin() {\n  timeOrigin = getTimeOrigin();\n}\n\nmodule.exports = {\n  now\x2C\n  getMilestoneTimestamp\x2C\n  refreshTimeOrigin\x2C\n};\n
code-source-info,0x30e76770a7a8,53,525,563,C0O532C5O545C11O543C18O562,,
code-creation,LazyCompile,10,53667,0x30e76770aa18,62,setupInspectorHooks node:internal/process/pre_execution:377:29,0x202f02877a50,~
code-source-info,0x30e76770aa18,447,11382,11936,C0O11725C6O11729C11O11754C17O11820C23O11820C28O11789C33O11803C38O11866C44O11866C49O11894C54O11895C61O11935,,
code-creation,Eval,10,53709,0x30e76770adb8,5, node:internal/inspector_async_hook:1:1,0x30e76770ac00,~
script-source,448,node:internal/inspector_async_hook,'use strict';\n\nlet hook;\nlet config;\n\nconst {\n  SafeSet\x2C\n} = primordials;\n\nfunction lazyHookCreation() {\n  const inspector = internalBinding('inspector');\n  const { createHook } = require('async_hooks');\n  config = internalBinding('config');\n\n  hook = createHook({\n    init(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n    // It's difficult to tell which tasks will be recurring and which won't\x2C\n    // therefore we mark all tasks as recurring. Based on the discussion\n    // in https://github.com/nodejs/node/pull/13870#discussion_r124515293\x2C\n    // this should be fine as long as we call asyncTaskCanceled() too.\n      const recurring = true;\n      if (type === 'PROMISE')\n        this.promiseIds.add(asyncId);\n      else\n        inspector.asyncTaskScheduled(type\x2C asyncId\x2C recurring);\n    }\x2C\n\n    before(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskStarted(asyncId);\n    }\x2C\n\n    after(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskFinished(asyncId);\n    }\x2C\n\n    destroy(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return this.promiseIds.delete(asyncId);\n      inspector.asyncTaskCanceled(asyncId);\n    }\x2C\n  });\n\n  hook.promiseIds = new SafeSet();\n}\n\nfunction enable() {\n  if (hook === undefined) lazyHookCreation();\n  if (config.bits < 64) {\n    // V8 Inspector stores task ids as (void*) pointers.\n    // async_hooks store ids as 64bit numbers.\n    // As a result\x2C we cannot reliably translate async_hook ids to V8 async_task\n    // ids on 32bit platforms.\n    process.emitWarning(\n      'Warning: Async stack traces in debugger are not available ' +\n      `on ${config.bits}bit platforms. The feature is disabled.`\x2C\n      {\n        code: 'INSPECTOR_ASYNC_STACK_TRACES_NOT_AVAILABLE'\x2C\n      });\n  } else {\n    hook.enable();\n  }\n}\n\nfunction disable() {\n  if (hook === undefined) lazyHookCreation();\n  hook.disable();\n}\n\nmodule.exports = {\n  enable\x2C\n  disable\x2C\n};\n
code-source-info,0x30e76770adb8,448,0,1973,C0O0C4O1973,,
code-creation,Function,10,53834,0x30e76770afd8,79, node:internal/inspector_async_hook:1:1,0x30e76770ad30,~
code-source-info,0x30e76770afd8,448,0,1973,C0O0C42O19C43O19C45O29C46O29C48O48C54O1930C61O1951C67O1961C73O1945C78O1972,,
code-creation,LazyCompile,10,53917,0x30e76770b568,126,setupWarningHandler node:internal/process/pre_execution:191:29,0x202f028775b8,~
code-source-info,0x30e76770b568,447,5925,6417,C0O5925C11O5988C19O5988C24O5944C30O5959C36O6027C46O6031C57O6075C62O6079C69O6096C74O6111C79O6119C90O6119C96O6246C103O6250C108O6280C120O6280C125O6416,,
code-creation,LazyCompile,10,53959,0x30e76770bab8,202,setupFetch node:internal/process/pre_execution:212:20,0x202f02877608,~
code-source-info,0x30e76770bab8,447,6472,7584,C0O6472C24O6479C29O6491C34O6498C39O6508C49O6541C55O6541C61O6590C62O6597C63O6609C64O6609C66O6867C77O6883C86O6867C91O7160C102O7183C113O7211C124O7251C135O7290C146O7330C154O7160C159O7473C167O7473C172O7447C177O7509C185O7509C190O7540C195O7541C201O7583,,
tick,0x195a846b8,54000,0,0x0,3,0x0,0x30e767708f44,0x202f0287b4dd,0x202f02879dd8,0x202f028761e9
code-creation,LazyCompile,10,54000,0x30e76770bd28,5,get node:internal/bootstrap/node:171:6,0x41ccf05d5c8,~
script-source,16,node:internal/bootstrap/node,// Hello\x2C and welcome to hacking node.js!\n//\n// This file is invoked by `Realm::BootstrapNode()` in `src/node_realm.cc`\x2C\n// and is responsible for setting up Node.js core before main scripts\n// under `lib/internal/main/` are executed.\n//\n// By default\x2C Node.js binaries come with an embedded V8 startup snapshot\n// that is generated at build-time with a `node_mksnapshot` executable.\n// The snapshot generation code can be found in `SnapshotBuilder::Generate()`\n// from `src/node_snapshotable.cc`.\n// This snapshot captures the V8 heap initialized by scripts under\n// `lib/internal/bootstrap/`\x2C including this file. When initializing the main\n// thread\x2C Node.js deserializes the heap from the snapshot\x2C instead of actually\n// running this script and others in `lib/internal/bootstrap/`. To disable this\n// behavior\x2C pass `--no-node-snapshot` when starting the process so that\n// Node.js actually runs this script to initialize the heap.\n//\n// This script is expected not to perform any asynchronous operations itself\n// when being executed - those should be done in either\n// `lib/internal/process/pre_execution.js` or in main scripts. It should not\n// query any run-time states (e.g. command line arguments\x2C environment\n// variables) when being executed - functions in this script that are invoked\n// at a later time can\x2C however\x2C query those states lazily.\n// The majority of the code here focuses on setting up the global object and\n// the process object in a synchronous\x2C environment-independent manner.\n//\n// Scripts run before this file:\n// - `lib/internal/per_context/primordials.js`: this saves copies of JavaScript\n//   builtins that won't be affected by user land monkey-patching for internal\n//   modules to use.\n// - `lib/internal/per_context/domexception.js`: implementation of the\n//   `DOMException` class.\n// - `lib/internal/per_context/messageport.js`: JS-side components of the\n//   `MessagePort` implementation.\n// - `lib/internal/bootstrap/loaders.js`: this sets up internal binding and\n//   module loaders\x2C including `process.binding()`\x2C `process._linkedBinding()`\x2C\n//   `internalBinding()` and `BuiltinModule`.\n//\n// The initialization done in this script is included in both the main thread\n// and the worker threads. After this\x2C further initialization is done based\n// on the configuration of the Node.js instance by executing the scripts in\n// `lib/internal/bootstrap/switches/`.\n//\n// Then\x2C depending on how the Node.js instance is launched\x2C one of the main\n// scripts in `lib/internal/main` will be selected by C++ to start the actual\n// execution. They may run additional setups exported by\n// `lib/internal/process/pre_execution.js` depending on the run-time states.\n\n'use strict';\n\n// This file is compiled as if it's wrapped in a function with arguments\n// passed by `BuiltinLoader::CompileAndCall()`.\n/* global process\x2C require\x2C internalBinding\x2C primordials */\n\nsetupPrepareStackTrace();\n\nconst {\n  FunctionPrototypeCall\x2C\n  JSONParse\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectPreventExtensions\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectGet\x2C\n  ReflectSet\x2C\n  SymbolToStringTag\x2C\n  globalThis\x2C\n} = primordials;\nconst config = internalBinding('config');\nconst internalTimers = require('internal/timers');\nconst {\n  defineOperation\x2C\n  deprecate\x2C\n  exposeInterface\x2C\n} = require('internal/util');\nconst {\n  privateSymbols: {\n    exiting_aliased_Uint32Array\x2C\n  }\x2C\n} = internalBinding('util');\n\nsetupProcessObject();\n\nsetupGlobalProxy();\nsetupBuffer();\n\nprocess.domain = null;\n{\n  const exitingAliasedUint32Array = process[exiting_aliased_Uint32Array];\n  ObjectDefineProperty(process\x2C '_exiting'\x2C {\n    __proto__: null\x2C\n    get() {\n      return exitingAliasedUint32Array[0] === 1;\n    }\x2C\n    set(value) {\n      exitingAliasedUint32Array[0] = value ? 1 : 0;\n    }\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n  });\n}\nprocess._exiting = false;\n\n// TODO(@jasnell): Once this has gone through one full major\n// release cycle\x2C remove the Proxy and setter and update the\n// getter to either return a read-only object or always return\n// a freshly parsed version of nativeModule.config.\n\nconst deprecationHandler = {\n  warned: false\x2C\n  message: 'Setting process.config is deprecated. ' +\n           'In the future the property will be read-only.'\x2C\n  code: 'DEP0150'\x2C\n  maybeWarn() {\n    if (!this.warned) {\n      process.emitWarning(this.message\x2C {\n        type: 'DeprecationWarning'\x2C\n        code: this.code\x2C\n      });\n      this.warned = true;\n    }\n  }\x2C\n\n  defineProperty(target\x2C key\x2C descriptor) {\n    this.maybeWarn();\n    return ObjectDefineProperty(target\x2C key\x2C descriptor);\n  }\x2C\n\n  deleteProperty(target\x2C key) {\n    this.maybeWarn();\n    delete target[key];\n  }\x2C\n\n  preventExtensions(target) {\n    this.maybeWarn();\n    return ObjectPreventExtensions(target);\n  }\x2C\n\n  set(target\x2C key\x2C value) {\n    this.maybeWarn();\n    return ReflectSet(target\x2C key\x2C value);\n  }\x2C\n\n  get(target\x2C key\x2C receiver) {\n    const val = ReflectGet(target\x2C key\x2C receiver);\n    if (val != null && typeof val === 'object') {\n      // eslint-disable-next-line node-core/prefer-primordials\n      return new Proxy(val\x2C deprecationHandler);\n    }\n    return val;\n  }\x2C\n\n  setPrototypeOf(target\x2C proto) {\n    this.maybeWarn();\n    return ObjectSetPrototypeOf(target\x2C proto);\n  }\x2C\n};\n\n// process.config is serialized config.gypi\nconst binding = internalBinding('builtins');\n\n// eslint-disable-next-line node-core/prefer-primordials\nlet processConfig = new Proxy(\n  JSONParse(binding.config)\x2C\n  deprecationHandler);\n\nObjectDefineProperty(process\x2C 'config'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  configurable: true\x2C\n  get() { return processConfig; }\x2C\n  set(value) {\n    deprecationHandler.maybeWarn();\n    processConfig = value;\n  }\x2C\n});\n\nrequire('internal/worker/js_transferable').setup();\n\n// Bootstrappers for all threads\x2C including worker threads and main thread\nconst perThreadSetup = require('internal/process/per_thread');\nconst rawMethods = internalBinding('process_methods');\n\n// Set up methods on the process object for all threads\n{\n  process.dlopen = rawMethods.dlopen;\n  process.uptime = rawMethods.uptime;\n\n  // TODO(joyeecheung): either remove them or make them public\n  process._getActiveRequests = rawMethods._getActiveRequests;\n  process._getActiveHandles = rawMethods._getActiveHandles;\n  process.getActiveResourcesInfo = rawMethods.getActiveResourcesInfo;\n\n  // TODO(joyeecheung): remove these\n  process.reallyExit = rawMethods.reallyExit;\n  process._kill = rawMethods._kill;\n\n  const wrapped = perThreadSetup.wrapProcessMethods(rawMethods);\n  process._rawDebug = wrapped._rawDebug;\n  process.cpuUsage = wrapped.cpuUsage;\n  process.resourceUsage = wrapped.resourceUsage;\n  process.memoryUsage = wrapped.memoryUsage;\n  process.constrainedMemory = rawMethods.constrainedMemory;\n  process.kill = wrapped.kill;\n  process.exit = wrapped.exit;\n\n  process.hrtime = perThreadSetup.hrtime;\n  process.hrtime.bigint = perThreadSetup.hrtimeBigInt;\n\n  process.openStdin = function() {\n    process.stdin.resume();\n    return process.stdin;\n  };\n}\n\nconst credentials = internalBinding('credentials');\nif (credentials.implementsPosixCredentials) {\n  process.getuid = credentials.getuid;\n  process.geteuid = credentials.geteuid;\n  process.getgid = credentials.getgid;\n  process.getegid = credentials.getegid;\n  process.getgroups = credentials.getgroups;\n}\n\n// Setup the callbacks that node::AsyncWrap will call when there are hooks to\n// process. They use the same functions as the JS embedder API. These callbacks\n// are setup immediately to prevent async_wrap.setupHooks() from being hijacked\n// and the cost of doing so is negligible.\nconst { nativeHooks } = require('internal/async_hooks');\ninternalBinding('async_wrap').setupHooks(nativeHooks);\n\nconst {\n  setupTaskQueue\x2C\n  queueMicrotask\x2C\n} = require('internal/process/task_queues');\n\n// Non-standard extensions:\nconst { BroadcastChannel } = require('internal/worker/io');\nexposeInterface(globalThis\x2C 'BroadcastChannel'\x2C BroadcastChannel);\n\ndefineOperation(globalThis\x2C 'queueMicrotask'\x2C queueMicrotask);\n\nconst timers = require('timers');\ndefineOperation(globalThis\x2C 'clearImmediate'\x2C timers.clearImmediate);\ndefineOperation(globalThis\x2C 'setImmediate'\x2C timers.setImmediate);\n\nconst {\n  structuredClone\x2C\n} = require('internal/structured_clone');\ndefineOperation(globalThis\x2C 'structuredClone'\x2C structuredClone);\n\n// Set the per-Environment callback that will be called\n// when the TrackingTraceStateObserver updates trace state.\n// Note that when NODE_USE_V8_PLATFORM is true\x2C the observer is\n// attached to the per-process TracingController.\nconst { setTraceCategoryStateUpdateHandler } = internalBinding('trace_events');\nsetTraceCategoryStateUpdateHandler(perThreadSetup.toggleTraceCategoryState);\n\n// process.allowedNodeEnvironmentFlags\nObjectDefineProperty(process\x2C 'allowedNodeEnvironmentFlags'\x2C {\n  __proto__: null\x2C\n  get() {\n    const flags = perThreadSetup.buildAllowedFlags();\n    process.allowedNodeEnvironmentFlags = flags;\n    return process.allowedNodeEnvironmentFlags;\n  }\x2C\n  // If the user tries to set this to another value\x2C override\n  // this completely to that value.\n  set(value) {\n    ObjectDefineProperty(this\x2C 'allowedNodeEnvironmentFlags'\x2C {\n      __proto__: null\x2C\n      value\x2C\n      configurable: true\x2C\n      enumerable: true\x2C\n      writable: true\x2C\n    });\n  }\x2C\n  enumerable: true\x2C\n  configurable: true\x2C\n});\n\n// process.assert\nprocess.assert = deprecate(\n  perThreadSetup.assert\x2C\n  'process.assert() is deprecated. Please use the `assert` module instead.'\x2C\n  'DEP0100');\n\n// TODO(joyeecheung): this property has not been well-maintained\x2C should we\n// deprecate it in favor of a better API?\nconst { isDebugBuild\x2C hasOpenSSL\x2C hasInspector } = config;\nconst features = {\n  inspector: hasInspector\x2C\n  debug: isDebugBuild\x2C\n  uv: true\x2C\n  ipv6: true\x2C  // TODO(bnoordhuis) ping libuv\n  tls_alpn: hasOpenSSL\x2C\n  tls_sni: hasOpenSSL\x2C\n  tls_ocsp: hasOpenSSL\x2C\n  tls: hasOpenSSL\x2C\n  // This needs to be dynamic because --no-node-snapshot disables the\n  // code cache even if the binary is built with embedded code cache.\n  get cached_builtins() {\n    return binding.hasCachedBuiltins();\n  }\x2C\n};\n\nObjectDefineProperty(process\x2C 'features'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  writable: false\x2C\n  configurable: false\x2C\n  value: features\x2C\n});\n\n{\n  const {\n    onGlobalUncaughtException\x2C\n    setUncaughtExceptionCaptureCallback\x2C\n    hasUncaughtExceptionCaptureCallback\x2C\n  } = require('internal/process/execution');\n\n  // For legacy reasons this is still called `_fatalException`\x2C even\n  // though it is now a global uncaught exception handler.\n  // The C++ land node::errors::TriggerUncaughtException grabs it\n  // from the process object because it has been monkey-patchable.\n  // TODO(joyeecheung): investigate whether process._fatalException\n  // can be deprecated.\n  process._fatalException = onGlobalUncaughtException;\n  process.setUncaughtExceptionCaptureCallback =\n    setUncaughtExceptionCaptureCallback;\n  process.hasUncaughtExceptionCaptureCallback =\n    hasUncaughtExceptionCaptureCallback;\n}\n\nconst { emitWarning } = require('internal/process/warning');\nprocess.emitWarning = emitWarning;\n\n// We initialize the tick callbacks and the timer callbacks last during\n// bootstrap to make sure that any operation done before this are synchronous.\n// If any ticks or timers are scheduled before this they are unlikely to work.\n{\n  const { nextTick\x2C runNextTicks } = setupTaskQueue();\n  process.nextTick = nextTick;\n  // Used to emulate a tick manually in the JS land.\n  // A better name for this function would be `runNextTicks` but\n  // it has been exposed to the process object so we keep this legacy name\n  // TODO(joyeecheung): either remove it or make it public\n  process._tickCallback = runNextTicks;\n\n  const { setupTimers } = internalBinding('timers');\n  const {\n    processImmediate\x2C\n    processTimers\x2C\n  } = internalTimers.getTimerCallbacks(runNextTicks);\n  // Sets two per-Environment callbacks that will be run from libuv:\n  // - processImmediate will be run in the callback of the per-Environment\n  //   check handle.\n  // - processTimers will be run in the callback of the per-Environment timer.\n  setupTimers(processImmediate\x2C processTimers);\n  // Note: only after this point are the timers effective\n}\n\n// Preload modules so that they are included in the builtin snapshot.\nrequire('fs');\nrequire('v8');\nrequire('vm');\nrequire('url');\nrequire('internal/options');\nif (config.hasOpenSSL) {\n  require('crypto');\n}\n\nfunction setupPrepareStackTrace() {\n  const {\n    setEnhanceStackForFatalException\x2C\n    setPrepareStackTraceCallback\x2C\n  } = internalBinding('errors');\n  const {\n    prepareStackTrace\x2C\n    fatalExceptionStackEnhancers: {\n      beforeInspector\x2C\n      afterInspector\x2C\n    }\x2C\n  } = require('internal/errors');\n  // Tell our PrepareStackTraceCallback passed to the V8 API\n  // to call prepareStackTrace().\n  setPrepareStackTraceCallback(prepareStackTrace);\n  // Set the function used to enhance the error stack for printing\n  setEnhanceStackForFatalException(beforeInspector\x2C afterInspector);\n}\n\nfunction setupProcessObject() {\n  const EventEmitter = require('events');\n  const origProcProto = ObjectGetPrototypeOf(process);\n  ObjectSetPrototypeOf(origProcProto\x2C EventEmitter.prototype);\n  FunctionPrototypeCall(EventEmitter\x2C process);\n  ObjectDefineProperty(process\x2C SymbolToStringTag\x2C {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    writable: true\x2C\n    configurable: false\x2C\n    value: 'process'\x2C\n  });\n\n  // Create global.process as getters so that we have a\n  // deprecation path for these in ES Modules.\n  // See https://github.com/nodejs/node/pull/26334.\n  let _process = process;\n  ObjectDefineProperty(globalThis\x2C 'process'\x2C {\n    __proto__: null\x2C\n    get() {\n      return _process;\n    }\x2C\n    set(value) {\n      _process = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n  });\n}\n\nfunction setupGlobalProxy() {\n  ObjectDefineProperty(globalThis\x2C SymbolToStringTag\x2C {\n    __proto__: null\x2C\n    value: 'global'\x2C\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n  });\n  globalThis.global = globalThis;\n}\n\nfunction setupBuffer() {\n  const {\n    Buffer\x2C\n  } = require('buffer');\n  const bufferBinding = internalBinding('buffer');\n\n  // Only after this point can C++ use Buffer::New()\n  bufferBinding.setBufferPrototype(Buffer.prototype);\n  delete bufferBinding.setBufferPrototype;\n  delete bufferBinding.zeroFill;\n\n  // Create global.Buffer as getters so that we have a\n  // deprecation path for these in ES Modules.\n  // See https://github.com/nodejs/node/pull/26334.\n  let _Buffer = Buffer;\n  ObjectDefineProperty(globalThis\x2C 'Buffer'\x2C {\n    __proto__: null\x2C\n    get() {\n      return _Buffer;\n    }\x2C\n    set(value) {\n      _Buffer = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n  });\n}\n
code-source-info,0x30e76770bd28,16,5621,5649,C0O5626C4O5647,,
code-creation,LazyCompile,10,54667,0x30e76770cc98,52,get node:internal/bootstrap/node:144:6,0x41ccf05d528,~
code-source-info,0x30e76770cc98,16,4902,5166,C0O4944C14O4944C20O4983C29O5098C35O5120C43O5105C48O5140C49O5151C51O5162,,
code-creation,LazyCompile,10,54709,0x30e76770cf38,33,lazyInterface node:internal/process/pre_execution:234:25,0x30e76770b910,~
code-source-info,0x30e76770cf38,447,6937,7156,C0O6937C9O6950C14O7016C22O7074C32O7152,,
code-creation,Eval,10,54750,0x30e76770d410,5, node:internal/wasm_web_api:1:1,0x30e76770d268,~
script-source,449,node:internal/wasm_web_api,'use strict';\n\nconst {\n  PromiseResolve\x2C\n} = primordials;\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_WEBASSEMBLY_RESPONSE\x2C\n} = require('internal/errors').codes;\n\nlet undici;\nfunction lazyUndici() {\n  return undici ??= require('internal/deps/undici/undici');\n}\n\n// This is essentially an implementation of a v8::WasmStreamingCallback\x2C except\n// that it is implemented in JavaScript because the fetch() implementation is\n// difficult to use from C++. See lib/internal/process/pre_execution.js and\n// src/node_wasm_web_api.cc that interact with this function.\nfunction wasmStreamingCallback(streamState\x2C source) {\n  (async () => {\n    const response = await PromiseResolve(source);\n    if (!(response instanceof lazyUndici().Response)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'source'\x2C ['Response'\x2C 'Promise resolving to Response']\x2C response);\n    }\n\n    const contentType = response.headers.get('Content-Type');\n    if (contentType !== 'application/wasm') {\n      throw new ERR_WEBASSEMBLY_RESPONSE(\n        `has unsupported MIME type '${contentType}'`);\n    }\n\n    if (!response.ok) {\n      throw new ERR_WEBASSEMBLY_RESPONSE(\n        `has status code ${response.status}`);\n    }\n\n    if (response.bodyUsed !== false) {\n      throw new ERR_WEBASSEMBLY_RESPONSE('body has already been used');\n    }\n\n    if (response.url) {\n      streamState.setURL(response.url);\n    }\n\n    // Pass all data from the response body to the WebAssembly compiler.\n    const { body } = response;\n    if (body != null) {\n      for await (const chunk of body) {\n        streamState.push(chunk);\n      }\n    }\n  })().then(() => {\n    // No error occurred. Tell the implementation that the stream has ended.\n    streamState.finish();\n  }\x2C (err) => {\n    // An error occurred\x2C either because the given object was not a valid\n    // and usable Response or because a network error occurred.\n    streamState.abort(err);\n  });\n}\n\nmodule.exports = {\n  wasmStreamingCallback\x2C\n};\n
code-source-info,0x30e76770d410,449,0,1948,C0O0C4O1948,,
code-creation,Function,10,54875,0x30e76770d5a8,88, node:internal/wasm_web_api:1:1,0x30e76770d388,~
code-source-info,0x30e76770d5a8,449,0,1948,C0O0C32O25C38O122C44O122C49O148C54O68C60O92C66O161C67O161C69O1901C76O1922C82O1916C87O1947,,
code-creation,LazyCompile,10,54959,0x30e76770dfc8,256,setupWebCrypto node:internal/process/pre_execution:261:24,0x202f028776b8,~
code-source-info,0x30e76770dfc8,447,7713,8540,C0O7713C8O7720C13O7732C18O7739C23O7749C33O7783C39O7783C45O7840C46O7847C47O7859C48O7859C50O7872C61O7893C76O7960C107O7960C120O7872C125O8234C133O8238C138O8263C144O8282C158O8296C162O8292C164O8338C175O8354C184O8386C189O8338C194O8399C205O8415C214O8450C219O8399C224O8466C235O8482C244O8520C249O8466C255O8539,,
code-creation,LazyCompile,10,55000,0x30e76770e2d0,74,setupCustomEvent node:internal/process/pre_execution:298:26,0x202f02877780,~
code-source-info,0x30e76770e2d0,447,9196,9457,C0O9203C3O9215C8O9222C13O9232C21O9266C27O9266C33O9325C34O9332C35O9363C41O9363C46O9347C51O9399C58O9415C67O9399C73O9456,,
code-creation,LazyCompile,10,55000,0x30e76770e488,64,setupCodeCoverage node:internal/process/pre_execution:283:27,0x202f02877730,~
code-source-info,0x30e76770e488,447,8568,9063,C0O8874C3O8886C8O8890C16O8917C22O8917C28O8971C31O8979C38O9008C44O9035C49O9039C54O9008C58O9000C63O9062,,
code-creation,LazyCompile,10,55042,0x30e76770e668,75,setupDebugEnv node:internal/process/pre_execution:329:23,0x202f02877898,~
code-source-info,0x30e76770e668,447,9955,10166,C0O9962C6O9962C11O9995C19O10023C24O10027C29O9996C34O10042C42O10046C48O10090C54O10090C59O10127C64O10141C69O10142C74O10165,,
tick,0x195a4df24,55084,0,0x0,3,0x0,0x202f0287b501,0x202f02879dd8,0x202f028761e9
code-creation,LazyCompile,10,55125,0x30e76770e9e8,159,initializeDebugEnv node:internal/util/debuglog:22:28,0x1012a3968480,~
script-source,28,node:internal/util/debuglog,'use strict';\n\nconst {\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  RegExp\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n} = primordials;\n\nconst { inspect\x2C format\x2C formatWithOptions } = require('internal/util/inspect');\n\n// `debugImpls` and `testEnabled` are deliberately not initialized so any call\n// to `debuglog()` before `initializeDebugEnv()` is called will throw.\nlet debugImpls;\nlet testEnabled;\n\n\n// `debugEnv` is initial value of process.env.NODE_DEBUG\nfunction initializeDebugEnv(debugEnv) {\n  debugImpls = ObjectCreate(null);\n  if (debugEnv) {\n    // This is run before any user code\x2C it's OK not to use primordials.\n    debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g\x2C '\\\\$&')\n      .replaceAll('*'\x2C '.*')\n      .replaceAll('\x2C'\x2C '$|^');\n    const debugEnvRegex = new RegExp(`^${debugEnv}$`\x2C 'i');\n    testEnabled = (str) => RegExpPrototypeExec(debugEnvRegex\x2C str) !== null;\n  } else {\n    testEnabled = () => false;\n  }\n}\n\n// Emits warning when user sets\n// NODE_DEBUG=http or NODE_DEBUG=http2.\nfunction emitWarningIfNeeded(set) {\n  if ('HTTP' === set || 'HTTP2' === set) {\n    process.emitWarning('Setting the NODE_DEBUG environment variable ' +\n      'to \\'' + StringPrototypeToLowerCase(set) + '\\' can expose sensitive ' +\n      'data (such as passwords\x2C tokens and authentication headers) ' +\n      'in the resulting log.');\n  }\n}\n\nconst noop = () => {};\n\nlet utilColors;\nfunction lazyUtilColors() {\n  utilColors ??= require('internal/util/colors');\n  return utilColors;\n}\n\nfunction debuglogImpl(enabled\x2C set) {\n  if (debugImpls[set] === undefined) {\n    if (enabled) {\n      const pid = process.pid;\n      emitWarningIfNeeded(set);\n      debugImpls[set] = function debug(...args) {\n        const colors = lazyUtilColors().shouldColorize(process.stderr);\n        const msg = formatWithOptions({ colors }\x2C ...args);\n        const coloredPID = inspect(pid\x2C { colors });\n        process.stderr.write(format('%s %s: %s\\n'\x2C set\x2C coloredPID\x2C msg));\n      };\n    } else {\n      debugImpls[set] = noop;\n    }\n  }\n  return debugImpls[set];\n}\n\n// debuglogImpl depends on process.pid and process.env.NODE_DEBUG\x2C\n// so it needs to be called lazily in top scopes of internal modules\n// that may be loaded before these run time states are allowed to\n// be accessed.\nfunction debuglog(set\x2C cb) {\n  function init() {\n    set = StringPrototypeToUpperCase(set);\n    enabled = testEnabled(set);\n  }\n  let debug = (...args) => {\n    init();\n    // Only invokes debuglogImpl() when the debug function is\n    // called for the first time.\n    debug = debuglogImpl(enabled\x2C set);\n    if (typeof cb === 'function')\n      cb(debug);\n    switch (args.length) {\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  let enabled;\n  let test = () => {\n    init();\n    test = () => enabled;\n    return enabled;\n  };\n  const logger = (...args) => {\n    switch (args.length) {\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  ObjectDefineProperty(logger\x2C 'enabled'\x2C {\n    __proto__: null\x2C\n    get() {\n      return test();\n    }\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n  });\n  return logger;\n}\n\nmodule.exports = {\n  debuglog\x2C\n  initializeDebugEnv\x2C\n};\n
code-source-info,0x30e76770e9e8,28,546,991,C0O561C7O574C14O572C20O596C31O709C44O709C51O753C62O754C69O782C80O783C88O833C100O848C116O833C121O833C123O871C132O883C144O959C151O971C158O990,,
code-creation,LazyCompile,10,55750,0x30e76770f0c0,62,initializeReport node:internal/process/pre_execution:317:26,0x202f02877820,~
code-source-info,0x30e76770f0c0,447,9711,9931,C0O9711C8O9737C16O9737C21O9726C27O9775C42O9796C47O9888C55O9775C61O9930,,
code-creation,Eval,10,55834,0x30e76770f638,5, node:internal/process/report:1:1,0x30e76770f440,~
script-source,450,node:internal/process/report,'use strict';\nconst {\n  ERR_SYNTHETIC\x2C\n} = require('internal/errors').codes;\nconst {\n  validateBoolean\x2C\n  validateObject\x2C\n  validateSignalName\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst nr = internalBinding('report');\nconst {\n  JSONParse\x2C\n} = primordials;\nconst report = {\n  writeReport(file\x2C err) {\n    if (typeof file === 'object' && file !== null) {\n      err = file;\n      file = undefined;\n    } else if (file !== undefined) {\n      validateString(file\x2C 'file');\n    }\n\n    if (err === undefined) {\n      err = new ERR_SYNTHETIC();\n    } else {\n      validateObject(err\x2C 'err');\n    }\n\n    return nr.writeReport('JavaScript API'\x2C 'API'\x2C file\x2C err);\n  }\x2C\n  getReport(err) {\n    if (err === undefined)\n      err = new ERR_SYNTHETIC();\n    else\n      validateObject(err\x2C 'err');\n\n    return JSONParse(nr.getReport(err));\n  }\x2C\n  get directory() {\n    return nr.getDirectory();\n  }\x2C\n  set directory(dir) {\n    validateString(dir\x2C 'directory');\n    nr.setDirectory(dir);\n  }\x2C\n  get filename() {\n    return nr.getFilename();\n  }\x2C\n  set filename(name) {\n    validateString(name\x2C 'filename');\n    nr.setFilename(name);\n  }\x2C\n  get compact() {\n    return nr.getCompact();\n  }\x2C\n  set compact(b) {\n    validateBoolean(b\x2C 'compact');\n    nr.setCompact(b);\n  }\x2C\n  get signal() {\n    return nr.getSignal();\n  }\x2C\n  set signal(sig) {\n    validateSignalName(sig\x2C 'signal');\n    removeSignalHandler();\n    addSignalHandler(sig);\n    nr.setSignal(sig);\n  }\x2C\n  get reportOnFatalError() {\n    return nr.shouldReportOnFatalError();\n  }\x2C\n  set reportOnFatalError(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnFatalError(trigger);\n  }\x2C\n  get reportOnSignal() {\n    return nr.shouldReportOnSignal();\n  }\x2C\n  set reportOnSignal(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnSignal(trigger);\n    removeSignalHandler();\n    addSignalHandler();\n  }\x2C\n  get reportOnUncaughtException() {\n    return nr.shouldReportOnUncaughtException();\n  }\x2C\n  set reportOnUncaughtException(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnUncaughtException(trigger);\n  }\x2C\n};\n\nfunction addSignalHandler(sig) {\n  if (nr.shouldReportOnSignal()) {\n    if (typeof sig !== 'string')\n      sig = nr.getSignal();\n\n    process.on(sig\x2C signalHandler);\n  }\n}\n\nfunction removeSignalHandler() {\n  const sig = nr.getSignal();\n\n  if (sig)\n    process.removeListener(sig\x2C signalHandler);\n}\n\nfunction signalHandler(sig) {\n  nr.writeReport(sig\x2C 'Signal'\x2C null\x2C '');\n}\n\nmodule.exports = {\n  addSignalHandler\x2C\n  report\x2C\n};\n
code-source-info,0x30e76770f638,450,0,2548,C0O0C4O2548,,
code-creation,Function,10,56000,0x30e767710148,306, node:internal/process/report:1:1,0x30e76770f5b0,~
code-source-info,0x30e767710148,450,0,2548,C0O0C48O43C51O43C56O69C61O24C67O166C70O166C75O87C81O106C87O124C93O146C99O209C102O209C106O209C108O246C114O289C119O293C127O679C281O2496C288O2517C294O2537C300O2511C305O2547,,
code-creation,LazyCompile,10,56125,0x30e767711de8,35,initializeSourceMapsHandlers node:internal/process/pre_execution:573:38,0x202f02877c80,~
code-source-info,0x30e767711de8,447,18252,18502,C0O18318C6O18318C11O18267C16O18289C21O18369C26O18398C30O18477C34O18501,,
code-creation,Eval,10,56334,0x30e767712a58,5, node:internal/source_map/source_map_cache:1:1,0x30e767712680,~
script-source,451,node:internal/source_map/source_map_cache,'use strict';\n\nconst {\n  ArrayPrototypeMap\x2C\n  JSONParse\x2C\n  ObjectCreate\x2C\n  ObjectKeys\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeSymbolSplit\x2C\n  SafeMap\x2C\n  StringPrototypeSplit\x2C\n} = primordials;\n\nfunction ObjectGetValueSafe(obj\x2C key) {\n  const desc = ObjectGetOwnPropertyDescriptor(obj\x2C key);\n  return ObjectPrototypeHasOwnProperty(desc\x2C 'value') ? desc.value : undefined;\n}\n\n// See https://sourcemaps.info/spec.html for SourceMap V3 specification.\nconst { Buffer } = require('buffer');\nlet debug = require('internal/util/debuglog').debuglog('source_map'\x2C (fn) => {\n  debug = fn;\n});\nconst fs = require('fs');\nconst { getOptionValue } = require('internal/options');\nconst { IterableWeakMap } = require('internal/util/iterable_weak_map');\nconst {\n  normalizeReferrerURL\x2C\n} = require('internal/modules/cjs/helpers');\nconst { validateBoolean } = require('internal/validators');\nconst { setMaybeCacheGeneratedSourceMap } = internalBinding('errors');\n\n// Since the CJS module cache is mutable\x2C which leads to memory leaks when\n// modules are deleted\x2C we use a WeakMap so that the source map cache will\n// be purged automatically:\nconst cjsSourceMapCache = new IterableWeakMap();\n// The esm cache is not mutable\x2C so we can use a Map without memory concerns:\nconst esmSourceMapCache = new SafeMap();\n// The generated sources is not mutable\x2C so we can use a Map without memory concerns:\nconst generatedSourceMapCache = new SafeMap();\nconst kLeadingProtocol = /^\\w+:\\/\\//;\nconst kSourceMappingURLMagicComment = /\\/[*/]#\\s+sourceMappingURL=(?<sourceMappingURL>[^\\s]+)/g;\nconst kSourceURLMagicComment = /\\/[*/]#\\s+sourceURL=(?<sourceURL>[^\\s]+)/g;\n\nconst { fileURLToPath\x2C pathToFileURL\x2C URL } = require('internal/url');\nlet SourceMap;\n\nlet sourceMapsEnabled;\nfunction getSourceMapsEnabled() {\n  if (sourceMapsEnabled === undefined) {\n    setSourceMapsEnabled(getOptionValue('--enable-source-maps'));\n  }\n  return sourceMapsEnabled;\n}\n\nfunction setSourceMapsEnabled(val) {\n  validateBoolean(val\x2C 'val');\n\n  const {\n    setSourceMapsEnabled\x2C\n    setPrepareStackTraceCallback\x2C\n  } = internalBinding('errors');\n  setSourceMapsEnabled(val);\n  if (val) {\n    const {\n      prepareStackTrace\x2C\n    } = require('internal/source_map/prepare_stack_trace');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  } else if (sourceMapsEnabled !== undefined) {\n    // Reset prepare stack trace callback only when disabling source maps.\n    const {\n      prepareStackTrace\x2C\n    } = require('internal/errors');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  }\n\n  sourceMapsEnabled = val;\n}\n\nfunction extractSourceURLMagicComment(content) {\n  let match;\n  let matchSourceURL;\n  // A while loop is used here to get the last occurrence of sourceURL.\n  // This is needed so that we don't match sourceURL in string literals.\n  while ((match = RegExpPrototypeExec(kSourceURLMagicComment\x2C content))) {\n    matchSourceURL = match;\n  }\n  if (matchSourceURL == null) {\n    return null;\n  }\n  let sourceURL = matchSourceURL.groups.sourceURL;\n  if (sourceURL != null && RegExpPrototypeExec(kLeadingProtocol\x2C sourceURL) === null) {\n    sourceURL = pathToFileURL(sourceURL).href;\n  }\n  return sourceURL;\n}\n\nfunction extractSourceMapURLMagicComment(content) {\n  let match;\n  let lastMatch;\n  // A while loop is used here to get the last occurrence of sourceMappingURL.\n  // This is needed so that we don't match sourceMappingURL in string literals.\n  while ((match = RegExpPrototypeExec(kSourceMappingURLMagicComment\x2C content))) {\n    lastMatch = match;\n  }\n  if (lastMatch == null) {\n    return null;\n  }\n  return lastMatch.groups.sourceMappingURL;\n}\n\nfunction maybeCacheSourceMap(filename\x2C content\x2C cjsModuleInstance\x2C isGeneratedSource\x2C sourceURL\x2C sourceMapURL) {\n  const sourceMapsEnabled = getSourceMapsEnabled();\n  if (!(process.env.NODE_V8_COVERAGE || sourceMapsEnabled)) return;\n  try {\n    filename = normalizeReferrerURL(filename);\n  } catch (err) {\n    // This is most likely an invalid filename in sourceURL of [eval]-wrapper.\n    debug(err);\n    return;\n  }\n\n  if (sourceMapURL === undefined) {\n    sourceMapURL = extractSourceMapURLMagicComment(content);\n  }\n\n  // Bail out when there is no source map url.\n  if (typeof sourceMapURL !== 'string') {\n    return;\n  }\n\n  if (sourceURL === undefined) {\n    sourceURL = extractSourceURLMagicComment(content);\n  }\n\n  const data = dataFromUrl(filename\x2C sourceMapURL);\n  const url = data ? null : sourceMapURL;\n  if (cjsModuleInstance) {\n    cjsSourceMapCache.set(cjsModuleInstance\x2C {\n      filename\x2C\n      lineLengths: lineLengths(content)\x2C\n      data\x2C\n      url\x2C\n      sourceURL\x2C\n    });\n  } else if (isGeneratedSource) {\n    const entry = {\n      lineLengths: lineLengths(content)\x2C\n      data\x2C\n      url\x2C\n      sourceURL\x2C\n    };\n    generatedSourceMapCache.set(filename\x2C entry);\n    if (sourceURL) {\n      generatedSourceMapCache.set(sourceURL\x2C entry);\n    }\n  } else {\n    // If there is no cjsModuleInstance and is not generated source assume we are in a\n    // "modules/esm" context.\n    const entry = {\n      lineLengths: lineLengths(content)\x2C\n      data\x2C\n      url\x2C\n      sourceURL\x2C\n    };\n    esmSourceMapCache.set(filename\x2C entry);\n    if (sourceURL) {\n      esmSourceMapCache.set(sourceURL\x2C entry);\n    }\n  }\n}\n\nfunction maybeCacheGeneratedSourceMap(content) {\n  const sourceMapsEnabled = getSourceMapsEnabled();\n  if (!(process.env.NODE_V8_COVERAGE || sourceMapsEnabled)) return;\n\n  const sourceURL = extractSourceURLMagicComment(content);\n  if (sourceURL === null) {\n    return;\n  }\n  try {\n    maybeCacheSourceMap(sourceURL\x2C content\x2C null\x2C true\x2C sourceURL);\n  } catch (err) {\n    // This can happen if the filename is not a valid URL.\n    // If we fail to cache the source map\x2C we should not fail the whole process.\n    debug(err);\n  }\n}\nsetMaybeCacheGeneratedSourceMap(maybeCacheGeneratedSourceMap);\n\nfunction dataFromUrl(sourceURL\x2C sourceMappingURL) {\n  try {\n    const url = new URL(sourceMappingURL);\n    switch (url.protocol) {\n      case 'data:':\n        return sourceMapFromDataUrl(sourceURL\x2C url.pathname);\n      default:\n        debug(`unknown protocol ${url.protocol}`);\n        return null;\n    }\n  } catch (err) {\n    debug(err);\n    // If no scheme is present\x2C we assume we are dealing with a file path.\n    const mapURL = new URL(sourceMappingURL\x2C sourceURL).href;\n    return sourceMapFromFile(mapURL);\n  }\n}\n\n// Cache the length of each line in the file that a source map was extracted\n// from. This allows translation from byte offset V8 coverage reports\x2C\n// to line/column offset Source Map V3.\nfunction lineLengths(content) {\n  // We purposefully keep \\r as part of the line-length calculation\x2C in\n  // cases where there is a \\r\\n separator\x2C so that this can be taken into\n  // account in coverage calculations.\n  return ArrayPrototypeMap(RegExpPrototypeSymbolSplit(/\\n|\\u2028|\\u2029/\x2C content)\x2C (line) => {\n    return line.length;\n  });\n}\n\nfunction sourceMapFromFile(mapURL) {\n  try {\n    const content = fs.readFileSync(fileURLToPath(mapURL)\x2C 'utf8');\n    const data = JSONParse(content);\n    return sourcesToAbsolute(mapURL\x2C data);\n  } catch (err) {\n    debug(err);\n    return null;\n  }\n}\n\n// data:[<mediatype>][;base64]\x2C<data> see:\n// https://tools.ietf.org/html/rfc2397#section-2\nfunction sourceMapFromDataUrl(sourceURL\x2C url) {\n  const { 0: format\x2C 1: data } = StringPrototypeSplit(url\x2C '\x2C');\n  const splitFormat = StringPrototypeSplit(format\x2C ';');\n  const contentType = splitFormat[0];\n  const base64 = splitFormat[splitFormat.length - 1] === 'base64';\n  if (contentType === 'application/json') {\n    const decodedData = base64 ?\n      Buffer.from(data\x2C 'base64').toString('utf8') : data;\n    try {\n      const parsedData = JSONParse(decodedData);\n      return sourcesToAbsolute(sourceURL\x2C parsedData);\n    } catch (err) {\n      debug(err);\n      return null;\n    }\n  } else {\n    debug(`unknown content-type ${contentType}`);\n    return null;\n  }\n}\n\n// If the sources are not absolute URLs after prepending of the "sourceRoot"\x2C\n// the sources are resolved relative to the SourceMap (like resolving script\n// src in a html document).\nfunction sourcesToAbsolute(baseURL\x2C data) {\n  data.sources = data.sources.map((source) => {\n    source = (data.sourceRoot || '') + source;\n    return new URL(source\x2C baseURL).href;\n  });\n  // The sources array is now resolved to absolute URLs\x2C sourceRoot should\n  // be updated to noop.\n  data.sourceRoot = '';\n  return data;\n}\n\n// WARNING: The `sourceMapCacheToObject` and `appendCJSCache` run during\n// shutdown. In particular\x2C they also run when Workers are terminated\x2C making\n// it important that they do not call out to any user-provided code\x2C including\n// built-in prototypes that might have been tampered with.\n\n// Get serialized representation of source-map cache\x2C this is used\n// to persist a cache of source-maps to disk when NODE_V8_COVERAGE is enabled.\nfunction sourceMapCacheToObject() {\n  const obj = ObjectCreate(null);\n\n  for (const { 0: k\x2C 1: v } of esmSourceMapCache) {\n    obj[k] = v;\n  }\n\n  appendCJSCache(obj);\n\n  if (ObjectKeys(obj).length === 0) {\n    return undefined;\n  }\n  return obj;\n}\n\nfunction appendCJSCache(obj) {\n  for (const value of cjsSourceMapCache) {\n    obj[ObjectGetValueSafe(value\x2C 'filename')] = {\n      lineLengths: ObjectGetValueSafe(value\x2C 'lineLengths')\x2C\n      data: ObjectGetValueSafe(value\x2C 'data')\x2C\n      url: ObjectGetValueSafe(value\x2C 'url')\x2C\n    };\n  }\n}\n\nfunction findSourceMap(sourceURL) {\n  if (RegExpPrototypeExec(kLeadingProtocol\x2C sourceURL) === null) {\n    sourceURL = pathToFileURL(sourceURL).href;\n  }\n  if (!SourceMap) {\n    SourceMap = require('internal/source_map/source_map').SourceMap;\n  }\n  let sourceMap = esmSourceMapCache.get(sourceURL) ?? generatedSourceMapCache.get(sourceURL);\n  if (sourceMap === undefined) {\n    for (const value of cjsSourceMapCache) {\n      const filename = ObjectGetValueSafe(value\x2C 'filename');\n      const cachedSourceURL = ObjectGetValueSafe(value\x2C 'sourceURL');\n      if (sourceURL === filename || sourceURL === cachedSourceURL) {\n        sourceMap = {\n          data: ObjectGetValueSafe(value\x2C 'data')\x2C\n        };\n      }\n    }\n  }\n  if (sourceMap && sourceMap.data) {\n    return new SourceMap(sourceMap.data);\n  }\n  return undefined;\n}\n\nmodule.exports = {\n  findSourceMap\x2C\n  getSourceMapsEnabled\x2C\n  setSourceMapsEnabled\x2C\n  maybeCacheSourceMap\x2C\n  sourceMapCacheToObject\x2C\n};\n
code-source-info,0x30e767712a58,451,0,10428,C0O0C4O10428,,
code-creation,Function,10,56959,0x30e767713200,512, node:internal/source_map/source_map_cache:1:1,0x30e7677129d0,~
code-source-info,0x30e767713200,451,0,10428,C0O0C182O25C188O46C194O59C200O75C206O89C212O123C218O156C224O179C230O209C235O220C241O532C247O532C252O521C258O563C264O563C269O596C282O597C288O563C290O659C296O659C300O659C302O701C308O701C313O682C319O758C325O758C330O738C335O838C341O838C346O812C352O907C358O907C363O887C369O983C375O983C380O947C385O1215C387O1215C392O1215C394O1342C396O1342C401O1342C403O1475C405O1475C410O1475C412O1515C416O1515C418O1566C422O1566C424O1656C428O1656C430O1748C436O1748C441O1710C447O1725C453O1740C459O1777C460O1777C462O1793C463O1793C465O5837C469O10292C476O10313C482O10330C488O10354C494O10378C500O10401C506O10307C511O10427,,
code-creation,Eval,10,57125,0x30e767714668,5, node:internal/util/iterable_weak_map:1:1,0x30e767714408,~
script-source,452,node:internal/util/iterable_weak_map,'use strict';\n\nconst {\n  ObjectFreeze\x2C\n  SafeFinalizationRegistry\x2C\n  SafeSet\x2C\n  SafeWeakMap\x2C\n  SafeWeakRef\x2C\n  SymbolIterator\x2C\n} = primordials;\n\n// This class is modified from the example code in the WeakRefs specification:\n// https://github.com/tc39/proposal-weakrefs\n// Licensed under ECMA's MIT-style license\x2C see:\n// https://github.com/tc39/ecma262/blob/HEAD/LICENSE.md\nclass IterableWeakMap {\n  #weakMap = new SafeWeakMap();\n  #refSet = new SafeSet();\n  #finalizationGroup = new SafeFinalizationRegistry(cleanup);\n\n  set(key\x2C value) {\n    const entry = this.#weakMap.get(key);\n    if (entry) {\n      // If there's already an entry for the object represented by "key"\x2C\n      // the value can be updated without creating a new WeakRef:\n      this.#weakMap.set(key\x2C { value\x2C ref: entry.ref });\n    } else {\n      const ref = new SafeWeakRef(key);\n      this.#weakMap.set(key\x2C { value\x2C ref });\n      this.#refSet.add(ref);\n      this.#finalizationGroup.register(key\x2C {\n        set: this.#refSet\x2C\n        ref\x2C\n      }\x2C ref);\n    }\n  }\n\n  get(key) {\n    return this.#weakMap.get(key)?.value;\n  }\n\n  has(key) {\n    return this.#weakMap.has(key);\n  }\n\n  delete(key) {\n    const entry = this.#weakMap.get(key);\n    if (!entry) {\n      return false;\n    }\n    this.#weakMap.delete(key);\n    this.#refSet.delete(entry.ref);\n    this.#finalizationGroup.unregister(entry.ref);\n    return true;\n  }\n\n  [SymbolIterator]() {\n    const iterator = this.#refSet[SymbolIterator]();\n\n    const next = () => {\n      const result = iterator.next();\n      if (result.done) return result;\n      const key = result.value.deref();\n      if (key == null) return next();\n      const { value } = this.#weakMap.get(key);\n      return { done: false\x2C value };\n    };\n\n    return {\n      [SymbolIterator]() { return this; }\x2C\n      next\x2C\n    };\n  }\n}\n\nfunction cleanup({ set\x2C ref }) {\n  set.delete(ref);\n}\n\nObjectFreeze(IterableWeakMap.prototype);\n\nmodule.exports = {\n  IterableWeakMap\x2C\n};\n
code-source-info,0x30e767714668,452,0,1959,C0O0C4O1959,,
code-creation,Function,10,57250,0x30e767714dc8,196, node:internal/util/iterable_weak_map:1:1,0x30e7677145e0,~
code-source-info,0x30e767714dc8,452,0,1959,C0O0C26O25C31O41C37O69C43O80C49O95C55O110C134O1393C168O1905C173O1876C177O1918C184O1939C190O1933C195O1958,,
code-creation,Function,10,57250,0x30e767714f48,66,<instance_members_initializer> node:internal/util/iterable_weak_map:16:1,0x30e7677148f0,~
code-source-info,0x30e767714f48,452,373,1819,C3O410C10O410C22O441C29O441C41O479C55O479C65O1819,,
code-creation,Eval,10,57417,0x30e767715ba8,5, node:internal/modules/cjs/helpers:1:1,0x30e7677158d0,~
script-source,453,node:internal/modules/cjs/helpers,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeSome\x2C\n  ObjectDefineProperty\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst {\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\n  ERR_UNKNOWN_BUILTIN_MODULE\x2C\n} = require('internal/errors').codes;\nconst { BuiltinModule } = require('internal/bootstrap/loaders');\n\nconst { validateString } = require('internal/validators');\nconst path = require('path');\nconst { pathToFileURL\x2C fileURLToPath\x2C URL } = require('internal/url');\n\nconst { getOptionValue } = require('internal/options');\nconst { setOwnProperty } = require('internal/util');\nconst userConditions = getOptionValue('--conditions');\n\nconst {\n  privateSymbols: {\n    require_private_symbol\x2C\n  }\x2C\n} = internalBinding('util');\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\n\nconst noAddons = getOptionValue('--no-addons');\nconst addonConditions = noAddons ? [] : ['node-addons'];\n\n// TODO: Use this set when resolving pkg#exports conditions in loader.js.\nconst cjsConditions = new SafeSet([\n  'require'\x2C\n  'node'\x2C\n  ...addonConditions\x2C\n  ...userConditions\x2C\n]);\n\nfunction loadBuiltinModule(filename\x2C request) {\n  const mod = BuiltinModule.map.get(filename);\n  if (mod?.canBeRequiredByUsers) {\n    debug('load built-in module %s'\x2C request);\n    // compileForPublicLoader() throws if mod.canBeRequiredByUsers is false:\n    mod.compileForPublicLoader();\n    return mod;\n  }\n}\n\n// Invoke with makeRequireFunction(module) where |module| is the Module object\n// to use as the context for the require() function.\n// Use redirects to set up a mapping from a policy and restrict dependencies\nconst urlToFileCache = new SafeMap();\nfunction makeRequireFunction(mod\x2C redirects) {\n  const Module = mod.constructor;\n\n  let require;\n  if (redirects) {\n    const id = mod.filename || mod.id;\n    const conditions = cjsConditions;\n    const { resolve\x2C reaction } = redirects;\n    require = function require(specifier) {\n      let missing = true;\n      const destination = resolve(specifier\x2C conditions);\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        if (destination.protocol === 'node:') {\n          const specifier = destination.pathname;\n          const mod = loadBuiltinModule(specifier\x2C href);\n          if (mod && mod.canBeRequiredByUsers) {\n            return mod.exports;\n          }\n          throw new ERR_UNKNOWN_BUILTIN_MODULE(specifier);\n        } else if (destination.protocol === 'file:') {\n          let filepath;\n          if (urlToFileCache.has(href)) {\n            filepath = urlToFileCache.get(href);\n          } else {\n            filepath = fileURLToPath(destination);\n            urlToFileCache.set(href\x2C filepath);\n          }\n          return mod[require_private_symbol](mod\x2C filepath);\n        }\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          id\x2C\n          specifier\x2C\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C ')\x2C\n        ));\n      }\n      return mod[require_private_symbol](mod\x2C specifier);\n    };\n  } else {\n    require = function require(path) {\n      // When no policy manifest\x2C the original prototype.require is sustained\n      return mod.require(path);\n    };\n  }\n\n  function resolve(request\x2C options) {\n    validateString(request\x2C 'request');\n    return Module._resolveFilename(request\x2C mod\x2C false\x2C options);\n  }\n\n  require.resolve = resolve;\n\n  function paths(request) {\n    validateString(request\x2C 'request');\n    return Module._resolveLookupPaths(request\x2C mod);\n  }\n\n  resolve.paths = paths;\n\n  setOwnProperty(require\x2C 'main'\x2C process.mainModule);\n\n  // Enable support to add extra extension types.\n  require.extensions = Module._extensions;\n\n  require.cache = Module._cache;\n\n  return require;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n * because the buffer-to-string conversion in `fs.readFileSync()`\n * translates it to FEFF\x2C the UTF-16 BOM.\n */\nfunction stripBOM(content) {\n  if (StringPrototypeCharCodeAt(content) === 0xFEFF) {\n    content = StringPrototypeSlice(content\x2C 1);\n  }\n  return content;\n}\n\nfunction addBuiltinLibsToObject(object\x2C dummyModuleName) {\n  // Make built-in modules available directly (loaded lazily).\n  const Module = require('internal/modules/cjs/loader').Module;\n  const { builtinModules } = Module;\n\n  // To require built-in modules in user-land and ignore modules whose\n  // `canBeRequiredByUsers` is false. So we create a dummy module object and not\n  // use `require()` directly.\n  const dummyModule = new Module(dummyModuleName);\n\n  ArrayPrototypeForEach(builtinModules\x2C (name) => {\n    // Neither add underscored modules\x2C nor ones that contain slashes (e.g.\x2C\n    // 'fs/promises') or ones that are already defined.\n    if (StringPrototypeStartsWith(name\x2C '_') ||\n        StringPrototypeIncludes(name\x2C '/') ||\n        ObjectPrototypeHasOwnProperty(object\x2C name)) {\n      return;\n    }\n    // Goals of this mechanism are:\n    // - Lazy loading of built-in modules\n    // - Having all built-in modules available as non-enumerable properties\n    // - Allowing the user to re-assign these variables as if there were no\n    //   pre-existing globals with the same name.\n\n    const setReal = (val) => {\n      // Deleting the property before re-assigning it disables the\n      // getter/setter mechanism.\n      delete object[name];\n      object[name] = val;\n    };\n\n    ObjectDefineProperty(object\x2C name\x2C {\n      __proto__: null\x2C\n      get: () => {\n        const lib = dummyModule.require(name);\n\n        try {\n          // Override the current getter/setter and set up a new\n          // non-enumerable property.\n          ObjectDefineProperty(object\x2C name\x2C {\n            __proto__: null\x2C\n            get: () => lib\x2C\n            set: setReal\x2C\n            configurable: true\x2C\n            enumerable: false\x2C\n          });\n        } catch {\n          // If the property is no longer configurable\x2C ignore the error.\n        }\n\n        return lib;\n      }\x2C\n      set: setReal\x2C\n      configurable: true\x2C\n      enumerable: false\x2C\n    });\n  });\n}\n\n/**\n *\n * @param {string | URL} referrer\n * @returns {string}\n */\nfunction normalizeReferrerURL(referrer) {\n  if (typeof referrer === 'string' && path.isAbsolute(referrer)) {\n    return pathToFileURL(referrer).href;\n  }\n  return new URL(referrer).href;\n}\n\n// For error messages only - used to check if ESM syntax is in use.\nfunction hasEsmSyntax(code) {\n  debug('Checking for ESM syntax');\n  const parser = require('internal/deps/acorn/acorn/dist/acorn').Parser;\n  let root;\n  try {\n    root = parser.parse(code\x2C { sourceType: 'module'\x2C ecmaVersion: 'latest' });\n  } catch {\n    return false;\n  }\n\n  return ArrayPrototypeSome(root.body\x2C (stmt) =>\n    stmt.type === 'ExportDefaultDeclaration' ||\n    stmt.type === 'ExportNamedDeclaration' ||\n    stmt.type === 'ImportDeclaration' ||\n    stmt.type === 'ExportAllDeclaration');\n}\n\nmodule.exports = {\n  addBuiltinLibsToObject\x2C\n  cjsConditions\x2C\n  hasEsmSyntax\x2C\n  loadBuiltinModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n};\n
code-source-info,0x30e767715ba8,453,0,7261,C0O0C4O7261,,
code-creation,Function,10,58042,0x30e767716150,578, node:internal/modules/cjs/helpers:1:1,0x30e767715b20,~
code-source-info,0x30e767716150,453,0,7261,C0O0C110O25C116O50C122O72C128O94C134O118C140O151C145O162C150O173C156O202C162O229C168O253C174O374C180O374C185O400C190O307C196O342C202O434C208O434C213O416C219O501C225O501C230O482C236O546C242O546C246O546C248O609C254O609C259O571C265O586C271O601C277O662C283O662C288O643C293O718C299O718C304O699C310O767C313O767C318O865C321O865C326O865C331O832C337O903C343O903C348O936C361O937C367O903C369O1002C372O1002C377O1057C388O1187C395O1229C396O1229C452O1251C507O1187C512O1187C514O1815C516O1815C521O1815C523O7100C530O7121C536O7147C542O7164C548O7180C554O7201C560O7224C566O7248C572O7115C577O7260,,
tick,0x19594de58,58125,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x30e767711dee,0x202f0287b513,0x202f02879dd8,0x202f028761e9
code-creation,LazyCompile,10,58417,0x30e767716ea0,16,IterableWeakMap node:internal/util/iterable_weak_map:16:1,0x30e7677146e8,~
code-source-info,0x30e767716ea0,452,373,373,C0O373C15O373,,
code-creation,LazyCompile,10,58542,0x30e767717478,31,getSourceMapsEnabled node:internal/source_map/source_map_cache:51:30,0x30e767712ad8,~
code-source-info,0x30e767717478,451,1841,1986,C0O1848C6O1891C11O1912C17O1912C22O1891C26O1959C30O1984,,
code-creation,LazyCompile,10,58667,0x30e767718078,100,setSourceMapsEnabled node:internal/source_map/source_map_cache:58:30,0x30e767712b28,~
code-source-info,0x30e767718078,451,2017,2634,C0O2027C8O2027C13O2133C19O2133C24O2071C29O2097C34O2162C38O2191C42O2247C48O2247C53O2220C58O2303C64O2361C70O2520C76O2520C81O2493C86O2552C90O2608C92O2626C99O2633,,
code-creation,LazyCompile,10,58792,0x30e7677181f0,30,validateBoolean node:internal/validators:216:25,0x1012a394bdf8,~
script-source,22,node:internal/validators,/* eslint jsdoc/require-jsdoc: "error" */\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  NumberIsInteger\x2C\n  NumberIsNaN\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  NumberParseInt\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeExec\x2C\n  String\x2C\n  StringPrototypeToUpperCase\x2C\n  StringPrototypeTrim\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_SOCKET_BAD_PORT\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\x2C\n  }\x2C\n} = require('internal/errors');\nconst { normalizeEncoding } = require('internal/util');\nconst {\n  isAsyncFunction\x2C\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst { signals } = internalBinding('constants').os;\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isInt32(value) {\n  return value === (value | 0);\n}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isUint32(value) {\n  return value === (value >>> 0);\n}\n\nconst octalReg = /^[0-7]+$/;\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string';\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land\x2C but any value higher than 0o777 will result in platform-specific\n * behaviors.\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified\x2C will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value\x2C name\x2C def) {\n  value ??= def;\n  if (typeof value === 'string') {\n    if (RegExpPrototypeExec(octalReg\x2C value) === null) {\n      throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C modeDesc);\n    }\n    value = NumberParseInt(value\x2C 8);\n  }\n\n  validateUint32(value\x2C name);\n  return value;\n}\n\n/**\n * @callback validateInteger\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInteger} */\nconst validateInteger = hideStackFrames(\n  (value\x2C name\x2C min = NumberMIN_SAFE_INTEGER\x2C max = NumberMAX_SAFE_INTEGER) => {\n    if (typeof value !== 'number')\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    if (!NumberIsInteger(value))\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    if (value < min || value > max)\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n  }\x2C\n);\n\n/**\n * @callback validateInt32\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInt32} */\nconst validateInt32 = hideStackFrames(\n  (value\x2C name\x2C min = -2147483648\x2C max = 2147483647) => {\n    // The defaults for min and max correspond to the limits of 32-bit integers.\n    if (typeof value !== 'number') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    }\n    if (!NumberIsInteger(value)) {\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    }\n    if (value < min || value > max) {\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n    }\n  }\x2C\n);\n\n/**\n * @callback validateUint32\n * @param {*} value\n * @param {string} name\n * @param {number|boolean} [positive=false]\n * @returns {asserts value is number}\n */\n\n/** @type {validateUint32} */\nconst validateUint32 = hideStackFrames((value\x2C name\x2C positive = false) => {\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n  }\n  const min = positive ? 1 : 0;\n  // 2 ** 32 === 4294967296\n  const max = 4_294_967_295;\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n  }\n});\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value\x2C name) {\n  if (typeof value !== 'string')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'string'\x2C value);\n}\n\n/**\n * @callback validateNumber\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateNumber} */\nfunction validateNumber(value\x2C name\x2C min = undefined\x2C max) {\n  if (typeof value !== 'number')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n\n  if ((min != null && value < min) || (max != null && value > max) ||\n      ((min != null || max != null) && NumberIsNaN(value))) {\n    throw new ERR_OUT_OF_RANGE(\n      name\x2C\n      `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`\x2C\n      value);\n  }\n}\n\n/**\n * @callback validateOneOf\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} oneOf\n */\n\n/** @type {validateOneOf} */\nconst validateOneOf = hideStackFrames((value\x2C name\x2C oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf\x2C value)) {\n    const allowed = ArrayPrototypeJoin(\n      ArrayPrototypeMap(oneOf\x2C (v) =>\n        (typeof v === 'string' ? `'${v}'` : String(v)))\x2C\n      '\x2C ');\n    const reason = 'must be one of: ' + allowed;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\n/**\n * @callback validateBoolean\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean}\n */\n\n/** @type {validateBoolean} */\nfunction validateBoolean(value\x2C name) {\n  if (typeof value !== 'boolean')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'boolean'\x2C value);\n}\n\n/**\n * @param {any} options\n * @param {string} key\n * @param {boolean} defaultValue\n * @returns {boolean}\n */\nfunction getOwnPropertyValueOrDefault(options\x2C key\x2C defaultValue) {\n  return options == null || !ObjectPrototypeHasOwnProperty(options\x2C key) ?\n    defaultValue :\n    options[key];\n}\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean\x2C\n *   allowFunction?: boolean\x2C\n *   nullable?: boolean\n * }} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = hideStackFrames(\n  (value\x2C name\x2C options = null) => {\n    const allowArray = getOwnPropertyValueOrDefault(options\x2C 'allowArray'\x2C false);\n    const allowFunction = getOwnPropertyValueOrDefault(options\x2C 'allowFunction'\x2C false);\n    const nullable = getOwnPropertyValueOrDefault(options\x2C 'nullable'\x2C false);\n    if ((!nullable && value === null) ||\n        (!allowArray && ArrayIsArray(value)) ||\n        (typeof value !== 'object' && (\n          !allowFunction || typeof value !== 'function'\n        ))) {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'Object'\x2C value);\n    }\n  });\n\n/**\n * @callback validateDictionary - We are using the Web IDL Standard definition\n *                                of "dictionary" here\x2C which means any value\n *                                whose Type is either Undefined\x2C Null\x2C or\n *                                Object (which includes functions).\n * @param {*} value\n * @param {string} name\n * @see https://webidl.spec.whatwg.org/#es-dictionary\n * @see https://tc39.es/ecma262/#table-typeof-operator-results\n */\n\n/** @type {validateDictionary} */\nconst validateDictionary = hideStackFrames(\n  (value\x2C name) => {\n    if (value != null && typeof value !== 'object' && typeof value !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'a dictionary'\x2C value);\n    }\n  });\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\n\n/** @type {validateArray} */\nconst validateArray = hideStackFrames((value\x2C name\x2C minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Array'\x2C value);\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\n/**\n * @callback validateStringArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string[]}\n */\n\n/** @type {validateStringArray} */\nfunction validateStringArray(value\x2C name) {\n  validateArray(value\x2C name);\n  for (let i = 0; i < value.length; i++) {\n    validateString(value[i]\x2C `${name}[${i}]`);\n  }\n}\n\n/**\n * @callback validateBooleanArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean[]}\n */\n\n/** @type {validateBooleanArray} */\nfunction validateBooleanArray(value\x2C name) {\n  validateArray(value\x2C name);\n  for (let i = 0; i < value.length; i++) {\n    validateBoolean(value[i]\x2C `${name}[${i}]`);\n  }\n}\n\n/**\n * @callback validateAbortSignalArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is AbortSignal[]}\n */\n\n/** @type {validateAbortSignalArray} */\nfunction validateAbortSignalArray(value\x2C name) {\n  validateArray(value\x2C name);\n  for (let i = 0; i < value.length; i++) {\n    const signal = value[i];\n    const indexedName = `${name}[${i}]`;\n    if (signal == null) {\n      throw new ERR_INVALID_ARG_TYPE(indexedName\x2C 'AbortSignal'\x2C signal);\n    }\n    validateAbortSignal(signal\x2C indexedName);\n  }\n}\n\n/**\n * @param {*} signal\n * @param {string} [name='signal']\n * @returns {asserts signal is keyof signals}\n */\nfunction validateSignalName(signal\x2C name = 'signal') {\n  validateString(signal\x2C name);\n\n  if (signals[signal] === undefined) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal +\n                                   ' (signals must use all capital letters)');\n    }\n\n    throw new ERR_UNKNOWN_SIGNAL(signal);\n  }\n}\n\n/**\n * @callback validateBuffer\n * @param {*} buffer\n * @param {string} [name='buffer']\n * @returns {asserts buffer is ArrayBufferView}\n */\n\n/** @type {validateBuffer} */\nconst validateBuffer = hideStackFrames((buffer\x2C name = 'buffer') => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C\n                                   ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n                                   buffer);\n  }\n});\n\n/**\n * @param {string} data\n * @param {string} encoding\n */\nfunction validateEncoding(data\x2C encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding);\n  const length = data.length;\n\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding'\x2C encoding\x2C\n                                    `is invalid for data of length ${length}`);\n  }\n}\n\n/**\n * Check that the port number is not NaN when coerced to a number\x2C\n * is an integer and that it falls within the legal range of port numbers.\n * @param {*} port\n * @param {string} [name='Port']\n * @param {boolean} [allowZero=true]\n * @returns {number}\n */\nfunction validatePort(port\x2C name = 'Port'\x2C allowZero = true) {\n  if ((typeof port !== 'number' && typeof port !== 'string') ||\n      (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||\n      +port !== (+port >>> 0) ||\n      port > 0xFFFF ||\n      (port === 0 && !allowZero)) {\n    throw new ERR_SOCKET_BAD_PORT(name\x2C port\x2C allowZero);\n  }\n  return port | 0;\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\n\n/** @type {validateAbortSignal} */\nconst validateAbortSignal = hideStackFrames((signal\x2C name) => {\n  if (signal !== undefined &&\n      (signal === null ||\n       typeof signal !== 'object' ||\n       !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'AbortSignal'\x2C signal);\n  }\n});\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validateFunction} */\nconst validateFunction = hideStackFrames((value\x2C name) => {\n  if (typeof value !== 'function')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Function'\x2C value);\n});\n\n/**\n * @callback validatePlainFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validatePlainFunction} */\nconst validatePlainFunction = hideStackFrames((value\x2C name) => {\n  if (typeof value !== 'function' || isAsyncFunction(value))\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Function'\x2C value);\n});\n\n/**\n * @callback validateUndefined\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is undefined}\n */\n\n/** @type {validateUndefined} */\nconst validateUndefined = hideStackFrames((value\x2C name) => {\n  if (value !== undefined)\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'undefined'\x2C value);\n});\n\n/**\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} union\n */\nfunction validateUnion(value\x2C name\x2C union) {\n  if (!ArrayPrototypeIncludes(union\x2C value)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C `('${ArrayPrototypeJoin(union\x2C '|')}')`\x2C value);\n  }\n}\n\n/*\n  The rules for the Link header field are described here:\n  https://www.rfc-editor.org/rfc/rfc8288.html#section-3\n\n  This regex validates any string surrounded by angle brackets\n  (not necessarily a valid URI reference) followed by zero or more\n  link-params separated by semicolons.\n*/\nconst linkValueRegExp = /^(?:<[^>]*>)(?:\\s*;\\s*[^;"\\s]+(?:=(")?[^;"\\s]*\\1)?)*$/;\n\n/**\n * @param {any} value\n * @param {string} name\n */\nfunction validateLinkHeaderFormat(value\x2C name) {\n  if (\n    typeof value === 'undefined' ||\n    !RegExpPrototypeExec(linkValueRegExp\x2C value)\n  ) {\n    throw new ERR_INVALID_ARG_VALUE(\n      name\x2C\n      value\x2C\n      'must be an array or string of format "</styles.css>; rel=preload; as=style"'\x2C\n    );\n  }\n}\n\n/**\n * @param {any} hints\n * @return {string}\n */\nfunction validateLinkHeaderValue(hints) {\n  if (typeof hints === 'string') {\n    validateLinkHeaderFormat(hints\x2C 'hints');\n    return hints;\n  } else if (ArrayIsArray(hints)) {\n    const hintsLength = hints.length;\n    let result = '';\n\n    if (hintsLength === 0) {\n      return result;\n    }\n\n    for (let i = 0; i < hintsLength; i++) {\n      const link = hints[i];\n      validateLinkHeaderFormat(link\x2C 'hints');\n      result += link;\n\n      if (i !== hintsLength - 1) {\n        result += '\x2C ';\n      }\n    }\n\n    return result;\n  }\n\n  throw new ERR_INVALID_ARG_VALUE(\n    'hints'\x2C\n    hints\x2C\n    'must be an array or string of format "</styles.css>; rel=preload; as=style"'\x2C\n  );\n}\n\nmodule.exports = {\n  isInt32\x2C\n  isUint32\x2C\n  parseFileMode\x2C\n  validateArray\x2C\n  validateStringArray\x2C\n  validateBooleanArray\x2C\n  validateAbortSignalArray\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateDictionary\x2C\n  validateEncoding\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateInteger\x2C\n  validateNumber\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validatePlainFunction\x2C\n  validatePort\x2C\n  validateSignalName\x2C\n  validateString\x2C\n  validateUint32\x2C\n  validateUndefined\x2C\n  validateUnion\x2C\n  validateAbortSignal\x2C\n  validateLinkHeaderValue\x2C\n};\n
code-source-info,0x30e7677181f0,22,5597,5708,C0O5615C6O5651C22O5657C27O5651C29O5707,,
code-creation,LazyCompile,10,59542,0x30e767719938,358,initializeDeprecations node:internal/process/pre_execution:395:32,0x202f02877aa0,~
code-source-info,0x30e767719938,447,12162,14083,C0O12191C6O12191C11O12177C16O12246C24O12246C29O12437C35O12437C40O12478C46O12478C51O12531C80O12523C108O12523C111O12849C122O12869C126O12911C137O12985C148O13075C159O13030C168O12896C177O13134C180O12867C184O12512C249O13411C255O13411C260O13390C265O13440C267O13468C278O13489C285O13630C289O13468C294O13663C298O13693C304O13729C314O13806C321O13711C326O13709C330O13892C336O13934C347O13916C352O13914C357O14082,,
tick,0x100e1c4a4,59584,0,0x0,0,0x0,0x1012a396885a,0x30e7677162b9,0x41ccf0590b7,0x1100482ec,0x30e767713355,0x41ccf0590b7,0x1100482ec,0x30e767711dee,0x202f0287b513,0x202f02879dd8,0x202f028761e9
tick,0x195a4aa2c,59625,0,0x0,3,0x0,0x202f0287b519,0x202f02879dd8,0x202f028761e9
code-creation,Eval,10,59750,0x30e76771aec8,5, node:internal/dns/utils:1:1,0x30e76771aaf0,~
script-source,454,node:internal/dns/utils,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  FunctionPrototypeBind\x2C\n  NumberParseInt\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  ObjectCreate\x2C\n  Symbol\x2C\n} = primordials;\n\nconst errors = require('internal/errors');\nconst { isIP } = require('internal/net');\nconst { getOptionValue } = require('internal/options');\nconst {\n  validateArray\x2C\n  validateInt32\x2C\n  validateOneOf\x2C\n  validateString\x2C\n} = require('internal/validators');\nlet binding;\nfunction lazyBinding() {\n  binding ??= internalBinding('cares_wrap');\n  return binding;\n}\nconst IANA_DNS_PORT = 53;\nconst IPv6RE = /^\\[([^[\\]]*)\\]/;\nconst addrSplitRE = /(^.+?)(?::(\\d+))?$/;\nconst {\n  ERR_DNS_SET_SERVERS_FAILED\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_IP_ADDRESS\x2C\n} = errors.codes;\n\nconst {\n  addSerializeCallback\x2C\n  addDeserializeCallback\x2C\n  isBuildingSnapshot\x2C\n} = require('v8').startupSnapshot;\n\nfunction validateTimeout(options) {\n  const { timeout = -1 } = { ...options };\n  validateInt32(timeout\x2C 'options.timeout'\x2C -1);\n  return timeout;\n}\n\nfunction validateTries(options) {\n  const { tries = 4 } = { ...options };\n  validateInt32(tries\x2C 'options.tries'\x2C 1);\n  return tries;\n}\n\nconst kSerializeResolver = Symbol('dns:resolver:serialize');\nconst kDeserializeResolver = Symbol('dns:resolver:deserialize');\nconst kSnapshotStates = Symbol('dns:resolver:config');\nconst kInitializeHandle = Symbol('dns:resolver:initializeHandle');\nconst kSetServersInteral = Symbol('dns:resolver:setServers');\n\n// Resolver instances correspond 1:1 to c-ares channels.\n\nclass ResolverBase {\n  constructor(options = undefined) {\n    const timeout = validateTimeout(options);\n    const tries = validateTries(options);\n    // If we are building snapshot\x2C save the states of the resolver along\n    // the way.\n    if (isBuildingSnapshot()) {\n      this[kSnapshotStates] = { timeout\x2C tries };\n    }\n    this[kInitializeHandle](timeout\x2C tries);\n  }\n\n  [kInitializeHandle](timeout\x2C tries) {\n    const { ChannelWrap } = lazyBinding();\n    this._handle = new ChannelWrap(timeout\x2C tries);\n  }\n\n  cancel() {\n    this._handle.cancel();\n  }\n\n  getServers() {\n    return ArrayPrototypeMap(this._handle.getServers() || []\x2C (val) => {\n      if (!val[1] || val[1] === IANA_DNS_PORT)\n        return val[0];\n\n      const host = isIP(val[0]) === 6 ? `[${val[0]}]` : val[0];\n      return `${host}:${val[1]}`;\n    });\n  }\n\n  setServers(servers) {\n    validateArray(servers\x2C 'servers');\n\n    // Cache the original servers because in the event of an error while\n    // setting the servers\x2C c-ares won't have any servers available for\n    // resolution.\n    const newSet = [];\n    ArrayPrototypeForEach(servers\x2C (serv\x2C index) => {\n      validateString(serv\x2C `servers[${index}]`);\n      let ipVersion = isIP(serv);\n\n      if (ipVersion !== 0)\n        return ArrayPrototypePush(newSet\x2C [ipVersion\x2C serv\x2C IANA_DNS_PORT]);\n\n      const match = RegExpPrototypeExec(IPv6RE\x2C serv);\n\n      // Check for an IPv6 in brackets.\n      if (match) {\n        ipVersion = isIP(match[1]);\n\n        if (ipVersion !== 0) {\n          const port = NumberParseInt(\n            RegExpPrototypeSymbolReplace(addrSplitRE\x2C serv\x2C '$2')) || IANA_DNS_PORT;\n          return ArrayPrototypePush(newSet\x2C [ipVersion\x2C match[1]\x2C port]);\n        }\n      }\n\n      // addr::port\n      const addrSplitMatch = RegExpPrototypeExec(addrSplitRE\x2C serv);\n\n      if (addrSplitMatch) {\n        const hostIP = addrSplitMatch[1];\n        const port = addrSplitMatch[2] || IANA_DNS_PORT;\n\n        ipVersion = isIP(hostIP);\n\n        if (ipVersion !== 0) {\n          return ArrayPrototypePush(\n            newSet\x2C [ipVersion\x2C hostIP\x2C NumberParseInt(port)]);\n        }\n      }\n\n      throw new ERR_INVALID_IP_ADDRESS(serv);\n    });\n\n    this[kSetServersInteral](newSet\x2C servers);\n  }\n\n  [kSetServersInteral](newSet\x2C servers) {\n    const orig = this._handle.getServers() || [];\n    const errorNumber = this._handle.setServers(newSet);\n\n    if (errorNumber !== 0) {\n      // Reset the servers to the old servers\x2C because ares probably unset them.\n      this._handle.setServers(ArrayPrototypeJoin(orig\x2C '\x2C'));\n      const { strerror } = lazyBinding();\n      const err = strerror(errorNumber);\n      throw new ERR_DNS_SET_SERVERS_FAILED(err\x2C servers);\n    }\n\n    if (isBuildingSnapshot()) {\n      this[kSnapshotStates].servers = newSet;\n    }\n  }\n\n\n  setLocalAddress(ipv4\x2C ipv6) {\n    validateString(ipv4\x2C 'ipv4');\n\n    if (ipv6 !== undefined) {\n      validateString(ipv6\x2C 'ipv6');\n    }\n\n    this._handle.setLocalAddress(ipv4\x2C ipv6);\n\n    if (isBuildingSnapshot()) {\n      this[kSnapshotStates].localAddress = { ipv4\x2C ipv6 };\n    }\n  }\n\n  // TODO(joyeecheung): consider exposing this if custom DNS resolvers\n  // end up being useful for snapshot users.\n  [kSerializeResolver]() {\n    this._handle = null;  // We'll restore it during deserialization.\n    addDeserializeCallback(function deserializeResolver(resolver) {\n      resolver[kDeserializeResolver]();\n    }\x2C this);\n  }\n\n  [kDeserializeResolver]() {\n    const { timeout\x2C tries\x2C localAddress\x2C servers } = this[kSnapshotStates];\n    this[kInitializeHandle](timeout\x2C tries);\n    if (localAddress) {\n      const { ipv4\x2C ipv6 } = localAddress;\n      this._handle.setLocalAddress(ipv4\x2C ipv6);\n    }\n    if (servers) {\n      this[kSetServersInteral](servers\x2C servers);\n    }\n  }\n}\n\nlet defaultResolver;\nlet dnsOrder;\n\nfunction initializeDns() {\n  const orderFromCLI = getOptionValue('--dns-result-order');\n  if (!orderFromCLI) {\n    dnsOrder ??= 'verbatim';\n  } else {\n    // Allow the deserialized application to override order from CLI.\n    dnsOrder = orderFromCLI;\n  }\n\n  if (!isBuildingSnapshot()) {\n    return;\n  }\n\n  addSerializeCallback(() => {\n    defaultResolver?.[kSerializeResolver]();\n  });\n}\n\nconst resolverKeys = [\n  'getServers'\x2C\n  'resolve'\x2C\n  'resolve4'\x2C\n  'resolve6'\x2C\n  'resolveAny'\x2C\n  'resolveCaa'\x2C\n  'resolveCname'\x2C\n  'resolveMx'\x2C\n  'resolveNaptr'\x2C\n  'resolveNs'\x2C\n  'resolvePtr'\x2C\n  'resolveSoa'\x2C\n  'resolveSrv'\x2C\n  'resolveTxt'\x2C\n  'reverse'\x2C\n];\n\nfunction getDefaultResolver() {\n  // We do this here instead of pre-execution so that the default resolver is\n  // only ever created when the user loads any dns module.\n  if (defaultResolver === undefined) {\n    defaultResolver = new ResolverBase();\n  }\n  return defaultResolver;\n}\n\nfunction setDefaultResolver(resolver) {\n  defaultResolver = resolver;\n}\n\nfunction bindDefaultResolver(target\x2C source) {\n  const defaultResolver = getDefaultResolver();\n  ArrayPrototypeForEach(resolverKeys\x2C (key) => {\n    target[key] = FunctionPrototypeBind(source[key]\x2C defaultResolver);\n  });\n}\n\nfunction validateHints(hints) {\n  const { AI_ADDRCONFIG\x2C AI_ALL\x2C AI_V4MAPPED } = lazyBinding();\n  if ((hints & ~(AI_ADDRCONFIG | AI_ALL | AI_V4MAPPED)) !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('hints'\x2C hints);\n  }\n}\n\nlet invalidHostnameWarningEmitted = false;\nfunction emitInvalidHostnameWarning(hostname) {\n  if (!invalidHostnameWarningEmitted) {\n    process.emitWarning(\n      `The provided hostname "${hostname}" is not a valid ` +\n      'hostname\x2C and is supported in the dns module solely for compatibility.'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0118'\x2C\n    );\n    invalidHostnameWarningEmitted = true;\n  }\n}\n\nfunction getDefaultVerbatim() {\n  return dnsOrder !== 'ipv4first';\n}\n\nfunction setDefaultResultOrder(value) {\n  validateOneOf(value\x2C 'dnsOrder'\x2C ['verbatim'\x2C 'ipv4first']);\n  dnsOrder = value;\n}\n\nfunction getDefaultResultOrder() {\n  return dnsOrder;\n}\n\nfunction createResolverClass(resolver) {\n  const resolveMap = ObjectCreate(null);\n\n  class Resolver extends ResolverBase {}\n\n  Resolver.prototype.resolveAny = resolveMap.ANY = resolver('queryAny');\n  Resolver.prototype.resolve4 = resolveMap.A = resolver('queryA');\n  Resolver.prototype.resolve6 = resolveMap.AAAA = resolver('queryAaaa');\n  Resolver.prototype.resolveCaa = resolveMap.CAA = resolver('queryCaa');\n  Resolver.prototype.resolveCname = resolveMap.CNAME = resolver('queryCname');\n  Resolver.prototype.resolveMx = resolveMap.MX = resolver('queryMx');\n  Resolver.prototype.resolveNs = resolveMap.NS = resolver('queryNs');\n  Resolver.prototype.resolveTxt = resolveMap.TXT = resolver('queryTxt');\n  Resolver.prototype.resolveSrv = resolveMap.SRV = resolver('querySrv');\n  Resolver.prototype.resolvePtr = resolveMap.PTR = resolver('queryPtr');\n  Resolver.prototype.resolveNaptr = resolveMap.NAPTR = resolver('queryNaptr');\n  Resolver.prototype.resolveSoa = resolveMap.SOA = resolver('querySoa');\n  Resolver.prototype.reverse = resolver('getHostByAddr');\n\n  return {\n    resolveMap\x2C\n    Resolver\x2C\n  };\n}\n\n// ERROR CODES\nconst errorCodes = {\n  NODATA: 'ENODATA'\x2C\n  FORMERR: 'EFORMERR'\x2C\n  SERVFAIL: 'ESERVFAIL'\x2C\n  NOTFOUND: 'ENOTFOUND'\x2C\n  NOTIMP: 'ENOTIMP'\x2C\n  REFUSED: 'EREFUSED'\x2C\n  BADQUERY: 'EBADQUERY'\x2C\n  BADNAME: 'EBADNAME'\x2C\n  BADFAMILY: 'EBADFAMILY'\x2C\n  BADRESP: 'EBADRESP'\x2C\n  CONNREFUSED: 'ECONNREFUSED'\x2C\n  TIMEOUT: 'ETIMEOUT'\x2C\n  EOF: 'EOF'\x2C\n  FILE: 'EFILE'\x2C\n  NOMEM: 'ENOMEM'\x2C\n  DESTRUCTION: 'EDESTRUCTION'\x2C\n  BADSTR: 'EBADSTR'\x2C\n  BADFLAGS: 'EBADFLAGS'\x2C\n  NONAME: 'ENONAME'\x2C\n  BADHINTS: 'EBADHINTS'\x2C\n  NOTINITIALIZED: 'ENOTINITIALIZED'\x2C\n  LOADIPHLPAPI: 'ELOADIPHLPAPI'\x2C\n  ADDRGETNETWORKPARAMS: 'EADDRGETNETWORKPARAMS'\x2C\n  CANCELLED: 'ECANCELLED'\x2C\n};\n\nmodule.exports = {\n  bindDefaultResolver\x2C\n  getDefaultResolver\x2C\n  setDefaultResolver\x2C\n  validateHints\x2C\n  validateTimeout\x2C\n  validateTries\x2C\n  emitInvalidHostnameWarning\x2C\n  getDefaultVerbatim\x2C\n  getDefaultResultOrder\x2C\n  setDefaultResultOrder\x2C\n  errorCodes\x2C\n  createResolverClass\x2C\n  initializeDns\x2C\n};\n
code-source-info,0x30e76771aec8,454,0,9563,C0O0C4O9563,,
code-creation,Function,10,60209,0x30e76771bfb0,631, node:internal/dns/utils:1:1,0x30e76771ae40,~
code-source-info,0x30e76771bfb0,454,0,9563,C0O0C187O25C193O50C199O72C205O93C211O115C217O140C223O158C229O181C235O213C241O229C246O270C249O270C254O315C257O315C262O306C268O367C271O367C276O348C282O477C285O477C290O406C296O423C302O440C308O457C314O513C315O513C317O634C319O634C321O653C325O653C327O691C331O691C333O813C338O723C344O753C350O778C356O905C359O905C364O918C369O831C375O855C381O881C387O1250C390O1250C394O1250C396O1313C399O1313C403O1313C405O1373C408O1373C412O1373C414O1430C417O1430C421O1430C423O1498C426O1498C430O1498C443O1969C471O3831C487O4796C497O5020C518O1592C520O5375C521O5375C523O5396C524O5396C526O5816C530O5816C532O6891C533O6891C535O8650C540O9265C547O9286C553O9309C559O9331C565O9353C571O9370C577O9389C583O9406C589O9436C595O9458C601O9483C607O9508C613O9522C619O9545C625O9280C630O9562,,
code-creation,Eval,10,60542,0x30e76771d970,5, node:internal/net:1:1,0x30e76771d7a8,~
script-source,455,node:internal/net,'use strict';\n\nconst {\n  RegExp\x2C\n  RegExpPrototypeTest\x2C\n  Symbol\x2C\n} = primordials;\n\nconst Buffer = require('buffer').Buffer;\nconst { writeBuffer } = internalBinding('fs');\nconst errors = require('internal/errors');\n\n// IPv4 Segment\nconst v4Seg = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';\nconst v4Str = `(${v4Seg}[.]){3}${v4Seg}`;\nconst IPv4Reg = new RegExp(`^${v4Str}$`);\n\n// IPv6 Segment\nconst v6Seg = '(?:[0-9a-fA-F]{1\x2C4})';\nconst IPv6Reg = new RegExp('^(' +\n  `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` +\n  `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` +\n  `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1\x2C2}|:)|` +\n  `(?:${v6Seg}:){4}(?:(:${v6Seg}){0\x2C1}:${v4Str}|(:${v6Seg}){1\x2C3}|:)|` +\n  `(?:${v6Seg}:){3}(?:(:${v6Seg}){0\x2C2}:${v4Str}|(:${v6Seg}){1\x2C4}|:)|` +\n  `(?:${v6Seg}:){2}(?:(:${v6Seg}){0\x2C3}:${v4Str}|(:${v6Seg}){1\x2C5}|:)|` +\n  `(?:${v6Seg}:){1}(?:(:${v6Seg}){0\x2C4}:${v4Str}|(:${v6Seg}){1\x2C6}|:)|` +\n  `(?::((?::${v6Seg}){0\x2C5}:${v4Str}|(?::${v6Seg}){1\x2C7}|:))` +\n')(%[0-9a-zA-Z-.:]{1\x2C})?$');\n\nfunction isIPv4(s) {\n  // TODO(aduh95): Replace RegExpPrototypeTest with RegExpPrototypeExec when it\n  // no longer creates a perf regression in the dns benchmark.\n  // eslint-disable-next-line node-core/avoid-prototype-pollution\n  return RegExpPrototypeTest(IPv4Reg\x2C s);\n}\n\nfunction isIPv6(s) {\n  // TODO(aduh95): Replace RegExpPrototypeTest with RegExpPrototypeExec when it\n  // no longer creates a perf regression in the dns benchmark.\n  // eslint-disable-next-line node-core/avoid-prototype-pollution\n  return RegExpPrototypeTest(IPv6Reg\x2C s);\n}\n\nfunction isIP(s) {\n  if (isIPv4(s)) return 4;\n  if (isIPv6(s)) return 6;\n  return 0;\n}\n\nfunction makeSyncWrite(fd) {\n  return function(chunk\x2C enc\x2C cb) {\n    if (enc !== 'buffer')\n      chunk = Buffer.from(chunk\x2C enc);\n\n    this._handle.bytesWritten += chunk.length;\n\n    const ctx = {};\n    writeBuffer(fd\x2C chunk\x2C 0\x2C chunk.length\x2C null\x2C undefined\x2C ctx);\n    if (ctx.errno !== undefined) {\n      const ex = errors.uvException(ctx);\n      ex.errno = ctx.errno;\n      return cb(ex);\n    }\n    cb();\n  };\n}\n\nmodule.exports = {\n  kWrapConnectedHandle: Symbol('wrapConnectedHandle')\x2C\n  isIP\x2C\n  isIPv4\x2C\n  isIPv6\x2C\n  makeSyncWrite\x2C\n  normalizedArgsSymbol: Symbol('normalizedArgs')\x2C\n};\n
code-source-info,0x30e76771d970,455,0,2223,C0O0C4O2223,,
code-creation,Function,10,60625,0x30e76771dd80,628, node:internal/net:1:1,0x30e76771d8e8,~
code-source-info,0x30e76771dd80,455,0,2223,C0O0C45O25C50O35C56O58C61O99C64O99C69O116C73O99C75O149C78O149C83O133C89O187C92O187C96O187C98O246C101O316C106O320C119O335C124O360C129O375C142O360C147O360C149O417C152O457C160O483C173O499C183O473C192O521C205O537C218O547C228O511C237O569C250O586C263O597C273O559C282O625C295O643C308O658C321O669C331O615C340O697C353O715C366O730C379O741C389O687C398O769C411O787C424O802C437O813C447O759C456O841C469O859C482O874C495O885C505O831C514O919C527O934C540O947C550O903C556O965C562O457C567O457C569O2051C577O2094C587O2127C593O2135C599O2145C605O2155C612O2194C622O2066C627O2222,,
code-creation,LazyCompile,10,60792,0x30e76771e748,72,initializeDns node:internal/dns/utils:201:23,0x30e76771afe8,~
code-source-info,0x30e76771e748,454,5429,5793,C0O5457C8O5457C13O5497C15O5522C28O5531C36O5632C38O5641C44O5664C49O5669C54O5697C55O5704C56O5712C66O5712C71O5792,,
code-creation,LazyCompile,10,60834,0x30e76771f3d8,21,assert node:internal/assert:11:16,0x1012a3967448,~
script-source,27,node:internal/assert,'use strict';\n\nlet error;\nfunction lazyError() {\n  if (!error) {\n    error = require('internal/errors').codes.ERR_INTERNAL_ASSERTION;\n  }\n  return error;\n}\n\nfunction assert(value\x2C message) {\n  if (!value) {\n    const ERR_INTERNAL_ASSERTION = lazyError();\n    throw new ERR_INTERNAL_ASSERTION(message);\n  }\n}\n\nfunction fail(message) {\n  const ERR_INTERNAL_ASSERTION = lazyError();\n  throw new ERR_INTERNAL_ASSERTION(message);\n}\n\nassert.fail = fail;\n\nmodule.exports = assert;\n
code-source-info,0x30e76771f3d8,27,172,307,C0O193C4O242C7O242C11O259C13O265C18O259C20O306,,
code-creation,LazyCompile,10,60917,0x30e76771f7f8,446,readPolicyFromDisk node:internal/process/pre_execution:484:28,0x202f02877b90,~
code-source-info,0x30e76771f7f8,447,14951,16749,C0O14985C10O14985C15O15028C17O15058C21O15066C35O15066C41O15191C49O15191C55O15168C60O15183C65O15310C67O15327C75O15331C81O15346C87O15347C94O15387C100O15419C108O15401C116O15476C120O15498C126O15498C132O15476C138O15512C149O15528C153O15542C161O15556C167O15614C175O15614C180O15648C190O15648C197O15723C207O15723C212O15765C214O15818C222O15818C227O15896C235O15896C241O15864C246O15876C251O15945C257O15945C263O15995C269O15995C275O16054C277O16080C279O16104C283O16085C288O16195C290O16211C295O16145C300O16173C305O16237C311O16273C317O16273C322O16314C328O16314C334O16343C340O16363C344O16350C349O16383C356O16430C358O16459C360O16500C366O16522C376O16522C383O16500C389O16113C394O16067C397O16557C401O16584C415O16590C420O16584C421O16673C429O16701C433O16731C443O16743C445O16748,,
code-creation,LazyCompile,10,60959,0x30e76771fbe8,49,setupStacktracePrinterOnSigint node:internal/process/pre_execution:307:40,0x202f028777d0,~
code-source-info,0x30e76771fbe8,447,9498,9684,C0O9505C8O9510C14O9550C15O9557C16O9591C22O9591C27O9572C32O9641C38O9674C43O9674C48O9683,,
tick,0x100cd43ec,61000,0,0x0,2,0x0,0x202f0287b579,0x202f02879dd8,0x202f028761e9
code-creation,LazyCompile,10,61000,0x30e76771fd10,21,initializeReportSignalHandlers node:internal/process/pre_execution:337:40,0x202f028778e8,~
code-source-info,0x30e76771fd10,447,10267,10363,C0O10303C6O10303C11O10282C16O10342C20O10362,,
code-creation,LazyCompile,10,61042,0x30e76771fe18,57,addSignalHandler node:internal/process/report:98:26,0x30e76770f668,~
code-source-info,0x30e76771fe18,450,2146,2292,C0O2156C5O2163C10O2163C16O2193C22O2228C27O2237C32O2237C38O2255C41O2263C49O2263C56O2291,,
code-creation,LazyCompile,10,61084,0x30e767720470,136,initializeHeapSnapshotSignalHandlers node:internal/process/pre_execution:343:46,0x202f02877938,~
code-source-info,0x30e767720470,447,10410,10946,C0O10410C17O10432C27O10432C31O10432C33O10476C37O10493C38O10500C39O10504C47O10504C52O10534C60O10535C65O10595C73O10595C78O10573C84O10677C89O10685C100O10685C106O10813C113O10817C118O10845C130O10845C135O10945,,
code-creation,LazyCompile,10,61167,0x30e767720750,138,setupChildProcessIpcChannel node:internal/process/pre_execution:456:37,0x202f02877af0,~
code-source-info,0x30e767720750,447,14121,14650,C0O14128C3O14140C8O14144C14O14182C20O14182C25O14226C33O14249C38O14253C46O14226C52O14279C53O14289C57O14279C61O14370C64O14385C73O14443C76O14451C81O14455C90O14502C93O14517C102O14559C108O14559C113O14583C118O14584C124O14623C127O14638C132O14623C137O14649,,
code-creation,Eval,10,61500,0x30e767721728,5, node:child_process:1:1,0x30e7677211b0,~
script-source,456,node:child_process,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeLastIndexOf\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  ArrayPrototypePushApply\x2C\n  NumberIsInteger\x2C\n  ObjectAssign\x2C\n  ObjectDefineProperty\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeExec\x2C\n  SafeSet\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToUpperCase\x2C\n} = primordials;\n\nconst {\n  convertToValidSignal\x2C\n  createDeferredPromise\x2C\n  getSystemErrorName\x2C\n  kEmptyObject\x2C\n  promisify\x2C\n} = require('internal/util');\nconst { isArrayBufferView } = require('internal/util/types');\nlet debug = require('internal/util/debuglog').debuglog(\n  'child_process'\x2C\n  (fn) => {\n    debug = fn;\n  }\x2C\n);\nconst { Buffer } = require('buffer');\nconst { Pipe\x2C constants: PipeConstants } = internalBinding('pipe_wrap');\n\nconst {\n  AbortError\x2C\n  codes: errorCodes\x2C\n  genericNodeError\x2C\n} = require('internal/errors');\nconst {\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_CHILD_PROCESS_IPC_REQUIRED\x2C\n  ERR_CHILD_PROCESS_STDIO_MAXBUFFER\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_OUT_OF_RANGE\x2C\n} = errorCodes;\nconst { clearTimeout\x2C setTimeout } = require('timers');\nconst { getValidatedPath } = require('internal/fs/utils');\nconst {\n  isInt32\x2C\n  validateAbortSignal\x2C\n  validateArray\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst child_process = require('internal/child_process');\nconst {\n  getValidStdio\x2C\n  setupChannel\x2C\n  ChildProcess\x2C\n  stdioStringToArray\x2C\n} = child_process;\n\nconst MAX_BUFFER = 1024 * 1024;\n\nconst isZOS = process.platform === 'os390';\n\n/**\n * Spawns a new Node.js process + fork.\n * @param {string|URL} modulePath\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   detached?: boolean;\n *   env?: Record<string\x2C string>;\n *   execPath?: string;\n *   execArgv?: string[];\n *   gid?: number;\n *   serialization?: string;\n *   signal?: AbortSignal;\n *   killSignal?: string | number;\n *   silent?: boolean;\n *   stdio?: Array | string;\n *   uid?: number;\n *   windowsVerbatimArguments?: boolean;\n *   timeout?: number;\n *   }} [options]\n * @returns {ChildProcess}\n */\nfunction fork(modulePath\x2C args = []\x2C options) {\n  modulePath = getValidatedPath(modulePath\x2C 'modulePath');\n\n  // Get options and args arguments.\n  let execArgv;\n\n  if (args == null) {\n    args = [];\n  } else if (typeof args === 'object' && !ArrayIsArray(args)) {\n    options = args;\n    args = [];\n  } else {\n    validateArray(args\x2C 'args');\n  }\n\n  if (options != null) {\n    validateObject(options\x2C 'options');\n  }\n  options = { ...options\x2C shell: false };\n  options.execPath = options.execPath || process.execPath;\n  validateArgumentNullCheck(options.execPath\x2C 'options.execPath');\n\n  // Prepare arguments for fork:\n  execArgv = options.execArgv || process.execArgv;\n  validateArgumentsNullCheck(execArgv\x2C 'options.execArgv');\n\n  if (execArgv === process.execArgv && process._eval != null) {\n    const index = ArrayPrototypeLastIndexOf(execArgv\x2C process._eval);\n    if (index > 0) {\n      // Remove the -e switch to avoid fork bombing ourselves.\n      execArgv = ArrayPrototypeSlice(execArgv);\n      ArrayPrototypeSplice(execArgv\x2C index - 1\x2C 2);\n    }\n  }\n\n  args = [...execArgv\x2C modulePath\x2C ...args];\n\n  if (typeof options.stdio === 'string') {\n    options.stdio = stdioStringToArray(options.stdio\x2C 'ipc');\n  } else if (!ArrayIsArray(options.stdio)) {\n    // Use a separate fd=3 for the IPC channel. Inherit stdin\x2C stdout\x2C\n    // and stderr from the parent if silent isn't set.\n    options.stdio = stdioStringToArray(\n      options.silent ? 'pipe' : 'inherit'\x2C\n      'ipc');\n  } else if (!ArrayPrototypeIncludes(options.stdio\x2C 'ipc')) {\n    throw new ERR_CHILD_PROCESS_IPC_REQUIRED('options.stdio');\n  }\n\n  return spawn(options.execPath\x2C args\x2C options);\n}\n\nfunction _forkChild(fd\x2C serializationMode) {\n  // set process.send()\n  const p = new Pipe(PipeConstants.IPC);\n  p.open(fd);\n  p.unref();\n  const control = setupChannel(process\x2C p\x2C serializationMode);\n  process.on('newListener'\x2C function onNewListener(name) {\n    if (name === 'message' || name === 'disconnect') control.refCounted();\n  });\n  process.on('removeListener'\x2C function onRemoveListener(name) {\n    if (name === 'message' || name === 'disconnect') control.unrefCounted();\n  });\n}\n\nfunction normalizeExecArgs(command\x2C options\x2C callback) {\n  validateString(command\x2C 'command');\n  validateArgumentNullCheck(command\x2C 'command');\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = { ...options };\n  options.shell = typeof options.shell === 'string' ? options.shell : true;\n\n  return {\n    file: command\x2C\n    options: options\x2C\n    callback: callback\x2C\n  };\n}\n\n/**\n * Spawns a shell executing the given command.\n * @param {string} command\n * @param {{\n *   cmd?: string;\n *   env?: Record<string\x2C string>;\n *   encoding?: string;\n *   shell?: string;\n *   signal?: AbortSignal;\n *   timeout?: number;\n *   maxBuffer?: number;\n *   killSignal?: string | number;\n *   uid?: number;\n *   gid?: number;\n *   windowsHide?: boolean;\n *   }} [options]\n * @param {(\n *   error?: Error\x2C\n *   stdout?: string | Buffer\x2C\n *   stderr?: string | Buffer\n *   ) => any} [callback]\n * @returns {ChildProcess}\n */\nfunction exec(command\x2C options\x2C callback) {\n  const opts = normalizeExecArgs(command\x2C options\x2C callback);\n  return module.exports.execFile(opts.file\x2C\n                                 opts.options\x2C\n                                 opts.callback);\n}\n\nconst customPromiseExecFunction = (orig) => {\n  return (...args) => {\n    const { promise\x2C resolve\x2C reject } = createDeferredPromise();\n\n    promise.child = orig(...args\x2C (err\x2C stdout\x2C stderr) => {\n      if (err !== null) {\n        err.stdout = stdout;\n        err.stderr = stderr;\n        reject(err);\n      } else {\n        resolve({ stdout\x2C stderr });\n      }\n    });\n\n    return promise;\n  };\n};\n\nObjectDefineProperty(exec\x2C promisify.custom\x2C {\n  __proto__: null\x2C\n  enumerable: false\x2C\n  value: customPromiseExecFunction(exec)\x2C\n});\n\nfunction normalizeExecFileArgs(file\x2C args\x2C options\x2C callback) {\n  if (ArrayIsArray(args)) {\n    args = ArrayPrototypeSlice(args);\n  } else if (args != null && typeof args === 'object') {\n    callback = options;\n    options = args;\n    args = null;\n  } else if (typeof args === 'function') {\n    callback = args;\n    options = null;\n    args = null;\n  }\n\n  if (args == null) {\n    args = [];\n  }\n\n  if (typeof options === 'function') {\n    callback = options;\n  } else if (options != null) {\n    validateObject(options\x2C 'options');\n  }\n\n  if (options == null) {\n    options = kEmptyObject;\n  }\n\n  if (callback != null) {\n    validateFunction(callback\x2C 'callback');\n  }\n\n  // Validate argv0\x2C if present.\n  if (options.argv0 != null) {\n    validateString(options.argv0\x2C 'options.argv0');\n    validateArgumentNullCheck(options.argv0\x2C 'options.argv0');\n  }\n\n  return { file\x2C args\x2C options\x2C callback };\n}\n\n/**\n * Spawns the specified file as a shell.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   env?: Record<string\x2C string>;\n *   encoding?: string;\n *   timeout?: number;\n *   maxBuffer?: number;\n *   killSignal?: string | number;\n *   uid?: number;\n *   gid?: number;\n *   windowsHide?: boolean;\n *   windowsVerbatimArguments?: boolean;\n *   shell?: boolean | string;\n *   signal?: AbortSignal;\n *   }} [options]\n * @param {(\n *   error?: Error\x2C\n *   stdout?: string | Buffer\x2C\n *   stderr?: string | Buffer\n *   ) => any} [callback]\n * @returns {ChildProcess}\n */\nfunction execFile(file\x2C args\x2C options\x2C callback) {\n  ({ file\x2C args\x2C options\x2C callback } = normalizeExecFileArgs(file\x2C args\x2C options\x2C callback));\n\n  options = {\n    encoding: 'utf8'\x2C\n    timeout: 0\x2C\n    maxBuffer: MAX_BUFFER\x2C\n    killSignal: 'SIGTERM'\x2C\n    cwd: null\x2C\n    env: null\x2C\n    shell: false\x2C\n    ...options\x2C\n  };\n\n  // Validate the timeout\x2C if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer\x2C if present.\n  validateMaxBuffer(options.maxBuffer);\n\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  const child = spawn(file\x2C args\x2C {\n    cwd: options.cwd\x2C\n    env: options.env\x2C\n    gid: options.gid\x2C\n    shell: options.shell\x2C\n    signal: options.signal\x2C\n    uid: options.uid\x2C\n    windowsHide: !!options.windowsHide\x2C\n    windowsVerbatimArguments: !!options.windowsVerbatimArguments\x2C\n  });\n\n  let encoding;\n  const _stdout = [];\n  const _stderr = [];\n  if (options.encoding !== 'buffer' && Buffer.isEncoding(options.encoding)) {\n    encoding = options.encoding;\n  } else {\n    encoding = null;\n  }\n  let stdoutLen = 0;\n  let stderrLen = 0;\n  let killed = false;\n  let exited = false;\n  let timeoutId;\n\n  let ex = null;\n\n  let cmd = file;\n\n  function exithandler(code\x2C signal) {\n    if (exited) return;\n    exited = true;\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n\n    if (!callback) return;\n\n    // merge chunks\n    let stdout;\n    let stderr;\n    if (encoding ||\n      (\n        child.stdout &&\n        child.stdout.readableEncoding\n      )) {\n      stdout = ArrayPrototypeJoin(_stdout\x2C '');\n    } else {\n      stdout = Buffer.concat(_stdout);\n    }\n    if (encoding ||\n      (\n        child.stderr &&\n        child.stderr.readableEncoding\n      )) {\n      stderr = ArrayPrototypeJoin(_stderr\x2C '');\n    } else {\n      stderr = Buffer.concat(_stderr);\n    }\n\n    if (!ex && code === 0 && signal === null) {\n      callback(null\x2C stdout\x2C stderr);\n      return;\n    }\n\n    if (args?.length)\n      cmd += ` ${ArrayPrototypeJoin(args\x2C ' ')}`;\n\n    if (!ex) {\n      ex = genericNodeError(`Command failed: ${cmd}\\n${stderr}`\x2C {\n        code: code < 0 ? getSystemErrorName(code) : code\x2C\n        killed: child.killed || killed\x2C\n        signal: signal\x2C\n      });\n    }\n\n    ex.cmd = cmd;\n    callback(ex\x2C stdout\x2C stderr);\n  }\n\n  function errorhandler(e) {\n    ex = e;\n\n    if (child.stdout)\n      child.stdout.destroy();\n\n    if (child.stderr)\n      child.stderr.destroy();\n\n    exithandler();\n  }\n\n  function kill() {\n    if (child.stdout)\n      child.stdout.destroy();\n\n    if (child.stderr)\n      child.stderr.destroy();\n\n    killed = true;\n    try {\n      child.kill(options.killSignal);\n    } catch (e) {\n      ex = e;\n      exithandler();\n    }\n  }\n\n  if (options.timeout > 0) {\n    timeoutId = setTimeout(function delayedKill() {\n      kill();\n      timeoutId = null;\n    }\x2C options.timeout);\n  }\n\n  if (child.stdout) {\n    if (encoding)\n      child.stdout.setEncoding(encoding);\n\n    child.stdout.on('data'\x2C function onChildStdout(chunk) {\n      // Do not need to count the length\n      if (options.maxBuffer === Infinity) {\n        ArrayPrototypePush(_stdout\x2C chunk);\n        return;\n      }\n      const encoding = child.stdout.readableEncoding;\n      const length = encoding ?\n        Buffer.byteLength(chunk\x2C encoding) :\n        chunk.length;\n      const slice = encoding ? StringPrototypeSlice :\n        (buf\x2C ...args) => buf.slice(...args);\n      stdoutLen += length;\n\n      if (stdoutLen > options.maxBuffer) {\n        const truncatedLen = options.maxBuffer - (stdoutLen - length);\n        ArrayPrototypePush(_stdout\x2C slice(chunk\x2C 0\x2C truncatedLen));\n\n        ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stdout');\n        kill();\n      } else {\n        ArrayPrototypePush(_stdout\x2C chunk);\n      }\n    });\n  }\n\n  if (child.stderr) {\n    if (encoding)\n      child.stderr.setEncoding(encoding);\n\n    child.stderr.on('data'\x2C function onChildStderr(chunk) {\n      // Do not need to count the length\n      if (options.maxBuffer === Infinity) {\n        ArrayPrototypePush(_stderr\x2C chunk);\n        return;\n      }\n      const encoding = child.stderr.readableEncoding;\n      const length = encoding ?\n        Buffer.byteLength(chunk\x2C encoding) :\n        chunk.length;\n      stderrLen += length;\n\n      if (stderrLen > options.maxBuffer) {\n        const truncatedLen = options.maxBuffer - (stderrLen - length);\n        ArrayPrototypePush(_stderr\x2C\n                           chunk.slice(0\x2C truncatedLen));\n\n        ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stderr');\n        kill();\n      } else {\n        ArrayPrototypePush(_stderr\x2C chunk);\n      }\n    });\n  }\n\n  child.addListener('close'\x2C exithandler);\n  child.addListener('error'\x2C errorhandler);\n\n  return child;\n}\n\nObjectDefineProperty(execFile\x2C promisify.custom\x2C {\n  __proto__: null\x2C\n  enumerable: false\x2C\n  value: customPromiseExecFunction(execFile)\x2C\n});\n\nfunction copyProcessEnvToEnv(env\x2C name\x2C optionEnv) {\n  if (process.env[name] &&\n      (!optionEnv ||\n       !ObjectPrototypeHasOwnProperty(optionEnv\x2C name))) {\n    env[name] = process.env[name];\n  }\n}\n\nfunction normalizeSpawnArguments(file\x2C args\x2C options) {\n  validateString(file\x2C 'file');\n  validateArgumentNullCheck(file\x2C 'file');\n\n  if (file.length === 0)\n    throw new ERR_INVALID_ARG_VALUE('file'\x2C file\x2C 'cannot be empty');\n\n  if (ArrayIsArray(args)) {\n    args = ArrayPrototypeSlice(args);\n  } else if (args == null) {\n    args = [];\n  } else if (typeof args !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('args'\x2C 'object'\x2C args);\n  } else {\n    options = args;\n    args = [];\n  }\n\n  validateArgumentsNullCheck(args\x2C 'args');\n\n  if (options === undefined)\n    options = kEmptyObject;\n  else\n    validateObject(options\x2C 'options');\n\n  let cwd = options.cwd;\n\n  // Validate the cwd\x2C if present.\n  if (cwd != null) {\n    cwd = getValidatedPath(cwd\x2C 'options.cwd');\n  }\n\n  // Validate detached\x2C if present.\n  if (options.detached != null) {\n    validateBoolean(options.detached\x2C 'options.detached');\n  }\n\n  // Validate the uid\x2C if present.\n  if (options.uid != null && !isInt32(options.uid)) {\n    throw new ERR_INVALID_ARG_TYPE('options.uid'\x2C 'int32'\x2C options.uid);\n  }\n\n  // Validate the gid\x2C if present.\n  if (options.gid != null && !isInt32(options.gid)) {\n    throw new ERR_INVALID_ARG_TYPE('options.gid'\x2C 'int32'\x2C options.gid);\n  }\n\n  // Validate the shell\x2C if present.\n  if (options.shell != null &&\n      typeof options.shell !== 'boolean' &&\n      typeof options.shell !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE('options.shell'\x2C\n                                   ['boolean'\x2C 'string']\x2C options.shell);\n  }\n\n  // Validate argv0\x2C if present.\n  if (options.argv0 != null) {\n    validateString(options.argv0\x2C 'options.argv0');\n    validateArgumentNullCheck(options.argv0\x2C 'options.argv0');\n  }\n\n  // Validate windowsHide\x2C if present.\n  if (options.windowsHide != null) {\n    validateBoolean(options.windowsHide\x2C 'options.windowsHide');\n  }\n\n  // Validate windowsVerbatimArguments\x2C if present.\n  let { windowsVerbatimArguments } = options;\n  if (windowsVerbatimArguments != null) {\n    validateBoolean(windowsVerbatimArguments\x2C\n                    'options.windowsVerbatimArguments');\n  }\n\n  if (options.shell) {\n    validateArgumentNullCheck(options.shell\x2C 'options.shell');\n    const command = ArrayPrototypeJoin([file\x2C ...args]\x2C ' ');\n    // Set the shell\x2C switches\x2C and commands.\n    if (process.platform === 'win32') {\n      if (typeof options.shell === 'string')\n        file = options.shell;\n      else\n        file = process.env.comspec || 'cmd.exe';\n      // '/d /s /c' is used only for cmd.exe.\n      if (RegExpPrototypeExec(/^(?:.*\\\\)?cmd(?:\\.exe)?$/i\x2C file) !== null) {\n        args = ['/d'\x2C '/s'\x2C '/c'\x2C `"${command}"`];\n        windowsVerbatimArguments = true;\n      } else {\n        args = ['-c'\x2C command];\n      }\n    } else {\n      if (typeof options.shell === 'string')\n        file = options.shell;\n      else if (process.platform === 'android')\n        file = '/system/bin/sh';\n      else\n        file = '/bin/sh';\n      args = ['-c'\x2C command];\n    }\n  }\n\n  if (typeof options.argv0 === 'string') {\n    ArrayPrototypeUnshift(args\x2C options.argv0);\n  } else {\n    ArrayPrototypeUnshift(args\x2C file);\n  }\n\n  const env = options.env || process.env;\n  const envPairs = [];\n\n  // process.env.NODE_V8_COVERAGE always propagates\x2C making it possible to\n  // collect coverage for programs that spawn with white-listed environment.\n  copyProcessEnvToEnv(env\x2C 'NODE_V8_COVERAGE'\x2C options.env);\n\n  if (isZOS) {\n    // The following environment variables must always propagate if set.\n    copyProcessEnvToEnv(env\x2C '_BPXK_AUTOCVT'\x2C options.env);\n    copyProcessEnvToEnv(env\x2C '_CEE_RUNOPTS'\x2C options.env);\n    copyProcessEnvToEnv(env\x2C '_TAG_REDIR_ERR'\x2C options.env);\n    copyProcessEnvToEnv(env\x2C '_TAG_REDIR_IN'\x2C options.env);\n    copyProcessEnvToEnv(env\x2C '_TAG_REDIR_OUT'\x2C options.env);\n    copyProcessEnvToEnv(env\x2C 'STEPLIB'\x2C options.env);\n    copyProcessEnvToEnv(env\x2C 'LIBPATH'\x2C options.env);\n    copyProcessEnvToEnv(env\x2C '_EDC_SIG_DFLT'\x2C options.env);\n    copyProcessEnvToEnv(env\x2C '_EDC_SUSV3'\x2C options.env);\n  }\n\n  let envKeys = [];\n  // Prototype values are intentionally included.\n  for (const key in env) {\n    ArrayPrototypePush(envKeys\x2C key);\n  }\n\n  if (process.platform === 'win32') {\n    // On Windows env keys are case insensitive. Filter out duplicates\x2C\n    // keeping only the first one (in lexicographic order)\n    const sawKey = new SafeSet();\n    envKeys = ArrayPrototypeFilter(\n      ArrayPrototypeSort(envKeys)\x2C\n      (key) => {\n        const uppercaseKey = StringPrototypeToUpperCase(key);\n        if (sawKey.has(uppercaseKey)) {\n          return false;\n        }\n        sawKey.add(uppercaseKey);\n        return true;\n      }\x2C\n    );\n  }\n\n  for (const key of envKeys) {\n    const value = env[key];\n    if (value !== undefined) {\n      validateArgumentNullCheck(key\x2C `options.env['${key}']`);\n      validateArgumentNullCheck(value\x2C `options.env['${key}']`);\n      ArrayPrototypePush(envPairs\x2C `${key}=${value}`);\n    }\n  }\n\n  return {\n    // Make a shallow copy so we don't clobber the user's options object.\n    ...options\x2C\n    args\x2C\n    cwd\x2C\n    detached: !!options.detached\x2C\n    envPairs\x2C\n    file\x2C\n    windowsHide: !!options.windowsHide\x2C\n    windowsVerbatimArguments: !!windowsVerbatimArguments\x2C\n  };\n}\n\nfunction abortChildProcess(child\x2C killSignal\x2C reason) {\n  if (!child)\n    return;\n  try {\n    if (child.kill(killSignal)) {\n      child.emit('error'\x2C new AbortError(undefined\x2C { cause: reason }));\n    }\n  } catch (err) {\n    child.emit('error'\x2C err);\n  }\n}\n\n/**\n * Spawns a new process using the given `file`.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   env?: Record<string\x2C string>;\n *   argv0?: string;\n *   stdio?: Array | string;\n *   detached?: boolean;\n *   uid?: number;\n *   gid?: number;\n *   serialization?: string;\n *   shell?: boolean | string;\n *   windowsVerbatimArguments?: boolean;\n *   windowsHide?: boolean;\n *   signal?: AbortSignal;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   }} [options]\n * @returns {ChildProcess}\n */\nfunction spawn(file\x2C args\x2C options) {\n  options = normalizeSpawnArguments(file\x2C args\x2C options);\n  validateTimeout(options.timeout);\n  validateAbortSignal(options.signal\x2C 'options.signal');\n  const killSignal = sanitizeKillSignal(options.killSignal);\n  const child = new ChildProcess();\n\n  debug('spawn'\x2C options);\n  child.spawn(options);\n\n  if (options.timeout > 0) {\n    let timeoutId = setTimeout(() => {\n      if (timeoutId) {\n        try {\n          child.kill(killSignal);\n        } catch (err) {\n          child.emit('error'\x2C err);\n        }\n        timeoutId = null;\n      }\n    }\x2C options.timeout);\n\n    child.once('exit'\x2C () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n    });\n  }\n\n  if (options.signal) {\n    const signal = options.signal;\n    if (signal.aborted) {\n      process.nextTick(onAbortListener);\n    } else {\n      signal.addEventListener('abort'\x2C onAbortListener\x2C { once: true });\n      child.once('exit'\x2C\n                 () => signal.removeEventListener('abort'\x2C onAbortListener));\n    }\n\n    function onAbortListener() {\n      abortChildProcess(child\x2C killSignal\x2C options.signal.reason);\n    }\n  }\n\n  return child;\n}\n\n/**\n * Spawns a new process synchronously using the given `file`.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   argv0?: string;\n *   stdio?: string | Array;\n *   env?: Record<string\x2C string>;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   shell?: boolean | string;\n *   windowsVerbatimArguments?: boolean;\n *   windowsHide?: boolean;\n *   }} [options]\n * @returns {{\n *   pid: number;\n *   output: Array;\n *   stdout: Buffer | string;\n *   stderr: Buffer | string;\n *   status: number | null;\n *   signal: string | null;\n *   error: Error;\n *   }}\n */\nfunction spawnSync(file\x2C args\x2C options) {\n  options = {\n    maxBuffer: MAX_BUFFER\x2C\n    ...normalizeSpawnArguments(file\x2C args\x2C options)\x2C\n  };\n\n  debug('spawnSync'\x2C options);\n\n  // Validate the timeout\x2C if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer\x2C if present.\n  validateMaxBuffer(options.maxBuffer);\n\n  // Validate and translate the kill signal\x2C if present.\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  options.stdio = getValidStdio(options.stdio || 'pipe'\x2C true).stdio;\n\n  if (options.input) {\n    const stdin = options.stdio[0] = { ...options.stdio[0] };\n    stdin.input = options.input;\n  }\n\n  // We may want to pass data in on any given fd\x2C ensure it is a valid buffer\n  for (let i = 0; i < options.stdio.length; i++) {\n    const input = options.stdio[i] && options.stdio[i].input;\n    if (input != null) {\n      const pipe = options.stdio[i] = { ...options.stdio[i] };\n      if (isArrayBufferView(input)) {\n        pipe.input = input;\n      } else if (typeof input === 'string') {\n        pipe.input = Buffer.from(input\x2C options.encoding);\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(`options.stdio[${i}]`\x2C\n                                       ['Buffer'\x2C\n                                        'TypedArray'\x2C\n                                        'DataView'\x2C\n                                        'string']\x2C\n                                       input);\n      }\n    }\n  }\n\n  return child_process.spawnSync(options);\n}\n\n\nfunction checkExecSyncError(ret\x2C args\x2C cmd) {\n  let err;\n  if (ret.error) {\n    err = ret.error;\n    ObjectAssign(err\x2C ret);\n  } else if (ret.status !== 0) {\n    let msg = 'Command failed: ';\n    msg += cmd || ArrayPrototypeJoin(args\x2C ' ');\n    if (ret.stderr && ret.stderr.length > 0)\n      msg += `\\n${ret.stderr.toString()}`;\n    err = genericNodeError(msg\x2C ret);\n  }\n  return err;\n}\n\n/**\n * Spawns a file as a shell synchronously.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   stdio?: string | Array;\n *   env?: Record<string\x2C string>;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   windowsHide?: boolean;\n *   shell?: boolean | string;\n *   }} [options]\n * @returns {Buffer | string}\n */\nfunction execFileSync(file\x2C args\x2C options) {\n  ({ file\x2C args\x2C options } = normalizeExecFileArgs(file\x2C args\x2C options));\n\n  const inheritStderr = !options.stdio;\n  const ret = spawnSync(file\x2C args\x2C options);\n\n  if (inheritStderr && ret.stderr)\n    process.stderr.write(ret.stderr);\n\n  const errArgs = [options.argv0 || file];\n  ArrayPrototypePushApply(errArgs\x2C args);\n  const err = checkExecSyncError(ret\x2C errArgs);\n\n  if (err)\n    throw err;\n\n  return ret.stdout;\n}\n\n/**\n * Spawns a shell executing the given `command` synchronously.\n * @param {string} command\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   stdio?: string | Array;\n *   env?: Record<string\x2C string>;\n *   shell?: string;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   windowsHide?: boolean;\n *   }} [options]\n * @returns {Buffer | string}\n */\nfunction execSync(command\x2C options) {\n  const opts = normalizeExecArgs(command\x2C options\x2C null);\n  const inheritStderr = !opts.options.stdio;\n\n  const ret = spawnSync(opts.file\x2C opts.options);\n\n  if (inheritStderr && ret.stderr)\n    process.stderr.write(ret.stderr);\n\n  const err = checkExecSyncError(ret\x2C undefined\x2C command);\n\n  if (err)\n    throw err;\n\n  return ret.stdout;\n}\n\n\nfunction validateArgumentNullCheck(arg\x2C propName) {\n  if (typeof arg === 'string' && StringPrototypeIncludes(arg\x2C '\\u0000')) {\n    throw new ERR_INVALID_ARG_VALUE(propName\x2C arg\x2C 'must be a string without null bytes');\n  }\n}\n\n\nfunction validateArgumentsNullCheck(args\x2C propName) {\n  for (let i = 0; i < args.length; ++i) {\n    validateArgumentNullCheck(args[i]\x2C `${propName}[${i}]`);\n  }\n}\n\n\nfunction validateTimeout(timeout) {\n  if (timeout != null && !(NumberIsInteger(timeout) && timeout >= 0)) {\n    throw new ERR_OUT_OF_RANGE('timeout'\x2C 'an unsigned integer'\x2C timeout);\n  }\n}\n\n\nfunction validateMaxBuffer(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === 'number' && maxBuffer >= 0)) {\n    throw new ERR_OUT_OF_RANGE('options.maxBuffer'\x2C\n                               'a positive number'\x2C\n                               maxBuffer);\n  }\n}\n\n\nfunction sanitizeKillSignal(killSignal) {\n  if (typeof killSignal === 'string' || typeof killSignal === 'number') {\n    return convertToValidSignal(killSignal);\n  } else if (killSignal != null) {\n    throw new ERR_INVALID_ARG_TYPE('options.killSignal'\x2C\n                                   ['string'\x2C 'number']\x2C\n                                   killSignal);\n  }\n}\n\nmodule.exports = {\n  _forkChild\x2C\n  ChildProcess\x2C\n  exec\x2C\n  execFile\x2C\n  execFileSync\x2C\n  execSync\x2C\n  fork\x2C\n  spawn\x2C\n  spawnSync\x2C\n};\n
code-source-info,0x30e767721728,456,0,27018,C0O0C4O27018,,
code-creation,Function,10,63584,0x30e767722320,835, node:child_process:1:1,0x30e7677216a0,~
code-source-info,0x30e767722320,456,0,27018,C0O0C277O1159C283O1175C289O1199C295O1225C301O1247C307O1276C313O1298C319O1321C325O1343C331O1367C337O1392C343O1419C349O1438C355O1454C360O1478C366O1511C372O1534C378O1545C384O1572C390O1596C396O1754C399O1754C404O1652C410O1676C416O1701C422O1723C428O1739C433O1810C436O1810C441O1788C447O1854C450O1854C455O1887C468O1888C474O1854C476O1972C479O1972C484O1961C490O2034C493O2034C498O1999C504O2016C510O2132C513O2132C518O2075C524O2096C529O2110C535O2170C541O2195C547O2229C553O2266C559O2290C565O2361C568O2361C573O2332C579O2346C585O2409C588O2409C593O2388C599O2577C602O2577C607O2449C613O2460C619O2483C625O2500C631O2519C637O2539C643O2557C649O2631C652O2631C656O2631C658O2749C661O2676C667O2693C673O2709C679O2725C685O2784C691O2784C693O2812C696O2820C703O2829C706O2812C708O6853C713O7257C723O7316C734O7220C739O13645C749O13704C760O13604C765O26888C775O26909C781O26923C787O26939C793O26947C799O26959C805O26975C811O26987C817O26995C823O27004C829O26903C834O27017,,
tick,0x1959e93bc,63667,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x30e7677207bc,0x202f0287b58b,0x202f02879dd8,0x202f028761e9
tick,0x19596ce44,63667,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x30e7677207bc,0x202f0287b58b,0x202f02879dd8,0x202f028761e9
code-creation,Eval,10,64125,0x30e767727d70,5, node:internal/child_process:1:1,0x30e7677270b8,~
script-source,457,node:internal/child_process,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeReduce\x2C\n  ArrayPrototypeSlice\x2C\n  FunctionPrototype\x2C\n  FunctionPrototypeCall\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  StringPrototypeSlice\x2C\n  Symbol\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_HANDLE_TYPE\x2C\n    ERR_INVALID_SYNC_FORK_INPUT\x2C\n    ERR_IPC_CHANNEL_CLOSED\x2C\n    ERR_IPC_DISCONNECTED\x2C\n    ERR_IPC_ONE_PIPE\x2C\n    ERR_IPC_SYNC_FORK\x2C\n    ERR_MISSING_ARGS\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst EventEmitter = require('events');\nconst net = require('net');\nconst dgram = require('dgram');\nconst inspect = require('internal/util/inspect').inspect;\nconst assert = require('internal/assert');\n\nconst { Process } = internalBinding('process_wrap');\nconst {\n  WriteWrap\x2C\n  kReadBytesOrError\x2C\n  kArrayBufferOffset\x2C\n  kLastWriteWasAsync\x2C\n  streamBaseState\x2C\n} = internalBinding('stream_wrap');\nconst { Pipe\x2C constants: PipeConstants } = internalBinding('pipe_wrap');\nconst { TCP } = internalBinding('tcp_wrap');\nconst { TTY } = internalBinding('tty_wrap');\nconst { UDP } = internalBinding('udp_wrap');\nconst SocketList = require('internal/socket_list');\nconst { owner_symbol } = require('internal/async_hooks').symbols;\nconst { convertToValidSignal\x2C deprecate } = require('internal/util');\nconst { isArrayBufferView } = require('internal/util/types');\nconst spawn_sync = internalBinding('spawn_sync');\nconst { kStateSymbol } = require('internal/dgram');\n\nconst {\n  UV_EACCES\x2C\n  UV_EAGAIN\x2C\n  UV_EINVAL\x2C\n  UV_EMFILE\x2C\n  UV_ENFILE\x2C\n  UV_ENOENT\x2C\n  UV_ENOSYS\x2C\n  UV_ESRCH\x2C\n} = internalBinding('uv');\n\nconst { SocketListSend\x2C SocketListReceive } = SocketList;\n\n// Lazy loaded for startup performance and to allow monkey patching of\n// internalBinding('http_parser').HTTPParser.\nlet freeParser;\nlet HTTPParser;\n\nconst MAX_HANDLE_RETRANSMISSIONS = 3;\nconst kChannelHandle = Symbol('kChannelHandle');\nconst kIsUsedAsStdio = Symbol('kIsUsedAsStdio');\nconst kPendingMessages = Symbol('kPendingMessages');\n\n// This object contain function to convert TCP objects to native handle objects\n// and back again.\nconst handleConversion = {\n  'net.Native': {\n    simultaneousAccepts: true\x2C\n\n    send(message\x2C handle\x2C options) {\n      return handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      emit(handle);\n    }\x2C\n  }\x2C\n\n  'net.Server': {\n    simultaneousAccepts: true\x2C\n\n    send(message\x2C server\x2C options) {\n      return server._handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      const server = new net.Server();\n      server.listen(handle\x2C () => {\n        emit(server);\n      });\n    }\x2C\n  }\x2C\n\n  'net.Socket': {\n    send(message\x2C socket\x2C options) {\n      if (!socket._handle)\n        return;\n\n      // If the socket was created by net.Server\n      if (socket.server) {\n        // The worker should keep track of the socket\n        message.key = socket.server._connectionKey;\n\n        const firstTime = !this[kChannelHandle].sockets.send[message.key];\n        const socketList = getSocketList('send'\x2C this\x2C message.key);\n\n        // The server should no longer expose a .connection property\n        // and when asked to close it should query the socket status from\n        // the workers\n        if (firstTime) socket.server._setupWorker(socketList);\n\n        // Act like socket is detached\n        if (!options.keepOpen)\n          socket.server._connections--;\n      }\n\n      const handle = socket._handle;\n\n      // Remove handle from socket object\x2C it will be closed when the socket\n      // will be sent\n      if (!options.keepOpen) {\n        handle.onread = nop;\n        socket._handle = null;\n        socket.setTimeout(0);\n\n        if (freeParser === undefined)\n          freeParser = require('_http_common').freeParser;\n        if (HTTPParser === undefined)\n          HTTPParser = require('_http_common').HTTPParser;\n\n        // In case of an HTTP connection socket\x2C release the associated\n        // resources\n        if (socket.parser && socket.parser instanceof HTTPParser) {\n          freeParser(socket.parser\x2C null\x2C socket);\n          if (socket._httpMessage)\n            socket._httpMessage.detachSocket(socket);\n        }\n      }\n\n      return handle;\n    }\x2C\n\n    postSend(message\x2C handle\x2C options\x2C callback\x2C target) {\n      // Store the handle after successfully sending it\x2C so it can be closed\n      // when the NODE_HANDLE_ACK is received. If the handle could not be sent\x2C\n      // just close it.\n      if (handle && !options.keepOpen) {\n        if (target) {\n          // There can only be one _pendingMessage as passing handles are\n          // processed one at a time: handles are stored in _handleQueue while\n          // waiting for the NODE_HANDLE_ACK of the current passing handle.\n          assert(!target._pendingMessage);\n          target._pendingMessage =\n              { callback\x2C message\x2C handle\x2C options\x2C retransmissions: 0 };\n        } else {\n          handle.close();\n        }\n      }\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      const socket = new net.Socket({\n        handle: handle\x2C\n        readable: true\x2C\n        writable: true\x2C\n      });\n\n      // If the socket was created by net.Server we will track the socket\n      if (message.key) {\n\n        // Add socket to connections list\n        const socketList = getSocketList('got'\x2C this\x2C message.key);\n        socketList.add({\n          socket: socket\x2C\n        });\n      }\n\n      emit(socket);\n    }\x2C\n  }\x2C\n\n  'dgram.Native': {\n    simultaneousAccepts: false\x2C\n\n    send(message\x2C handle\x2C options) {\n      return handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      emit(handle);\n    }\x2C\n  }\x2C\n\n  'dgram.Socket': {\n    simultaneousAccepts: false\x2C\n\n    send(message\x2C socket\x2C options) {\n      message.dgramType = socket.type;\n\n      return socket[kStateSymbol].handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      const socket = new dgram.Socket(message.dgramType);\n\n      socket.bind(handle\x2C () => {\n        emit(socket);\n      });\n    }\x2C\n  }\x2C\n};\n\nfunction stdioStringToArray(stdio\x2C channel) {\n  const options = [];\n\n  switch (stdio) {\n    case 'ignore':\n    case 'overlapped':\n    case 'pipe': ArrayPrototypePush(options\x2C stdio\x2C stdio\x2C stdio); break;\n    case 'inherit': ArrayPrototypePush(options\x2C 0\x2C 1\x2C 2); break;\n    default:\n      throw new ERR_INVALID_ARG_VALUE('stdio'\x2C stdio);\n  }\n\n  if (channel) ArrayPrototypePush(options\x2C channel);\n\n  return options;\n}\n\nfunction ChildProcess() {\n  FunctionPrototypeCall(EventEmitter\x2C this);\n\n  this._closesNeeded = 1;\n  this._closesGot = 0;\n  this.connected = false;\n\n  this.signalCode = null;\n  this.exitCode = null;\n  this.killed = false;\n  this.spawnfile = null;\n\n  this._handle = new Process();\n  this._handle[owner_symbol] = this;\n\n  this._handle.onexit = (exitCode\x2C signalCode) => {\n    if (signalCode) {\n      this.signalCode = signalCode;\n    } else {\n      this.exitCode = exitCode;\n    }\n\n    if (this.stdin) {\n      this.stdin.destroy();\n    }\n\n    this._handle.close();\n    this._handle = null;\n\n    if (exitCode < 0) {\n      const syscall = this.spawnfile ? 'spawn ' + this.spawnfile : 'spawn';\n      const err = errnoException(exitCode\x2C syscall);\n\n      if (this.spawnfile)\n        err.path = this.spawnfile;\n\n      err.spawnargs = ArrayPrototypeSlice(this.spawnargs\x2C 1);\n      this.emit('error'\x2C err);\n    } else {\n      this.emit('exit'\x2C this.exitCode\x2C this.signalCode);\n    }\n\n    // If any of the stdio streams have not been touched\x2C\n    // then pull all the data through so that it can get the\n    // eof and emit a 'close' event.\n    // Do it on nextTick so that the user has one last chance\n    // to consume the output\x2C if for example they only want to\n    // start reading the data once the process exits.\n    process.nextTick(flushStdio\x2C this);\n\n    maybeClose(this);\n  };\n}\nObjectSetPrototypeOf(ChildProcess.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(ChildProcess\x2C EventEmitter);\n\n\nfunction flushStdio(subprocess) {\n  const stdio = subprocess.stdio;\n\n  if (stdio == null) return;\n\n  for (let i = 0; i < stdio.length; i++) {\n    const stream = stdio[i];\n    // TODO(addaleax): This doesn't necessarily account for all the ways in\n    // which data can be read from a stream\x2C e.g. being consumed on the\n    // native layer directly as a StreamBase.\n    if (!stream || !stream.readable || stream[kIsUsedAsStdio]) {\n      continue;\n    }\n    stream.resume();\n  }\n}\n\n\nfunction createSocket(pipe\x2C readable) {\n  return net.Socket({ handle: pipe\x2C readable });\n}\n\n\nfunction getHandleWrapType(stream) {\n  if (stream instanceof Pipe) return 'pipe';\n  if (stream instanceof TTY) return 'tty';\n  if (stream instanceof TCP) return 'tcp';\n  if (stream instanceof UDP) return 'udp';\n\n  return false;\n}\n\nfunction closePendingHandle(target) {\n  target._pendingMessage.handle.close();\n  target._pendingMessage = null;\n}\n\n\nChildProcess.prototype.spawn = function(options) {\n  let i = 0;\n\n  validateObject(options\x2C 'options');\n\n  // If no `stdio` option was given - use default\n  let stdio = options.stdio || 'pipe';\n\n  stdio = getValidStdio(stdio\x2C false);\n\n  const ipc = stdio.ipc;\n  const ipcFd = stdio.ipcFd;\n  stdio = options.stdio = stdio.stdio;\n\n\n  validateOneOf(options.serialization\x2C 'options.serialization'\x2C\n                [undefined\x2C 'json'\x2C 'advanced']);\n  const serialization = options.serialization || 'json';\n\n  if (ipc !== undefined) {\n    // Let child process know about opened IPC channel\n    if (options.envPairs === undefined)\n      options.envPairs = [];\n    else\n      validateArray(options.envPairs\x2C 'options.envPairs');\n\n    ArrayPrototypePush(options.envPairs\x2C `NODE_CHANNEL_FD=${ipcFd}`);\n    ArrayPrototypePush(options.envPairs\x2C\n                       `NODE_CHANNEL_SERIALIZATION_MODE=${serialization}`);\n  }\n\n  validateString(options.file\x2C 'options.file');\n  this.spawnfile = options.file;\n\n  if (options.args === undefined) {\n    this.spawnargs = [];\n  } else {\n    validateArray(options.args\x2C 'options.args');\n    this.spawnargs = options.args;\n  }\n\n  const err = this._handle.spawn(options);\n\n  // Run-time errors should emit an error\x2C not throw an exception.\n  if (err === UV_EACCES ||\n      err === UV_EAGAIN ||\n      err === UV_EMFILE ||\n      err === UV_ENFILE ||\n      err === UV_ENOENT) {\n    process.nextTick(onErrorNT\x2C this\x2C err);\n\n    // There is no point in continuing when we've hit EMFILE or ENFILE\n    // because we won't be able to set up the stdio file descriptors.\n    if (err === UV_EMFILE || err === UV_ENFILE)\n      return err;\n  } else if (err) {\n    // Close all opened fds on error\n    for (i = 0; i < stdio.length; i++) {\n      const stream = stdio[i];\n      if (stream.type === 'pipe') {\n        stream.handle.close();\n      }\n    }\n\n    this._handle.close();\n    this._handle = null;\n    throw errnoException(err\x2C 'spawn');\n  } else {\n    process.nextTick(onSpawnNT\x2C this);\n  }\n\n  this.pid = this._handle.pid;\n\n  for (i = 0; i < stdio.length; i++) {\n    const stream = stdio[i];\n    if (stream.type === 'ignore') continue;\n\n    if (stream.ipc) {\n      this._closesNeeded++;\n      continue;\n    }\n\n    // The stream is already cloned and piped\x2C thus stop its readable side\x2C\n    // otherwise we might attempt to read from the stream when at the same time\n    // the child process does.\n    if (stream.type === 'wrap') {\n      stream.handle.reading = false;\n      stream.handle.readStop();\n      stream._stdio.pause();\n      stream._stdio.readableFlowing = false;\n      stream._stdio._readableState.reading = false;\n      stream._stdio[kIsUsedAsStdio] = true;\n      continue;\n    }\n\n    if (stream.handle) {\n      stream.socket = createSocket(this.pid !== 0 ?\n        stream.handle : null\x2C i > 0);\n\n      if (i > 0 && this.pid !== 0) {\n        this._closesNeeded++;\n        stream.socket.on('close'\x2C () => {\n          maybeClose(this);\n        });\n      }\n    }\n  }\n\n  this.stdin = stdio.length >= 1 && stdio[0].socket !== undefined ?\n    stdio[0].socket : null;\n  this.stdout = stdio.length >= 2 && stdio[1].socket !== undefined ?\n    stdio[1].socket : null;\n  this.stderr = stdio.length >= 3 && stdio[2].socket !== undefined ?\n    stdio[2].socket : null;\n\n  this.stdio = [];\n\n  for (i = 0; i < stdio.length; i++)\n    ArrayPrototypePush(this.stdio\x2C\n                       stdio[i].socket === undefined ? null : stdio[i].socket);\n\n  // Add .send() method and start listening for IPC data\n  if (ipc !== undefined) setupChannel(this\x2C ipc\x2C serialization);\n\n  return err;\n};\n\n\nfunction onErrorNT(self\x2C err) {\n  self._handle.onexit(err);\n}\n\n\nfunction onSpawnNT(self) {\n  self.emit('spawn');\n}\n\n\nChildProcess.prototype.kill = function(sig) {\n\n  const signal = sig === 0 ? sig :\n    convertToValidSignal(sig === undefined ? 'SIGTERM' : sig);\n\n  if (this._handle) {\n    const err = this._handle.kill(signal);\n    if (err === 0) {\n      /* Success. */\n      this.killed = true;\n      return true;\n    }\n    if (err === UV_ESRCH) {\n      /* Already dead. */\n    } else if (err === UV_EINVAL || err === UV_ENOSYS) {\n      /* The underlying platform doesn't support this signal. */\n      throw errnoException(err\x2C 'kill');\n    } else {\n      /* Other error\x2C almost certainly EPERM. */\n      this.emit('error'\x2C errnoException(err\x2C 'kill'));\n    }\n  }\n\n  /* Kill didn't succeed. */\n  return false;\n};\n\n\nChildProcess.prototype.ref = function() {\n  if (this._handle) this._handle.ref();\n};\n\n\nChildProcess.prototype.unref = function() {\n  if (this._handle) this._handle.unref();\n};\n\nclass Control extends EventEmitter {\n  #channel = null;\n  #refs = 0;\n  #refExplicitlySet = false;\n\n  constructor(channel) {\n    super();\n    this.#channel = channel;\n    this[kPendingMessages] = [];\n  }\n\n  // The methods keeping track of the counter are being used to track the\n  // listener count on the child process object as well as when writes are\n  // in progress. Once the user has explicitly requested a certain state\x2C these\n  // methods become no-ops in order to not interfere with the user's intentions.\n  refCounted() {\n    if (++this.#refs === 1 && !this.#refExplicitlySet) {\n      this.#channel.ref();\n    }\n  }\n\n  unrefCounted() {\n    if (--this.#refs === 0 && !this.#refExplicitlySet) {\n      this.#channel.unref();\n      this.emit('unref');\n    }\n  }\n\n  ref() {\n    this.#refExplicitlySet = true;\n    this.#channel.ref();\n  }\n\n  unref() {\n    this.#refExplicitlySet = true;\n    this.#channel.unref();\n  }\n\n  get fd() {\n    return this.#channel ? this.#channel.fd : undefined;\n  }\n}\n\nconst channelDeprecationMsg = '_channel is deprecated. ' +\n                              'Use ChildProcess.channel instead.';\n\nlet serialization;\nfunction setupChannel(target\x2C channel\x2C serializationMode) {\n  const control = new Control(channel);\n  target.channel = control;\n  target[kChannelHandle] = channel;\n\n  ObjectDefineProperty(target\x2C '_channel'\x2C {\n    __proto__: null\x2C\n    get: deprecate(() => {\n      return target.channel;\n    }\x2C channelDeprecationMsg\x2C 'DEP0129')\x2C\n    set: deprecate((val) => {\n      target.channel = val;\n    }\x2C channelDeprecationMsg\x2C 'DEP0129')\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n  });\n\n  target._handleQueue = null;\n  target._pendingMessage = null;\n\n  if (serialization === undefined)\n    serialization = require('internal/child_process/serialization');\n  const {\n    initMessageChannel\x2C\n    parseChannelMessages\x2C\n    writeChannelMessage\x2C\n  } = serialization[serializationMode];\n\n  let pendingHandle = null;\n  initMessageChannel(channel);\n  channel.pendingHandle = null;\n  channel.onread = function(arrayBuffer) {\n    const recvHandle = channel.pendingHandle;\n    channel.pendingHandle = null;\n    if (arrayBuffer) {\n      const nread = streamBaseState[kReadBytesOrError];\n      const offset = streamBaseState[kArrayBufferOffset];\n      const pool = new Uint8Array(arrayBuffer\x2C offset\x2C nread);\n      if (recvHandle)\n        pendingHandle = recvHandle;\n\n      for (const message of parseChannelMessages(channel\x2C pool)) {\n        // There will be at most one NODE_HANDLE message in every chunk we\n        // read because SCM_RIGHTS messages don't get coalesced. Make sure\n        // that we deliver the handle with the right message however.\n        if (isInternal(message)) {\n          if (message.cmd === 'NODE_HANDLE') {\n            handleMessage(message\x2C pendingHandle\x2C true);\n            pendingHandle = null;\n          } else {\n            handleMessage(message\x2C undefined\x2C true);\n          }\n        } else {\n          handleMessage(message\x2C undefined\x2C false);\n        }\n      }\n    } else {\n      this.buffering = false;\n      target.disconnect();\n      channel.onread = nop;\n      channel.close();\n      target.channel = null;\n      maybeClose(target);\n    }\n  };\n\n  // Object where socket lists will live\n  channel.sockets = { got: {}\x2C send: {} };\n\n  // Handlers will go through this\n  target.on('internalMessage'\x2C function(message\x2C handle) {\n    // Once acknowledged - continue sending handles.\n    if (message.cmd === 'NODE_HANDLE_ACK' ||\n        message.cmd === 'NODE_HANDLE_NACK') {\n\n      if (target._pendingMessage) {\n        if (message.cmd === 'NODE_HANDLE_ACK') {\n          closePendingHandle(target);\n        } else if (target._pendingMessage.retransmissions++ ===\n                   MAX_HANDLE_RETRANSMISSIONS) {\n          closePendingHandle(target);\n          process.emitWarning('Handle did not reach the receiving process ' +\n                              'correctly'\x2C 'SentHandleNotReceivedWarning');\n        }\n      }\n\n      assert(ArrayIsArray(target._handleQueue));\n      const queue = target._handleQueue;\n      target._handleQueue = null;\n\n      if (target._pendingMessage) {\n        target._send(target._pendingMessage.message\x2C\n                     target._pendingMessage.handle\x2C\n                     target._pendingMessage.options\x2C\n                     target._pendingMessage.callback);\n      }\n\n      for (let i = 0; i < queue.length; i++) {\n        const args = queue[i];\n        target._send(args.message\x2C args.handle\x2C args.options\x2C args.callback);\n      }\n\n      // Process a pending disconnect (if any).\n      if (!target.connected && target.channel && !target._handleQueue)\n        target._disconnect();\n\n      return;\n    }\n\n    if (message.cmd !== 'NODE_HANDLE') return;\n\n    // It is possible that the handle is not received because of some error on\n    // ancillary data reception such as MSG_CTRUNC. In this case\x2C report the\n    // sender about it by sending a NODE_HANDLE_NACK message.\n    if (!handle)\n      return target._send({ cmd: 'NODE_HANDLE_NACK' }\x2C null\x2C true);\n\n    // Acknowledge handle receival. Don't emit error events (for example if\n    // the other side has disconnected) because this call to send() is not\n    // initiated by the user and it shouldn't be fatal to be unable to ACK\n    // a message.\n    target._send({ cmd: 'NODE_HANDLE_ACK' }\x2C null\x2C true);\n\n    const obj = handleConversion[message.type];\n\n    // Update simultaneous accepts on Windows\n    if (process.platform === 'win32') {\n      handle.setSimultaneousAccepts(false);\n    }\n\n    // Convert handle object\n    obj.got.call(this\x2C message\x2C handle\x2C (handle) => {\n      handleMessage(message.msg\x2C handle\x2C isInternal(message.msg));\n    });\n  });\n\n  target.on('newListener'\x2C function() {\n\n    process.nextTick(() => {\n      if (!target.channel || !target.listenerCount('message'))\n        return;\n\n      const messages = target.channel[kPendingMessages];\n      const { length } = messages;\n      if (!length) return;\n\n      for (let i = 0; i < length; i++) {\n        ReflectApply(target.emit\x2C target\x2C messages[i]);\n      }\n\n      target.channel[kPendingMessages] = [];\n    });\n  });\n\n  target.send = function(message\x2C handle\x2C options\x2C callback) {\n    if (typeof handle === 'function') {\n      callback = handle;\n      handle = undefined;\n      options = undefined;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    } else if (options !== undefined) {\n      validateObject(options\x2C 'options');\n    }\n\n    options = { swallowErrors: false\x2C ...options };\n\n    if (this.connected) {\n      return this._send(message\x2C handle\x2C options\x2C callback);\n    }\n    const ex = new ERR_IPC_CHANNEL_CLOSED();\n    if (typeof callback === 'function') {\n      process.nextTick(callback\x2C ex);\n    } else {\n      process.nextTick(() => this.emit('error'\x2C ex));\n    }\n    return false;\n  };\n\n  target._send = function(message\x2C handle\x2C options\x2C callback) {\n    assert(this.connected || this.channel);\n\n    if (message === undefined)\n      throw new ERR_MISSING_ARGS('message');\n\n    // Non-serializable messages should not reach the remote\n    // end point; as any failure in the stringification there\n    // will result in error message that is weakly consumable.\n    // So perform a final check on message prior to sending.\n    if (typeof message !== 'string' &&\n        typeof message !== 'object' &&\n        typeof message !== 'number' &&\n        typeof message !== 'boolean') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'message'\x2C ['string'\x2C 'object'\x2C 'number'\x2C 'boolean']\x2C message);\n    }\n\n    // Support legacy function signature\n    if (typeof options === 'boolean') {\n      options = { swallowErrors: options };\n    }\n\n    let obj;\n\n    // Package messages with a handle object\n    if (handle) {\n      // This message will be handled by an internalMessage event handler\n      message = {\n        cmd: 'NODE_HANDLE'\x2C\n        type: null\x2C\n        msg: message\x2C\n      };\n\n      if (handle instanceof net.Socket) {\n        message.type = 'net.Socket';\n      } else if (handle instanceof net.Server) {\n        message.type = 'net.Server';\n      } else if (handle instanceof TCP || handle instanceof Pipe) {\n        message.type = 'net.Native';\n      } else if (handle instanceof dgram.Socket) {\n        message.type = 'dgram.Socket';\n      } else if (handle instanceof UDP) {\n        message.type = 'dgram.Native';\n      } else {\n        throw new ERR_INVALID_HANDLE_TYPE();\n      }\n\n      // Queue-up message and handle if we haven't received ACK yet.\n      if (this._handleQueue) {\n        ArrayPrototypePush(this._handleQueue\x2C {\n          callback: callback\x2C\n          handle: handle\x2C\n          options: options\x2C\n          message: message.msg\x2C\n        });\n        return this._handleQueue.length === 1;\n      }\n\n      obj = handleConversion[message.type];\n\n      // convert TCP object to native handle object\n      handle = ReflectApply(handleConversion[message.type].send\x2C\n                            target\x2C [message\x2C handle\x2C options]);\n\n      // If handle was sent twice\x2C or it is impossible to get native handle\n      // out of it - just send a text without the handle.\n      if (!handle)\n        message = message.msg;\n\n      // Update simultaneous accepts on Windows\n      if (obj.simultaneousAccepts && process.platform === 'win32') {\n        handle.setSimultaneousAccepts(true);\n      }\n    } else if (this._handleQueue &&\n               !(message && (message.cmd === 'NODE_HANDLE_ACK' ||\n                             message.cmd === 'NODE_HANDLE_NACK'))) {\n      // Queue request anyway to avoid out-of-order messages.\n      ArrayPrototypePush(this._handleQueue\x2C {\n        callback: callback\x2C\n        handle: null\x2C\n        options: options\x2C\n        message: message\x2C\n      });\n      return this._handleQueue.length === 1;\n    }\n\n    const req = new WriteWrap();\n\n    const err = writeChannelMessage(channel\x2C req\x2C message\x2C handle);\n    const wasAsyncWrite = streamBaseState[kLastWriteWasAsync];\n\n    if (err === 0) {\n      if (handle) {\n        if (!this._handleQueue)\n          this._handleQueue = [];\n        if (obj && obj.postSend)\n          obj.postSend(message\x2C handle\x2C options\x2C callback\x2C target);\n      }\n\n      if (wasAsyncWrite) {\n        req.oncomplete = () => {\n          control.unrefCounted();\n          if (typeof callback === 'function')\n            callback(null);\n        };\n        control.refCounted();\n      } else if (typeof callback === 'function') {\n        process.nextTick(callback\x2C null);\n      }\n    } else {\n      // Cleanup handle on error\n      if (obj && obj.postSend)\n        obj.postSend(message\x2C handle\x2C options\x2C callback);\n\n      if (!options.swallowErrors) {\n        const ex = errnoException(err\x2C 'write');\n        if (typeof callback === 'function') {\n          process.nextTick(callback\x2C ex);\n        } else {\n          process.nextTick(() => this.emit('error'\x2C ex));\n        }\n      }\n    }\n\n    /* If the primary is > 2 read() calls behind\x2C please stop sending. */\n    return channel.writeQueueSize < (65536 * 2);\n  };\n\n  // Connected will be set to false immediately when a disconnect() is\n  // requested\x2C even though the channel might still be alive internally to\n  // process queued messages. The three states are distinguished as follows:\n  // - disconnect() never requested: channel is not null and connected\n  //   is true\n  // - disconnect() requested\x2C messages in the queue: channel is not null\n  //   and connected is false\n  // - disconnect() requested\x2C channel actually disconnected: channel is\n  //   null and connected is false\n  target.connected = true;\n\n  target.disconnect = function() {\n    if (!this.connected) {\n      this.emit('error'\x2C new ERR_IPC_DISCONNECTED());\n      return;\n    }\n\n    // Do not allow any new messages to be written.\n    this.connected = false;\n\n    // If there are no queued messages\x2C disconnect immediately. Otherwise\x2C\n    // postpone the disconnect so that it happens internally after the\n    // queue is flushed.\n    if (!this._handleQueue)\n      this._disconnect();\n  };\n\n  target._disconnect = function() {\n    assert(this.channel);\n\n    // This marks the fact that the channel is actually disconnected.\n    this.channel = null;\n    this[kChannelHandle] = null;\n\n    if (this._pendingMessage)\n      closePendingHandle(this);\n\n    let fired = false;\n    function finish() {\n      if (fired) return;\n      fired = true;\n\n      channel.close();\n      target.emit('disconnect');\n    }\n\n    // If a message is being read\x2C then wait for it to complete.\n    if (channel.buffering) {\n      this.once('message'\x2C finish);\n      this.once('internalMessage'\x2C finish);\n\n      return;\n    }\n\n    process.nextTick(finish);\n  };\n\n  function emit(event\x2C message\x2C handle) {\n    if ('internalMessage' === event || target.listenerCount('message')) {\n      target.emit(event\x2C message\x2C handle);\n      return;\n    }\n\n    ArrayPrototypePush(\n      target.channel[kPendingMessages]\x2C\n      [event\x2C message\x2C handle]\x2C\n    );\n  }\n\n  function handleMessage(message\x2C handle\x2C internal) {\n    if (!target.channel)\n      return;\n\n    const eventName = (internal ? 'internalMessage' : 'message');\n\n    process.nextTick(emit\x2C eventName\x2C message\x2C handle);\n  }\n\n  channel.readStart();\n  return control;\n}\n\nconst INTERNAL_PREFIX = 'NODE_';\nfunction isInternal(message) {\n  return (message !== null &&\n          typeof message === 'object' &&\n          typeof message.cmd === 'string' &&\n          message.cmd.length > INTERNAL_PREFIX.length &&\n          StringPrototypeSlice(message.cmd\x2C 0\x2C INTERNAL_PREFIX.length) ===\n            INTERNAL_PREFIX);\n}\n\nconst nop = FunctionPrototype;\n\nfunction getValidStdio(stdio\x2C sync) {\n  let ipc;\n  let ipcFd;\n\n  // Replace shortcut with an array\n  if (typeof stdio === 'string') {\n    stdio = stdioStringToArray(stdio);\n  } else if (!ArrayIsArray(stdio)) {\n    throw new ERR_INVALID_ARG_VALUE('stdio'\x2C stdio);\n  }\n\n  // At least 3 stdio will be created\n  // Don't concat() a new Array() because it would be sparse\x2C and\n  // stdio.reduce() would skip the sparse elements of stdio.\n  // See https://stackoverflow.com/a/5501711/3561\n  while (stdio.length < 3) ArrayPrototypePush(stdio\x2C undefined);\n\n  // Translate stdio into C++-readable form\n  // (i.e. PipeWraps or fds)\n  stdio = ArrayPrototypeReduce(stdio\x2C (acc\x2C stdio\x2C i) => {\n    function cleanup() {\n      for (let i = 0; i < acc.length; i++) {\n        if ((acc[i].type === 'pipe' || acc[i].type === 'ipc') && acc[i].handle)\n          acc[i].handle.close();\n      }\n    }\n\n    // Defaults\n    if (stdio == null) {\n      stdio = i < 3 ? 'pipe' : 'ignore';\n    }\n\n    if (stdio === 'ignore') {\n      ArrayPrototypePush(acc\x2C { type: 'ignore' });\n    } else if (stdio === 'pipe' || stdio === 'overlapped' ||\n               (typeof stdio === 'number' && stdio < 0)) {\n      const a = {\n        type: stdio === 'overlapped' ? 'overlapped' : 'pipe'\x2C\n        readable: i === 0\x2C\n        writable: i !== 0\x2C\n      };\n\n      if (!sync)\n        a.handle = new Pipe(PipeConstants.SOCKET);\n\n      ArrayPrototypePush(acc\x2C a);\n    } else if (stdio === 'ipc') {\n      if (sync || ipc !== undefined) {\n        // Cleanup previously created pipes\n        cleanup();\n        if (!sync)\n          throw new ERR_IPC_ONE_PIPE();\n        else\n          throw new ERR_IPC_SYNC_FORK();\n      }\n\n      ipc = new Pipe(PipeConstants.IPC);\n      ipcFd = i;\n\n      ArrayPrototypePush(acc\x2C {\n        type: 'pipe'\x2C\n        handle: ipc\x2C\n        ipc: true\x2C\n      });\n    } else if (stdio === 'inherit') {\n      ArrayPrototypePush(acc\x2C {\n        type: 'inherit'\x2C\n        fd: i\x2C\n      });\n    } else if (typeof stdio === 'number' || typeof stdio.fd === 'number') {\n      ArrayPrototypePush(acc\x2C {\n        type: 'fd'\x2C\n        fd: typeof stdio === 'number' ? stdio : stdio.fd\x2C\n      });\n    } else if (getHandleWrapType(stdio) || getHandleWrapType(stdio.handle) ||\n               getHandleWrapType(stdio._handle)) {\n      const handle = getHandleWrapType(stdio) ?\n        stdio :\n        getHandleWrapType(stdio.handle) ? stdio.handle : stdio._handle;\n\n      ArrayPrototypePush(acc\x2C {\n        type: 'wrap'\x2C\n        wrapType: getHandleWrapType(handle)\x2C\n        handle: handle\x2C\n        _stdio: stdio\x2C\n      });\n    } else if (isArrayBufferView(stdio) || typeof stdio === 'string') {\n      if (!sync) {\n        cleanup();\n        throw new ERR_INVALID_SYNC_FORK_INPUT(inspect(stdio));\n      }\n    } else {\n      // Cleanup\n      cleanup();\n      throw new ERR_INVALID_ARG_VALUE('stdio'\x2C stdio);\n    }\n\n    return acc;\n  }\x2C []);\n\n  return { stdio\x2C ipc\x2C ipcFd };\n}\n\n\nfunction getSocketList(type\x2C worker\x2C key) {\n  const sockets = worker[kChannelHandle].sockets[type];\n  let socketList = sockets[key];\n  if (!socketList) {\n    const Construct = type === 'send' ? SocketListSend : SocketListReceive;\n    socketList = sockets[key] = new Construct(worker\x2C key);\n  }\n  return socketList;\n}\n\n\nfunction maybeClose(subprocess) {\n  subprocess._closesGot++;\n\n  if (subprocess._closesGot === subprocess._closesNeeded) {\n    subprocess.emit('close'\x2C subprocess.exitCode\x2C subprocess.signalCode);\n  }\n}\n\nfunction spawnSync(options) {\n  const result = spawn_sync.spawn(options);\n\n  if (result.output && options.encoding && options.encoding !== 'buffer') {\n    for (let i = 0; i < result.output.length; i++) {\n      if (!result.output[i])\n        continue;\n      result.output[i] = result.output[i].toString(options.encoding);\n    }\n  }\n\n  result.stdout = result.output && result.output[1];\n  result.stderr = result.output && result.output[2];\n\n  if (result.error) {\n    result.error = errnoException(result.error\x2C 'spawnSync ' + options.file);\n    result.error.path = options.file;\n    result.error.spawnargs = ArrayPrototypeSlice(options.args\x2C 1);\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  ChildProcess\x2C\n  kChannelHandle\x2C\n  setupChannel\x2C\n  getValidStdio\x2C\n  stdioStringToArray\x2C\n  spawnSync\x2C\n};\n
code-source-info,0x30e767727d70,457,0,31449,C0O0C4O31449,,
code-creation,Function,10,66584,0x30e767729390,1265, node:internal/child_process:1:1,0x30e767727ce8,~
tick,0x195a84624,66584,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x30e7677225ac,0x41ccf0590b7,0x1100482ec,0x30e7677207bc,0x202f0287b58b,0x202f02879dd8,0x202f028761e9
tick,0x100d0a408,66584,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x30e7677225ac,0x41ccf0590b7,0x1100482ec,0x30e7677207bc,0x202f0287b58b,0x202f02879dd8,0x202f028761e9
code-source-info,0x30e767729390,457,0,31449,C0O0C296O25C302O41C308O63C314O87C320O110C325O131C331O156C337O180C342O204C348O220C354O244C359O254C365O566C371O566C376O294C387O325C393O351C399O378C405O407C411O440C417O468C423O494C429O516C435O539C441O676C447O676C452O604C458O621C464O639C470O656C476O729C482O729C486O729C488O760C494O760C498O760C500O790C506O790C510O790C512O824C518O824C523O856C527O824C529O881C535O881C539O881C541O930C544O930C549O918C555O1072C558O1072C563O973C569O986C575O1007C581O1029C587O1051C593O1147C596O1147C601O1112C607O1129C613O1193C616O1193C621O1185C627O1238C630O1238C635O1230C641O1283C644O1283C649O1275C655O1331C661O1331C666O1389C672O1389C677O1420C682O1372C688O1474C694O1474C699O1438C705O1460C711O1530C717O1530C722O1508C728O1581C731O1581C735O1581C737O1637C743O1637C748O1620C754O1780C757O1780C762O1675C768O1688C774O1701C780O1714C786O1727C792O1740C798O1753C804O1766C810O1812C816O1828C822O1984C823O1984C825O2000C826O2000C828O2048C830O2048C832O2074C835O2074C839O2074C841O2123C844O2123C848O2123C850O2174C853O2174C857O2174C859O2327C864O2345C869O2383C877O2449C891O2527C896O2565C904O2639C918O2804C923O2810C931O4371C939O5124C953O5607C958O5646C966O5712C980O5792C985O5831C993O5958C1009O2327C1011O7958C1019O7982C1024O7924C1029O7994C1032O7994C1037O8980C1046O8996C1050O12699C1059O12714C1063O13398C1072O13412C1076O13485C1085O13501C1137O13584C1193O13562C1195O14591C1200O14618C1203O14591C1205O14692C1206O14692C1208O26853C1210O26853C1212O27186C1214O27186C1216O31325C1223O31346C1229O31362C1235O31380C1241O31396C1247O31413C1253O31435C1259O31340C1264O31448,,
code-creation,Function,10,66709,0x30e767729b10,26,<instance_members_initializer> node:internal/child_process:522:1,0x30e767728a50,~
code-source-info,0x30e767729b10,457,13562,14559,C3O13612C11O13628C19O13653C25O14559,,
tick,0x10113ecac,67334,1,0x100b1d1ec,2,0x0,0x41ccf059096,0x1100482ec,0x30e76772957e,0x41ccf0590b7,0x1100482ec,0x30e7677225ac,0x41ccf0590b7,0x1100482ec,0x30e7677207bc,0x202f0287b58b,0x202f02879dd8,0x202f028761e9
code-creation,Eval,10,67542,0x30e76772ef68,5, node:net:1:1,0x30e76772d9a0,~
script-source,458,node:net,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypePush\x2C\n  Boolean\x2C\n  FunctionPrototypeBind\x2C\n  MathMax\x2C\n  Number\x2C\n  NumberIsNaN\x2C\n  NumberParseInt\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  Symbol\x2C\n  ObjectCreate\x2C\n} = primordials;\n\nconst EventEmitter = require('events');\nconst stream = require('stream');\nlet debug = require('internal/util/debuglog').debuglog('net'\x2C (fn) => {\n  debug = fn;\n});\nconst {\n  kWrapConnectedHandle\x2C\n  isIP\x2C\n  isIPv4\x2C\n  isIPv6\x2C\n  normalizedArgsSymbol\x2C\n  makeSyncWrite\x2C\n} = require('internal/net');\nconst assert = require('internal/assert');\nconst {\n  UV_EADDRINUSE\x2C\n  UV_EINVAL\x2C\n  UV_ENOTCONN\x2C\n} = internalBinding('uv');\n\nconst { Buffer } = require('buffer');\nconst { guessHandleType } = internalBinding('util');\nconst { ShutdownWrap } = internalBinding('stream_wrap');\nconst {\n  TCP\x2C\n  TCPConnectWrap\x2C\n  constants: TCPConstants\x2C\n} = internalBinding('tcp_wrap');\nconst {\n  Pipe\x2C\n  PipeConnectWrap\x2C\n  constants: PipeConstants\x2C\n} = internalBinding('pipe_wrap');\nconst {\n  newAsyncId\x2C\n  defaultTriggerAsyncIdScope\x2C\n  symbols: { async_id_symbol\x2C owner_symbol }\x2C\n} = require('internal/async_hooks');\nconst {\n  writevGeneric\x2C\n  writeGeneric\x2C\n  onStreamRead\x2C\n  kAfterAsyncWrite\x2C\n  kHandle\x2C\n  kUpdateTimer\x2C\n  setStreamTimeout\x2C\n  kBuffer\x2C\n  kBufferCb\x2C\n  kBufferGen\x2C\n} = require('internal/stream_base_commons');\nconst {\n  codes: {\n    ERR_INVALID_ADDRESS_FAMILY\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_FD_TYPE\x2C\n    ERR_INVALID_IP_ADDRESS\x2C\n    ERR_INVALID_HANDLE_TYPE\x2C\n    ERR_SERVER_ALREADY_LISTEN\x2C\n    ERR_SERVER_NOT_RUNNING\x2C\n    ERR_SOCKET_CLOSED\x2C\n    ERR_SOCKET_CLOSED_BEFORE_CONNECTION\x2C\n    ERR_MISSING_ARGS\x2C\n  }\x2C\n  aggregateErrors\x2C\n  errnoException\x2C\n  exceptionWithHostPort\x2C\n  genericNodeError\x2C\n  uvExceptionWithHostPort\x2C\n} = require('internal/errors');\nconst { isUint8Array } = require('internal/util/types');\nconst { queueMicrotask } = require('internal/process/task_queues');\nconst { kEmptyObject } = require('internal/util');\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateNumber\x2C\n  validatePort\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst kLastWriteQueueSize = Symbol('lastWriteQueueSize');\nconst {\n  DTRACE_NET_SERVER_CONNECTION\x2C\n  DTRACE_NET_STREAM_END\x2C\n} = require('internal/dtrace');\n\n// Lazy loaded to improve startup performance.\nlet cluster;\nlet dns;\nlet BlockList;\nlet SocketAddress;\n\nconst { clearTimeout\x2C setTimeout } = require('timers');\nconst { kTimeout } = require('internal/timers');\nconst kTimeoutTriggered = Symbol('kTimeoutTriggered');\n\nconst DEFAULT_IPV4_ADDR = '0.0.0.0';\nconst DEFAULT_IPV6_ADDR = '::';\n\nconst isWindows = process.platform === 'win32';\n\nconst noop = () => {};\n\nconst kPerfHooksNetConnectContext = Symbol('kPerfHooksNetConnectContext');\n\nlet netClientSocketChannel;\nlet netServerSocketChannel;\nfunction lazyChannels() {\n  // TODO(joyeecheung): support diagnostics channels in the snapshot.\n  // For now it is fine to create them lazily when there isn't a snapshot to\n  // build. If users need the channels they would have to create them first\n  // before invoking any built-ins that would publish to these channels\n  // anyway.\n  if (netClientSocketChannel === undefined) {\n    const dc = require('diagnostics_channel');\n    netClientSocketChannel = dc.channel('net.client.socket');\n    netServerSocketChannel = dc.channel('net.server.socket');\n  }\n}\n\nconst {\n  hasObserver\x2C\n  startPerf\x2C\n  stopPerf\x2C\n} = require('internal/perf/observe');\nconst { getDefaultHighWaterMark } = require('internal/streams/state');\n\nfunction getFlags(ipv6Only) {\n  return ipv6Only === true ? TCPConstants.UV_TCP_IPV6ONLY : 0;\n}\n\nfunction createHandle(fd\x2C is_server) {\n  validateInt32(fd\x2C 'fd'\x2C 0);\n  const type = guessHandleType(fd);\n  if (type === 'PIPE') {\n    return new Pipe(\n      is_server ? PipeConstants.SERVER : PipeConstants.SOCKET\x2C\n    );\n  }\n\n  if (type === 'TCP') {\n    return new TCP(\n      is_server ? TCPConstants.SERVER : TCPConstants.SOCKET\x2C\n    );\n  }\n\n  throw new ERR_INVALID_FD_TYPE(type);\n}\n\n\nfunction getNewAsyncId(handle) {\n  return (!handle || typeof handle.getAsyncId !== 'function') ?\n    newAsyncId() : handle.getAsyncId();\n}\n\n\nfunction isPipeName(s) {\n  return typeof s === 'string' && toNumber(s) === false;\n}\n\n/**\n * Creates a new TCP or IPC server\n * @param {{\n *   allowHalfOpen?: boolean;\n *   pauseOnConnect?: boolean;\n *   }} [options]\n * @param {Function} [connectionListener]\n * @returns {Server}\n */\n\nfunction createServer(options\x2C connectionListener) {\n  return new Server(options\x2C connectionListener);\n}\n\n\n// Target API:\n//\n// let s = net.connect({port: 80\x2C host: 'google.com'}\x2C function() {\n//   ...\n// });\n//\n// There are various forms:\n//\n// connect(options\x2C [cb])\n// connect(port\x2C [host]\x2C [cb])\n// connect(path\x2C [cb]);\n//\nfunction connect(...args) {\n  const normalized = normalizeArgs(args);\n  const options = normalized[0];\n  debug('createConnection'\x2C normalized);\n  const socket = new Socket(options);\n  lazyChannels();\n  if (netClientSocketChannel.hasSubscribers) {\n    netClientSocketChannel.publish({\n      socket\x2C\n    });\n  }\n  if (options.timeout) {\n    socket.setTimeout(options.timeout);\n  }\n\n  return socket.connect(normalized);\n}\n\n\n// Returns an array [options\x2C cb]\x2C where options is an object\x2C\n// cb is either a function or null.\n// Used to normalize arguments of Socket.prototype.connect() and\n// Server.prototype.listen(). Possible combinations of parameters:\n//   (options[...][\x2C cb])\n//   (path[...][\x2C cb])\n//   ([port][\x2C host][...][\x2C cb])\n// For Socket.prototype.connect()\x2C the [...] part is ignored\n// For Server.prototype.listen()\x2C the [...] part is [\x2C backlog]\n// but will not be handled here (handled in listen())\nfunction normalizeArgs(args) {\n  let arr;\n\n  if (args.length === 0) {\n    arr = [{}\x2C null];\n    arr[normalizedArgsSymbol] = true;\n    return arr;\n  }\n\n  const arg0 = args[0];\n  let options = {};\n  if (typeof arg0 === 'object' && arg0 !== null) {\n    // (options[...][\x2C cb])\n    options = arg0;\n  } else if (isPipeName(arg0)) {\n    // (path[...][\x2C cb])\n    options.path = arg0;\n  } else {\n    // ([port][\x2C host][...][\x2C cb])\n    options.port = arg0;\n    if (args.length > 1 && typeof args[1] === 'string') {\n      options.host = args[1];\n    }\n  }\n\n  const cb = args[args.length - 1];\n  if (typeof cb !== 'function')\n    arr = [options\x2C null];\n  else\n    arr = [options\x2C cb];\n\n  arr[normalizedArgsSymbol] = true;\n  return arr;\n}\n\n\n// Called when creating new Socket\x2C or when re-using a closed Socket\nfunction initSocketHandle(self) {\n  self._undestroy();\n  self._sockname = null;\n\n  // Handle creation may be deferred to bind() or connect() time.\n  if (self._handle) {\n    self._handle[owner_symbol] = self;\n    self._handle.onread = onStreamRead;\n    self[async_id_symbol] = getNewAsyncId(self._handle);\n\n    let userBuf = self[kBuffer];\n    if (userBuf) {\n      const bufGen = self[kBufferGen];\n      if (bufGen !== null) {\n        userBuf = bufGen();\n        if (!isUint8Array(userBuf))\n          return;\n        self[kBuffer] = userBuf;\n      }\n      self._handle.useUserBuffer(userBuf);\n    }\n  }\n}\n\nfunction closeSocketHandle(self\x2C isException\x2C isCleanupPending = false) {\n  if (self._handle) {\n    self._handle.close(() => {\n      debug('emit close');\n      self.emit('close'\x2C isException);\n      if (isCleanupPending) {\n        self._handle.onread = noop;\n        self._handle = null;\n        self._sockname = null;\n      }\n    });\n  }\n}\n\nconst kBytesRead = Symbol('kBytesRead');\nconst kBytesWritten = Symbol('kBytesWritten');\nconst kSetNoDelay = Symbol('kSetNoDelay');\nconst kSetKeepAlive = Symbol('kSetKeepAlive');\nconst kSetKeepAliveInitialDelay = Symbol('kSetKeepAliveInitialDelay');\n\nfunction Socket(options) {\n  if (!(this instanceof Socket)) return new Socket(options);\n  if (options?.objectMode) {\n    throw new ERR_INVALID_ARG_VALUE(\n      'options.objectMode'\x2C\n      options.objectMode\x2C\n      'is not supported'\x2C\n    );\n  } else if (options?.readableObjectMode || options?.writableObjectMode) {\n    throw new ERR_INVALID_ARG_VALUE(\n      `options.${\n        options.readableObjectMode ? 'readableObjectMode' : 'writableObjectMode'\n      }`\x2C\n      options.readableObjectMode || options.writableObjectMode\x2C\n      'is not supported'\x2C\n    );\n  }\n  if (typeof options?.keepAliveInitialDelay !== 'undefined') {\n    validateNumber(\n      options?.keepAliveInitialDelay\x2C 'options.keepAliveInitialDelay'\x2C\n    );\n\n    if (options.keepAliveInitialDelay < 0) {\n      options.keepAliveInitialDelay = 0;\n    }\n  }\n\n  this.connecting = false;\n  // Problem with this is that users can supply their own handle\x2C that may not\n  // have _handle.getAsyncId(). In this case an[async_id_symbol] should\n  // probably be supplied by async_hooks.\n  this[async_id_symbol] = -1;\n  this._hadError = false;\n  this[kHandle] = null;\n  this._parent = null;\n  this._host = null;\n  this[kLastWriteQueueSize] = 0;\n  this[kTimeout] = null;\n  this[kBuffer] = null;\n  this[kBufferCb] = null;\n  this[kBufferGen] = null;\n  this._closeAfterHandlingError = false;\n\n  if (typeof options === 'number')\n    options = { fd: options }; // Legacy interface.\n  else\n    options = { ...options };\n\n  // Default to *not* allowing half open sockets.\n  options.allowHalfOpen = Boolean(options.allowHalfOpen);\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n  options.autoDestroy = true;\n  // Handle strings directly.\n  options.decodeStrings = false;\n  stream.Duplex.call(this\x2C options);\n\n  if (options.handle) {\n    this._handle = options.handle; // private\n    this[async_id_symbol] = getNewAsyncId(this._handle);\n  } else if (options.fd !== undefined) {\n    const { fd } = options;\n    let err;\n\n    // createHandle will throw ERR_INVALID_FD_TYPE if `fd` is not\n    // a valid `PIPE` or `TCP` descriptor\n    this._handle = createHandle(fd\x2C false);\n\n    err = this._handle.open(fd);\n\n    // While difficult to fabricate\x2C in some architectures\n    // `open` may return an error code for valid file descriptors\n    // which cannot be opened. This is difficult to test as most\n    // un-openable fds will throw on `createHandle`\n    if (err)\n      throw errnoException(err\x2C 'open');\n\n    this[async_id_symbol] = this._handle.getAsyncId();\n\n    if ((fd === 1 || fd === 2) &&\n        (this._handle instanceof Pipe) && isWindows) {\n      // Make stdout and stderr blocking on Windows\n      err = this._handle.setBlocking(true);\n      if (err)\n        throw errnoException(err\x2C 'setBlocking');\n\n      this._writev = null;\n      this._write = makeSyncWrite(fd);\n      // makeSyncWrite adjusts this value like the original handle would\x2C so\n      // we need to let it do that by turning it into a writable\x2C own\n      // property.\n      ObjectDefineProperty(this._handle\x2C 'bytesWritten'\x2C {\n        __proto__: null\x2C\n        value: 0\x2C writable: true\x2C\n      });\n    }\n  }\n\n  const onread = options.onread;\n  if (onread !== null && typeof onread === 'object' &&\n      (isUint8Array(onread.buffer) || typeof onread.buffer === 'function') &&\n      typeof onread.callback === 'function') {\n    if (typeof onread.buffer === 'function') {\n      this[kBuffer] = true;\n      this[kBufferGen] = onread.buffer;\n    } else {\n      this[kBuffer] = onread.buffer;\n    }\n    this[kBufferCb] = onread.callback;\n  }\n\n  this[kSetNoDelay] = Boolean(options.noDelay);\n  this[kSetKeepAlive] = Boolean(options.keepAlive);\n  this[kSetKeepAliveInitialDelay] = ~~(options.keepAliveInitialDelay / 1000);\n\n  // Shut down the socket when we're finished with it.\n  this.on('end'\x2C onReadableStreamEnd);\n\n  initSocketHandle(this);\n\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  // If we have a handle\x2C then start the flow of data into the\n  // buffer.  if not\x2C then this will happen when we connect\n  if (this._handle && options.readable !== false) {\n    if (options.pauseOnCreate) {\n      // Stop the handle from reading and pause the stream\n      this._handle.reading = false;\n      this._handle.readStop();\n      this.readableFlowing = false;\n    } else if (!options.manualStart) {\n      this.read(0);\n    }\n  }\n\n  // Reserve properties\n  this.server = null;\n  this._server = null;\n\n  // Used after `.destroy()`\n  this[kBytesRead] = 0;\n  this[kBytesWritten] = 0;\n}\nObjectSetPrototypeOf(Socket.prototype\x2C stream.Duplex.prototype);\nObjectSetPrototypeOf(Socket\x2C stream.Duplex);\n\n// Refresh existing timeouts.\nSocket.prototype._unrefTimer = function _unrefTimer() {\n  for (let s = this; s !== null; s = s._parent) {\n    if (s[kTimeout])\n      s[kTimeout].refresh();\n  }\n};\n\n\n// The user has called .end()\x2C and all the bytes have been\n// sent out to the other side.\nSocket.prototype._final = function(cb) {\n  // If still connecting - defer handling `_final` until 'connect' will happen\n  if (this.pending) {\n    debug('_final: not yet connected');\n    return this.once('connect'\x2C () => this._final(cb));\n  }\n\n  if (!this._handle)\n    return cb();\n\n  debug('_final: not ended\x2C call shutdown()');\n\n  const req = new ShutdownWrap();\n  req.oncomplete = afterShutdown;\n  req.handle = this._handle;\n  req.callback = cb;\n  const err = this._handle.shutdown(req);\n\n  if (err === 1 || err === UV_ENOTCONN)  // synchronous finish\n    return cb();\n  else if (err !== 0)\n    return cb(errnoException(err\x2C 'shutdown'));\n};\n\nfunction afterShutdown() {\n  const self = this.handle[owner_symbol];\n\n  debug('afterShutdown destroyed=%j'\x2C self.destroyed);\n\n  this.callback();\n}\n\n// Provide a better error message when we call end() as a result\n// of the other side sending a FIN.  The standard 'write after end'\n// is overly vague\x2C and makes it seem like the user's code is to blame.\nfunction writeAfterFIN(chunk\x2C encoding\x2C cb) {\n  if (!this.writableEnded) {\n    return stream.Duplex.prototype.write.call(this\x2C chunk\x2C encoding\x2C cb);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  const er = genericNodeError(\n    'This socket has been ended by the other party'\x2C\n    { code: 'EPIPE' }\x2C\n  );\n  if (typeof cb === 'function') {\n    defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C process.nextTick\x2C cb\x2C er);\n  }\n  this.destroy(er);\n\n  return false;\n}\n\nSocket.prototype.setTimeout = setStreamTimeout;\n\n\nSocket.prototype._onTimeout = function() {\n  const handle = this._handle;\n  const lastWriteQueueSize = this[kLastWriteQueueSize];\n  if (lastWriteQueueSize > 0 && handle) {\n    // `lastWriteQueueSize !== writeQueueSize` means there is\n    // an active write in progress\x2C so we suppress the timeout.\n    const { writeQueueSize } = handle;\n    if (lastWriteQueueSize !== writeQueueSize) {\n      this[kLastWriteQueueSize] = writeQueueSize;\n      this._unrefTimer();\n      return;\n    }\n  }\n  debug('_onTimeout');\n  this.emit('timeout');\n};\n\n\nSocket.prototype.setNoDelay = function(enable) {\n  // Backwards compatibility: assume true when `enable` is omitted\n  enable = Boolean(enable === undefined ? true : enable);\n\n  if (!this._handle) {\n    this[kSetNoDelay] = enable;\n    return this;\n  }\n\n  if (this._handle.setNoDelay && enable !== this[kSetNoDelay]) {\n    this[kSetNoDelay] = enable;\n    this._handle.setNoDelay(enable);\n  }\n\n  return this;\n};\n\n\nSocket.prototype.setKeepAlive = function(enable\x2C initialDelayMsecs) {\n  enable = Boolean(enable);\n  const initialDelay = ~~(initialDelayMsecs / 1000);\n\n  if (!this._handle) {\n    this[kSetKeepAlive] = enable;\n    this[kSetKeepAliveInitialDelay] = initialDelay;\n    return this;\n  }\n\n  if (!this._handle.setKeepAlive) {\n    return this;\n  }\n\n  if (enable !== this[kSetKeepAlive] ||\n      (\n        enable &&\n        this[kSetKeepAliveInitialDelay] !== initialDelay\n      )\n  ) {\n    this[kSetKeepAlive] = enable;\n    this[kSetKeepAliveInitialDelay] = initialDelay;\n    this._handle.setKeepAlive(enable\x2C initialDelay);\n  }\n\n  return this;\n};\n\n\nSocket.prototype.address = function() {\n  return this._getsockname();\n};\n\n\nObjectDefineProperty(Socket.prototype\x2C '_connecting'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    return this.connecting;\n  }\x2C\n});\n\nObjectDefineProperty(Socket.prototype\x2C 'pending'\x2C {\n  __proto__: null\x2C\n  get() {\n    return !this._handle || this.connecting;\n  }\x2C\n  configurable: true\x2C\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C 'readyState'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    if (this.connecting) {\n      return 'opening';\n    } else if (this.readable && this.writable) {\n      return 'open';\n    } else if (this.readable && !this.writable) {\n      return 'readOnly';\n    } else if (!this.readable && this.writable) {\n      return 'writeOnly';\n    }\n    return 'closed';\n  }\x2C\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C 'bufferSize'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    if (this._handle) {\n      return this.writableLength;\n    }\n  }\x2C\n});\n\nObjectDefineProperty(Socket.prototype\x2C kUpdateTimer\x2C {\n  __proto__: null\x2C\n  get: function() {\n    return this._unrefTimer;\n  }\x2C\n});\n\n\nfunction tryReadStart(socket) {\n  // Not already reading\x2C start the flow\n  debug('Socket._handle.readStart');\n  socket._handle.reading = true;\n  const err = socket._handle.readStart();\n  if (err)\n    socket.destroy(errnoException(err\x2C 'read'));\n}\n\n// Just call handle.readStart until we have enough in the buffer\nSocket.prototype._read = function(n) {\n  debug('_read');\n\n  if (this.connecting || !this._handle) {\n    debug('_read wait for connection');\n    this.once('connect'\x2C () => this._read(n));\n  } else if (!this._handle.reading) {\n    tryReadStart(this);\n  }\n};\n\n\nSocket.prototype.end = function(data\x2C encoding\x2C callback) {\n  stream.Duplex.prototype.end.call(this\x2C\n                                   data\x2C encoding\x2C callback);\n  DTRACE_NET_STREAM_END(this);\n  return this;\n};\n\nSocket.prototype.resetAndDestroy = function() {\n  if (this._handle) {\n    if (!(this._handle instanceof TCP))\n      throw new ERR_INVALID_HANDLE_TYPE();\n    if (this.connecting) {\n      debug('reset wait for connection');\n      this.once('connect'\x2C () => this._reset());\n    } else {\n      this._reset();\n    }\n  } else {\n    this.destroy(new ERR_SOCKET_CLOSED());\n  }\n  return this;\n};\n\nSocket.prototype.pause = function() {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      this._handle.reading) {\n    this._handle.reading = false;\n    if (!this.destroyed) {\n      const err = this._handle.readStop();\n      if (err)\n        this.destroy(errnoException(err\x2C 'read'));\n    }\n  }\n  return stream.Duplex.prototype.pause.call(this);\n};\n\n\nSocket.prototype.resume = function() {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      !this._handle.reading) {\n    tryReadStart(this);\n  }\n  return stream.Duplex.prototype.resume.call(this);\n};\n\n\nSocket.prototype.read = function(n) {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      !this._handle.reading) {\n    tryReadStart(this);\n  }\n  return stream.Duplex.prototype.read.call(this\x2C n);\n};\n\n\n// Called when the 'end' event is emitted.\nfunction onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n  }\n}\n\n\nSocket.prototype.destroySoon = function() {\n  if (this.writable)\n    this.end();\n\n  if (this.writableFinished)\n    this.destroy();\n  else\n    this.once('finish'\x2C this.destroy);\n};\n\n\nSocket.prototype._destroy = function(exception\x2C cb) {\n  debug('destroy');\n\n  this.connecting = false;\n\n  for (let s = this; s !== null; s = s._parent) {\n    clearTimeout(s[kTimeout]);\n  }\n\n  debug('close');\n  if (this._handle) {\n    if (this !== process.stderr)\n      debug('close handle');\n    const isException = exception ? true : false;\n    // `bytesRead` and `kBytesWritten` should be accessible after `.destroy()`\n    this[kBytesRead] = this._handle.bytesRead;\n    this[kBytesWritten] = this._handle.bytesWritten;\n\n    if (this.resetAndClosing) {\n      this.resetAndClosing = false;\n      const err = this._handle.reset(() => {\n        debug('emit close');\n        this.emit('close'\x2C isException);\n      });\n      if (err)\n        this.emit('error'\x2C errnoException(err\x2C 'reset'));\n    } else if (this._closeAfterHandlingError) {\n      // Enqueue closing the socket as a microtask\x2C so that the socket can be\n      // accessible when an `error` event is handled in the `next tick queue`.\n      queueMicrotask(() => closeSocketHandle(this\x2C isException\x2C true));\n    } else {\n      closeSocketHandle(this\x2C isException);\n    }\n\n    if (!this._closeAfterHandlingError) {\n      this._handle.onread = noop;\n      this._handle = null;\n      this._sockname = null;\n    }\n    cb(exception);\n  } else {\n    cb(exception);\n    process.nextTick(emitCloseNT\x2C this);\n  }\n\n  if (this._server) {\n    debug('has server');\n    this._server._connections--;\n    if (this._server._emitCloseIfDrained) {\n      this._server._emitCloseIfDrained();\n    }\n  }\n};\n\nSocket.prototype._reset = function() {\n  debug('reset connection');\n  this.resetAndClosing = true;\n  return this.destroy();\n};\n\nSocket.prototype._getpeername = function() {\n  if (!this._handle || !this._handle.getpeername || this.connecting) {\n    return this._peername || {};\n  } else if (!this._peername) {\n    const out = {};\n    const err = this._handle.getpeername(out);\n    if (err) return out;\n    this._peername = out;\n  }\n  return this._peername;\n};\n\nfunction protoGetter(name\x2C callback) {\n  ObjectDefineProperty(Socket.prototype\x2C name\x2C {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    get: callback\x2C\n  });\n}\n\nprotoGetter('bytesRead'\x2C function bytesRead() {\n  return this._handle ? this._handle.bytesRead : this[kBytesRead];\n});\n\nprotoGetter('remoteAddress'\x2C function remoteAddress() {\n  return this._getpeername().address;\n});\n\nprotoGetter('remoteFamily'\x2C function remoteFamily() {\n  return this._getpeername().family;\n});\n\nprotoGetter('remotePort'\x2C function remotePort() {\n  return this._getpeername().port;\n});\n\n\nSocket.prototype._getsockname = function() {\n  if (!this._handle || !this._handle.getsockname) {\n    return {};\n  } else if (!this._sockname) {\n    this._sockname = {};\n    // FIXME(bnoordhuis) Throw when the return value is not 0?\n    this._handle.getsockname(this._sockname);\n  }\n  return this._sockname;\n};\n\n\nprotoGetter('localAddress'\x2C function localAddress() {\n  return this._getsockname().address;\n});\n\n\nprotoGetter('localPort'\x2C function localPort() {\n  return this._getsockname().port;\n});\n\nprotoGetter('localFamily'\x2C function localFamily() {\n  return this._getsockname().family;\n});\n\nSocket.prototype[kAfterAsyncWrite] = function() {\n  this[kLastWriteQueueSize] = 0;\n};\n\nSocket.prototype._writeGeneric = function(writev\x2C data\x2C encoding\x2C cb) {\n  // If we are still connecting\x2C then buffer this for later.\n  // The Writable logic will buffer up any more writes while\n  // waiting for this one to be done.\n  if (this.connecting) {\n    this._pendingData = data;\n    this._pendingEncoding = encoding;\n    this.once('connect'\x2C function connect() {\n      this.off('close'\x2C onClose);\n      this._writeGeneric(writev\x2C data\x2C encoding\x2C cb);\n    });\n    function onClose() {\n      cb(new ERR_SOCKET_CLOSED_BEFORE_CONNECTION());\n    }\n    this.once('close'\x2C onClose);\n    return;\n  }\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  if (!this._handle) {\n    cb(new ERR_SOCKET_CLOSED());\n    return false;\n  }\n\n  this._unrefTimer();\n\n  let req;\n  if (writev)\n    req = writevGeneric(this\x2C data\x2C cb);\n  else\n    req = writeGeneric(this\x2C data\x2C encoding\x2C cb);\n  if (req.async)\n    this[kLastWriteQueueSize] = req.bytes;\n};\n\n\nSocket.prototype._writev = function(chunks\x2C cb) {\n  this._writeGeneric(true\x2C chunks\x2C ''\x2C cb);\n};\n\n\nSocket.prototype._write = function(data\x2C encoding\x2C cb) {\n  this._writeGeneric(false\x2C data\x2C encoding\x2C cb);\n};\n\n\n// Legacy alias. Having this is probably being overly cautious\x2C but it doesn't\n// really hurt anyone either. This can probably be removed safely if desired.\nprotoGetter('_bytesDispatched'\x2C function _bytesDispatched() {\n  return this._handle ? this._handle.bytesWritten : this[kBytesWritten];\n});\n\nprotoGetter('bytesWritten'\x2C function bytesWritten() {\n  let bytes = this._bytesDispatched;\n  const data = this._pendingData;\n  const encoding = this._pendingEncoding;\n  const writableBuffer = this.writableBuffer;\n\n  if (!writableBuffer)\n    return undefined;\n\n  for (const el of writableBuffer) {\n    bytes += el.chunk instanceof Buffer ?\n      el.chunk.length :\n      Buffer.byteLength(el.chunk\x2C el.encoding);\n  }\n\n  if (ArrayIsArray(data)) {\n    // Was a writev\x2C iterate over chunks to get total length\n    for (let i = 0; i < data.length; i++) {\n      const chunk = data[i];\n\n      if (data.allBuffers || chunk instanceof Buffer)\n        bytes += chunk.length;\n      else\n        bytes += Buffer.byteLength(chunk.chunk\x2C chunk.encoding);\n    }\n  } else if (data) {\n    // Writes are either a string or a Buffer.\n    if (typeof data !== 'string')\n      bytes += data.length;\n    else\n      bytes += Buffer.byteLength(data\x2C encoding);\n  }\n\n  return bytes;\n});\n\n\nfunction checkBindError(err\x2C port\x2C handle) {\n  // EADDRINUSE may not be reported until we call listen() or connect().\n  // To complicate matters\x2C a failed bind() followed by listen() or connect()\n  // will implicitly bind to a random port. Ergo\x2C check that the socket is\n  // bound to the expected port before calling listen() or connect().\n  //\n  // FIXME(bnoordhuis) Doesn't work for pipe handles\x2C they don't have a\n  // getsockname() method. Non-issue for now\x2C the cluster module doesn't\n  // really support pipes anyway.\n  if (err === 0 && port > 0 && handle.getsockname) {\n    const out = {};\n    err = handle.getsockname(out);\n    if (err === 0 && port !== out.port) {\n      debug(`checkBindError\x2C bound to ${out.port} instead of ${port}`);\n      err = UV_EADDRINUSE;\n    }\n  }\n  return err;\n}\n\n\nfunction internalConnect(\n  self\x2C address\x2C port\x2C addressType\x2C localAddress\x2C localPort\x2C flags) {\n  // TODO return promise from Socket.prototype.connect which\n  // wraps _connectReq.\n\n  assert(self.connecting);\n\n  let err;\n\n  if (localAddress || localPort) {\n    if (addressType === 4) {\n      localAddress = localAddress || DEFAULT_IPV4_ADDR;\n      err = self._handle.bind(localAddress\x2C localPort);\n    } else { // addressType === 6\n      localAddress = localAddress || DEFAULT_IPV6_ADDR;\n      err = self._handle.bind6(localAddress\x2C localPort\x2C flags);\n    }\n    debug('binding to localAddress: %s and localPort: %d (addressType: %d)'\x2C\n          localAddress\x2C localPort\x2C addressType);\n\n    err = checkBindError(err\x2C localPort\x2C self._handle);\n    if (err) {\n      const ex = exceptionWithHostPort(err\x2C 'bind'\x2C localAddress\x2C localPort);\n      self.destroy(ex);\n      return;\n    }\n  }\n\n  if (addressType === 6 || addressType === 4) {\n    const req = new TCPConnectWrap();\n    req.oncomplete = afterConnect;\n    req.address = address;\n    req.port = port;\n    req.localAddress = localAddress;\n    req.localPort = localPort;\n\n    if (addressType === 4)\n      err = self._handle.connect(req\x2C address\x2C port);\n    else\n      err = self._handle.connect6(req\x2C address\x2C port);\n  } else {\n    const req = new PipeConnectWrap();\n    req.address = address;\n    req.oncomplete = afterConnect;\n\n    err = self._handle.connect(req\x2C address);\n  }\n\n  if (err) {\n    const sockname = self._getsockname();\n    let details;\n\n    if (sockname) {\n      details = sockname.address + ':' + sockname.port;\n    }\n\n    const ex = exceptionWithHostPort(err\x2C 'connect'\x2C address\x2C port\x2C details);\n    self.destroy(ex);\n  } else if ((addressType === 6 || addressType === 4) && hasObserver('net')) {\n    startPerf(self\x2C kPerfHooksNetConnectContext\x2C { type: 'net'\x2C name: 'connect'\x2C detail: { host: address\x2C port } });\n  }\n}\n\n\nfunction internalConnectMultiple(context) {\n  clearTimeout(context[kTimeout]);\n  const self = context.socket;\n  assert(self.connecting);\n\n  // All connections have been tried without success\x2C destroy with error\n  if (context.current === context.addresses.length) {\n    self.destroy(aggregateErrors(context.errors));\n    return;\n  }\n\n  const { localPort\x2C port\x2C flags } = context;\n  const { address\x2C family: addressType } = context.addresses[context.current++];\n  const handle = new TCP(TCPConstants.SOCKET);\n  let localAddress;\n  let err;\n\n  if (localPort) {\n    if (addressType === 4) {\n      localAddress = DEFAULT_IPV4_ADDR;\n      err = handle.bind(localAddress\x2C localPort);\n    } else { // addressType === 6\n      localAddress = DEFAULT_IPV6_ADDR;\n      err = handle.bind6(localAddress\x2C localPort\x2C flags);\n    }\n\n    debug('connect/multiple: binding to localAddress: %s and localPort: %d (addressType: %d)'\x2C\n          localAddress\x2C localPort\x2C addressType);\n\n    err = checkBindError(err\x2C localPort\x2C handle);\n    if (err) {\n      ArrayPrototypePush(context.errors\x2C exceptionWithHostPort(err\x2C 'bind'\x2C localAddress\x2C localPort));\n      internalConnectMultiple(context);\n      return;\n    }\n  }\n\n  const req = new TCPConnectWrap();\n  req.oncomplete = FunctionPrototypeBind(afterConnectMultiple\x2C undefined\x2C context);\n  req.address = address;\n  req.port = port;\n  req.localAddress = localAddress;\n  req.localPort = localPort;\n\n  if (addressType === 4) {\n    err = handle.connect(req\x2C address\x2C port);\n  } else {\n    err = handle.connect6(req\x2C address\x2C port);\n  }\n\n  if (err) {\n    const sockname = self._getsockname();\n    let details;\n\n    if (sockname) {\n      details = sockname.address + ':' + sockname.port;\n    }\n\n    ArrayPrototypePush(context.errors\x2C exceptionWithHostPort(err\x2C 'connect'\x2C address\x2C port\x2C details));\n    internalConnectMultiple(context);\n    return;\n  }\n\n  // If the attempt has not returned an error\x2C start the connection timer\n  context[kTimeout] = setTimeout(internalConnectMultipleTimeout\x2C context.timeout\x2C context\x2C req);\n}\n\nSocket.prototype.connect = function(...args) {\n  let normalized;\n  // If passed an array\x2C it's treated as an array of arguments that have\n  // already been normalized (so we don't normalize more than once). This has\n  // been solved before in https://github.com/nodejs/node/pull/12342\x2C but was\n  // reverted as it had unintended side effects.\n  if (ArrayIsArray(args[0]) && args[0][normalizedArgsSymbol]) {\n    normalized = args[0];\n  } else {\n    normalized = normalizeArgs(args);\n  }\n  const options = normalized[0];\n  const cb = normalized[1];\n\n  // options.port === null will be checked later.\n  if (options.port === undefined && options.path == null)\n    throw new ERR_MISSING_ARGS(['options'\x2C 'port'\x2C 'path']);\n\n  if (this.write !== Socket.prototype.write)\n    this.write = Socket.prototype.write;\n\n  if (this.destroyed) {\n    this._handle = null;\n    this._peername = null;\n    this._sockname = null;\n  }\n\n  const { path } = options;\n  const pipe = !!path;\n  debug('pipe'\x2C pipe\x2C path);\n\n  if (!this._handle) {\n    this._handle = pipe ?\n      new Pipe(PipeConstants.SOCKET) :\n      new TCP(TCPConstants.SOCKET);\n    initSocketHandle(this);\n  }\n\n  if (cb !== null) {\n    this.once('connect'\x2C cb);\n  }\n\n  this._unrefTimer();\n\n  this.connecting = true;\n\n  if (pipe) {\n    validateString(path\x2C 'options.path');\n    defaultTriggerAsyncIdScope(\n      this[async_id_symbol]\x2C internalConnect\x2C this\x2C path\x2C\n    );\n  } else {\n    lookupAndConnect(this\x2C options);\n  }\n  return this;\n};\n\nfunction socketToDnsFamily(family) {\n  switch (family) {\n    case 'IPv4':\n      return 4;\n    case 'IPv6':\n      return 6;\n  }\n\n  return family;\n}\n\nfunction lookupAndConnect(self\x2C options) {\n  const { localAddress\x2C localPort\x2C autoSelectFamily } = options;\n  const host = options.host || 'localhost';\n  let { port\x2C autoSelectFamilyAttemptTimeout } = options;\n\n  if (localAddress && !isIP(localAddress)) {\n    throw new ERR_INVALID_IP_ADDRESS(localAddress);\n  }\n\n  if (localPort) {\n    validateNumber(localPort\x2C 'options.localPort');\n  }\n\n  if (typeof port !== 'undefined') {\n    if (typeof port !== 'number' && typeof port !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('options.port'\x2C\n                                     ['number'\x2C 'string']\x2C port);\n    }\n    validatePort(port);\n  }\n  port |= 0;\n\n  if (autoSelectFamily !== undefined) {\n    validateBoolean(autoSelectFamily);\n  }\n\n  if (autoSelectFamilyAttemptTimeout !== undefined) {\n    validateInt32(autoSelectFamilyAttemptTimeout\x2C 'options.autoSelectFamilyAttemptTimeout'\x2C 1);\n\n    if (autoSelectFamilyAttemptTimeout < 10) {\n      autoSelectFamilyAttemptTimeout = 10;\n    }\n  } else {\n    autoSelectFamilyAttemptTimeout = 250;\n  }\n\n  // If host is an IP\x2C skip performing a lookup\n  const addressType = isIP(host);\n  if (addressType) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C process.nextTick\x2C () => {\n      if (self.connecting)\n        defaultTriggerAsyncIdScope(\n          self[async_id_symbol]\x2C\n          internalConnect\x2C\n          self\x2C host\x2C port\x2C addressType\x2C localAddress\x2C localPort\x2C\n        );\n    });\n    return;\n  }\n\n  if (options.lookup !== undefined)\n    validateFunction(options.lookup\x2C 'options.lookup');\n\n  if (dns === undefined) dns = require('dns');\n  const dnsopts = {\n    family: socketToDnsFamily(options.family)\x2C\n    hints: options.hints || 0\x2C\n  };\n\n  if (!isWindows &&\n      dnsopts.family !== 4 &&\n      dnsopts.family !== 6 &&\n      dnsopts.hints === 0) {\n    dnsopts.hints = dns.ADDRCONFIG;\n  }\n\n  debug('connect: find host'\x2C host);\n  debug('connect: dns options'\x2C dnsopts);\n  self._host = host;\n  const lookup = options.lookup || dns.lookup;\n\n  if (dnsopts.family !== 4 && dnsopts.family !== 6 && !localAddress && autoSelectFamily) {\n    debug('connect: autodetecting');\n\n    dnsopts.all = true;\n    lookupAndConnectMultiple(\n      self\x2C\n      async_id_symbol\x2C\n      lookup\x2C\n      host\x2C\n      options\x2C\n      dnsopts\x2C\n      port\x2C\n      localPort\x2C\n      autoSelectFamilyAttemptTimeout\x2C\n    );\n\n    return;\n  }\n\n  defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C function() {\n    lookup(host\x2C dnsopts\x2C function emitLookup(err\x2C ip\x2C addressType) {\n      self.emit('lookup'\x2C err\x2C ip\x2C addressType\x2C host);\n\n      // It's possible we were destroyed while looking this up.\n      // XXX it would be great if we could cancel the promise returned by\n      // the look up.\n      if (!self.connecting) return;\n\n      if (err) {\n        // net.createConnection() creates a net.Socket object and immediately\n        // calls net.Socket.connect() on it (that's us). There are no event\n        // listeners registered yet so defer the error event to the next tick.\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else if (!isIP(ip)) {\n        err = new ERR_INVALID_IP_ADDRESS(ip);\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else if (addressType !== 4 && addressType !== 6) {\n        err = new ERR_INVALID_ADDRESS_FAMILY(addressType\x2C\n                                             options.host\x2C\n                                             options.port);\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else {\n        self._unrefTimer();\n        defaultTriggerAsyncIdScope(\n          self[async_id_symbol]\x2C\n          internalConnect\x2C\n          self\x2C ip\x2C port\x2C addressType\x2C localAddress\x2C localPort\x2C\n        );\n      }\n    });\n  });\n}\n\nfunction lookupAndConnectMultiple(self\x2C async_id_symbol\x2C lookup\x2C host\x2C options\x2C dnsopts\x2C port\x2C localPort\x2C timeout) {\n  defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C function emitLookup() {\n    lookup(host\x2C dnsopts\x2C function emitLookup(err\x2C addresses) {\n      // It's possible we were destroyed while looking this up.\n      // XXX it would be great if we could cancel the promise returned by\n      // the look up.\n      if (!self.connecting) {\n        return;\n      } else if (err) {\n        // net.createConnection() creates a net.Socket object and immediately\n        // calls net.Socket.connect() on it (that's us). There are no event\n        // listeners registered yet so defer the error event to the next tick.\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n        return;\n      }\n\n      // Filter addresses by only keeping the one which are either IPv4 or IPV6.\n      // The first valid address determines which group has preference on the\n      // alternate family sorting which happens later.\n      const validIps = [[]\x2C []];\n      let destinations;\n      for (let i = 0\x2C l = addresses.length; i < l; i++) {\n        const address = addresses[i];\n        const { address: ip\x2C family: addressType } = address;\n        self.emit('lookup'\x2C err\x2C ip\x2C addressType\x2C host);\n\n        if (isIP(ip) && (addressType === 4 || addressType === 6)) {\n          if (!destinations) {\n            destinations = addressType === 6 ? { 6: 0\x2C 4: 1 } : { 4: 0\x2C 6: 1 };\n          }\n\n          ArrayPrototypePush(validIps[destinations[addressType]]\x2C address);\n        }\n      }\n\n      // When no AAAA or A records are available\x2C fail on the first one\n      if (!validIps[0].length && !validIps[1].length) {\n        const { address: firstIp\x2C family: firstAddressType } = addresses[0];\n\n        if (!isIP(firstIp)) {\n          err = new ERR_INVALID_IP_ADDRESS(firstIp);\n          process.nextTick(connectErrorNT\x2C self\x2C err);\n        } else if (firstAddressType !== 4 && firstAddressType !== 6) {\n          err = new ERR_INVALID_ADDRESS_FAMILY(firstAddressType\x2C\n                                               options.host\x2C\n                                               options.port);\n          process.nextTick(connectErrorNT\x2C self\x2C err);\n        }\n\n        return;\n      }\n\n      // Sort addresses alternating families\n      const toAttempt = [];\n      for (let i = 0\x2C l = MathMax(validIps[0].length\x2C validIps[1].length); i < l; i++) {\n        if (i in validIps[0]) {\n          ArrayPrototypePush(toAttempt\x2C validIps[0][i]);\n        }\n        if (i in validIps[1]) {\n          ArrayPrototypePush(toAttempt\x2C validIps[1][i]);\n        }\n      }\n\n      const context = {\n        socket: self\x2C\n        addresses\x2C\n        current: 0\x2C\n        port\x2C\n        localPort\x2C\n        timeout\x2C\n        [kTimeout]: null\x2C\n        [kTimeoutTriggered]: false\x2C\n        errors: []\x2C\n      };\n\n      self._unrefTimer();\n      defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C internalConnectMultiple\x2C context);\n    });\n  });\n}\n\nfunction connectErrorNT(self\x2C err) {\n  self.destroy(err);\n}\n\n\nSocket.prototype.ref = function() {\n  if (!this._handle) {\n    this.once('connect'\x2C this.ref);\n    return this;\n  }\n\n  if (typeof this._handle.ref === 'function') {\n    this._handle.ref();\n  }\n\n  return this;\n};\n\n\nSocket.prototype.unref = function() {\n  if (!this._handle) {\n    this.once('connect'\x2C this.unref);\n    return this;\n  }\n\n  if (typeof this._handle.unref === 'function') {\n    this._handle.unref();\n  }\n\n  return this;\n};\n\n\nfunction afterConnect(status\x2C handle\x2C req\x2C readable\x2C writable) {\n  const self = handle[owner_symbol];\n\n  // Callback may come after call to destroy\n  if (self.destroyed) {\n    return;\n  }\n\n  debug('afterConnect');\n\n  assert(self.connecting);\n  self.connecting = false;\n  self._sockname = null;\n\n  if (status === 0) {\n    if (self.readable && !readable) {\n      self.push(null);\n      self.read();\n    }\n    if (self.writable && !writable) {\n      self.end();\n    }\n    self._unrefTimer();\n\n    if (self[kSetNoDelay] && self._handle.setNoDelay) {\n      self._handle.setNoDelay(true);\n    }\n\n    if (self[kSetKeepAlive] && self._handle.setKeepAlive) {\n      self._handle.setKeepAlive(true\x2C self[kSetKeepAliveInitialDelay]);\n    }\n\n    self.emit('connect');\n    self.emit('ready');\n\n    // Start the first read\x2C or get an immediate EOF.\n    // this doesn't actually consume any bytes\x2C because len=0.\n    if (readable && !self.isPaused())\n      self.read(0);\n    if (self[kPerfHooksNetConnectContext] && hasObserver('net')) {\n      stopPerf(self\x2C kPerfHooksNetConnectContext);\n    }\n  } else {\n    let details;\n    if (req.localAddress && req.localPort) {\n      details = req.localAddress + ':' + req.localPort;\n    }\n    const ex = exceptionWithHostPort(status\x2C\n                                     'connect'\x2C\n                                     req.address\x2C\n                                     req.port\x2C\n                                     details);\n    if (details) {\n      ex.localAddress = req.localAddress;\n      ex.localPort = req.localPort;\n    }\n    self.destroy(ex);\n  }\n}\n\nfunction afterConnectMultiple(context\x2C status\x2C handle\x2C req\x2C readable\x2C writable) {\n  const self = context.socket;\n\n  // Make sure another connection is not spawned\n  clearTimeout(context[kTimeout]);\n\n  // Some error occurred\x2C add to the list of exceptions\n  if (status !== 0) {\n    let details;\n    if (req.localAddress && req.localPort) {\n      details = req.localAddress + ':' + req.localPort;\n    }\n    const ex = exceptionWithHostPort(status\x2C\n                                     'connect'\x2C\n                                     req.address\x2C\n                                     req.port\x2C\n                                     details);\n    if (details) {\n      ex.localAddress = req.localAddress;\n      ex.localPort = req.localPort;\n    }\n\n    ArrayPrototypePush(context.errors\x2C ex);\n\n    // Try the next address\n    internalConnectMultiple(context);\n    return;\n  }\n\n  // One of the connection has completed and correctly dispatched but after timeout\x2C ignore this one\n  if (context[kTimeoutTriggered]) {\n    debug('connect/multiple: ignoring successful but timedout connection to %s:%s'\x2C req.address\x2C req.port);\n    handle.close();\n    return;\n  }\n\n  // Perform initialization sequence on the handle\x2C then move on with the regular callback\n  self._handle = handle;\n  initSocketHandle(self);\n\n  if (self[kWrapConnectedHandle]) {\n    self[kWrapConnectedHandle](handle);\n    initSocketHandle(self); // This is called again to initialize the TLSWrap\n  }\n\n  if (hasObserver('net')) {\n    startPerf(\n      self\x2C\n      kPerfHooksNetConnectContext\x2C\n      { type: 'net'\x2C name: 'connect'\x2C detail: { host: req.address\x2C port: req.port } }\x2C\n    );\n  }\n\n  afterConnect(status\x2C handle\x2C req\x2C readable\x2C writable);\n}\n\nfunction internalConnectMultipleTimeout(context\x2C req) {\n  context[kTimeoutTriggered] = true;\n  internalConnectMultiple(context);\n}\n\nfunction addAbortSignalOption(self\x2C options) {\n  if (options?.signal === undefined) {\n    return;\n  }\n  validateAbortSignal(options.signal\x2C 'options.signal');\n  const { signal } = options;\n  const onAborted = () => {\n    self.close();\n  };\n  if (signal.aborted) {\n    process.nextTick(onAborted);\n  } else {\n    signal.addEventListener('abort'\x2C onAborted);\n    self.once('close'\x2C () => signal.removeEventListener('abort'\x2C onAborted));\n  }\n}\n\nfunction Server(options\x2C connectionListener) {\n  if (!(this instanceof Server))\n    return new Server(options\x2C connectionListener);\n\n  EventEmitter.call(this);\n\n  if (typeof options === 'function') {\n    connectionListener = options;\n    options = kEmptyObject;\n    this.on('connection'\x2C connectionListener);\n  } else if (options == null || typeof options === 'object') {\n    options = { ...options };\n\n    if (typeof connectionListener === 'function') {\n      this.on('connection'\x2C connectionListener);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C 'Object'\x2C options);\n  }\n  if (typeof options.keepAliveInitialDelay !== 'undefined') {\n    validateNumber(\n      options.keepAliveInitialDelay\x2C 'options.keepAliveInitialDelay'\x2C\n    );\n\n    if (options.keepAliveInitialDelay < 0) {\n      options.keepAliveInitialDelay = 0;\n    }\n  }\n  if (typeof options.highWaterMark !== 'undefined') {\n    validateNumber(\n      options.highWaterMark\x2C 'options.highWaterMark'\x2C\n    );\n\n    if (options.highWaterMark < 0) {\n      options.highWaterMark = getDefaultHighWaterMark();\n    }\n  }\n\n  this._connections = 0;\n\n  this[async_id_symbol] = -1;\n  this._handle = null;\n  this._usingWorkers = false;\n  this._workers = [];\n  this._unref = false;\n\n  this.allowHalfOpen = options.allowHalfOpen || false;\n  this.pauseOnConnect = !!options.pauseOnConnect;\n  this.noDelay = Boolean(options.noDelay);\n  this.keepAlive = Boolean(options.keepAlive);\n  this.keepAliveInitialDelay = ~~(options.keepAliveInitialDelay / 1000);\n  this.highWaterMark = options.highWaterMark ?? getDefaultHighWaterMark();\n}\nObjectSetPrototypeOf(Server.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(Server\x2C EventEmitter);\n\n\nfunction toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }\n\n// Returns handle if it can be created\x2C or error code if it can't\nfunction createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags) {\n  let err = 0;\n  // Assign handle in listen\x2C and clean up if bind or listen fails\n  let handle;\n\n  let isTCP = false;\n  if (typeof fd === 'number' && fd >= 0) {\n    try {\n      handle = createHandle(fd\x2C true);\n    } catch (e) {\n      // Not a fd we can listen on.  This will trigger an error.\n      debug('listen invalid fd=%d:'\x2C fd\x2C e.message);\n      return UV_EINVAL;\n    }\n\n    err = handle.open(fd);\n    if (err)\n      return err;\n\n    assert(!address && !port);\n  } else if (port === -1 && addressType === -1) {\n    handle = new Pipe(PipeConstants.SERVER);\n    if (isWindows) {\n      const instances = NumberParseInt(process.env.NODE_PENDING_PIPE_INSTANCES);\n      if (!NumberIsNaN(instances)) {\n        handle.setPendingInstances(instances);\n      }\n    }\n  } else {\n    handle = new TCP(TCPConstants.SERVER);\n    isTCP = true;\n  }\n\n  if (address || port || isTCP) {\n    debug('bind to'\x2C address || 'any');\n    if (!address) {\n      // Try binding to ipv6 first\n      err = handle.bind6(DEFAULT_IPV6_ADDR\x2C port\x2C flags);\n      if (err) {\n        handle.close();\n        // Fallback to ipv4\n        return createServerHandle(DEFAULT_IPV4_ADDR\x2C port);\n      }\n    } else if (addressType === 6) {\n      err = handle.bind6(address\x2C port\x2C flags);\n    } else {\n      err = handle.bind(address\x2C port);\n    }\n  }\n\n  if (err) {\n    handle.close();\n    return err;\n  }\n\n  return handle;\n}\n\nfunction setupListenHandle(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags) {\n  debug('setupListenHandle'\x2C address\x2C port\x2C addressType\x2C backlog\x2C fd);\n\n  // If there is not yet a handle\x2C we need to create one and bind.\n  // In the case of a server sent via IPC\x2C we don't need to do this.\n  if (this._handle) {\n    debug('setupListenHandle: have a handle already');\n  } else {\n    debug('setupListenHandle: create a handle');\n\n    let rval = null;\n\n    // Try to bind to the unspecified IPv6 address\x2C see if IPv6 is available\n    if (!address && typeof fd !== 'number') {\n      rval = createServerHandle(DEFAULT_IPV6_ADDR\x2C port\x2C 6\x2C fd\x2C flags);\n\n      if (typeof rval === 'number') {\n        rval = null;\n        address = DEFAULT_IPV4_ADDR;\n        addressType = 4;\n      } else {\n        address = DEFAULT_IPV6_ADDR;\n        addressType = 6;\n      }\n    }\n\n    if (rval === null)\n      rval = createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags);\n\n    if (typeof rval === 'number') {\n      const error = uvExceptionWithHostPort(rval\x2C 'listen'\x2C address\x2C port);\n      process.nextTick(emitErrorNT\x2C this\x2C error);\n      return;\n    }\n    this._handle = rval;\n  }\n\n  this[async_id_symbol] = getNewAsyncId(this._handle);\n  this._handle.onconnection = onconnection;\n  this._handle[owner_symbol] = this;\n\n  // Use a backlog of 512 entries. We pass 511 to the listen() call because\n  // the kernel does: backlogsize = roundup_pow_of_two(backlogsize + 1);\n  // which will thus give us a backlog of 512 entries.\n  const err = this._handle.listen(backlog || 511);\n\n  if (err) {\n    const ex = uvExceptionWithHostPort(err\x2C 'listen'\x2C address\x2C port);\n    this._handle.close();\n    this._handle = null;\n    defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                               process.nextTick\x2C\n                               emitErrorNT\x2C\n                               this\x2C\n                               ex);\n    return;\n  }\n\n  // Generate connection key\x2C this should be unique to the connection\n  this._connectionKey = addressType + ':' + address + ':' + port;\n\n  // Unref the handle if the server was unref'ed prior to listening\n  if (this._unref)\n    this.unref();\n\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                             process.nextTick\x2C\n                             emitListeningNT\x2C\n                             this);\n}\n\nServer.prototype._listen2 = setupListenHandle;  // legacy alias\n\nfunction emitErrorNT(self\x2C err) {\n  self.emit('error'\x2C err);\n}\n\n\nfunction emitListeningNT(self) {\n  // Ensure handle hasn't closed\n  if (self._handle)\n    self.emit('listening');\n}\n\n\nfunction listenInCluster(server\x2C address\x2C port\x2C addressType\x2C\n                         backlog\x2C fd\x2C exclusive\x2C flags\x2C options) {\n  exclusive = !!exclusive;\n\n  if (cluster === undefined) cluster = require('cluster');\n\n  if (cluster.isPrimary || exclusive) {\n    // Will create a new handle\n    // _listen2 sets up the listened handle\x2C it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags);\n    return;\n  }\n\n  const serverQuery = {\n    address: address\x2C\n    port: port\x2C\n    addressType: addressType\x2C\n    fd: fd\x2C\n    flags\x2C\n    backlog\x2C\n    ...options\x2C\n  };\n  // Get the primary's server handle\x2C and listen on it\n  cluster._getServer(server\x2C serverQuery\x2C listenOnPrimaryHandle);\n\n  function listenOnPrimaryHandle(err\x2C handle) {\n    err = checkBindError(err\x2C port\x2C handle);\n\n    if (err) {\n      const ex = exceptionWithHostPort(err\x2C 'bind'\x2C address\x2C port);\n      return server.emit('error'\x2C ex);\n    }\n\n    // Reuse primary's server handle\n    server._handle = handle;\n    // _listen2 sets up the listened handle\x2C it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags);\n  }\n}\n\n\nServer.prototype.listen = function(...args) {\n  const normalized = normalizeArgs(args);\n  let options = normalized[0];\n  const cb = normalized[1];\n\n  if (this._handle) {\n    throw new ERR_SERVER_ALREADY_LISTEN();\n  }\n\n  if (cb !== null) {\n    this.once('listening'\x2C cb);\n  }\n  const backlogFromArgs =\n    // (handle\x2C backlog) or (path\x2C backlog) or (port\x2C backlog)\n    toNumber(args.length > 1 && args[1]) ||\n    toNumber(args.length > 2 && args[2]);  // (port\x2C host\x2C backlog)\n\n  options = options._handle || options.handle || options;\n  const flags = getFlags(options.ipv6Only);\n  // (handle[\x2C backlog][\x2C cb]) where handle is an object with a handle\n  if (options instanceof TCP) {\n    this._handle = options;\n    this[async_id_symbol] = this._handle.getAsyncId();\n    listenInCluster(this\x2C null\x2C -1\x2C -1\x2C backlogFromArgs);\n    return this;\n  }\n  addAbortSignalOption(this\x2C options);\n  // (handle[\x2C backlog][\x2C cb]) where handle is an object with a fd\n  if (typeof options.fd === 'number' && options.fd >= 0) {\n    listenInCluster(this\x2C null\x2C null\x2C null\x2C backlogFromArgs\x2C options.fd);\n    return this;\n  }\n\n  // ([port][\x2C host][\x2C backlog][\x2C cb]) where port is omitted\x2C\n  // that is\x2C listen()\x2C listen(null)\x2C listen(cb)\x2C or listen(null\x2C cb)\n  // or (options[\x2C cb]) where options.port is explicitly set as undefined or\n  // null\x2C bind to an arbitrary unused port\n  if (args.length === 0 || typeof args[0] === 'function' ||\n      (typeof options.port === 'undefined' && 'port' in options) ||\n      options.port === null) {\n    options.port = 0;\n  }\n  // ([port][\x2C host][\x2C backlog][\x2C cb]) where port is specified\n  // or (options[\x2C cb]) where options.port is specified\n  // or if options.port is normalized as 0 before\n  let backlog;\n  if (typeof options.port === 'number' || typeof options.port === 'string') {\n    validatePort(options.port\x2C 'options.port');\n    backlog = options.backlog || backlogFromArgs;\n    // start TCP server listening on host:port\n    if (options.host) {\n      lookupAndListen(this\x2C options.port | 0\x2C options.host\x2C backlog\x2C\n                      options.exclusive\x2C flags);\n    } else { // Undefined host\x2C listens on unspecified address\n      // Default addressType 4 will be used to search for primary server\n      listenInCluster(this\x2C null\x2C options.port | 0\x2C 4\x2C\n                      backlog\x2C undefined\x2C options.exclusive);\n    }\n    return this;\n  }\n\n  // (path[\x2C backlog][\x2C cb]) or (options[\x2C cb])\n  // where path or options.path is a UNIX domain socket or Windows pipe\n  if (options.path && isPipeName(options.path)) {\n    const pipeName = this._pipeName = options.path;\n    backlog = options.backlog || backlogFromArgs;\n    listenInCluster(this\x2C\n                    pipeName\x2C\n                    -1\x2C\n                    -1\x2C\n                    backlog\x2C\n                    undefined\x2C\n                    options.exclusive\x2C\n                    undefined\x2C\n                    {\n                      readableAll: options.readableAll\x2C\n                      writableAll: options.writableAll\x2C\n                    });\n\n    if (!this._handle) {\n      // Failed and an error shall be emitted in the next tick.\n      // Therefore\x2C we directly return.\n      return this;\n    }\n\n    let mode = 0;\n    if (options.readableAll === true)\n      mode |= PipeConstants.UV_READABLE;\n    if (options.writableAll === true)\n      mode |= PipeConstants.UV_WRITABLE;\n    if (mode !== 0) {\n      const err = this._handle.fchmod(mode);\n      if (err) {\n        this._handle.close();\n        this._handle = null;\n        throw errnoException(err\x2C 'uv_pipe_chmod');\n      }\n    }\n    return this;\n  }\n\n  if (!(('port' in options) || ('path' in options))) {\n    throw new ERR_INVALID_ARG_VALUE('options'\x2C options\x2C\n                                    'must have the property "port" or "path"');\n  }\n\n  throw new ERR_INVALID_ARG_VALUE('options'\x2C options);\n};\n\nfunction lookupAndListen(self\x2C port\x2C address\x2C backlog\x2C exclusive\x2C flags) {\n  if (dns === undefined) dns = require('dns');\n  dns.lookup(address\x2C function doListen(err\x2C ip\x2C addressType) {\n    if (err) {\n      self.emit('error'\x2C err);\n    } else {\n      addressType = ip ? addressType : 4;\n      listenInCluster(self\x2C ip\x2C port\x2C addressType\x2C\n                      backlog\x2C undefined\x2C exclusive\x2C flags);\n    }\n  });\n}\n\nObjectDefineProperty(Server.prototype\x2C 'listening'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    return !!this._handle;\n  }\x2C\n  configurable: true\x2C\n  enumerable: true\x2C\n});\n\nServer.prototype.address = function() {\n  if (this._handle && this._handle.getsockname) {\n    const out = {};\n    const err = this._handle.getsockname(out);\n    if (err) {\n      throw errnoException(err\x2C 'address');\n    }\n    return out;\n  } else if (this._pipeName) {\n    return this._pipeName;\n  }\n  return null;\n};\n\nfunction onconnection(err\x2C clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error'\x2C errnoException(err\x2C 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    if (clientHandle.getsockname || clientHandle.getpeername) {\n      const data = ObjectCreate(null);\n      if (clientHandle.getsockname) {\n        const localInfo = ObjectCreate(null);\n        clientHandle.getsockname(localInfo);\n        data.localAddress = localInfo.address;\n        data.localPort = localInfo.port;\n        data.localFamily = localInfo.family;\n      }\n      if (clientHandle.getpeername) {\n        const remoteInfo = ObjectCreate(null);\n        clientHandle.getpeername(remoteInfo);\n        data.remoteAddress = remoteInfo.address;\n        data.remotePort = remoteInfo.port;\n        data.remoteFamily = remoteInfo.family;\n      }\n      self.emit('drop'\x2C data);\n    } else {\n      self.emit('drop');\n    }\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle\x2C\n    allowHalfOpen: self.allowHalfOpen\x2C\n    pauseOnCreate: self.pauseOnConnect\x2C\n    readable: true\x2C\n    writable: true\x2C\n    readableHighWaterMark: self.highWaterMark\x2C\n    writableHighWaterMark: self.highWaterMark\x2C\n  });\n\n  if (self.noDelay && clientHandle.setNoDelay) {\n    socket[kSetNoDelay] = true;\n    clientHandle.setNoDelay(true);\n  }\n  if (self.keepAlive && clientHandle.setKeepAlive) {\n    socket[kSetKeepAlive] = true;\n    socket[kSetKeepAliveInitialDelay] = self.keepAliveInitialDelay;\n    clientHandle.setKeepAlive(true\x2C self.keepAliveInitialDelay);\n  }\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection'\x2C socket);\n  lazyChannels();\n  if (netServerSocketChannel.hasSubscribers) {\n    netServerSocketChannel.publish({\n      socket\x2C\n    });\n  }\n}\n\n/**\n * Gets the number of concurrent connections on the server\n * @param {Function} cb\n * @returns {Server}\n */\n\nServer.prototype.getConnections = function(cb) {\n  const self = this;\n\n  function end(err\x2C connections) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C\n                               process.nextTick\x2C\n                               cb\x2C\n                               err\x2C\n                               connections);\n  }\n\n  if (!this._usingWorkers) {\n    end(null\x2C this._connections);\n    return this;\n  }\n\n  // Poll workers\n  let left = this._workers.length;\n  let total = this._connections;\n\n  function oncount(err\x2C count) {\n    if (err) {\n      left = -1;\n      return end(err);\n    }\n\n    total += count;\n    if (--left === 0) return end(null\x2C total);\n  }\n\n  for (let n = 0; n < this._workers.length; n++) {\n    this._workers[n].getConnections(oncount);\n  }\n\n  return this;\n};\n\n\nServer.prototype.close = function(cb) {\n  if (typeof cb === 'function') {\n    if (!this._handle) {\n      this.once('close'\x2C function close() {\n        cb(new ERR_SERVER_NOT_RUNNING());\n      });\n    } else {\n      this.once('close'\x2C cb);\n    }\n  }\n\n  if (this._handle) {\n    this._handle.close();\n    this._handle = null;\n  }\n\n  if (this._usingWorkers) {\n    let left = this._workers.length;\n    const onWorkerClose = () => {\n      if (--left !== 0) return;\n\n      this._connections = 0;\n      this._emitCloseIfDrained();\n    };\n\n    // Increment connections to be sure that\x2C even if all sockets will be closed\n    // during polling of workers\x2C `close` event will be emitted only once.\n    this._connections++;\n\n    // Poll workers\n    for (let n = 0; n < this._workers.length; n++)\n      this._workers[n].close(onWorkerClose);\n  } else {\n    this._emitCloseIfDrained();\n  }\n\n  return this;\n};\n\nServer.prototype._emitCloseIfDrained = function() {\n  debug('SERVER _emitCloseIfDrained');\n\n  if (this._handle || this._connections) {\n    debug('SERVER handle? %j   connections? %d'\x2C\n          !!this._handle\x2C this._connections);\n    return;\n  }\n\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                             process.nextTick\x2C\n                             emitCloseNT\x2C\n                             this);\n};\n\n\nfunction emitCloseNT(self) {\n  debug('SERVER: emit close');\n  self.emit('close');\n}\n\n\nServer.prototype[EventEmitter.captureRejectionSymbol] = function(\n  err\x2C event\x2C sock) {\n\n  switch (event) {\n    case 'connection':\n      sock.destroy(err);\n      break;\n    default:\n      this.emit('error'\x2C err);\n  }\n};\n\n\n// Legacy alias on the C++ wrapper object. This is not public API\x2C so we may\n// want to runtime-deprecate it at some point. There's no hurry\x2C though.\nObjectDefineProperty(TCP.prototype\x2C 'owner'\x2C {\n  __proto__: null\x2C\n  get() { return this[owner_symbol]; }\x2C\n  set(v) { return this[owner_symbol] = v; }\x2C\n});\n\nObjectDefineProperty(Socket.prototype\x2C '_handle'\x2C {\n  __proto__: null\x2C\n  get() { return this[kHandle]; }\x2C\n  set(v) { return this[kHandle] = v; }\x2C\n});\n\nServer.prototype._setupWorker = function(socketList) {\n  this._usingWorkers = true;\n  this._workers.push(socketList);\n  socketList.once('exit'\x2C (socketList) => {\n    const index = ArrayPrototypeIndexOf(this._workers\x2C socketList);\n    this._workers.splice(index\x2C 1);\n  });\n};\n\nServer.prototype.ref = function() {\n  this._unref = false;\n\n  if (this._handle)\n    this._handle.ref();\n\n  return this;\n};\n\nServer.prototype.unref = function() {\n  this._unref = true;\n\n  if (this._handle)\n    this._handle.unref();\n\n  return this;\n};\n\nlet _setSimultaneousAccepts;\nlet warnSimultaneousAccepts = true;\n\nif (isWindows) {\n  let simultaneousAccepts;\n\n  _setSimultaneousAccepts = function(handle) {\n    if (warnSimultaneousAccepts) {\n      process.emitWarning(\n        'net._setSimultaneousAccepts() is deprecated and will be removed.'\x2C\n        'DeprecationWarning'\x2C 'DEP0121');\n      warnSimultaneousAccepts = false;\n    }\n    if (handle === undefined) {\n      return;\n    }\n\n    if (simultaneousAccepts === undefined) {\n      simultaneousAccepts = (process.env.NODE_MANY_ACCEPTS &&\n                             process.env.NODE_MANY_ACCEPTS !== '0');\n    }\n\n    if (handle._simultaneousAccepts !== simultaneousAccepts) {\n      handle.setSimultaneousAccepts(!!simultaneousAccepts);\n      handle._simultaneousAccepts = simultaneousAccepts;\n    }\n  };\n} else {\n  _setSimultaneousAccepts = function() {\n    if (warnSimultaneousAccepts) {\n      process.emitWarning(\n        'net._setSimultaneousAccepts() is deprecated and will be removed.'\x2C\n        'DeprecationWarning'\x2C 'DEP0121');\n      warnSimultaneousAccepts = false;\n    }\n  };\n}\n\nmodule.exports = {\n  _createServerHandle: createServerHandle\x2C\n  _normalizeArgs: normalizeArgs\x2C\n  _setSimultaneousAccepts\x2C\n  get BlockList() {\n    BlockList ??= require('internal/blocklist').BlockList;\n    return BlockList;\n  }\x2C\n  get SocketAddress() {\n    SocketAddress ??= require('internal/socketaddress').SocketAddress;\n    return SocketAddress;\n  }\x2C\n  connect\x2C\n  createConnection: connect\x2C\n  createServer\x2C\n  isIP: isIP\x2C\n  isIPv4: isIPv4\x2C\n  isIPv6: isIPv6\x2C\n  Server\x2C\n  Socket\x2C\n  Stream: Socket\x2C // Legacy naming\n};\n
code-source-info,0x30e76772ef68,458,0,62451,C0O0C4O62451,,
code-creation,Function,10,70667,0x30e767732348,3013, node:net:1:1,0x30e76772eee0,~
code-source-info,0x30e767732348,458,0,62451,C0O0C519O1159C525O1175C531O1200C537O1222C543O1233C549O1258C555O1269C561O1279C567O1294C573O1312C579O1336C584O1360C589O1370C595O1423C601O1423C605O1423C607O1457C613O1457C617O1457C619O1488C625O1488C630O1521C644O1522C650O1488C652O1671C658O1671C663O1576C669O1600C675O1608C680O1618C685O1628C691O1652C697O1711C703O1711C707O1711C709O1796C712O1796C717O1749C723O1766C729O1779C735O1839C741O1839C746O1828C752O1886C755O1886C760O1866C766O1936C769O1936C774O1919C780O2032C783O2032C788O1978C794O1985C800O2014C806O2128C809O2128C814O2071C820O2079C826O2109C832O2260C838O2260C843O2168C849O2182C860O2223C866O2240C872O2459C878O2459C883O2303C889O2320C895O2336C901O2352C906O2372C912O2383C917O2399C922O2419C928O2430C934O2443C940O2949C946O2949C951O2949C956O2523C962O2555C968O2581C974O2608C980O2633C986O2661C992O2690C998O2721C1004O2749C1010O2772C1016O2813C1022O2838C1028O2857C1034O2875C1040O2900C1046O2920C1052O3002C1058O3002C1063O2985C1069O3061C1075O3061C1080O3042C1086O3127C1092O3127C1097O3110C1103O3296C1109O3296C1114O3163C1120O3186C1126O3205C1132O3225C1138O3242C1144O3260C1150O3276C1156O3356C1159O3356C1163O3356C1165O3455C1171O3455C1176O3396C1182O3428C1188O3535C1189O3535C1191O3548C1192O3548C1194O3557C1195O3557C1197O3572C1198O3572C1200O3625C1206O3625C1211O3596C1217O3610C1223O3665C1229O3665C1234O3652C1240O3719C1243O3719C1247O3719C1249O3775C1251O3775C1253O3812C1255O3812C1257O3837C1260O3845C1267O3854C1270O3837C1272O3881C1276O3881C1278O3928C1281O3928C1285O3928C1287O3972C1288O3972C1290O4000C1291O4000C1293O4634C1299O4634C1304O4592C1310O4607C1316O4620C1322O4704C1328O4704C1333O4676C1339O8651C1342O8651C1346O8651C1348O8695C1351O8695C1355O8695C1357O8740C1360O8740C1364O8740C1366O8785C1369O8785C1373O8785C1375O8844C1378O8844C1382O8844C1384O13426C1387O13454C1395O13472C1400O13479C1405O13426C1410O13491C1416O13527C1421O13491C1426O13567C1429O13574C1438O13596C1442O13822C1445O13829C1454O13846C1458O15330C1461O15337C1468O15358C1472O15380C1475O15387C1484O15408C1488O15918C1491O15925C1500O15946C1504O16329C1507O16336C1516O16359C1520O16971C1523O16978C1532O16996C1536O17046C1542O17074C1559O17128C1571O17046C1581O17179C1587O17207C1604O17252C1616O17179C1626O17338C1632O17366C1649O17419C1661O17338C1671O17742C1677O17770C1694O17823C1706O17742C1716O17910C1722O17938C1727O17949C1736O17991C1751O17910C1761O18357C1764O18364C1773O18380C1781O18615C1784O18622C1793O18636C1801O18828C1804O18835C1813O18861C1821O19216C1824O19223C1833O19239C1841O19579C1844O19586C1853O19603C1861O19793C1864O19800C1873O19815C1881O20152C1884O20159C1893O20181C1901O20334C1904O20341C1913O20360C1921O21875C1924O21882C1933O21899C1941O22003C1944O22010C1953O22033C1961O22519C1969O22519C1979O22639C1987O22639C1997O22738C2005O22738C2015O22834C2023O22834C2033O22925C2036O22932C2045O22955C2053O23237C2061O23237C2071O23335C2079O23335C2089O23423C2097O23423C2107O23517C2110O23524C2115O23534C2119O23552C2127O23604C2130O23611C2139O23635C2147O24553C2150O24560C2159O24578C2167O24652C2170O24659C2179O24676C2187O24920C2195O24920C2205O25060C2213O25060C2223O30761C2226O30768C2235O30786C2243O39158C2246O39165C2255O39179C2263O39372C2266O39379C2275O39395C2283O45042C2286O45070C2298O45094C2307O45042C2317O45106C2323O45106C2333O49092C2336O49099C2347O49118C2355O50603C2358O50610C2371O50627C2379O54872C2385O54900C2406O54952C2418O54872C2428O55044C2431O55051C2444O55069C2452O57433C2455O57440C2468O57465C2476O58224C2479O58231C2492O58247C2500O59119C2503O59126C2516O59156C2524O59634C2527O59641C2539O59664C2552O59688C2560O60006C2566O60031C2587O60074C2602O60114C2617O60006C2627O60162C2633O60190C2652O60235C2667O60270C2682O60162C2692O60313C2695O60320C2711O60343C2719O60589C2722O60596C2738O60610C2746O60713C2749O60720C2765O60736C2773O60844C2775O60899C2776O60899C2778O60906C2793O60929C2794O60929C2796O60953C2810O61661C2818O61933C2828O61975C2838O62013C2848O62030C2858O62289C2868O62318C2878O62329C2888O62351C2898O62367C2908O62385C2918O62395C2928O62405C2938O62423C3003O61948C3012O62450,,
tick,0x19596ce9c,70834,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x30e76772957e,0x41ccf0590b7,0x1100482ec,0x30e7677225ac,0x41ccf0590b7,0x1100482ec,0x30e7677207bc,0x202f0287b58b,0x202f02879dd8,0x202f028761e9
tick,0x100ab9044,70834,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x30e76772957e,0x41ccf0590b7,0x1100482ec,0x30e7677225ac,0x41ccf0590b7,0x1100482ec,0x30e7677207bc,0x202f0287b58b,0x202f02879dd8,0x202f028761e9
code-creation,Eval,10,71084,0x30e767739a20,5, node:internal/dtrace:1:1,0x30e7677398d8,~
script-source,459,node:internal/dtrace,'use strict';\n\nconst config = internalBinding('config');\n\nconst {\n  DTRACE_HTTP_CLIENT_REQUEST = () => {}\x2C\n  DTRACE_HTTP_CLIENT_RESPONSE = () => {}\x2C\n  DTRACE_HTTP_SERVER_REQUEST = () => {}\x2C\n  DTRACE_HTTP_SERVER_RESPONSE = () => {}\x2C\n  DTRACE_NET_SERVER_CONNECTION = () => {}\x2C\n  DTRACE_NET_STREAM_END = () => {}\x2C\n} = (config.hasDtrace ? internalBinding('dtrace') : {});\n\nmodule.exports = {\n  DTRACE_HTTP_CLIENT_REQUEST\x2C\n  DTRACE_HTTP_CLIENT_RESPONSE\x2C\n  DTRACE_HTTP_SERVER_REQUEST\x2C\n  DTRACE_HTTP_SERVER_RESPONSE\x2C\n  DTRACE_NET_SERVER_CONNECTION\x2C\n  DTRACE_NET_STREAM_END\x2C\n};\n
code-source-info,0x30e767739a20,459,0,570,C0O0C4O570,,
code-creation,Function,10,71167,0x30e767739ef8,140, node:internal/dtrace:1:1,0x30e767739998,~
code-source-info,0x30e767739ef8,459,0,570,C0O30C3O30C8O323C17O335C25O68C36O109C47O151C58O192C69O234C80O277C91O369C98O390C104O420C110O451C116O481C122O512C128O544C134O384C139O569,,
tick,0x195ab7c6c,71209,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x30e7677327db,0x41ccf0590b7,0x1100482ec,0x30e76772957e,0x41ccf0590b7,0x1100482ec,0x30e7677225ac,0x41ccf0590b7,0x1100482ec,0x30e7677207bc,0x202f0287b58b,0x202f02879dd8,0x202f028761e9
code-creation,LazyCompile,10,71334,0x30e76773ae28,34,protoGetter node:net:845:21,0x30e76772f448,~
code-source-info,0x30e76773ae28,458,22355,22517,C0O22376C8O22404C13O22415C20O22500C27O22376C33O22516,,
new,MemoryChunk,0x2b3d46cc0000,262144
code-creation,Eval,10,71917,0x2b3d46cc2120,5, node:dgram:1:1,0x2b3d46cc1b98,~
script-source,460,node:dgram,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n} = primordials;\n\nconst errors = require('internal/errors');\nconst {\n  kStateSymbol\x2C\n  _createSocketHandle\x2C\n  newHandle\x2C\n} = require('internal/dgram');\nconst { guessHandleType } = internalBinding('util');\nconst {\n  ERR_BUFFER_OUT_OF_BOUNDS\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_MISSING_ARGS\x2C\n  ERR_SOCKET_ALREADY_BOUND\x2C\n  ERR_SOCKET_BAD_BUFFER_SIZE\x2C\n  ERR_SOCKET_BUFFER_SIZE\x2C\n  ERR_SOCKET_DGRAM_IS_CONNECTED\x2C\n  ERR_SOCKET_DGRAM_NOT_CONNECTED\x2C\n  ERR_SOCKET_DGRAM_NOT_RUNNING\x2C\n  ERR_INVALID_FD_TYPE\x2C\n} = errors.codes;\nconst {\n  isInt32\x2C\n  validateAbortSignal\x2C\n  validateString\x2C\n  validateNumber\x2C\n  validatePort\x2C\n} = require('internal/validators');\nconst { Buffer } = require('buffer');\nconst { deprecate } = require('internal/util');\nconst { isArrayBufferView } = require('internal/util/types');\nconst EventEmitter = require('events');\nconst {\n  defaultTriggerAsyncIdScope\x2C\n  symbols: { async_id_symbol\x2C owner_symbol }\x2C\n} = require('internal/async_hooks');\nconst { UV_UDP_REUSEADDR } = internalBinding('constants').os;\n\nconst {\n  constants: { UV_UDP_IPV6ONLY }\x2C\n  UDP\x2C\n  SendWrap\x2C\n} = internalBinding('udp_wrap');\n\nconst dc = require('diagnostics_channel');\nconst udpSocketChannel = dc.channel('udp.socket');\n\nconst BIND_STATE_UNBOUND = 0;\nconst BIND_STATE_BINDING = 1;\nconst BIND_STATE_BOUND = 2;\n\nconst CONNECT_STATE_DISCONNECTED = 0;\nconst CONNECT_STATE_CONNECTING = 1;\nconst CONNECT_STATE_CONNECTED = 2;\n\nconst RECV_BUFFER = true;\nconst SEND_BUFFER = false;\n\n// Lazily loaded\nlet _cluster = null;\nfunction lazyLoadCluster() {\n  if (!_cluster) _cluster = require('cluster');\n  return _cluster;\n}\n\nconst errnoException = errors.errnoException;\nconst exceptionWithHostPort = errors.exceptionWithHostPort;\n\n\nfunction Socket(type\x2C listener) {\n  FunctionPrototypeCall(EventEmitter\x2C this);\n  let lookup;\n  let recvBufferSize;\n  let sendBufferSize;\n\n  let options;\n  if (type !== null && typeof type === 'object') {\n    options = type;\n    type = options.type;\n    lookup = options.lookup;\n    recvBufferSize = options.recvBufferSize;\n    sendBufferSize = options.sendBufferSize;\n  }\n\n  const handle = newHandle(type\x2C lookup);\n  handle[owner_symbol] = this;\n\n  this[async_id_symbol] = handle.getAsyncId();\n  this.type = type;\n\n  if (typeof listener === 'function')\n    this.on('message'\x2C listener);\n\n  this[kStateSymbol] = {\n    handle\x2C\n    receiving: false\x2C\n    bindState: BIND_STATE_UNBOUND\x2C\n    connectState: CONNECT_STATE_DISCONNECTED\x2C\n    queue: undefined\x2C\n    reuseAddr: options && options.reuseAddr\x2C // Use UV_UDP_REUSEADDR if true.\n    ipv6Only: options && options.ipv6Only\x2C\n    recvBufferSize\x2C\n    sendBufferSize\x2C\n  };\n\n  if (options?.signal !== undefined) {\n    const { signal } = options;\n    validateAbortSignal(signal\x2C 'options.signal');\n    const onAborted = () => {\n      if (this[kStateSymbol].handle) this.close();\n    };\n    if (signal.aborted) {\n      onAborted();\n    } else {\n      signal.addEventListener('abort'\x2C onAborted);\n      this.once('close'\x2C () => signal.removeEventListener('abort'\x2C onAborted));\n    }\n  }\n  if (udpSocketChannel.hasSubscribers) {\n    udpSocketChannel.publish({\n      socket: this\x2C\n    });\n  }\n}\nObjectSetPrototypeOf(Socket.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(Socket\x2C EventEmitter);\n\n\nfunction createSocket(type\x2C listener) {\n  return new Socket(type\x2C listener);\n}\n\n\nfunction startListening(socket) {\n  const state = socket[kStateSymbol];\n\n  state.handle.onmessage = onMessage;\n  state.handle.onerror = onError;\n  state.handle.recvStart();\n  state.receiving = true;\n  state.bindState = BIND_STATE_BOUND;\n\n  if (state.recvBufferSize)\n    bufferSize(socket\x2C state.recvBufferSize\x2C RECV_BUFFER);\n\n  if (state.sendBufferSize)\n    bufferSize(socket\x2C state.sendBufferSize\x2C SEND_BUFFER);\n\n  socket.emit('listening');\n}\n\nfunction replaceHandle(self\x2C newHandle) {\n  const state = self[kStateSymbol];\n  const oldHandle = state.handle;\n  // Sync the old handle state to new handle\n  if (!oldHandle.hasRef() && typeof newHandle.unref === 'function') {\n    newHandle.unref();\n  }\n  // Set up the handle that we got from primary.\n  newHandle.lookup = oldHandle.lookup;\n  newHandle.bind = oldHandle.bind;\n  newHandle.send = oldHandle.send;\n  newHandle[owner_symbol] = self;\n\n  // Replace the existing handle by the handle we got from primary.\n  oldHandle.close();\n  state.handle = newHandle;\n}\n\nfunction bufferSize(self\x2C size\x2C buffer) {\n  if (size >>> 0 !== size)\n    throw new ERR_SOCKET_BAD_BUFFER_SIZE();\n\n  const ctx = {};\n  const ret = self[kStateSymbol].handle.bufferSize(size\x2C buffer\x2C ctx);\n  if (ret === undefined) {\n    throw new ERR_SOCKET_BUFFER_SIZE(ctx);\n  }\n  return ret;\n}\n\n// Query primary process to get the server handle and utilize it.\nfunction bindServerHandle(self\x2C options\x2C errCb) {\n  const cluster = lazyLoadCluster();\n\n  const state = self[kStateSymbol];\n  cluster._getServer(self\x2C options\x2C (err\x2C handle) => {\n    if (err) {\n      errCb(err);\n      return;\n    }\n\n    if (!state.handle) {\n      // Handle has been closed in the mean time.\n      return handle.close();\n    }\n\n    replaceHandle(self\x2C handle);\n    startListening(self);\n  });\n}\n\nSocket.prototype.bind = function(port_\x2C address_ /* \x2C callback */) {\n  let port = port_;\n\n  healthCheck(this);\n  const state = this[kStateSymbol];\n\n  if (state.bindState !== BIND_STATE_UNBOUND)\n    throw new ERR_SOCKET_ALREADY_BOUND();\n\n  state.bindState = BIND_STATE_BINDING;\n\n  const cb = arguments.length && arguments[arguments.length - 1];\n  if (typeof cb === 'function') {\n    function removeListeners() {\n      this.removeListener('error'\x2C removeListeners);\n      this.removeListener('listening'\x2C onListening);\n    }\n\n    function onListening() {\n      FunctionPrototypeCall(removeListeners\x2C this);\n      FunctionPrototypeCall(cb\x2C this);\n    }\n\n    this.on('error'\x2C removeListeners);\n    this.on('listening'\x2C onListening);\n  }\n\n  if (port !== null &&\n      typeof port === 'object' &&\n      typeof port.recvStart === 'function') {\n    replaceHandle(this\x2C port);\n    startListening(this);\n    return this;\n  }\n\n  // Open an existing fd instead of creating a new one.\n  if (port !== null && typeof port === 'object' &&\n      isInt32(port.fd) && port.fd > 0) {\n    const fd = port.fd;\n    const exclusive = !!port.exclusive;\n    const state = this[kStateSymbol];\n\n    const cluster = lazyLoadCluster();\n\n    if (cluster.isWorker && !exclusive) {\n      bindServerHandle(this\x2C {\n        address: null\x2C\n        port: null\x2C\n        addressType: this.type\x2C\n        fd\x2C\n        flags: null\x2C\n      }\x2C (err) => {\n        // Callback to handle error.\n        const ex = errnoException(err\x2C 'open');\n        state.bindState = BIND_STATE_UNBOUND;\n        this.emit('error'\x2C ex);\n      });\n      return this;\n    }\n\n    const type = guessHandleType(fd);\n    if (type !== 'UDP')\n      throw new ERR_INVALID_FD_TYPE(type);\n    const err = state.handle.open(fd);\n\n    if (err)\n      throw errnoException(err\x2C 'open');\n\n    startListening(this);\n    return this;\n  }\n\n  let address;\n  let exclusive;\n\n  if (port !== null && typeof port === 'object') {\n    address = port.address || '';\n    exclusive = !!port.exclusive;\n    port = port.port;\n  } else {\n    address = typeof address_ === 'function' ? '' : address_;\n    exclusive = false;\n  }\n\n  // Defaulting address for bind to all interfaces\n  if (!address) {\n    if (this.type === 'udp4')\n      address = '0.0.0.0';\n    else\n      address = '::';\n  }\n\n  // Resolve address first\n  state.handle.lookup(address\x2C (err\x2C ip) => {\n    if (err) {\n      state.bindState = BIND_STATE_UNBOUND;\n      this.emit('error'\x2C err);\n      return;\n    }\n\n    const cluster = lazyLoadCluster();\n\n    let flags = 0;\n    if (state.reuseAddr)\n      flags |= UV_UDP_REUSEADDR;\n    if (state.ipv6Only)\n      flags |= UV_UDP_IPV6ONLY;\n\n    if (cluster.isWorker && !exclusive) {\n      bindServerHandle(this\x2C {\n        address: ip\x2C\n        port: port\x2C\n        addressType: this.type\x2C\n        fd: -1\x2C\n        flags: flags\x2C\n      }\x2C (err) => {\n        // Callback to handle error.\n        const ex = exceptionWithHostPort(err\x2C 'bind'\x2C ip\x2C port);\n        state.bindState = BIND_STATE_UNBOUND;\n        this.emit('error'\x2C ex);\n      });\n    } else {\n      if (!state.handle)\n        return; // Handle has been closed in the mean time\n\n      const err = state.handle.bind(ip\x2C port || 0\x2C flags);\n      if (err) {\n        const ex = exceptionWithHostPort(err\x2C 'bind'\x2C ip\x2C port);\n        state.bindState = BIND_STATE_UNBOUND;\n        this.emit('error'\x2C ex);\n        // Todo: close?\n        return;\n      }\n\n      startListening(this);\n    }\n  });\n\n  return this;\n};\n\nSocket.prototype.connect = function(port\x2C address\x2C callback) {\n  port = validatePort(port\x2C 'Port'\x2C false);\n  if (typeof address === 'function') {\n    callback = address;\n    address = '';\n  } else if (address === undefined) {\n    address = '';\n  }\n\n  validateString(address\x2C 'address');\n\n  const state = this[kStateSymbol];\n\n  if (state.connectState !== CONNECT_STATE_DISCONNECTED)\n    throw new ERR_SOCKET_DGRAM_IS_CONNECTED();\n\n  state.connectState = CONNECT_STATE_CONNECTING;\n  if (state.bindState === BIND_STATE_UNBOUND)\n    this.bind({ port: 0\x2C exclusive: true }\x2C null);\n\n  if (state.bindState !== BIND_STATE_BOUND) {\n    enqueue(this\x2C FunctionPrototypeBind(_connect\x2C this\x2C\n                                        port\x2C address\x2C callback));\n    return;\n  }\n\n  ReflectApply(_connect\x2C this\x2C [port\x2C address\x2C callback]);\n};\n\n\nfunction _connect(port\x2C address\x2C callback) {\n  const state = this[kStateSymbol];\n  if (callback)\n    this.once('connect'\x2C callback);\n\n  const afterDns = (ex\x2C ip) => {\n    defaultTriggerAsyncIdScope(\n      this[async_id_symbol]\x2C\n      doConnect\x2C\n      ex\x2C this\x2C ip\x2C address\x2C port\x2C callback\x2C\n    );\n  };\n\n  state.handle.lookup(address\x2C afterDns);\n}\n\n\nfunction doConnect(ex\x2C self\x2C ip\x2C address\x2C port\x2C callback) {\n  const state = self[kStateSymbol];\n  if (!state.handle)\n    return;\n\n  if (!ex) {\n    const err = state.handle.connect(ip\x2C port);\n    if (err) {\n      ex = exceptionWithHostPort(err\x2C 'connect'\x2C address\x2C port);\n    }\n  }\n\n  if (ex) {\n    state.connectState = CONNECT_STATE_DISCONNECTED;\n    return process.nextTick(() => {\n      if (callback) {\n        self.removeListener('connect'\x2C callback);\n        callback(ex);\n      } else {\n        self.emit('error'\x2C ex);\n      }\n    });\n  }\n\n  state.connectState = CONNECT_STATE_CONNECTED;\n  process.nextTick(() => self.emit('connect'));\n}\n\n\nSocket.prototype.disconnect = function() {\n  const state = this[kStateSymbol];\n  if (state.connectState !== CONNECT_STATE_CONNECTED)\n    throw new ERR_SOCKET_DGRAM_NOT_CONNECTED();\n\n  const err = state.handle.disconnect();\n  if (err)\n    throw errnoException(err\x2C 'connect');\n  else\n    state.connectState = CONNECT_STATE_DISCONNECTED;\n};\n\n\n// Thin wrapper around `send`\x2C here for compatibility with dgram_legacy.js\nSocket.prototype.sendto = function(buffer\x2C\n                                   offset\x2C\n                                   length\x2C\n                                   port\x2C\n                                   address\x2C\n                                   callback) {\n  validateNumber(offset\x2C 'offset');\n  validateNumber(length\x2C 'length');\n  validateNumber(port\x2C 'port');\n  validateString(address\x2C 'address');\n\n  this.send(buffer\x2C offset\x2C length\x2C port\x2C address\x2C callback);\n};\n\n\nfunction sliceBuffer(buffer\x2C offset\x2C length) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer);\n  } else if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE('buffer'\x2C\n                                   ['Buffer'\x2C\n                                    'TypedArray'\x2C\n                                    'DataView'\x2C\n                                    'string']\x2C\n                                   buffer);\n  }\n\n  offset = offset >>> 0;\n  length = length >>> 0;\n  if (offset > buffer.byteLength) {\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('offset');\n  }\n\n  if (offset + length > buffer.byteLength) {\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('length');\n  }\n\n  return Buffer.from(buffer.buffer\x2C buffer.byteOffset + offset\x2C length);\n}\n\n\nfunction fixBufferList(list) {\n  const newlist = new Array(list.length);\n\n  for (let i = 0\x2C l = list.length; i < l; i++) {\n    const buf = list[i];\n    if (typeof buf === 'string')\n      newlist[i] = Buffer.from(buf);\n    else if (!isArrayBufferView(buf))\n      return null;\n    else\n      newlist[i] = Buffer.from(buf.buffer\x2C buf.byteOffset\x2C buf.byteLength);\n  }\n\n  return newlist;\n}\n\n\nfunction enqueue(self\x2C toEnqueue) {\n  const state = self[kStateSymbol];\n\n  // If the send queue hasn't been initialized yet\x2C do it\x2C and install an\n  // event handler that flushes the send queue after binding is done.\n  if (state.queue === undefined) {\n    state.queue = [];\n    self.once(EventEmitter.errorMonitor\x2C onListenError);\n    self.once('listening'\x2C onListenSuccess);\n  }\n  ArrayPrototypePush(state.queue\x2C toEnqueue);\n}\n\n\nfunction onListenSuccess() {\n  this.removeListener(EventEmitter.errorMonitor\x2C onListenError);\n  FunctionPrototypeCall(clearQueue\x2C this);\n}\n\n\nfunction onListenError(err) {\n  this.removeListener('listening'\x2C onListenSuccess);\n  this[kStateSymbol].queue = undefined;\n}\n\n\nfunction clearQueue() {\n  const state = this[kStateSymbol];\n  const queue = state.queue;\n  state.queue = undefined;\n\n  // Flush the send queue.\n  for (const queueEntry of queue)\n    queueEntry();\n}\n\n// valid combinations\n// For connectionless sockets\n// send(buffer\x2C offset\x2C length\x2C port\x2C address\x2C callback)\n// send(buffer\x2C offset\x2C length\x2C port\x2C address)\n// send(buffer\x2C offset\x2C length\x2C port\x2C callback)\n// send(buffer\x2C offset\x2C length\x2C port)\n// send(bufferOrList\x2C port\x2C address\x2C callback)\n// send(bufferOrList\x2C port\x2C address)\n// send(bufferOrList\x2C port\x2C callback)\n// send(bufferOrList\x2C port)\n// For connected sockets\n// send(buffer\x2C offset\x2C length\x2C callback)\n// send(buffer\x2C offset\x2C length)\n// send(bufferOrList\x2C callback)\n// send(bufferOrList)\nSocket.prototype.send = function(buffer\x2C\n                                 offset\x2C\n                                 length\x2C\n                                 port\x2C\n                                 address\x2C\n                                 callback) {\n\n  let list;\n  const state = this[kStateSymbol];\n  const connected = state.connectState === CONNECT_STATE_CONNECTED;\n  if (!connected) {\n    if (address || (port && typeof port !== 'function')) {\n      buffer = sliceBuffer(buffer\x2C offset\x2C length);\n    } else {\n      callback = port;\n      port = offset;\n      address = length;\n    }\n  } else {\n    if (typeof length === 'number') {\n      buffer = sliceBuffer(buffer\x2C offset\x2C length);\n      if (typeof port === 'function') {\n        callback = port;\n        port = null;\n      }\n    } else {\n      callback = offset;\n    }\n\n    if (port || address)\n      throw new ERR_SOCKET_DGRAM_IS_CONNECTED();\n  }\n\n  if (!ArrayIsArray(buffer)) {\n    if (typeof buffer === 'string') {\n      list = [ Buffer.from(buffer) ];\n    } else if (!isArrayBufferView(buffer)) {\n      throw new ERR_INVALID_ARG_TYPE('buffer'\x2C\n                                     ['Buffer'\x2C\n                                      'TypedArray'\x2C\n                                      'DataView'\x2C\n                                      'string']\x2C\n                                     buffer);\n    } else {\n      list = [ buffer ];\n    }\n  } else if (!(list = fixBufferList(buffer))) {\n    throw new ERR_INVALID_ARG_TYPE('buffer list arguments'\x2C\n                                   ['Buffer'\x2C\n                                    'TypedArray'\x2C\n                                    'DataView'\x2C\n                                    'string']\x2C\n                                   buffer);\n  }\n\n  if (!connected)\n    port = validatePort(port\x2C 'Port'\x2C false);\n\n  // Normalize callback so it's either a function or undefined but not anything\n  // else.\n  if (typeof callback !== 'function')\n    callback = undefined;\n\n  if (typeof address === 'function') {\n    callback = address;\n    address = undefined;\n  } else if (address != null) {\n    validateString(address\x2C 'address');\n  }\n\n  healthCheck(this);\n\n  if (state.bindState === BIND_STATE_UNBOUND)\n    this.bind({ port: 0\x2C exclusive: true }\x2C null);\n\n  if (list.length === 0)\n    ArrayPrototypePush(list\x2C Buffer.alloc(0));\n\n  // If the socket hasn't been bound yet\x2C push the outbound packet onto the\n  // send queue and send after binding is complete.\n  if (state.bindState !== BIND_STATE_BOUND) {\n    enqueue(this\x2C FunctionPrototypeBind(this.send\x2C this\x2C\n                                        list\x2C port\x2C address\x2C callback));\n    return;\n  }\n\n  const afterDns = (ex\x2C ip) => {\n    defaultTriggerAsyncIdScope(\n      this[async_id_symbol]\x2C\n      doSend\x2C\n      ex\x2C this\x2C ip\x2C list\x2C address\x2C port\x2C callback\x2C\n    );\n  };\n\n  if (!connected) {\n    state.handle.lookup(address\x2C afterDns);\n  } else {\n    afterDns(null\x2C null);\n  }\n};\n\nfunction doSend(ex\x2C self\x2C ip\x2C list\x2C address\x2C port\x2C callback) {\n  const state = self[kStateSymbol];\n\n  if (ex) {\n    if (typeof callback === 'function') {\n      process.nextTick(callback\x2C ex);\n      return;\n    }\n\n    process.nextTick(() => self.emit('error'\x2C ex));\n    return;\n  } else if (!state.handle) {\n    return;\n  }\n\n  const req = new SendWrap();\n  req.list = list;  // Keep reference alive.\n  req.address = address;\n  req.port = port;\n  if (callback) {\n    req.callback = callback;\n    req.oncomplete = afterSend;\n  }\n\n  let err;\n  if (port)\n    err = state.handle.send(req\x2C list\x2C list.length\x2C port\x2C ip\x2C !!callback);\n  else\n    err = state.handle.send(req\x2C list\x2C list.length\x2C !!callback);\n\n  if (err >= 1) {\n    // Synchronous finish. The return code is msg_length + 1 so that we can\n    // distinguish between synchronous success and asynchronous success.\n    if (callback)\n      process.nextTick(callback\x2C null\x2C err - 1);\n    return;\n  }\n\n  if (err && callback) {\n    // Don't emit as error\x2C dgram_legacy.js compatibility\n    const ex = exceptionWithHostPort(err\x2C 'send'\x2C address\x2C port);\n    process.nextTick(callback\x2C ex);\n  }\n}\n\nfunction afterSend(err\x2C sent) {\n  if (err) {\n    err = exceptionWithHostPort(err\x2C 'send'\x2C this.address\x2C this.port);\n  } else {\n    err = null;\n  }\n\n  this.callback(err\x2C sent);\n}\n\nSocket.prototype.close = function(callback) {\n  const state = this[kStateSymbol];\n  const queue = state.queue;\n\n  if (typeof callback === 'function')\n    this.on('close'\x2C callback);\n\n  if (queue !== undefined) {\n    ArrayPrototypePush(queue\x2C FunctionPrototypeBind(this.close\x2C this));\n    return this;\n  }\n\n  healthCheck(this);\n  stopReceiving(this);\n  state.handle.close();\n  state.handle = null;\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                             process.nextTick\x2C\n                             socketCloseNT\x2C\n                             this);\n\n  return this;\n};\n\n\nfunction socketCloseNT(self) {\n  self.emit('close');\n}\n\n\nSocket.prototype.address = function() {\n  healthCheck(this);\n\n  const out = {};\n  const err = this[kStateSymbol].handle.getsockname(out);\n  if (err) {\n    throw errnoException(err\x2C 'getsockname');\n  }\n\n  return out;\n};\n\nSocket.prototype.remoteAddress = function() {\n  healthCheck(this);\n\n  const state = this[kStateSymbol];\n  if (state.connectState !== CONNECT_STATE_CONNECTED)\n    throw new ERR_SOCKET_DGRAM_NOT_CONNECTED();\n\n  const out = {};\n  const err = state.handle.getpeername(out);\n  if (err)\n    throw errnoException(err\x2C 'getpeername');\n\n  return out;\n};\n\n\nSocket.prototype.setBroadcast = function(arg) {\n  const err = this[kStateSymbol].handle.setBroadcast(arg ? 1 : 0);\n  if (err) {\n    throw errnoException(err\x2C 'setBroadcast');\n  }\n};\n\n\nSocket.prototype.setTTL = function(ttl) {\n  validateNumber(ttl\x2C 'ttl');\n\n  const err = this[kStateSymbol].handle.setTTL(ttl);\n  if (err) {\n    throw errnoException(err\x2C 'setTTL');\n  }\n\n  return ttl;\n};\n\n\nSocket.prototype.setMulticastTTL = function(ttl) {\n  validateNumber(ttl\x2C 'ttl');\n\n  const err = this[kStateSymbol].handle.setMulticastTTL(ttl);\n  if (err) {\n    throw errnoException(err\x2C 'setMulticastTTL');\n  }\n\n  return ttl;\n};\n\n\nSocket.prototype.setMulticastLoopback = function(arg) {\n  const err = this[kStateSymbol].handle.setMulticastLoopback(arg ? 1 : 0);\n  if (err) {\n    throw errnoException(err\x2C 'setMulticastLoopback');\n  }\n\n  return arg; // 0.4 compatibility\n};\n\n\nSocket.prototype.setMulticastInterface = function(interfaceAddress) {\n  healthCheck(this);\n  validateString(interfaceAddress\x2C 'interfaceAddress');\n\n  const err = this[kStateSymbol].handle.setMulticastInterface(interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'setMulticastInterface');\n  }\n};\n\nSocket.prototype.addMembership = function(multicastAddress\x2C\n                                          interfaceAddress) {\n  healthCheck(this);\n\n  if (!multicastAddress) {\n    throw new ERR_MISSING_ARGS('multicastAddress');\n  }\n\n  const { handle } = this[kStateSymbol];\n  const err = handle.addMembership(multicastAddress\x2C interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'addMembership');\n  }\n};\n\n\nSocket.prototype.dropMembership = function(multicastAddress\x2C\n                                           interfaceAddress) {\n  healthCheck(this);\n\n  if (!multicastAddress) {\n    throw new ERR_MISSING_ARGS('multicastAddress');\n  }\n\n  const { handle } = this[kStateSymbol];\n  const err = handle.dropMembership(multicastAddress\x2C interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'dropMembership');\n  }\n};\n\nSocket.prototype.addSourceSpecificMembership = function(sourceAddress\x2C\n                                                        groupAddress\x2C\n                                                        interfaceAddress) {\n  healthCheck(this);\n\n  validateString(sourceAddress\x2C 'sourceAddress');\n  validateString(groupAddress\x2C 'groupAddress');\n\n  const err =\n    this[kStateSymbol].handle.addSourceSpecificMembership(sourceAddress\x2C\n                                                          groupAddress\x2C\n                                                          interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'addSourceSpecificMembership');\n  }\n};\n\n\nSocket.prototype.dropSourceSpecificMembership = function(sourceAddress\x2C\n                                                         groupAddress\x2C\n                                                         interfaceAddress) {\n  healthCheck(this);\n\n  validateString(sourceAddress\x2C 'sourceAddress');\n  validateString(groupAddress\x2C 'groupAddress');\n\n  const err =\n    this[kStateSymbol].handle.dropSourceSpecificMembership(sourceAddress\x2C\n                                                           groupAddress\x2C\n                                                           interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'dropSourceSpecificMembership');\n  }\n};\n\n\nfunction healthCheck(socket) {\n  if (!socket[kStateSymbol].handle) {\n    // Error message from dgram_legacy.js.\n    throw new ERR_SOCKET_DGRAM_NOT_RUNNING();\n  }\n}\n\n\nfunction stopReceiving(socket) {\n  const state = socket[kStateSymbol];\n\n  if (!state.receiving)\n    return;\n\n  state.handle.recvStop();\n  state.receiving = false;\n}\n\n\nfunction onMessage(nread\x2C handle\x2C buf\x2C rinfo) {\n  const self = handle[owner_symbol];\n  if (nread < 0) {\n    return self.emit('error'\x2C errnoException(nread\x2C 'recvmsg'));\n  }\n  rinfo.size = buf.length; // compatibility\n  self.emit('message'\x2C buf\x2C rinfo);\n}\n\n\nfunction onError(nread\x2C handle\x2C error) {\n  const self = handle[owner_symbol];\n  return self.emit('error'\x2C error);\n}\n\n\nSocket.prototype.ref = function() {\n  const handle = this[kStateSymbol].handle;\n\n  if (handle)\n    handle.ref();\n\n  return this;\n};\n\n\nSocket.prototype.unref = function() {\n  const handle = this[kStateSymbol].handle;\n\n  if (handle)\n    handle.unref();\n\n  return this;\n};\n\n\nSocket.prototype.setRecvBufferSize = function(size) {\n  bufferSize(this\x2C size\x2C RECV_BUFFER);\n};\n\n\nSocket.prototype.setSendBufferSize = function(size) {\n  bufferSize(this\x2C size\x2C SEND_BUFFER);\n};\n\n\nSocket.prototype.getRecvBufferSize = function() {\n  return bufferSize(this\x2C 0\x2C RECV_BUFFER);\n};\n\n\nSocket.prototype.getSendBufferSize = function() {\n  return bufferSize(this\x2C 0\x2C SEND_BUFFER);\n};\n\nSocket.prototype.getSendQueueSize = function() {\n  return this[kStateSymbol].handle.getSendQueueSize();\n};\n\nSocket.prototype.getSendQueueCount = function() {\n  return this[kStateSymbol].handle.getSendQueueCount();\n};\n\n// Deprecated private APIs.\nObjectDefineProperty(Socket.prototype\x2C '_handle'\x2C {\n  __proto__: null\x2C\n  get: deprecate(function() {\n    return this[kStateSymbol].handle;\n  }\x2C 'Socket.prototype._handle is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].handle = val;\n  }\x2C 'Socket.prototype._handle is deprecated'\x2C 'DEP0112')\x2C\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_receiving'\x2C {\n  __proto__: null\x2C\n  get: deprecate(function() {\n    return this[kStateSymbol].receiving;\n  }\x2C 'Socket.prototype._receiving is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].receiving = val;\n  }\x2C 'Socket.prototype._receiving is deprecated'\x2C 'DEP0112')\x2C\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_bindState'\x2C {\n  __proto__: null\x2C\n  get: deprecate(function() {\n    return this[kStateSymbol].bindState;\n  }\x2C 'Socket.prototype._bindState is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].bindState = val;\n  }\x2C 'Socket.prototype._bindState is deprecated'\x2C 'DEP0112')\x2C\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_queue'\x2C {\n  __proto__: null\x2C\n  get: deprecate(function() {\n    return this[kStateSymbol].queue;\n  }\x2C 'Socket.prototype._queue is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].queue = val;\n  }\x2C 'Socket.prototype._queue is deprecated'\x2C 'DEP0112')\x2C\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_reuseAddr'\x2C {\n  __proto__: null\x2C\n  get: deprecate(function() {\n    return this[kStateSymbol].reuseAddr;\n  }\x2C 'Socket.prototype._reuseAddr is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].reuseAddr = val;\n  }\x2C 'Socket.prototype._reuseAddr is deprecated'\x2C 'DEP0112')\x2C\n});\n\n\nSocket.prototype._healthCheck = deprecate(function() {\n  healthCheck(this);\n}\x2C 'Socket.prototype._healthCheck() is deprecated'\x2C 'DEP0112');\n\n\nSocket.prototype._stopReceiving = deprecate(function() {\n  stopReceiving(this);\n}\x2C 'Socket.prototype._stopReceiving() is deprecated'\x2C 'DEP0112');\n\n\n// Legacy alias on the C++ wrapper object. This is not public API\x2C so we may\n// want to runtime-deprecate it at some point. There's no hurry\x2C though.\nObjectDefineProperty(UDP.prototype\x2C 'owner'\x2C {\n  __proto__: null\x2C\n  get() { return this[owner_symbol]; }\x2C\n  set(v) { return this[owner_symbol] = v; }\x2C\n});\n\n\nmodule.exports = {\n  _createSocketHandle: deprecate(\n    _createSocketHandle\x2C\n    'dgram._createSocketHandle() is deprecated'\x2C\n    'DEP0112'\x2C\n  )\x2C\n  createSocket\x2C\n  Socket\x2C\n};\n
code-source-info,0x2b3d46cc2120,460,0,28067,C0O0C4O28067,,
code-creation,Function,10,73709,0x2b3d46cc41e0,1578, node:dgram:1:1,0x2b3d46cc2098,~
code-source-info,0x2b3d46cc41e0,460,0,28067,C0O0C279O1159C285O1168C291O1184C297O1206C303O1231C309O1256C314O1280C319O1304C325O1351C331O1351C336O1443C342O1443C347O1389C353O1405C358O1428C364O1498C367O1498C372O1478C378O1820C383O1533C389O1561C395O1585C401O1605C407O1633C413O1663C419O1689C425O1722C431O1756C437O1788C443O1925C449O1925C454O1837C460O1848C466O1871C472O1889C478O1907C484O1976C490O1976C495O1965C501O2017C507O2017C512O2003C517O2073C523O2073C528O2051C534O2126C540O2126C544O2126C546O2233C552O2233C557O2155C568O2196C574O2213C580O2295C583O2295C588O2323C593O2274C599O2394C602O2394C607O2394C612O2352C618O2373C623O2380C629O2435C635O2435C640O2495C648O2495C653O2492C655O2546C656O2546C658O2576C660O2576C662O2604C664O2604C666O2643C667O2643C669O2679C671O2679C673O2714C675O2714C677O2738C678O2738C680O2764C681O2764C683O2804C684O2804C686O2939C690O2932C692O2992C696O2985C698O4449C701O4477C709O4501C714O4449C719O4513C725O4513C730O6424C733O6431C742O6446C746O9894C749O9901C758O9919C762O11715C765O11722C774O11743C778O12131C781O12138C790O12155C794O15194C797O15201C806O15216C810O19434C813O19441C822O19457C826O20088C829O20095C838O20113C842O20308C845O20315C854O20339C858O20655C861O20662C870O20685C874O20839C877O20846C886O20863C890O21043C893O21050C902O21076C906O21274C909O21281C918O21312C922O21518C925O21525C934O21557C938O21824C941O21831C950O21855C954O22235C957O22242C966O22267C970O22649C973O22656C982O22694C986O23307C989O23314C998O23353C1002O24680C1005O24687C1014O24701C1018O24814C1021O24821C1030O24837C1034O24952C1037O24959C1046O24987C1050O25050C1053O25057C1062O25085C1066O25148C1069O25155C1078O25183C1082O25246C1085O25253C1094O25281C1098O25343C1101O25350C1110O25377C1114O25451C1117O25458C1126O25486C1130O25589C1133O25617C1146O25667C1158O25667C1167O25794C1179O25794C1188O25589C1193O25922C1196O25950C1209O26003C1221O26003C1230O26136C1242O26136C1251O25922C1256O26270C1259O26298C1272O26351C1284O26351C1293O26484C1305O26484C1314O26270C1319O26618C1322O26646C1335O26695C1347O26695C1356O26820C1368O26820C1377O26618C1382O26946C1385O26974C1398O27027C1410O27027C1419O27160C1431O27160C1440O26946C1445O27294C1448O27301C1453O27326C1464O27326C1469O27324C1473O27436C1476O27443C1481O27470C1492O27470C1497O27468C1501O27759C1514O27802C1522O27842C1530O27734C1535O27891C1549O27933C1560O28040C1566O28056C1572O27906C1577O28066,,
tick,0x195a4aa2c,73834,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x30e76772958a,0x41ccf0590b7,0x1100482ec,0x30e7677225ac,0x41ccf0590b7,0x1100482ec,0x30e7677207bc,0x202f0287b58b,0x202f02879dd8,0x202f028761e9
tick,0x1011eefb4,73834,1,0x100b1d1ec,6,0x0,0x41ccf059096,0x1100482ec,0x30e76772958a,0x41ccf0590b7,0x1100482ec,0x30e7677225ac,0x41ccf0590b7,0x1100482ec,0x30e7677207bc,0x202f0287b58b,0x202f02879dd8,0x202f028761e9
code-creation,Eval,10,73959,0x2b3d46cc77b0,5, node:internal/dgram:1:1,0x2b3d46cc75a8,~
script-source,461,node:internal/dgram,'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  Symbol\x2C\n} = primordials;\n\nconst { codes } = require('internal/errors');\nconst { UDP } = internalBinding('udp_wrap');\nconst { guessHandleType } = internalBinding('util');\nconst {\n  isInt32\x2C\n  validateFunction\x2C\n} = require('internal/validators');\nconst { UV_EINVAL } = internalBinding('uv');\nconst {\n  ERR_SOCKET_BAD_TYPE\x2C\n} = codes;\nconst kStateSymbol = Symbol('state symbol');\nlet dns;  // Lazy load for startup performance.\n\n\nfunction lookup4(lookup\x2C address\x2C callback) {\n  return lookup(address || '127.0.0.1'\x2C 4\x2C callback);\n}\n\n\nfunction lookup6(lookup\x2C address\x2C callback) {\n  return lookup(address || '::1'\x2C 6\x2C callback);\n}\n\nfunction newHandle(type\x2C lookup) {\n  if (lookup === undefined) {\n    if (dns === undefined) {\n      dns = require('dns');\n    }\n\n    lookup = dns.lookup;\n  } else {\n    validateFunction(lookup\x2C 'lookup');\n  }\n\n  if (type === 'udp4') {\n    const handle = new UDP();\n\n    handle.lookup = FunctionPrototypeBind(lookup4\x2C handle\x2C lookup);\n    return handle;\n  }\n\n  if (type === 'udp6') {\n    const handle = new UDP();\n\n    handle.lookup = FunctionPrototypeBind(lookup6\x2C handle\x2C lookup);\n    handle.bind = handle.bind6;\n    handle.connect = handle.connect6;\n    handle.send = handle.send6;\n    return handle;\n  }\n\n  throw new ERR_SOCKET_BAD_TYPE();\n}\n\n\nfunction _createSocketHandle(address\x2C port\x2C addressType\x2C fd\x2C flags) {\n  const handle = newHandle(addressType);\n  let err;\n\n  if (isInt32(fd) && fd > 0) {\n    const type = guessHandleType(fd);\n    if (type !== 'UDP') {\n      err = UV_EINVAL;\n    } else {\n      err = handle.open(fd);\n    }\n  } else if (port || address) {\n    err = handle.bind(address\x2C port || 0\x2C flags);\n  }\n\n  if (err) {\n    handle.close();\n    return err;\n  }\n\n  return handle;\n}\n\n\nmodule.exports = {\n  kStateSymbol\x2C\n  _createSocketHandle\x2C\n  newHandle\x2C\n};\n
code-source-info,0x2b3d46cc77b0,461,0,1850,C0O0C4O1850,,
code-creation,Function,10,74042,0x2b3d46cc7a78,196, node:internal/dgram:1:1,0x2b3d46cc7728,~
code-source-info,0x2b3d46cc7a78,461,0,1850,C0O0C56O25C62O50C67O94C73O94C78O84C83O138C86O138C91O130C97O195C100O195C105O175C111O263C117O263C122O230C128O241C134O317C137O317C142O303C148O350C154O403C157O403C162O431C163O431C165O1776C172O1797C178O1813C184O1836C190O1791C195O1849,,
code-creation,Eval,10,74209,0x2b3d46cca198,5, node:diagnostics_channel:1:1,0x2b3d46cc9f28,~
script-source,462,node:diagnostics_channel,'use strict';\n\nconst {\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSplice\x2C\n  ObjectCreate\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  SymbolHasInstance\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  validateFunction\x2C\n} = require('internal/validators');\n\nconst { triggerUncaughtException } = internalBinding('errors');\n\nconst { WeakReference } = internalBinding('util');\n\n// TODO(qard): should there be a C++ channel interface?\nclass ActiveChannel {\n  subscribe(subscription) {\n    validateFunction(subscription\x2C 'subscription');\n    ArrayPrototypePush(this._subscribers\x2C subscription);\n  }\n\n  unsubscribe(subscription) {\n    const index = ArrayPrototypeIndexOf(this._subscribers\x2C subscription);\n    if (index === -1) return false;\n\n    ArrayPrototypeSplice(this._subscribers\x2C index\x2C 1);\n\n    // When there are no more active subscribers\x2C restore to fast prototype.\n    if (!this._subscribers.length) {\n      // eslint-disable-next-line no-use-before-define\n      ObjectSetPrototypeOf(this\x2C Channel.prototype);\n    }\n\n    return true;\n  }\n\n  get hasSubscribers() {\n    return true;\n  }\n\n  publish(data) {\n    for (let i = 0; i < this._subscribers.length; i++) {\n      try {\n        const onMessage = this._subscribers[i];\n        onMessage(data\x2C this.name);\n      } catch (err) {\n        process.nextTick(() => {\n          triggerUncaughtException(err\x2C false);\n        });\n      }\n    }\n  }\n}\n\nclass Channel {\n  constructor(name) {\n    this._subscribers = undefined;\n    this.name = name;\n  }\n\n  static [SymbolHasInstance](instance) {\n    const prototype = ObjectGetPrototypeOf(instance);\n    return prototype === Channel.prototype ||\n           prototype === ActiveChannel.prototype;\n  }\n\n  subscribe(subscription) {\n    ObjectSetPrototypeOf(this\x2C ActiveChannel.prototype);\n    this._subscribers = [];\n    this.subscribe(subscription);\n  }\n\n  unsubscribe() {\n    return false;\n  }\n\n  get hasSubscribers() {\n    return false;\n  }\n\n  publish() {}\n}\n\nconst channels = ObjectCreate(null);\n\nfunction channel(name) {\n  let channel;\n  const ref = channels[name];\n  if (ref) channel = ref.get();\n  if (channel) return channel;\n\n  if (typeof name !== 'string' && typeof name !== 'symbol') {\n    throw new ERR_INVALID_ARG_TYPE('channel'\x2C ['string'\x2C 'symbol']\x2C name);\n  }\n\n  channel = new Channel(name);\n  channels[name] = new WeakReference(channel);\n  return channel;\n}\n\nfunction subscribe(name\x2C subscription) {\n  const chan = channel(name);\n  channels[name].incRef();\n  chan.subscribe(subscription);\n}\n\nfunction unsubscribe(name\x2C subscription) {\n  const chan = channel(name);\n  if (!chan.unsubscribe(subscription)) {\n    return false;\n  }\n\n  channels[name].decRef();\n  if (channels[name].getRef() === 0) {\n    delete channels[name];\n  }\n  return true;\n}\n\nfunction hasSubscribers(name) {\n  let channel;\n  const ref = channels[name];\n  if (ref) channel = ref.get();\n  if (!channel) {\n    return false;\n  }\n\n  return channel.hasSubscribers;\n}\n\nmodule.exports = {\n  channel\x2C\n  hasSubscribers\x2C\n  subscribe\x2C\n  unsubscribe\x2C\n  Channel\x2C\n};\n
code-source-info,0x2b3d46cca198,462,0,3112,C0O0C4O3112,,
code-creation,Function,10,74334,0x2b3d46ccade8,337, node:diagnostics_channel:1:1,0x2b3d46cca110,~
code-source-info,0x2b3d46ccade8,462,0,3112,C0O0C66O25C72O50C78O72C84O96C89O112C95O136C101O160C106O251C109O251C114O251C119O220C125O311C128O311C133O289C139O381C142O381C147O352C153O435C156O435C161O417C208O517C226O1593C284O1483C286O2055C288O2055C292O2055C294O3022C301O3043C307O3054C313O3072C319O3085C325O3100C331O3037C336O3111,,
code-creation,LazyCompile,10,74417,0x2b3d46ccb7d0,105,channel node:diagnostics_channel:97:17,0x2b3d46cca1c8,~
code-source-info,0x2b3d46ccb7d0,462,2092,2449,C0O2107C2O2130C9O2138C13O2148C15O2171C20O2171C25O2180C29O2193C31O2208C32O2212C44O2276C62O2282C67O2276C68O2354C75O2364C81O2385C88O2406C93O2402C98O2400C102O2432C104O2447,,
code-creation,LazyCompile,10,74459,0x2b3d46ccbe20,13,Channel node:diagnostics_channel:67:14,0x2b3d46cca4c0,~
code-source-info,0x2b3d46ccbe20,462,1512,1581,C0O1525C1O1543C5O1560C7O1570C12O1580,,
code-creation,Eval,10,74584,0x2b3d46ccda58,5, node:internal/socket_list:1:1,0x2b3d46ccd900,~
script-source,463,node:internal/socket_list,'use strict';\n\nconst { ERR_CHILD_CLOSED_BEFORE_REPLY } = require('internal/errors').codes;\n\nconst EventEmitter = require('events');\n\n// This object keeps track of the sockets that are sent\nclass SocketListSend extends EventEmitter {\n  constructor(child\x2C key) {\n    super();\n    this.key = key;\n    this.child = child;\n    child.once('exit'\x2C () => this.emit('exit'\x2C this));\n  }\n\n  _request(msg\x2C cmd\x2C swallowErrors\x2C callback) {\n    const self = this;\n\n    if (!this.child.connected) return onclose();\n    this.child._send(msg\x2C undefined\x2C swallowErrors);\n\n    function onclose() {\n      self.child.removeListener('internalMessage'\x2C onreply);\n      callback(new ERR_CHILD_CLOSED_BEFORE_REPLY());\n    }\n\n    function onreply(msg) {\n      if (!(msg.cmd === cmd && msg.key === self.key)) return;\n      self.child.removeListener('disconnect'\x2C onclose);\n      self.child.removeListener('internalMessage'\x2C onreply);\n\n      callback(null\x2C msg);\n    }\n\n    this.child.once('disconnect'\x2C onclose);\n    this.child.on('internalMessage'\x2C onreply);\n  }\n\n  close(callback) {\n    this._request({\n      cmd: 'NODE_SOCKET_NOTIFY_CLOSE'\x2C\n      key: this.key\x2C\n    }\x2C 'NODE_SOCKET_ALL_CLOSED'\x2C true\x2C callback);\n  }\n\n  getConnections(callback) {\n    this._request({\n      cmd: 'NODE_SOCKET_GET_COUNT'\x2C\n      key: this.key\x2C\n    }\x2C 'NODE_SOCKET_COUNT'\x2C false\x2C (err\x2C msg) => {\n      if (err) return callback(err);\n      callback(null\x2C msg.count);\n    });\n  }\n}\n\n\n// This object keeps track of the sockets that are received\nclass SocketListReceive extends EventEmitter {\n  constructor(child\x2C key) {\n    super();\n\n    this.connections = 0;\n    this.key = key;\n    this.child = child;\n\n    function onempty(self) {\n      if (!self.child.connected) return;\n\n      self.child._send({\n        cmd: 'NODE_SOCKET_ALL_CLOSED'\x2C\n        key: self.key\x2C\n      }\x2C undefined\x2C true);\n    }\n\n    this.child.on('internalMessage'\x2C (msg) => {\n      if (msg.key !== this.key) return;\n\n      if (msg.cmd === 'NODE_SOCKET_NOTIFY_CLOSE') {\n        // Already empty\n        if (this.connections === 0) return onempty(this);\n\n        // Wait for sockets to get closed\n        this.once('empty'\x2C onempty);\n      } else if (msg.cmd === 'NODE_SOCKET_GET_COUNT') {\n        if (!this.child.connected) return;\n        this.child._send({\n          cmd: 'NODE_SOCKET_COUNT'\x2C\n          key: this.key\x2C\n          count: this.connections\x2C\n        });\n      }\n    });\n  }\n\n  add(obj) {\n    this.connections++;\n\n    // Notify the previous owner of the socket about its state change\n    obj.socket.once('close'\x2C () => {\n      this.connections--;\n\n      if (this.connections === 0) this.emit('empty'\x2C this);\n    });\n  }\n}\n\nmodule.exports = { SocketListSend\x2C SocketListReceive };\n
code-source-info,0x2b3d46ccda58,463,0,2709,C0O0C4O2709,,
code-creation,Function,10,74709,0x2b3d46cce098,126, node:internal/socket_list:1:1,0x2b3d46ccd9d0,~
code-source-info,0x2b3d46cce098,463,0,2709,C0O0C8O57C11O57C16O83C21O23C27O113C30O113C35O218C73O1527C101O2653C108O2672C114O2688C120O2668C125O2708,,
code-creation,LazyCompile,10,74959,0x2b3d46cce988,14,customPromiseExecFunction node:child_process:237:35,0x30e767721e48,~
code-source-info,0x2b3d46cce988,456,6853,7217,C0O6853C9O6867C13O7215,,
new,MemoryChunk,0x3c2d33740000,262144
code-creation,LazyCompile,10,75042,0x2b3d46cd0be8,129,_forkChild node:child_process:173:20,0x30e7677217a8,~
code-source-info,0x2b3d46cd0be8,456,5064,5534,C0O5064C8O5126C19O5135C22O5149C29O5126C35O5159C40O5159C45O5173C50O5173C54O5200C72O5200C77O5200C79O5247C84O5255C97O5255C103O5387C108O5395C121O5395C128O5533,,
tick,0x195a4aaa8,75125,1,0x100be42ec,6,0x0,0x2b3d46cd0c05,0x30e7677207c6,0x202f0287b58b,0x202f02879dd8,0x202f028761e9
code-creation,LazyCompile,10,75209,0x2b3d46cd15f0,396,setupChannel node:internal/child_process:569:22,0x30e767728020,~
code-source-info,0x2b3d46cd15f0,457,14728,26827,C0O14728C37O14785C49O14785C54O14785C56O14809C61O14824C65O14837C72O14844C77O14860C81O14874C94O14895C103O14947C115O15001C121O14947C134O15045C146O15101C152O15045C161O14874C166O15192C170O15212C174O15222C178O15245C182O15256C190O15293C198O15309C207O15307C215O15449C224O15462C228O15372C233O15396C239O15422C245O15506C246O15506C248O15514C251O15514C255O15545C259O15567C263O15577C270O15592C274O16819C281O16835C285O16898C288O16905C301O16905C307O19274C310O19281C323O19281C329O19710C336O19722C340O20449C347O20462C351O25157C355O25174C359O25185C366O25203C370O25634C377O25653C381O26787C384O26795C389O26795C393O26810C395O26825,,
code-creation,LazyCompile,10,75250,0x2b3d46cd3db8,72,Control node:internal/child_process:527:14,0x30e767728858,~
code-source-info,0x2b3d46cd3db8,457,13674,13764,C3O13690C11O13690C40O13703C48O13717C52O13732C59O13737C64O13755C71O13763,,
code-creation,Eval,10,75375,0x2b3d46cd4670,5, node:internal/child_process/serialization:1:1,0x2b3d46cd4348,~
script-source,464,node:internal/child_process/serialization,'use strict';\n\nconst {\n  JSONParse\x2C\n  JSONStringify\x2C\n  StringPrototypeSplit\x2C\n  ArrayPrototypePush\x2C\n  Symbol\x2C\n  TypedArrayPrototypeSubarray\x2C\n} = primordials;\nconst { Buffer } = require('buffer');\nconst { StringDecoder } = require('string_decoder');\nconst v8 = require('v8');\nconst { isArrayBufferView } = require('internal/util/types');\nconst assert = require('internal/assert');\nconst { streamBaseState\x2C kLastWriteWasAsync } = internalBinding('stream_wrap');\n\nconst kMessageBuffer = Symbol('kMessageBuffer');\nconst kMessageBufferSize = Symbol('kMessageBufferSize');\nconst kJSONBuffer = Symbol('kJSONBuffer');\nconst kStringDecoder = Symbol('kStringDecoder');\n\n// Extend V8's serializer APIs to give more JSON-like behaviour in\n// some cases; in particular\x2C for native objects this serializes them the same\n// way that JSON does rather than throwing an exception.\nconst kArrayBufferViewTag = 0;\nconst kNotArrayBufferViewTag = 1;\nclass ChildProcessSerializer extends v8.DefaultSerializer {\n  _writeHostObject(object) {\n    if (isArrayBufferView(object)) {\n      this.writeUint32(kArrayBufferViewTag);\n      return super._writeHostObject(object);\n    }\n    this.writeUint32(kNotArrayBufferViewTag);\n    this.writeValue({ ...object });\n  }\n}\n\nclass ChildProcessDeserializer extends v8.DefaultDeserializer {\n  _readHostObject() {\n    const tag = this.readUint32();\n    if (tag === kArrayBufferViewTag)\n      return super._readHostObject();\n\n    assert(tag === kNotArrayBufferViewTag);\n    return this.readValue();\n  }\n}\n\n// Messages are parsed in either of the following formats:\n// - Newline-delimited JSON\x2C or\n// - V8-serialized buffers\x2C prefixed with their length as a big endian uint32\n//   (aka 'advanced')\nconst advanced = {\n  initMessageChannel(channel) {\n    channel[kMessageBuffer] = [];\n    channel[kMessageBufferSize] = 0;\n    channel.buffering = false;\n  }\x2C\n\n  *parseChannelMessages(channel\x2C readData) {\n    if (readData.length === 0) return;\n\n    ArrayPrototypePush(channel[kMessageBuffer]\x2C readData);\n    channel[kMessageBufferSize] += readData.length;\n\n    // Index 0 should always be present because we just pushed data into it.\n    let messageBufferHead = channel[kMessageBuffer][0];\n    while (messageBufferHead.length >= 4) {\n      // We call `readUInt32BE` manually here\x2C because this is faster than first converting\n      // it to a buffer and using `readUInt32BE` on that.\n      const fullMessageSize = (\n        messageBufferHead[0] << 24 |\n        messageBufferHead[1] << 16 |\n        messageBufferHead[2] << 8 |\n        messageBufferHead[3]\n      ) + 4;\n\n      if (channel[kMessageBufferSize] < fullMessageSize) break;\n\n      const concatenatedBuffer = channel[kMessageBuffer].length === 1 ?\n        channel[kMessageBuffer][0] :\n        Buffer.concat(\n          channel[kMessageBuffer]\x2C\n          channel[kMessageBufferSize]\x2C\n        );\n\n      const deserializer = new ChildProcessDeserializer(\n        TypedArrayPrototypeSubarray(concatenatedBuffer\x2C 4\x2C fullMessageSize)\x2C\n      );\n\n      messageBufferHead = TypedArrayPrototypeSubarray(concatenatedBuffer\x2C fullMessageSize);\n      channel[kMessageBufferSize] = messageBufferHead.length;\n      channel[kMessageBuffer] =\n        channel[kMessageBufferSize] !== 0 ? [messageBufferHead] : [];\n\n      deserializer.readHeader();\n      yield deserializer.readValue();\n    }\n\n    channel.buffering = channel[kMessageBufferSize] > 0;\n  }\x2C\n\n  writeChannelMessage(channel\x2C req\x2C message\x2C handle) {\n    const ser = new ChildProcessSerializer();\n    // Add 4 bytes\x2C to later populate with message length\n    ser.writeRawBytes(Buffer.allocUnsafe(4));\n    ser.writeHeader();\n    ser.writeValue(message);\n\n    const serializedMessage = ser.releaseBuffer();\n    const serializedMessageLength = serializedMessage.length - 4;\n\n    serializedMessage.set([\n      serializedMessageLength >> 24 & 0xFF\x2C\n      serializedMessageLength >> 16 & 0xFF\x2C\n      serializedMessageLength >> 8 & 0xFF\x2C\n      serializedMessageLength & 0xFF\x2C\n    ]\x2C 0);\n\n    const result = channel.writeBuffer(req\x2C serializedMessage\x2C handle);\n\n    // Mirror what stream_base_commons.js does for Buffer retention.\n    if (streamBaseState[kLastWriteWasAsync])\n      req.buffer = serializedMessage;\n\n    return result;\n  }\x2C\n};\n\nconst json = {\n  initMessageChannel(channel) {\n    channel[kJSONBuffer] = '';\n    channel[kStringDecoder] = undefined;\n  }\x2C\n\n  *parseChannelMessages(channel\x2C readData) {\n    if (readData.length === 0) return;\n\n    if (channel[kStringDecoder] === undefined)\n      channel[kStringDecoder] = new StringDecoder('utf8');\n    const chunks =\n      StringPrototypeSplit(channel[kStringDecoder].write(readData)\x2C '\\n');\n    const numCompleteChunks = chunks.length - 1;\n    // Last line does not have trailing linebreak\n    const incompleteChunk = chunks[numCompleteChunks];\n    if (numCompleteChunks === 0) {\n      channel[kJSONBuffer] += incompleteChunk;\n    } else {\n      chunks[0] = channel[kJSONBuffer] + chunks[0];\n      for (let i = 0; i < numCompleteChunks; i++)\n        yield JSONParse(chunks[i]);\n      channel[kJSONBuffer] = incompleteChunk;\n    }\n    channel.buffering = channel[kJSONBuffer].length !== 0;\n  }\x2C\n\n  writeChannelMessage(channel\x2C req\x2C message\x2C handle) {\n    const string = JSONStringify(message) + '\\n';\n    return channel.writeUtf8String(req\x2C string\x2C handle);\n  }\x2C\n};\n\nmodule.exports = { advanced\x2C json };\n
code-source-info,0x2b3d46cd4670,464,0,5360,C0O0C4O5360,,
code-creation,Function,10,75625,0x2b3d46cd4ee8,390, node:internal/child_process/serialization:1:1,0x2b3d46cd45e8,~
code-source-info,0x2b3d46cd4ee8,464,0,5360,C0O0C62O25C68O38C74O55C80O79C86O101C91O111C97O176C100O176C105O165C111O221C114O221C119O203C125O259C128O259C133O304C136O304C141O282C147O351C150O351C154O351C156O427C159O427C164O387C170O404C176O483C179O483C183O483C185O536C188O536C192O536C194O586C197O586C201O586C203O632C206O632C210O632C212O890C213O890C215O924C217O924C223O967C258O927C264O1280C299O1238C301O1723C306O1727C314O1867C322O3401C333O4251C338O4255C346O4365C354O5154C365O5323C372O5342C378O5352C384O5338C389O5359,,
code-creation,LazyCompile,10,75750,0x2b3d46cd5b80,23,initMessageChannel node:internal/child_process/serialization:132:21,0x2b3d46cd48d0,~
code-source-info,0x2b3d46cd5b80,464,4273,4360,C0O4289C2O4297C7O4310C11O4320C13O4328C17O4344C22O4359,,
code-creation,LazyCompile,10,75834,0x2b3d46cd62d8,19,_getMaxListeners node:events:415:26,0x1012a3972008,~
script-source,29,node:events,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeShift\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  Boolean\x2C\n  Error\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  NumberIsNaN\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromiseReject\x2C\n  PromiseResolve\x2C\n  ReflectApply\x2C\n  ReflectOwnKeys\x2C\n  String\x2C\n  StringPrototypeSplit\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolAsyncIterator\x2C\n} = primordials;\nconst kRejection = SymbolFor('nodejs.rejection');\n\nconst { kEmptyObject } = require('internal/util');\n\nconst {\n  inspect\x2C\n  identicalSequenceRange\x2C\n} = require('internal/util/inspect');\n\nlet spliceOne;\n\nconst {\n  AbortError\x2C\n  kEnhanceStackBeforeInspector\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_THIS\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNHANDLED_ERROR\x2C\n  }\x2C\n  genericNodeError\x2C\n} = require('internal/errors');\n\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst kCapture = Symbol('kCapture');\nconst kErrorMonitor = Symbol('events.errorMonitor');\nconst kMaxEventTargetListeners = Symbol('events.maxEventTargetListeners');\nconst kMaxEventTargetListenersWarned =\n  Symbol('events.maxEventTargetListenersWarned');\n\nlet EventEmitterAsyncResource;\n// The EventEmitterAsyncResource has to be initialized lazily because event.js\n// is loaded so early in the bootstrap process\x2C before async_hooks is available.\n//\n// This implementation was adapted straight from addaleax's\n// eventemitter-asyncresource MIT-licensed userland module.\n// https://github.com/addaleax/eventemitter-asyncresource\nfunction lazyEventEmitterAsyncResource() {\n  if (EventEmitterAsyncResource === undefined) {\n    const {\n      AsyncResource\x2C\n    } = require('async_hooks');\n\n    const kEventEmitter = Symbol('kEventEmitter');\n    const kAsyncResource = Symbol('kAsyncResource');\n    class EventEmitterReferencingAsyncResource extends AsyncResource {\n      /**\n       * @param {EventEmitter} ee\n       * @param {string} [type]\n       * @param {{\n       *   triggerAsyncId?: number\x2C\n       *   requireManualDestroy?: boolean\x2C\n       * }} [options]\n       */\n      constructor(ee\x2C type\x2C options) {\n        super(type\x2C options);\n        this[kEventEmitter] = ee;\n      }\n\n      /**\n       * @type {EventEmitter}\n       */\n      get eventEmitter() {\n        if (this[kEventEmitter] === undefined)\n          throw new ERR_INVALID_THIS('EventEmitterReferencingAsyncResource');\n        return this[kEventEmitter];\n      }\n    }\n\n    EventEmitterAsyncResource =\n      class EventEmitterAsyncResource extends EventEmitter {\n        /**\n         * @param {{\n         *   name?: string\x2C\n         *   triggerAsyncId?: number\x2C\n         *   requireManualDestroy?: boolean\x2C\n         * }} [options]\n         */\n        constructor(options = undefined) {\n          let name;\n          if (typeof options === 'string') {\n            name = options;\n            options = undefined;\n          } else {\n            if (new.target === EventEmitterAsyncResource) {\n              validateString(options?.name\x2C 'options.name');\n            }\n            name = options?.name || new.target.name;\n          }\n          super(options);\n\n          this[kAsyncResource] =\n            new EventEmitterReferencingAsyncResource(this\x2C name\x2C options);\n        }\n\n        /**\n         * @param {symbol\x2Cstring} event\n         * @param  {...any} args\n         * @returns {boolean}\n         */\n        emit(event\x2C ...args) {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          const { asyncResource } = this;\n          ArrayPrototypeUnshift(args\x2C super.emit\x2C this\x2C event);\n          return ReflectApply(asyncResource.runInAsyncScope\x2C asyncResource\x2C\n                              args);\n        }\n\n        /**\n         * @returns {void}\n         */\n        emitDestroy() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          this.asyncResource.emitDestroy();\n        }\n\n        /**\n         * @type {number}\n         */\n        get asyncId() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this.asyncResource.asyncId();\n        }\n\n        /**\n         * @type {number}\n         */\n        get triggerAsyncId() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this.asyncResource.triggerAsyncId();\n        }\n\n        /**\n         * @type {EventEmitterReferencingAsyncResource}\n         */\n        get asyncResource() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this[kAsyncResource];\n        }\n      };\n  }\n  return EventEmitterAsyncResource;\n}\n\n/**\n * Creates a new `EventEmitter` instance.\n * @param {{ captureRejections?: boolean; }} [opts]\n * @constructs {EventEmitter}\n */\nfunction EventEmitter(opts) {\n  EventEmitter.init.call(this\x2C opts);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\nmodule.exports.on = on;\nmodule.exports.getEventListeners = getEventListeners;\nmodule.exports.getMaxListeners = getMaxListeners;\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.captureRejectionSymbol = kRejection;\nObjectDefineProperty(EventEmitter\x2C 'captureRejections'\x2C {\n  __proto__: null\x2C\n  get() {\n    return EventEmitter.prototype[kCapture];\n  }\x2C\n  set(value) {\n    validateBoolean(value\x2C 'EventEmitter.captureRejections');\n\n    EventEmitter.prototype[kCapture] = value;\n  }\x2C\n  enumerable: true\x2C\n});\n\nObjectDefineProperty(EventEmitter\x2C 'EventEmitterAsyncResource'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get: lazyEventEmitterAsyncResource\x2C\n  set: undefined\x2C\n  configurable: true\x2C\n});\n\nEventEmitter.errorMonitor = kErrorMonitor;\n\n// The default for captureRejections is false\nObjectDefineProperty(EventEmitter.prototype\x2C kCapture\x2C {\n  __proto__: null\x2C\n  value: false\x2C\n  writable: true\x2C\n  enumerable: false\x2C\n});\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nlet defaultMaxListeners = 10;\nlet isEventTarget;\n\nfunction checkListener(listener) {\n  validateFunction(listener\x2C 'listener');\n}\n\nObjectDefineProperty(EventEmitter\x2C 'defaultMaxListeners'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get: function() {\n    return defaultMaxListeners;\n  }\x2C\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new ERR_OUT_OF_RANGE('defaultMaxListeners'\x2C\n                                 'a non-negative number'\x2C\n                                 arg);\n    }\n    defaultMaxListeners = arg;\n  }\x2C\n});\n\nObjectDefineProperties(EventEmitter\x2C {\n  kMaxEventTargetListeners: {\n    __proto__: null\x2C\n    value: kMaxEventTargetListeners\x2C\n    enumerable: false\x2C\n    configurable: false\x2C\n    writable: false\x2C\n  }\x2C\n  kMaxEventTargetListenersWarned: {\n    __proto__: null\x2C\n    value: kMaxEventTargetListenersWarned\x2C\n    enumerable: false\x2C\n    configurable: false\x2C\n    writable: false\x2C\n  }\x2C\n});\n\n/**\n * Sets the max listeners.\n * @param {number} n\n * @param {EventTarget[] | EventEmitter[]} [eventTargets]\n * @returns {void}\n */\nEventEmitter.setMaxListeners =\n  function(n = defaultMaxListeners\x2C ...eventTargets) {\n    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n))\n      throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\n    if (eventTargets.length === 0) {\n      defaultMaxListeners = n;\n    } else {\n      if (isEventTarget === undefined)\n        isEventTarget = require('internal/event_target').isEventTarget;\n\n      for (let i = 0; i < eventTargets.length; i++) {\n        const target = eventTargets[i];\n        if (isEventTarget(target)) {\n          target[kMaxEventTargetListeners] = n;\n          target[kMaxEventTargetListenersWarned] = false;\n        } else if (typeof target.setMaxListeners === 'function') {\n          target.setMaxListeners(n);\n        } else {\n          throw new ERR_INVALID_ARG_TYPE(\n            'eventTargets'\x2C\n            ['EventEmitter'\x2C 'EventTarget']\x2C\n            target);\n        }\n      }\n    }\n  };\n\n// If you're updating this function definition\x2C please also update any\n// re-definitions\x2C such as the one in the Domain module (lib/domain.js).\nEventEmitter.init = function(opts) {\n\n  if (this._events === undefined ||\n      this._events === ObjectGetPrototypeOf(this)._events) {\n    this._events = ObjectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n\n\n  if (opts?.captureRejections) {\n    validateBoolean(opts.captureRejections\x2C 'options.captureRejections');\n    this[kCapture] = Boolean(opts.captureRejections);\n  } else {\n    // Assigning the kCapture property directly saves an expensive\n    // prototype lookup in a very sensitive hot path.\n    this[kCapture] = EventEmitter.prototype[kCapture];\n  }\n};\n\nfunction addCatch(that\x2C promise\x2C type\x2C args) {\n  if (!that[kCapture]) {\n    return;\n  }\n\n  // Handle Promises/A+ spec\x2C then could be a getter\n  // that throws on second use.\n  try {\n    const then = promise.then;\n\n    if (typeof then === 'function') {\n      then.call(promise\x2C undefined\x2C function(err) {\n        // The callback is called with nextTick to avoid a follow-up\n        // rejection from this promise.\n        process.nextTick(emitUnhandledRejectionOrErr\x2C that\x2C err\x2C type\x2C args);\n      });\n    }\n  } catch (err) {\n    that.emit('error'\x2C err);\n  }\n}\n\nfunction emitUnhandledRejectionOrErr(ee\x2C err\x2C type\x2C args) {\n  if (typeof ee[kRejection] === 'function') {\n    ee[kRejection](err\x2C type\x2C ...args);\n  } else {\n    // We have to disable the capture rejections mechanism\x2C otherwise\n    // we might end up in an infinite loop.\n    const prev = ee[kCapture];\n\n    // If the error handler throws\x2C it is not catchable and it\n    // will end up in 'uncaughtException'. We restore the previous\n    // value of kCapture in case the uncaughtException is present\n    // and the exception is handled.\n    try {\n      ee[kCapture] = false;\n      ee.emit('error'\x2C err);\n    } finally {\n      ee[kCapture] = prev;\n    }\n  }\n}\n\n/**\n * Increases the max listeners of the event emitter.\n * @param {number} n\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\n/**\n * Returns the current max listener value for the event emitter.\n * @returns {number}\n */\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nfunction enhanceStackTrace(err\x2C own) {\n  let ctorInfo = '';\n  try {\n    const { name } = this.constructor;\n    if (name !== 'EventEmitter')\n      ctorInfo = ` on ${name} instance`;\n  } catch {\n    // Continue regardless of error.\n  }\n  const sep = `\\nEmitted 'error' event${ctorInfo} at:\\n`;\n\n  const errStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(err.stack\x2C '\\n')\x2C 1);\n  const ownStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(own.stack\x2C '\\n')\x2C 1);\n\n  const { len\x2C offset } = identicalSequenceRange(ownStack\x2C errStack);\n  if (len > 0) {\n    ArrayPrototypeSplice(ownStack\x2C offset + 1\x2C len - 2\x2C\n                         '    [... lines matching original stack trace ...]');\n  }\n\n  return err.stack + sep + ArrayPrototypeJoin(ownStack\x2C '\\n');\n}\n\n/**\n * Synchronously calls each of the listeners registered\n * for the event.\n * @param {string | symbol} type\n * @param {...any} [args]\n * @returns {boolean}\n */\nEventEmitter.prototype.emit = function emit(type\x2C ...args) {\n  let doError = (type === 'error');\n\n  const events = this._events;\n  if (events !== undefined) {\n    if (doError && events[kErrorMonitor] !== undefined)\n      this.emit(kErrorMonitor\x2C ...args);\n    doError = (doError && events.error === undefined);\n  } else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    let er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      try {\n        const capture = {};\n        ErrorCaptureStackTrace(capture\x2C EventEmitter.prototype.emit);\n        ObjectDefineProperty(er\x2C kEnhanceStackBeforeInspector\x2C {\n          __proto__: null\x2C\n          value: FunctionPrototypeBind(enhanceStackTrace\x2C this\x2C er\x2C capture)\x2C\n          configurable: true\x2C\n        });\n      } catch {\n        // Continue regardless of error.\n      }\n\n      // Note: The comments on the `throw` lines are intentional\x2C they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n\n    let stringifiedEr;\n    try {\n      stringifiedEr = inspect(er);\n    } catch {\n      stringifiedEr = er;\n    }\n\n    // At least give some kind of context to the user\n    const err = new ERR_UNHANDLED_ERROR(stringifiedEr);\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  const handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    const result = handler.apply(this\x2C args);\n\n    // We check if result is undefined first because that\n    // is the most common case so we do not pay any perf\n    // penalty\n    if (result !== undefined && result !== null) {\n      addCatch(this\x2C result\x2C type\x2C args);\n    }\n  } else {\n    const len = handler.length;\n    const listeners = arrayClone(handler);\n    for (let i = 0; i < len; ++i) {\n      const result = listeners[i].apply(this\x2C args);\n\n      // We check if result is undefined first because that\n      // is the most common case so we do not pay any perf\n      // penalty.\n      // This code is duplicated because extracting it away\n      // would make it non-inlineable.\n      if (result !== undefined && result !== null) {\n        addCatch(this\x2C result\x2C type\x2C args);\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction _addListener(target\x2C type\x2C listener\x2C prepend) {\n  let m;\n  let events;\n  let existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = ObjectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === "newListener"! Before\n    // adding it to the listeners\x2C first emit "newListener".\n    if (events.newListener !== undefined) {\n      target.emit('newListener'\x2C type\x2C\n                  listener.listener ?? listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element\x2C need to change to array.\n      existing = events[type] =\n        prepend ? [listener\x2C existing] : [existing\x2C listener];\n      // If we've already got an array\x2C just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      const w = genericNodeError(\n        `Possible EventEmitter memory leak detected. ${existing.length} ${String(type)} listeners ` +\n        `added to ${inspect(target\x2C { depth: -1 })}. Use emitter.setMaxListeners() to increase limit`\x2C\n        { name: 'MaxListenersExceededWarning'\x2C emitter: target\x2C type: type\x2C count: existing.length });\n      process.emitWarning(w);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Adds a listener to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.addListener = function addListener(type\x2C listener) {\n  return _addListener(this\x2C type\x2C listener\x2C false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n/**\n * Adds the `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependListener =\n    function prependListener(type\x2C listener) {\n      return _addListener(this\x2C type\x2C listener\x2C true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type\x2C this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target\x2C arguments);\n  }\n}\n\nfunction _onceWrap(target\x2C type\x2C listener) {\n  const state = { fired: false\x2C wrapFn: undefined\x2C target\x2C type\x2C listener };\n  const wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\n/**\n * Adds a one-time `listener` function to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.once = function once(type\x2C listener) {\n  checkListener(listener);\n\n  this.on(type\x2C _onceWrap(this\x2C type\x2C listener));\n  return this;\n};\n\n/**\n * Adds a one-time `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type\x2C listener) {\n      checkListener(listener);\n\n      this.prependListener(type\x2C _onceWrap(this\x2C type\x2C listener));\n      return this;\n    };\n\n/**\n * Removes the specified `listener` from the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeListener =\n    function removeListener(type\x2C listener) {\n      checkListener(listener);\n\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      const list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = ObjectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener'\x2C type\x2C list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        let position = -1;\n\n        for (let i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          if (spliceOne === undefined)\n            spliceOne = require('internal/util').spliceOne;\n          spliceOne(list\x2C position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener'\x2C type\x2C listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\n/**\n * Removes all listeners from the event emitter. (Only\n * removes listeners for a specific event name if specified\n * as `type`).\n * @param {string | symbol} [type]\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      // Not listening for removeListener\x2C no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = ObjectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = ObjectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // Emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        for (const key of ReflectOwnKeys(events)) {\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = ObjectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      const listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type\x2C listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type\x2C listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target\x2C type\x2C unwrap) {\n  const events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  const evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener);\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this\x2C type\x2C true);\n};\n\n/**\n * Returns a copy of the array of listeners and wrappers for\n * the event name specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this\x2C type\x2C false);\n};\n\n/**\n * Returns the number of listeners listening to the event name\n * specified as `type`.\n * @deprecated since v3.2.0\n * @param {EventEmitter} emitter\n * @param {string | symbol} type\n * @returns {number}\n */\nEventEmitter.listenerCount = function(emitter\x2C type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  }\n  return FunctionPrototypeCall(listenerCount\x2C emitter\x2C type);\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\n/**\n * Returns the number of listeners listening to event name\n * specified as `type`.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {number}\n */\nfunction listenerCount(type\x2C listener) {\n  const events = this._events;\n\n  if (events !== undefined) {\n    const evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      if (listener != null) {\n        return listener === evlistener ? 1 : 0;\n      }\n\n      return 1;\n    } else if (evlistener !== undefined) {\n      if (listener != null) {\n        let matching = 0;\n\n        for (let i = 0\x2C l = evlistener.length; i < l; i++) {\n          if (evlistener[i] === listener || evlistener[i].listener === listener) {\n            matching++;\n          }\n        }\n\n        return matching;\n      }\n\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Returns an array listing the events for which\n * the emitter has registered listeners.\n * @returns {any[]}\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr) {\n  // At least since V8 8.3\x2C this implementation is faster than the previous\n  // which always used a simple for-loop\n  switch (arr.length) {\n    case 2: return [arr[0]\x2C arr[1]];\n    case 3: return [arr[0]\x2C arr[1]\x2C arr[2]];\n    case 4: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]];\n    case 5: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]];\n    case 6: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]\x2C arr[5]];\n  }\n  return ArrayPrototypeSlice(arr);\n}\n\nfunction unwrapListeners(arr) {\n  const ret = arrayClone(arr);\n  for (let i = 0; i < ret.length; ++i) {\n    const orig = ret[i].listener;\n    if (typeof orig === 'function')\n      ret[i] = orig;\n  }\n  return ret;\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {EventEmitter | EventTarget} emitterOrTarget\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nfunction getEventListeners(emitterOrTarget\x2C type) {\n  // First check if EventEmitter\n  if (typeof emitterOrTarget.listeners === 'function') {\n    return emitterOrTarget.listeners(type);\n  }\n  // Require event target lazily to avoid always loading it\n  const { isEventTarget\x2C kEvents } = require('internal/event_target');\n  if (isEventTarget(emitterOrTarget)) {\n    const root = emitterOrTarget[kEvents].get(type);\n    const listeners = [];\n    let handler = root?.next;\n    while (handler?.listener !== undefined) {\n      const listener = handler.listener?.deref ?\n        handler.listener.deref() : handler.listener;\n      listeners.push(listener);\n      handler = handler.next;\n    }\n    return listeners;\n  }\n  throw new ERR_INVALID_ARG_TYPE('emitter'\x2C\n                                 ['EventEmitter'\x2C 'EventTarget']\x2C\n                                 emitterOrTarget);\n}\n\n/**\n * Returns the max listeners set.\n * @param {EventEmitter | EventTarget} emitterOrTarget\n * @returns {number}\n */\nfunction getMaxListeners(emitterOrTarget) {\n  if (typeof emitterOrTarget?.getMaxListeners === 'function') {\n    return _getMaxListeners(emitterOrTarget);\n  } else if (emitterOrTarget?.[kMaxEventTargetListeners]) {\n    return emitterOrTarget[kMaxEventTargetListeners];\n  }\n\n  throw new ERR_INVALID_ARG_TYPE('emitter'\x2C\n                                 ['EventEmitter'\x2C 'EventTarget']\x2C\n                                 emitterOrTarget);\n}\n\n/**\n * Creates a `Promise` that is fulfilled when the emitter\n * emits the given event.\n * @param {EventEmitter} emitter\n * @param {string} name\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {Promise}\n */\nasync function once(emitter\x2C name\x2C options = kEmptyObject) {\n  const signal = options?.signal;\n  validateAbortSignal(signal\x2C 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\n  return new Promise((resolve\x2C reject) => {\n    const errorListener = (err) => {\n      emitter.removeListener(name\x2C resolver);\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\n      }\n      reject(err);\n    };\n    const resolver = (...args) => {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error'\x2C errorListener);\n      }\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\n      }\n      resolve(args);\n    };\n    eventTargetAgnosticAddListener(emitter\x2C name\x2C resolver\x2C { once: true });\n    if (name !== 'error' && typeof emitter.once === 'function') {\n      // EventTarget does not have `error` event semantics like Node\n      // EventEmitters\x2C we listen to `error` events only on EventEmitters.\n      emitter.once('error'\x2C errorListener);\n    }\n    function abortListener() {\n      eventTargetAgnosticRemoveListener(emitter\x2C name\x2C resolver);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorListener);\n      reject(new AbortError(undefined\x2C { cause: signal?.reason }));\n    }\n    if (signal != null) {\n      eventTargetAgnosticAddListener(\n        signal\x2C 'abort'\x2C abortListener\x2C { once: true });\n    }\n  });\n}\n\nconst AsyncIteratorPrototype = ObjectGetPrototypeOf(\n  ObjectGetPrototypeOf(async function* () {}).prototype);\n\nfunction createIterResult(value\x2C done) {\n  return { value\x2C done };\n}\n\nfunction eventTargetAgnosticRemoveListener(emitter\x2C name\x2C listener\x2C flags) {\n  if (typeof emitter.removeListener === 'function') {\n    emitter.removeListener(name\x2C listener);\n  } else if (typeof emitter.removeEventListener === 'function') {\n    emitter.removeEventListener(name\x2C listener\x2C flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter\x2C name\x2C listener\x2C flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags?.once) {\n      emitter.once(name\x2C listener);\n    } else {\n      emitter.on(name\x2C listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    emitter.addEventListener(name\x2C listener\x2C flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\n  }\n}\n\n/**\n * Returns an `AsyncIterator` that iterates `event` events.\n * @param {EventEmitter} emitter\n * @param {string | symbol} event\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {AsyncIterator}\n */\nfunction on(emitter\x2C event\x2C options = kEmptyObject) {\n  const signal = options?.signal;\n  validateAbortSignal(signal\x2C 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\n\n  const unconsumedEvents = [];\n  const unconsumedPromises = [];\n  let error = null;\n  let finished = false;\n\n  const iterator = ObjectSetPrototypeOf({\n    next() {\n      // First\x2C we consume all unread events\n      const value = unconsumedEvents.shift();\n      if (value) {\n        return PromiseResolve(createIterResult(value\x2C false));\n      }\n\n      // Then we error\x2C if an error happened\n      // This happens one time if at all\x2C because after 'error'\n      // we stop listening\n      if (error) {\n        const p = PromiseReject(error);\n        // Only the first element errors\n        error = null;\n        return p;\n      }\n\n      // If the iterator is finished\x2C resolve to done\n      if (finished) {\n        return PromiseResolve(createIterResult(undefined\x2C true));\n      }\n\n      // Wait until an event happens\n      return new Promise(function(resolve\x2C reject) {\n        unconsumedPromises.push({ resolve\x2C reject });\n      });\n    }\x2C\n\n    return() {\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\n\n      if (signal) {\n        eventTargetAgnosticRemoveListener(\n          signal\x2C\n          'abort'\x2C\n          abortListener\x2C\n          { once: true });\n      }\n\n      finished = true;\n\n      for (const promise of unconsumedPromises) {\n        promise.resolve(createIterResult(undefined\x2C true));\n      }\n\n      return PromiseResolve(createIterResult(undefined\x2C true));\n    }\x2C\n\n    throw(err) {\n      if (!err || !(err instanceof Error)) {\n        throw new ERR_INVALID_ARG_TYPE('EventEmitter.AsyncIterator'\x2C\n                                       'Error'\x2C err);\n      }\n      error = err;\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\n    }\x2C\n\n    [SymbolAsyncIterator]() {\n      return this;\n    }\x2C\n  }\x2C AsyncIteratorPrototype);\n\n  eventTargetAgnosticAddListener(emitter\x2C event\x2C eventHandler);\n  if (event !== 'error' && typeof emitter.on === 'function') {\n    emitter.on('error'\x2C errorHandler);\n  }\n\n  if (signal) {\n    eventTargetAgnosticAddListener(\n      signal\x2C\n      'abort'\x2C\n      abortListener\x2C\n      { once: true });\n  }\n\n  function abortListener() {\n    errorHandler(new AbortError(undefined\x2C { cause: signal?.reason }));\n  }\n\n  function eventHandler(...args) {\n    const promise = ArrayPrototypeShift(unconsumedPromises);\n    if (promise) {\n      promise.resolve(createIterResult(args\x2C false));\n    } else {\n      unconsumedEvents.push(args);\n    }\n  }\n\n  function errorHandler(err) {\n    finished = true;\n\n    const toError = ArrayPrototypeShift(unconsumedPromises);\n\n    if (toError) {\n      toError.reject(err);\n    } else {\n      // The next time we call next()\n      error = err;\n    }\n\n    iterator.return();\n  }\n  return iterator;\n}\n
code-source-info,0x2b3d46cd62d8,29,12089,12213,C0O12109C6O12142C9O12162C13O12182C14O12197C18O12211,,
code-creation,LazyCompile,10,78584,0x2b3d46cd8ab0,322,arrayClone node:events:883:20,0x1012a3972fa0,~
code-source-info,0x2b3d46cd8ab0,29,25140,25594,C0O25279C42O25301C50O25312C62O25320C71O25325C72O25338C80O25349C92O25357C104O25365C113O25370C114O25383C122O25394C134O25402C146O25410C158O25418C167O25423C168O25436C176O25447C188O25455C200O25463C212O25471C224O25479C233O25484C234O25497C242O25508C254O25516C266O25524C278O25532C290O25540C302O25548C311O25553C312O25560C317O25567C321O25592,,
code-creation,LazyCompile,10,78625,0x2b3d46cd8d88,22, node:internal/child_process:705:36,0x2b3d46cd1108,~
code-source-info,0x2b3d46cd8d88,457,19307,19704,C0O19317C5O19325C15O19325C21O19703,,
tick,0x195a4df24,78667,0,0x0,3,0x0,0x1012a3972686,0x1012a3972abe,0x2b3d46cd1733,0x2b3d46cd0c30,0x30e7677207c6,0x202f0287b58b,0x202f02879dd8,0x202f028761e9
code-creation,LazyCompile,10,78667,0x2b3d46cd9028,372,nextTick node:internal/process/task_queues:103:18,0x35d29719b940,~
script-source,39,node:internal/process/task_queues,'use strict';\n\nconst {\n  Array\x2C\n  FunctionPrototypeBind\x2C\n} = primordials;\n\nconst {\n  // For easy access to the nextTick state in the C++ land\x2C\n  // and to avoid unnecessary calls into JS land.\n  tickInfo\x2C\n  // Used to run V8's micro task queue.\n  runMicrotasks\x2C\n  setTickCallback\x2C\n  enqueueMicrotask\x2C\n} = internalBinding('task_queue');\n\nconst {\n  setHasRejectionToWarn\x2C\n  hasRejectionToWarn\x2C\n  listenForRejections\x2C\n  processPromiseRejections\x2C\n} = require('internal/process/promises');\n\nconst {\n  getDefaultTriggerAsyncId\x2C\n  newAsyncId\x2C\n  initHooksExist\x2C\n  destroyHooksExist\x2C\n  emitInit\x2C\n  emitBefore\x2C\n  emitAfter\x2C\n  emitDestroy\x2C\n  symbols: { async_id_symbol\x2C trigger_async_id_symbol }\x2C\n} = require('internal/async_hooks');\nconst FixedQueue = require('internal/fixed_queue');\n\nconst {\n  validateFunction\x2C\n} = require('internal/validators');\n\nconst { AsyncResource } = require('async_hooks');\n\n// *Must* match Environment::TickInfo::Fields in src/env.h.\nconst kHasTickScheduled = 0;\n\nfunction hasTickScheduled() {\n  return tickInfo[kHasTickScheduled] === 1;\n}\n\nfunction setHasTickScheduled(value) {\n  tickInfo[kHasTickScheduled] = value ? 1 : 0;\n}\n\nconst queue = new FixedQueue();\n\n// Should be in sync with RunNextTicksNative in node_task_queue.cc\nfunction runNextTicks() {\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    runMicrotasks();\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    return;\n\n  processTicksAndRejections();\n}\n\nfunction processTicksAndRejections() {\n  let tock;\n  do {\n    while ((tock = queue.shift()) !== null) {\n      const asyncId = tock[async_id_symbol];\n      emitBefore(asyncId\x2C tock[trigger_async_id_symbol]\x2C tock);\n\n      try {\n        const callback = tock.callback;\n        if (tock.args === undefined) {\n          callback();\n        } else {\n          const args = tock.args;\n          switch (args.length) {\n            case 1: callback(args[0]); break;\n            case 2: callback(args[0]\x2C args[1]); break;\n            case 3: callback(args[0]\x2C args[1]\x2C args[2]); break;\n            case 4: callback(args[0]\x2C args[1]\x2C args[2]\x2C args[3]); break;\n            default: callback(...args);\n          }\n        }\n      } finally {\n        if (destroyHooksExist())\n          emitDestroy(asyncId);\n      }\n\n      emitAfter(asyncId);\n    }\n    runMicrotasks();\n  } while (!queue.isEmpty() || processPromiseRejections());\n  setHasTickScheduled(false);\n  setHasRejectionToWarn(false);\n}\n\n// `nextTick()` will not enqueue any callback when the process is about to\n// exit since the callback would not have a chance to be executed.\nfunction nextTick(callback) {\n  validateFunction(callback\x2C 'callback');\n\n  if (process._exiting)\n    return;\n\n  let args;\n  switch (arguments.length) {\n    case 1: break;\n    case 2: args = [arguments[1]]; break;\n    case 3: args = [arguments[1]\x2C arguments[2]]; break;\n    case 4: args = [arguments[1]\x2C arguments[2]\x2C arguments[3]]; break;\n    default:\n      args = new Array(arguments.length - 1);\n      for (let i = 1; i < arguments.length; i++)\n        args[i - 1] = arguments[i];\n  }\n\n  if (queue.isEmpty())\n    setHasTickScheduled(true);\n  const asyncId = newAsyncId();\n  const triggerAsyncId = getDefaultTriggerAsyncId();\n  const tickObject = {\n    [async_id_symbol]: asyncId\x2C\n    [trigger_async_id_symbol]: triggerAsyncId\x2C\n    callback\x2C\n    args\x2C\n  };\n  if (initHooksExist())\n    emitInit(asyncId\x2C 'TickObject'\x2C triggerAsyncId\x2C tickObject);\n  queue.push(tickObject);\n}\n\nfunction runMicrotask() {\n  this.runInAsyncScope(() => {\n    const callback = this.callback;\n    try {\n      callback();\n    } finally {\n      this.emitDestroy();\n    }\n  });\n}\n\nconst defaultMicrotaskResourceOpts = { requireManualDestroy: true };\n\nfunction queueMicrotask(callback) {\n  validateFunction(callback\x2C 'callback');\n\n  const asyncResource = new AsyncResource(\n    'Microtask'\x2C\n    defaultMicrotaskResourceOpts\x2C\n  );\n  asyncResource.callback = callback;\n\n  enqueueMicrotask(FunctionPrototypeBind(runMicrotask\x2C asyncResource));\n}\n\nmodule.exports = {\n  setupTaskQueue() {\n    // Sets the per-isolate promise rejection callback\n    listenForRejections();\n    // Sets the callback to be run in every tick.\n    setTickCallback(processTicksAndRejections);\n    return {\n      nextTick\x2C\n      runNextTicks\x2C\n    };\n  }\x2C\n  queueMicrotask\x2C\n};\n
code-source-info,0x2b3d46cd9028,39,2585,3442,C0O2585C2O2600C10O2600C15O2643C18O2655C24O2669C25O2676C26O2684C28O2710C63O2732C65O2751C74O2768C86O2774C88O2793C97O2810C109O2824C121O2830C123O2849C132O2866C144O2880C156O2894C168O2900C170O2926C175O2953C179O2960C185O2933C191O2985C194O3002C198O2990C203O3023C205O3030C211O3046C214O3035C218O3011C223O2972C226O3058C231O3068C236O3068C242O3083C247O3083C251O3128C256O3128C260O3167C265O3167C269O3216C276O3223C282O3241C289O3255C295O3281C305O3301C315O3315C323O3328C328O3332C333O3354C350O3354C355O3417C360O3423C365O3423C371O3441,,
code-creation,LazyCompile,10,79042,0x2b3d46cd9898,16,get node:internal/bootstrap/node:92:8,0x41ccf05d0a0,~
code-source-info,0x2b3d46cd9898,16,3656,3715,C0O3667C6O3699C12O3703C15O3709,,
code-creation,LazyCompile,10,79084,0x2b3d46cd9988,15,isEmpty node:internal/fixed_queue:95:10,0x35d2971a0858,~
script-source,41,node:internal/fixed_queue,'use strict';\n\nconst {\n  Array\x2C\n} = primordials;\n\n// Currently optimal queue size\x2C tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or\x2C if there is only one circular buffer\x2C it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one\x2C removing means\n// moving `bottom` forward by one. After reaching the end\x2C the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n\n  isFull() {\n    return ((this.top + 1) & kMask) === this.bottom;\n  }\n\n  push(data) {\n    this.list[this.top] = data;\n    this.top = (this.top + 1) & kMask;\n  }\n\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined)\n      return null;\n    this.list[this.bottom] = undefined;\n    this.bottom = (this.bottom + 1) & kMask;\n    return nextItem;\n  }\n}\n\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n\n  push(data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue\x2C sets the old queue's `.next` to it\x2C\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n  }\n\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue\x2C it forms the new tail.\n      this.tail = tail.next;\n      tail.next = null;\n    }\n    return next;\n  }\n};\n
code-source-info,0x2b3d46cd9988,41,3637,3677,C0O3658C5O3663C10O3663C14O3673,,
code-creation,LazyCompile,10,79250,0x2b3d46cd9e40,13,isEmpty node:internal/fixed_queue:67:10,0x35d2971a05a8,~
code-source-info,0x2b3d46cd9e40,41,3084,3129,C0O3105C5O3118C9O3109C12O3125,,
code-creation,LazyCompile,10,79292,0x2b3d46cd9f30,25,setHasTickScheduled node:internal/process/task_queues:51:29,0x35d29719b850,~
code-source-info,0x2b3d46cd9f30,39,1087,1145,C0O1099C7O1108C12O1129C19O1127C24O1144,,
code-creation,LazyCompile,10,79334,0x2b3d46cda030,23,newAsyncId node:internal/async_hooks:416:20,0x2da83affcb58,~
script-source,19,node:internal/async_hooks,'use strict';\n\nconst {\n  ArrayPrototypeSlice\x2C\n  ErrorCaptureStackTrace\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectDefineProperty\x2C\n  Symbol\x2C\n} = primordials;\n\nconst promiseHooks = require('internal/promise_hooks');\n\nconst async_wrap = internalBinding('async_wrap');\nconst { setCallbackTrampoline } = async_wrap;\n/* async_hook_fields is a Uint32Array wrapping the uint32_t array of\n * Environment::AsyncHooks::fields_[]. Each index tracks the number of active\n * hooks for each type.\n *\n * async_id_fields is a Float64Array wrapping the double array of\n * Environment::AsyncHooks::async_id_fields_[]. Each index contains the ids for\n * the various asynchronous states of the application. These are:\n *  kExecutionAsyncId: The async_id assigned to the resource responsible for the\n *    current execution stack.\n *  kTriggerAsyncId: The async_id of the resource that caused (or 'triggered')\n *    the resource corresponding to the current execution stack.\n *  kAsyncIdCounter: Incremental counter tracking the next assigned async_id.\n *  kDefaultTriggerAsyncId: Written immediately before a resource's constructor\n *    that sets the value of the init()'s triggerAsyncId. The precedence order\n *    of retrieving the triggerAsyncId value is:\n *    1. the value passed directly to the constructor\n *    2. value set in kDefaultTriggerAsyncId\n *    3. executionAsyncId of the current resource.\n *\n * async_ids_stack is a Float64Array that contains part of the async ID\n * stack. Each pushAsyncContext() call adds two doubles to it\x2C and each\n * popAsyncContext() call removes two doubles from it.\n * It has a fixed size\x2C so if that is exceeded\x2C calls to the native\n * side are used instead in pushAsyncContext() and popAsyncContext().\n */\nconst {\n  async_hook_fields\x2C\n  async_id_fields\x2C\n  execution_async_resources\x2C\n} = async_wrap;\n// Store the pair executionAsyncId and triggerAsyncId in a AliasedFloat64Array\n// in Environment::AsyncHooks::async_ids_stack_ which tracks the resource\n// responsible for the current execution stack. This is unwound as each resource\n// exits. In the case of a fatal exception this stack is emptied after calling\n// each hook's after() callback.\nconst {\n  pushAsyncContext: pushAsyncContext_\x2C\n  popAsyncContext: popAsyncContext_\x2C\n  executionAsyncResource: executionAsyncResource_\x2C\n  clearAsyncIdStack\x2C\n} = async_wrap;\n// Properties in active_hooks are used to keep track of the set of hooks being\n// executed in case another hook is enabled/disabled. The new set of hooks is\n// then restored once the active set of hooks is finished executing.\nconst active_hooks = {\n  // Array of all AsyncHooks that will be iterated whenever an async event\n  // fires. Using var instead of (preferably const) in order to assign\n  // active_hooks.tmp_array if a hook is enabled/disabled during hook\n  // execution.\n  array: []\x2C\n  // Use a counter to track nested calls of async hook callbacks and make sure\n  // the active_hooks.array isn't altered mid execution.\n  call_depth: 0\x2C\n  // Use to temporarily store and updated active_hooks.array if the user\n  // enables or disables a hook while hooks are being processed. If a hook is\n  // enabled() or disabled() during hook execution then the current set of\n  // active hooks is duplicated and set equal to active_hooks.tmp_array. Any\n  // subsequent changes are on the duplicated array. When all hooks have\n  // completed executing active_hooks.tmp_array is assigned to\n  // active_hooks.array.\n  tmp_array: null\x2C\n  // Keep track of the field counts held in active_hooks.tmp_array. Because the\n  // async_hook_fields can't be reassigned\x2C store each uint32 in an array that\n  // is written back to async_hook_fields when active_hooks.array is restored.\n  tmp_fields: null\x2C\n};\n\nconst { registerDestroyHook } = async_wrap;\nconst { enqueueMicrotask } = internalBinding('task_queue');\nconst { resource_symbol\x2C owner_symbol } = internalBinding('symbols');\n\n// Each constant tracks how many callbacks there are for any given step of\n// async execution. These are tracked so if the user didn't include callbacks\n// for a given step\x2C that step can bail out early.\nconst {\n  kInit\x2C kBefore\x2C kAfter\x2C kDestroy\x2C kTotals\x2C kPromiseResolve\x2C\n  kCheck\x2C kExecutionAsyncId\x2C kAsyncIdCounter\x2C kTriggerAsyncId\x2C\n  kDefaultTriggerAsyncId\x2C kStackLength\x2C kUsesExecutionAsyncResource\x2C\n} = async_wrap.constants;\n\nconst { async_id_symbol\x2C\n        trigger_async_id_symbol } = internalBinding('symbols');\n\n// Lazy load of internal/util/inspect;\nlet inspect;\n\n// Used in AsyncHook and AsyncResource.\nconst init_symbol = Symbol('init');\nconst before_symbol = Symbol('before');\nconst after_symbol = Symbol('after');\nconst destroy_symbol = Symbol('destroy');\nconst promise_resolve_symbol = Symbol('promiseResolve');\nconst emitBeforeNative = emitHookFactory(before_symbol\x2C 'emitBeforeNative');\nconst emitAfterNative = emitHookFactory(after_symbol\x2C 'emitAfterNative');\nconst emitDestroyNative = emitHookFactory(destroy_symbol\x2C 'emitDestroyNative');\nconst emitPromiseResolveNative =\n    emitHookFactory(promise_resolve_symbol\x2C 'emitPromiseResolveNative');\n\nlet domain_cb;\nfunction useDomainTrampoline(fn) {\n  domain_cb = fn;\n}\n\nfunction callbackTrampoline(asyncId\x2C resource\x2C cb\x2C ...args) {\n  const index = async_hook_fields[kStackLength] - 1;\n  execution_async_resources[index] = resource;\n\n  if (asyncId !== 0 && hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n\n  let result;\n  if (asyncId === 0 && typeof domain_cb === 'function') {\n    args.unshift(cb);\n    result = domain_cb.apply(this\x2C args);\n  } else {\n    result = cb.apply(this\x2C args);\n  }\n\n  if (asyncId !== 0 && hasHooks(kAfter))\n    emitAfterNative(asyncId);\n\n  execution_async_resources.pop();\n  return result;\n}\n\nconst topLevelResource = {};\n\nfunction executionAsyncResource() {\n  // Indicate to the native layer that this function is likely to be used\x2C\n  // in which case it will inform JS about the current async resource via\n  // the trampoline above.\n  async_hook_fields[kUsesExecutionAsyncResource] = 1;\n\n  const index = async_hook_fields[kStackLength] - 1;\n  if (index === -1) return topLevelResource;\n  const resource = execution_async_resources[index] ||\n    executionAsyncResource_(index);\n  return lookupPublicResource(resource);\n}\n\nfunction inspectExceptionValue(e) {\n  inspect ??= require('internal/util/inspect').inspect;\n  return { message: inspect(e) };\n}\n\n// Used to fatally abort the process if a callback throws.\nfunction fatalError(e) {\n  if (typeof e?.stack === 'string') {\n    process._rawDebug(e.stack);\n  } else {\n    const o = inspectExceptionValue(e);\n    ErrorCaptureStackTrace(o\x2C fatalError);\n    process._rawDebug(o.stack);\n  }\n\n  const { getOptionValue } = require('internal/options');\n  if (getOptionValue('--abort-on-uncaught-exception')) {\n    process.abort();\n  }\n  process.exit(1);\n}\n\nfunction lookupPublicResource(resource) {\n  if (typeof resource !== 'object' || resource === null) return resource;\n  // TODO(addaleax): Merge this with owner_symbol and use it across all\n  // AsyncWrap instances.\n  const publicResource = resource[resource_symbol];\n  if (publicResource !== undefined)\n    return publicResource;\n  return resource;\n}\n\n// Emit From Native //\n\n// Used by C++ to call all init() callbacks. Because some state can be setup\n// from C++ there's no need to perform all the same operations as in\n// emitInitScript.\nfunction emitInitNative(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n  active_hooks.call_depth += 1;\n  resource = lookupPublicResource(resource);\n  // Use a single try/catch for all hooks to avoid setting up one per iteration.\n  try {\n    // Using var here instead of let because "for (var ...)" is faster than let.\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\n    // eslint-disable-next-line no-var\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][init_symbol] === 'function') {\n        active_hooks.array[i][init_symbol](\n          asyncId\x2C type\x2C triggerAsyncId\x2C\n          resource\x2C\n        );\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n\n  // Hooks can only be restored if there have been no recursive hook calls.\n  // Also the active hooks do not need to be restored if enable()/disable()\n  // weren't called during hook execution\x2C in which case active_hooks.tmp_array\n  // will be null.\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\n\n// Called from native. The asyncId stack handling is taken care of there\n// before this is called.\nfunction emitHook(symbol\x2C asyncId) {\n  active_hooks.call_depth += 1;\n  // Use a single try/catch for all hook to avoid setting up one per\n  // iteration.\n  try {\n    // Using var here instead of let because "for (var ...)" is faster than let.\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\n    // eslint-disable-next-line no-var\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][symbol] === 'function') {\n        active_hooks.array[i][symbol](asyncId);\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n\n  // Hooks can only be restored if there have been no recursive hook calls.\n  // Also the active hooks do not need to be restored if enable()/disable()\n  // weren't called during hook execution\x2C in which case\n  // active_hooks.tmp_array will be null.\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\n\nfunction emitHookFactory(symbol\x2C name) {\n  const fn = emitHook.bind(undefined\x2C symbol);\n\n  // Set the name property of the function as it looks good in the stack trace.\n  ObjectDefineProperty(fn\x2C 'name'\x2C {\n    __proto__: null\x2C\n    value: name\x2C\n  });\n  return fn;\n}\n\n// Manage Active Hooks //\n\nfunction getHookArrays() {\n  if (active_hooks.call_depth === 0)\n    return [active_hooks.array\x2C async_hook_fields];\n  // If this hook is being enabled while in the middle of processing the array\n  // of currently active hooks then duplicate the current set of active hooks\n  // and store this there. This shouldn't fire until the next time hooks are\n  // processed.\n  if (active_hooks.tmp_array === null)\n    storeActiveHooks();\n  return [active_hooks.tmp_array\x2C active_hooks.tmp_fields];\n}\n\n\nfunction storeActiveHooks() {\n  active_hooks.tmp_array = ArrayPrototypeSlice(active_hooks.array);\n  // Don't want to make the assumption that kInit to kDestroy are indexes 0 to\n  // 4. So do this the long way.\n  active_hooks.tmp_fields = [];\n  copyHooks(active_hooks.tmp_fields\x2C async_hook_fields);\n}\n\nfunction copyHooks(destination\x2C source) {\n  destination[kInit] = source[kInit];\n  destination[kBefore] = source[kBefore];\n  destination[kAfter] = source[kAfter];\n  destination[kDestroy] = source[kDestroy];\n  destination[kPromiseResolve] = source[kPromiseResolve];\n}\n\n\n// Then restore the correct hooks array in case any hooks were added/removed\n// during hook callback execution.\nfunction restoreActiveHooks() {\n  active_hooks.array = active_hooks.tmp_array;\n  copyHooks(async_hook_fields\x2C active_hooks.tmp_fields);\n\n  active_hooks.tmp_array = null;\n  active_hooks.tmp_fields = null;\n}\n\nfunction trackPromise(promise\x2C parent) {\n  if (promise[async_id_symbol]) {\n    return;\n  }\n\n  // Get trigger id from parent async id before making the async id of the\n  // child so if a new one must be made it will be lower than the child.\n  const triggerAsyncId = parent ? getOrSetAsyncId(parent) :\n    getDefaultTriggerAsyncId();\n\n  promise[async_id_symbol] = newAsyncId();\n  promise[trigger_async_id_symbol] = triggerAsyncId;\n}\n\nfunction promiseInitHook(promise\x2C parent) {\n  trackPromise(promise\x2C parent);\n  const asyncId = promise[async_id_symbol];\n  const triggerAsyncId = promise[trigger_async_id_symbol];\n  emitInitScript(asyncId\x2C 'PROMISE'\x2C triggerAsyncId\x2C promise);\n}\n\nfunction promiseInitHookWithDestroyTracking(promise\x2C parent) {\n  promiseInitHook(promise\x2C parent);\n  destroyTracking(promise\x2C parent);\n}\n\nfunction destroyTracking(promise\x2C parent) {\n  trackPromise(promise\x2C parent);\n  const asyncId = promise[async_id_symbol];\n  registerDestroyHook(promise\x2C asyncId);\n}\n\nfunction promiseBeforeHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  const triggerId = promise[trigger_async_id_symbol];\n  emitBeforeScript(asyncId\x2C triggerId\x2C promise);\n}\n\nfunction promiseAfterHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  if (hasHooks(kAfter)) {\n    emitAfterNative(asyncId);\n  }\n  if (asyncId === executionAsyncId()) {\n    // This condition might not be true if async_hooks was enabled during\n    // the promise callback execution.\n    // Popping it off the stack can be skipped in that case\x2C because it is\n    // known that it would correspond to exactly one call with\n    // PromiseHookType::kBefore that was not witnessed by the PromiseHook.\n    popAsyncContext(asyncId);\n  }\n}\n\nfunction promiseResolveHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  emitPromiseResolveNative(asyncId);\n}\n\nlet wantPromiseHook = false;\nfunction enableHooks() {\n  async_hook_fields[kCheck] += 1;\n\n  setCallbackTrampoline(callbackTrampoline);\n}\n\nlet stopPromiseHook;\nfunction updatePromiseHookMode() {\n  wantPromiseHook = true;\n  let initHook;\n  if (initHooksExist()) {\n    initHook = destroyHooksExist() ? promiseInitHookWithDestroyTracking :\n      promiseInitHook;\n  } else if (destroyHooksExist()) {\n    initHook = destroyTracking;\n  }\n  if (stopPromiseHook) stopPromiseHook();\n  stopPromiseHook = promiseHooks.createHook({\n    init: initHook\x2C\n    before: promiseBeforeHook\x2C\n    after: promiseAfterHook\x2C\n    settled: promiseResolveHooksExist() ? promiseResolveHook : undefined\x2C\n  });\n}\n\nfunction disableHooks() {\n  async_hook_fields[kCheck] -= 1;\n\n  wantPromiseHook = false;\n\n  setCallbackTrampoline();\n\n  // Delay the call to `disablePromiseHook()` because we might currently be\n  // between the `before` and `after` calls of a Promise.\n  enqueueMicrotask(disablePromiseHookIfNecessary);\n}\n\nfunction disablePromiseHookIfNecessary() {\n  if (!wantPromiseHook && stopPromiseHook) {\n    stopPromiseHook();\n  }\n}\n\n// Internal Embedder API //\n\n// Increment the internal id counter and return the value. Important that the\n// counter increment first. Since it's done the same way in\n// Environment::new_async_uid()\nfunction newAsyncId() {\n  return ++async_id_fields[kAsyncIdCounter];\n}\n\nfunction getOrSetAsyncId(object) {\n  if (ObjectPrototypeHasOwnProperty(object\x2C async_id_symbol)) {\n    return object[async_id_symbol];\n  }\n\n  return object[async_id_symbol] = newAsyncId();\n}\n\n\n// Return the triggerAsyncId meant for the constructor calling it. It's up to\n// the user to safeguard this call and make sure it's zero'd out when the\n// constructor is complete.\nfunction getDefaultTriggerAsyncId() {\n  const defaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  // If defaultTriggerAsyncId isn't set\x2C use the executionAsyncId\n  if (defaultTriggerAsyncId < 0)\n    return async_id_fields[kExecutionAsyncId];\n  return defaultTriggerAsyncId;\n}\n\n\nfunction clearDefaultTriggerAsyncId() {\n  async_id_fields[kDefaultTriggerAsyncId] = -1;\n}\n\n/**\n * Sets a default top level trigger ID to be used\n * @template {Array<unknown>} T\n * @template {unknown} R\n * @param {number} triggerAsyncId\n * @param { (...T: args) => R } block\n * @param  {T} args\n * @returns {R}\n */\nfunction defaultTriggerAsyncIdScope(triggerAsyncId\x2C block\x2C ...args) {\n  if (triggerAsyncId === undefined)\n    return block.apply(null\x2C args);\n  // CHECK(NumberIsSafeInteger(triggerAsyncId))\n  // CHECK(triggerAsyncId > 0)\n  const oldDefaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  async_id_fields[kDefaultTriggerAsyncId] = triggerAsyncId;\n\n  try {\n    return block.apply(null\x2C args);\n  } finally {\n    async_id_fields[kDefaultTriggerAsyncId] = oldDefaultTriggerAsyncId;\n  }\n}\n\nfunction hasHooks(key) {\n  return async_hook_fields[key] > 0;\n}\n\nfunction enabledHooksExist() {\n  return hasHooks(kCheck);\n}\n\nfunction initHooksExist() {\n  return hasHooks(kInit);\n}\n\nfunction afterHooksExist() {\n  return hasHooks(kAfter);\n}\n\nfunction destroyHooksExist() {\n  return hasHooks(kDestroy);\n}\n\nfunction promiseResolveHooksExist() {\n  return hasHooks(kPromiseResolve);\n}\n\n\nfunction emitInitScript(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n  // Short circuit all checks for the common case. Which is that no hooks have\n  // been set. Do this to remove performance impact for embedders (and core).\n  if (!hasHooks(kInit))\n    return;\n\n  if (triggerAsyncId === null) {\n    triggerAsyncId = getDefaultTriggerAsyncId();\n  }\n\n  emitInitNative(asyncId\x2C type\x2C triggerAsyncId\x2C resource);\n}\n\n\nfunction emitBeforeScript(asyncId\x2C triggerAsyncId\x2C resource) {\n  pushAsyncContext(asyncId\x2C triggerAsyncId\x2C resource);\n\n  if (hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n}\n\n\nfunction emitAfterScript(asyncId) {\n  if (hasHooks(kAfter))\n    emitAfterNative(asyncId);\n\n  popAsyncContext(asyncId);\n}\n\n\nfunction emitDestroyScript(asyncId) {\n  // Return early if there are no destroy callbacks\x2C or invalid asyncId.\n  if (!hasHooks(kDestroy) || asyncId <= 0)\n    return;\n  async_wrap.queueDestroyAsyncId(asyncId);\n}\n\n\nfunction hasAsyncIdStack() {\n  return hasHooks(kStackLength);\n}\n\n\n// This is the equivalent of the native push_async_ids() call.\nfunction pushAsyncContext(asyncId\x2C triggerAsyncId\x2C resource) {\n  const offset = async_hook_fields[kStackLength];\n  execution_async_resources[offset] = resource;\n  if (offset * 2 >= async_wrap.async_ids_stack.length)\n    return pushAsyncContext_(asyncId\x2C triggerAsyncId);\n  async_wrap.async_ids_stack[offset * 2] = async_id_fields[kExecutionAsyncId];\n  async_wrap.async_ids_stack[offset * 2 + 1] = async_id_fields[kTriggerAsyncId];\n  async_hook_fields[kStackLength]++;\n  async_id_fields[kExecutionAsyncId] = asyncId;\n  async_id_fields[kTriggerAsyncId] = triggerAsyncId;\n}\n\n\n// This is the equivalent of the native pop_async_ids() call.\nfunction popAsyncContext(asyncId) {\n  const stackLength = async_hook_fields[kStackLength];\n  if (stackLength === 0) return false;\n\n  if (enabledHooksExist() && async_id_fields[kExecutionAsyncId] !== asyncId) {\n    // Do the same thing as the native code (i.e. crash hard).\n    return popAsyncContext_(asyncId);\n  }\n\n  const offset = stackLength - 1;\n  async_id_fields[kExecutionAsyncId] = async_wrap.async_ids_stack[2 * offset];\n  async_id_fields[kTriggerAsyncId] = async_wrap.async_ids_stack[2 * offset + 1];\n  execution_async_resources.pop();\n  async_hook_fields[kStackLength] = offset;\n  return offset > 0;\n}\n\n\nfunction executionAsyncId() {\n  return async_id_fields[kExecutionAsyncId];\n}\n\nfunction triggerAsyncId() {\n  return async_id_fields[kTriggerAsyncId];\n}\n\n\nmodule.exports = {\n  executionAsyncId\x2C\n  triggerAsyncId\x2C\n  // Private API\n  getHookArrays\x2C\n  symbols: {\n    async_id_symbol\x2C trigger_async_id_symbol\x2C\n    init_symbol\x2C before_symbol\x2C after_symbol\x2C destroy_symbol\x2C\n    promise_resolve_symbol\x2C owner_symbol\x2C\n  }\x2C\n  constants: {\n    kInit\x2C kBefore\x2C kAfter\x2C kDestroy\x2C kTotals\x2C kPromiseResolve\x2C\n  }\x2C\n  enableHooks\x2C\n  disableHooks\x2C\n  updatePromiseHookMode\x2C\n  clearDefaultTriggerAsyncId\x2C\n  clearAsyncIdStack\x2C\n  hasAsyncIdStack\x2C\n  executionAsyncResource\x2C\n  // Internal Embedder API\n  newAsyncId\x2C\n  getOrSetAsyncId\x2C\n  getDefaultTriggerAsyncId\x2C\n  defaultTriggerAsyncIdScope\x2C\n  enabledHooksExist\x2C\n  initHooksExist\x2C\n  afterHooksExist\x2C\n  destroyHooksExist\x2C\n  emitInit: emitInitScript\x2C\n  emitBefore: emitBeforeScript\x2C\n  emitAfter: emitAfterScript\x2C\n  emitDestroy: emitDestroyScript\x2C\n  pushAsyncContext\x2C\n  popAsyncContext\x2C\n  registerDestroyHook\x2C\n  useDomainTrampoline\x2C\n  nativeHooks: {\n    init: emitInitNative\x2C\n    before: emitBeforeNative\x2C\n    after: emitAfterNative\x2C\n    destroy: emitDestroyNative\x2C\n    promise_resolve: emitPromiseResolveNative\x2C\n  }\x2C\n  asyncWrap: {\n    Providers: async_wrap.Providers\x2C\n  }\x2C\n};\n
code-source-info,0x2b3d46cda030,19,14478,14529,C0O14485C7O14510C16O14525C22O14527,,
code-creation,LazyCompile,10,80125,0x2b3d46cdb500,35,getDefaultTriggerAsyncId node:internal/async_hooks:432:34,0x2da83affcbf8,~
code-source-info,0x2b3d46cdb500,19,14937,15194,C0O14974C7O14990C9O14989C13O15083C14O15109C19O15118C26O15141C28O15140C31O15160C32O15163C34O15192,,
code-creation,LazyCompile,10,80167,0x2b3d46cdb970,13,initHooksExist node:internal/async_hooks:477:24,0x2da83affcd88,~
code-source-info,0x2b3d46cdb970,19,16155,16187,C0O16162C5O16178C8O16169C12O16185,,
code-creation,LazyCompile,10,80167,0x2b3d46cdba58,16,hasHooks node:internal/async_hooks:469:18,0x2da83affcce8,~
code-source-info,0x2b3d46cdba58,19,16023,16069,C0O16033C7O16057C12O16063C15O16067,,
code-creation,LazyCompile,10,80167,0x2b3d46cdbb60,59,push node:internal/fixed_queue:99:7,0x35d2971a08a8,~
code-source-info,0x2b3d46cdbb60,41,3685,3945,C0O3707C5O3712C10O3712C16O3871C23O3887C26O3883C32O3881C38O3864C42O3925C47O3930C52O3930C58O3944,,
code-creation,LazyCompile,10,80209,0x2b3d46cdbca0,24,isFull node:internal/fixed_queue:71:9,0x35d2971a05f8,~
code-source-info,0x2b3d46cdbca0,41,3139,3200,C0O3162C4O3166C10O3173C12O3171C16O3189C20O3180C23O3196,,
code-creation,LazyCompile,10,80209,0x2b3d46cdbda8,37,push node:internal/fixed_queue:75:7,0x35d2971a0648,~
code-source-info,0x2b3d46cdbda8,41,3208,3291,C0O3226C5O3236C12O3241C16O3270C20O3274C26O3281C28O3279C31O3262C36O3290,,
code-creation,LazyCompile,10,80250,0x2b3d46cdbec8,30,onNewListener node:child_process:179:51,0x2b3d46cd0aa0,~
code-source-info,0x2b3d46cdbec8,456,5295,5382,C0O5308C2O5317C9O5339C14O5357C19O5365C24O5365C29O5381,,
code-creation,LazyCompile,10,80292,0x2b3d46cdc008,63,initializeClusterIPC node:internal/process/pre_execution:475:30,0x202f02877b40,~
code-source-info,0x2b3d46cdc008,447,14681,14922,C0O14688C3O14700C10O14704C18O14719C23O14723C29O14761C35O14761C40O14793C45O14793C49O14882C52O14897C62O14921,,
code-creation,LazyCompile,10,80334,0x2b3d46cdc148,53,runDeserializeCallbacks node:internal/v8/startup_snapshot:32:33,0x25dc1a856568,~
code-source-info,0x2b3d46cdc148,85,757,898,C0O799C5O792C11O799C16O843C21O864C26O864C31O821C37O834C44O877C48O764C52O897,,
code-creation,LazyCompile,10,80375,0x2b3d46cdc2b0,52,setupUserModules node:internal/process/pre_execution:112:26,0x202f02877478,~
code-source-info,0x2b3d46cdc2b0,447,3177,3441,C0O3184C3O3184C6O3209C9O3209C12O3252C18O3252C23O3294C28O3312C34O3294C38O3342C41O3342C44O3410C47O3410C51O3440,,
code-creation,LazyCompile,10,80375,0x2b3d46cdc4b8,66,initializeCJSLoader node:internal/process/pre_execution:534:29,0x202f02877be0,~
code-source-info,0x2b3d46cdc4b8,447,16779,17094,C0O16804C6O16804C11O16846C16O16851C20O16871C26O16909C31O16916C36O16916C40O17012C51O17033C56O17069C60O17027C65O17093,,
tick,0x195a4df24,80500,0,0x0,3,0x0,0x2b3d46cd9114,0x2b3d46cd8d97,0x1012a39722b9,0x1012a39725f5,0x1012a3972abe,0x2b3d46cd0c49,0x30e7677207c6,0x202f0287b58b,0x202f02879dd8,0x202f028761e9
code-creation,Eval,10,81000,0x2b3d46cdf380,5, node:internal/modules/cjs/loader:1:1,0x2b3d46cddde8,~
script-source,465,node:internal/modules/cjs/loader,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypePushApply\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  ArrayPrototypeUnshiftApply\x2C\n  ArrayPrototypeFlatMap\x2C\n  Boolean\x2C\n  Error\x2C\n  JSONParse\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectFreeze\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ObjectPrototype\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  Proxy\x2C\n  ReflectApply\x2C\n  ReflectSet\x2C\n  RegExpPrototypeExec\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  SafeWeakMap\x2C\n  String\x2C\n  StringPrototypeCharAt\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\n// Map used to store CJS parsing data.\nconst cjsParseCache = new SafeWeakMap();\n\n// Set first due to cycle with ESM loader functions.\nmodule.exports = {\n  wrapSafe\x2C Module\x2C toRealPath\x2C readPackageScope\x2C cjsParseCache\x2C\n  get hasLoadedAnyUserCJSModule() { return hasLoadedAnyUserCJSModule; }\x2C\n};\n\nconst { BuiltinModule } = require('internal/bootstrap/loaders');\nconst {\n  maybeCacheSourceMap\x2C\n} = require('internal/source_map/source_map_cache');\nconst { pathToFileURL\x2C fileURLToPath\x2C isURL } = require('internal/url');\nconst {\n  deprecate\x2C\n  emitExperimentalWarning\x2C\n  kEmptyObject\x2C\n  filterOwnProperties\x2C\n  setOwnProperty\x2C\n} = require('internal/util');\nconst { Script } = require('vm');\nconst { internalCompileFunction } = require('internal/vm');\nconst assert = require('internal/assert');\nconst fs = require('fs');\nconst internalFS = require('internal/fs/utils');\nconst path = require('path');\nconst { sep } = path;\nconst { internalModuleStat } = internalBinding('fs');\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst { safeGetenv } = internalBinding('credentials');\nconst {\n  privateSymbols: {\n    require_private_symbol\x2C\n  }\x2C\n} = internalBinding('util');\nconst {\n  cjsConditions\x2C\n  hasEsmSyntax\x2C\n  loadBuiltinModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n} = require('internal/modules/cjs/helpers');\nconst { getOptionValue } = require('internal/options');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\nconst shouldReportRequiredModules = process.env.WATCH_REPORT_DEPENDENCIES;\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\n\n// Whether any user-provided CJS modules had been loaded (executed).\n// Used for internal assertions.\nlet hasLoadedAnyUserCJSModule = false;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_MODULE_SPECIFIER\x2C\n    ERR_REQUIRE_ESM\x2C\n    ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  }\x2C\n  setArrowMessage\x2C\n} = require('internal/errors');\nconst { validateString } = require('internal/validators');\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\n\nconst {\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\x2C\n  CHAR_DOT\x2C\n  CHAR_FORWARD_SLASH\x2C\n} = require('internal/constants');\n\nconst {\n  isProxy\x2C\n} = require('internal/util/types');\n\nconst asyncESM = require('internal/process/esm_loader');\nconst { enrichCJSError } = require('internal/modules/esm/translators');\nconst { kEvaluated } = internalBinding('module_wrap');\nconst {\n  encodedSepRegEx\x2C\n  packageExportsResolve\x2C\n  packageImportsResolve\x2C\n} = require('internal/modules/esm/resolve');\n\nconst isWindows = process.platform === 'win32';\n\nconst relativeResolveCache = ObjectCreate(null);\n\nlet requireDepth = 0;\nlet statCache = null;\nlet isPreloading = false;\n\nfunction internalRequire(module\x2C id) {\n  validateString(id\x2C 'id');\n  if (id === '') {\n    throw new ERR_INVALID_ARG_VALUE('id'\x2C id\x2C\n                                    'must be a non-empty string');\n  }\n  requireDepth++;\n  try {\n    return Module._load(id\x2C module\x2C /* isMain */ false);\n  } finally {\n    requireDepth--;\n  }\n}\n\nfunction stat(filename) {\n  filename = path.toNamespacedPath(filename);\n  if (statCache !== null) {\n    const result = statCache.get(filename);\n    if (result !== undefined) return result;\n  }\n  const result = internalModuleStat(filename);\n  if (statCache !== null && result >= 0) {\n    // Only set cache when `internalModuleStat(filename)` succeeds.\n    statCache.set(filename\x2C result);\n  }\n  return result;\n}\n\nlet _stat = stat;\nObjectDefineProperty(Module\x2C '_stat'\x2C {\n  __proto__: null\x2C\n  get() { return _stat; }\x2C\n  set(stat) {\n    emitExperimentalWarning('Module._stat');\n    _stat = stat;\n    return true;\n  }\x2C\n  configurable: true\x2C\n});\n\nfunction updateChildren(parent\x2C child\x2C scan) {\n  const children = parent?.children;\n  if (children && !(scan && ArrayPrototypeIncludes(children\x2C child)))\n    ArrayPrototypePush(children\x2C child);\n}\n\nfunction reportModuleToWatchMode(filename) {\n  if (shouldReportRequiredModules && process.send) {\n    process.send({ 'watch:require': [filename] });\n  }\n}\n\nfunction reportModuleNotFoundToWatchMode(basePath\x2C extensions) {\n  if (shouldReportRequiredModules && process.send) {\n    process.send({ 'watch:require': ArrayPrototypeMap(extensions\x2C (ext) => path.resolve(`${basePath}${ext}`)) });\n  }\n}\n\nconst moduleParentCache = new SafeWeakMap();\nfunction Module(id = ''\x2C parent) {\n  this.id = id;\n  this.path = path.dirname(id);\n  setOwnProperty(this\x2C 'exports'\x2C {});\n  moduleParentCache.set(this\x2C parent);\n  updateChildren(parent\x2C this\x2C false);\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n  let redirects;\n  if (policy?.manifest) {\n    const moduleURL = pathToFileURL(id);\n    redirects = policy.manifest.getDependencyMapper(moduleURL);\n    // TODO(rafaelgss): remove the necessity of this branch\n    setOwnProperty(this\x2C 'require'\x2C makeRequireFunction(this\x2C redirects));\n    // eslint-disable-next-line no-proto\n    setOwnProperty(this.__proto__\x2C 'require'\x2C makeRequireFunction(this\x2C redirects));\n  }\n  this[require_private_symbol] = internalRequire;\n}\n\nconst builtinModules = [];\nfor (const { 0: id\x2C 1: mod } of BuiltinModule.map) {\n  if (mod.canBeRequiredByUsers &&\n    BuiltinModule.canBeRequiredWithoutScheme(id)) {\n    ArrayPrototypePush(builtinModules\x2C id);\n  }\n}\n\nconst allBuiltins = new SafeSet(\n  ArrayPrototypeFlatMap(builtinModules\x2C (bm) => [bm\x2C `node:${bm}`])\x2C\n);\nBuiltinModule.getSchemeOnlyModuleNames().forEach((builtin) => allBuiltins.add(`node:${builtin}`));\n\nObjectFreeze(builtinModules);\nModule.builtinModules = builtinModules;\n\nModule._cache = ObjectCreate(null);\nModule._pathCache = ObjectCreate(null);\nModule._extensions = ObjectCreate(null);\nlet modulePaths = [];\nModule.globalPaths = [];\n\nlet patched = false;\n\n// eslint-disable-next-line func-style\nlet wrap = function(script) {\n  return Module.wrapper[0] + script + Module.wrapper[1];\n};\n\nconst wrapper = [\n  '(function (exports\x2C require\x2C module\x2C __filename\x2C __dirname) { '\x2C\n  '\\n});'\x2C\n];\n\nlet wrapperProxy = new Proxy(wrapper\x2C {\n  __proto__: null\x2C\n\n  set(target\x2C property\x2C value\x2C receiver) {\n    patched = true;\n    return ReflectSet(target\x2C property\x2C value\x2C receiver);\n  }\x2C\n\n  defineProperty(target\x2C property\x2C descriptor) {\n    patched = true;\n    return ObjectDefineProperty(target\x2C property\x2C descriptor);\n  }\x2C\n});\n\nObjectDefineProperty(Module\x2C 'wrap'\x2C {\n  __proto__: null\x2C\n  get() {\n    return wrap;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrap = value;\n  }\x2C\n});\n\nObjectDefineProperty(Module\x2C 'wrapper'\x2C {\n  __proto__: null\x2C\n  get() {\n    return wrapperProxy;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrapperProxy = value;\n  }\x2C\n});\n\nconst isPreloadingDesc = { get() { return isPreloading; } };\nObjectDefineProperty(Module.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\nObjectDefineProperty(BuiltinModule.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\n\nfunction getModuleParent() {\n  return moduleParentCache.get(this);\n}\n\nfunction setModuleParent(value) {\n  moduleParentCache.set(this\x2C value);\n}\n\nObjectDefineProperty(Module.prototype\x2C 'parent'\x2C {\n  __proto__: null\x2C\n  get: pendingDeprecation ? deprecate(\n    getModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\x2C\n  ) : getModuleParent\x2C\n  set: pendingDeprecation ? deprecate(\n    setModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\x2C\n  ) : setModuleParent\x2C\n});\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\nModule._debug = deprecate(debug\x2C 'Module._debug is deprecated.'\x2C 'DEP0077');\n\n// Given a module name\x2C and a list of paths to test\x2C returns the first\n// matching file in the following precedence.\n//\n// require("a.<ext>")\n//   -> a.<ext>\n//\n// require("a")\n//   -> a\n//   -> a.<ext>\n//   -> a/index.<ext>\n\nconst packageJsonCache = new SafeMap();\n\nfunction readPackage(requestPath) {\n  const jsonPath = path.resolve(requestPath\x2C 'package.json');\n\n  const existing = packageJsonCache.get(jsonPath);\n  if (existing !== undefined) return existing;\n\n  const result = packageJsonReader.read(jsonPath);\n  const json = result.containsKeys === false ? '{}' : result.string;\n  if (json === undefined) {\n    packageJsonCache.set(jsonPath\x2C false);\n    return false;\n  }\n\n  try {\n    const filtered = filterOwnProperties(JSONParse(json)\x2C [\n      'name'\x2C\n      'main'\x2C\n      'exports'\x2C\n      'imports'\x2C\n      'type'\x2C\n    ]);\n    packageJsonCache.set(jsonPath\x2C filtered);\n    return filtered;\n  } catch (e) {\n    e.path = jsonPath;\n    e.message = 'Error parsing ' + jsonPath + ': ' + e.message;\n    throw e;\n  }\n}\n\nlet _readPackage = readPackage;\nObjectDefineProperty(Module\x2C '_readPackage'\x2C {\n  __proto__: null\x2C\n  get() { return _readPackage; }\x2C\n  set(readPackage) {\n    emitExperimentalWarning('Module._readPackage');\n    _readPackage = readPackage;\n    return true;\n  }\x2C\n  configurable: true\x2C\n});\n\nfunction readPackageScope(checkPath) {\n  const rootSeparatorIndex = StringPrototypeIndexOf(checkPath\x2C sep);\n  let separatorIndex;\n  do {\n    separatorIndex = StringPrototypeLastIndexOf(checkPath\x2C sep);\n    checkPath = StringPrototypeSlice(checkPath\x2C 0\x2C separatorIndex);\n    if (StringPrototypeEndsWith(checkPath\x2C sep + 'node_modules'))\n      return false;\n    const pjson = _readPackage(checkPath + sep);\n    if (pjson) return {\n      data: pjson\x2C\n      path: checkPath\x2C\n    };\n  } while (separatorIndex > rootSeparatorIndex);\n  return false;\n}\n\nfunction tryPackage(requestPath\x2C exts\x2C isMain\x2C originalPath) {\n  const pkg = _readPackage(requestPath)?.main;\n\n  if (!pkg) {\n    return tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n  }\n\n  const filename = path.resolve(requestPath\x2C pkg);\n  let actual = tryFile(filename\x2C isMain) ||\n    tryExtensions(filename\x2C exts\x2C isMain) ||\n    tryExtensions(path.resolve(filename\x2C 'index')\x2C exts\x2C isMain);\n  if (actual === false) {\n    actual = tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n    if (!actual) {\n      // eslint-disable-next-line no-restricted-syntax\n      const err = new Error(\n        `Cannot find module '${filename}'. ` +\n        'Please verify that the package.json has a valid "main" entry'\x2C\n      );\n      err.code = 'MODULE_NOT_FOUND';\n      err.path = path.resolve(requestPath\x2C 'package.json');\n      err.requestPath = originalPath;\n      // TODO(BridgeAR): Add the requireStack as well.\n      throw err;\n    } else {\n      const jsonPath = path.resolve(requestPath\x2C 'package.json');\n      process.emitWarning(\n        `Invalid 'main' field in '${jsonPath}' of '${pkg}'. ` +\n          'Please either fix that or report it to the module author'\x2C\n        'DeprecationWarning'\x2C\n        'DEP0128'\x2C\n      );\n    }\n  }\n  return actual;\n}\n\n// In order to minimize unnecessary lstat() calls\x2C\n// this cache is a list of known-real paths.\n// Set to an empty Map to reset.\nconst realpathCache = new SafeMap();\n\n// Check if the file exists and is not a directory\n// if using --preserve-symlinks and isMain is false\x2C\n// keep symlinks intact\x2C otherwise resolve to the\n// absolute realpath.\nfunction tryFile(requestPath\x2C isMain) {\n  const rc = _stat(requestPath);\n  if (rc !== 0) return;\n  if (preserveSymlinks && !isMain) {\n    return path.resolve(requestPath);\n  }\n  return toRealPath(requestPath);\n}\n\nfunction toRealPath(requestPath) {\n  return fs.realpathSync(requestPath\x2C {\n    [internalFS.realpathCacheKey]: realpathCache\x2C\n  });\n}\n\n// Given a path\x2C check if the file exists with any of the set extensions\nfunction tryExtensions(p\x2C exts\x2C isMain) {\n  for (let i = 0; i < exts.length; i++) {\n    const filename = tryFile(p + exts[i]\x2C isMain);\n\n    if (filename) {\n      return filename;\n    }\n  }\n  return false;\n}\n\n// Find the longest (possibly multi-dot) extension registered in\n// Module._extensions\nfunction findLongestRegisteredExtension(filename) {\n  const name = path.basename(filename);\n  let currentExtension;\n  let index;\n  let startIndex = 0;\n  while ((index = StringPrototypeIndexOf(name\x2C '.'\x2C startIndex)) !== -1) {\n    startIndex = index + 1;\n    if (index === 0) continue; // Skip dotfiles like .gitignore\n    currentExtension = StringPrototypeSlice(name\x2C index);\n    if (Module._extensions[currentExtension]) return currentExtension;\n  }\n  return '.js';\n}\n\nfunction trySelfParentPath(parent) {\n  if (!parent) return false;\n\n  if (parent.filename) {\n    return parent.filename;\n  } else if (parent.id === '<repl>' || parent.id === 'internal/preload') {\n    try {\n      return process.cwd() + path.sep;\n    } catch {\n      return false;\n    }\n  }\n}\n\nfunction trySelf(parentPath\x2C request) {\n  if (!parentPath) return false;\n\n  const { data: pkg\x2C path: pkgPath } = readPackageScope(parentPath) || {};\n  if (!pkg || pkg.exports === undefined) return false;\n  if (typeof pkg.name !== 'string') return false;\n\n  let expansion;\n  if (request === pkg.name) {\n    expansion = '.';\n  } else if (StringPrototypeStartsWith(request\x2C `${pkg.name}/`)) {\n    expansion = '.' + StringPrototypeSlice(request\x2C pkg.name.length);\n  } else {\n    return false;\n  }\n\n  try {\n    return finalizeEsmResolution(packageExportsResolve(\n      pathToFileURL(pkgPath + '/package.json')\x2C expansion\x2C pkg\x2C\n      pathToFileURL(parentPath)\x2C cjsConditions)\x2C parentPath\x2C pkgPath);\n  } catch (e) {\n    if (e.code === 'ERR_MODULE_NOT_FOUND')\n      throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n    throw e;\n  }\n}\n\n// This only applies to requests of a specific form:\n// 1. name/.*\n// 2. @scope/name/.*\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^./\\\\%][^/\\\\%]*)(\\/.*)?$/;\nfunction resolveExports(nmPath\x2C request) {\n  // The implementation's behavior is meant to mirror resolution in ESM.\n  const { 1: name\x2C 2: expansion = '' } =\n    RegExpPrototypeExec(EXPORTS_PATTERN\x2C request) || kEmptyObject;\n  if (!name)\n    return;\n  const pkgPath = path.resolve(nmPath\x2C name);\n  const pkg = _readPackage(pkgPath);\n  if (pkg?.exports != null) {\n    try {\n      return finalizeEsmResolution(packageExportsResolve(\n        pathToFileURL(pkgPath + '/package.json')\x2C '.' + expansion\x2C pkg\x2C null\x2C\n        cjsConditions)\x2C null\x2C pkgPath);\n    } catch (e) {\n      if (e.code === 'ERR_MODULE_NOT_FOUND')\n        throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n      throw e;\n    }\n  }\n}\n\n/**\n * @param {string} request a relative or absolute file path\n * @param {Array<string>} paths file system directories to search as file paths\n * @param {boolean} isMain if the request is the main app entry point\n * @returns {string | false}\n */\nModule._findPath = function(request\x2C paths\x2C isMain) {\n  const absoluteRequest = path.isAbsolute(request);\n  if (absoluteRequest) {\n    paths = [''];\n  } else if (!paths || paths.length === 0) {\n    return false;\n  }\n\n  const cacheKey = request + '\\x00' + ArrayPrototypeJoin(paths\x2C '\\x00');\n  const entry = Module._pathCache[cacheKey];\n  if (entry)\n    return entry;\n\n  let exts;\n  const trailingSlash = request.length > 0 &&\n    (StringPrototypeCharCodeAt(request\x2C request.length - 1) === CHAR_FORWARD_SLASH || (\n      StringPrototypeCharCodeAt(request\x2C request.length - 1) === CHAR_DOT &&\n      (\n        request.length === 1 ||\n        StringPrototypeCharCodeAt(request\x2C request.length - 2) === CHAR_FORWARD_SLASH ||\n        (StringPrototypeCharCodeAt(request\x2C request.length - 2) === CHAR_DOT && (\n          request.length === 2 ||\n          StringPrototypeCharCodeAt(request\x2C request.length - 3) === CHAR_FORWARD_SLASH\n        ))\n      )\n    ));\n\n  const isRelative = StringPrototypeCharCodeAt(request\x2C 0) === CHAR_DOT &&\n    (\n      request.length === 1 ||\n      StringPrototypeCharCodeAt(request\x2C 1) === CHAR_FORWARD_SLASH ||\n      (isWindows && StringPrototypeCharCodeAt(request\x2C 1) === CHAR_BACKWARD_SLASH) ||\n      (StringPrototypeCharCodeAt(request\x2C 1) === CHAR_DOT && ((\n        request.length === 2 ||\n        StringPrototypeCharCodeAt(request\x2C 2) === CHAR_FORWARD_SLASH) ||\n        (isWindows && StringPrototypeCharCodeAt(request\x2C 2) === CHAR_BACKWARD_SLASH)))\n    );\n  let insidePath = true;\n  if (isRelative) {\n    const normalizedRequest = path.normalize(request);\n    if (StringPrototypeStartsWith(normalizedRequest\x2C '..')) {\n      insidePath = false;\n    }\n  }\n\n  // For each path\n  for (let i = 0; i < paths.length; i++) {\n    // Don't search further if path doesn't exist and request is inside the path\n    const curPath = paths[i];\n    if (insidePath && curPath && _stat(curPath) < 1) continue;\n\n    if (!absoluteRequest) {\n      const exportsResolved = resolveExports(curPath\x2C request);\n      if (exportsResolved)\n        return exportsResolved;\n    }\n\n    const basePath = path.resolve(curPath\x2C request);\n    let filename;\n\n    const rc = _stat(basePath);\n    if (!trailingSlash) {\n      if (rc === 0) {  // File.\n        if (!isMain) {\n          if (preserveSymlinks) {\n            filename = path.resolve(basePath);\n          } else {\n            filename = toRealPath(basePath);\n          }\n        } else if (preserveSymlinksMain) {\n          // For the main module\x2C we use the preserveSymlinksMain flag instead\n          // mainly for backward compatibility\x2C as the preserveSymlinks flag\n          // historically has not applied to the main module.  Most likely this\n          // was intended to keep .bin/ binaries working\x2C as following those\n          // symlinks is usually required for the imports in the corresponding\n          // files to resolve; that said\x2C in some use cases following symlinks\n          // causes bigger problems which is why the preserveSymlinksMain option\n          // is needed.\n          filename = path.resolve(basePath);\n        } else {\n          filename = toRealPath(basePath);\n        }\n      }\n\n      if (!filename) {\n        // Try it with each of the extensions\n        if (exts === undefined)\n          exts = ObjectKeys(Module._extensions);\n        filename = tryExtensions(basePath\x2C exts\x2C isMain);\n      }\n    }\n\n    if (!filename && rc === 1) {  // Directory.\n      // try it with each of the extensions at "index"\n      if (exts === undefined)\n        exts = ObjectKeys(Module._extensions);\n      filename = tryPackage(basePath\x2C exts\x2C isMain\x2C request);\n    }\n\n    if (filename) {\n      Module._pathCache[cacheKey] = filename;\n      return filename;\n    }\n\n    const extensions = [''];\n    if (exts !== undefined) {\n      ArrayPrototypePushApply(extensions\x2C exts);\n    }\n    reportModuleNotFoundToWatchMode(basePath\x2C extensions);\n  }\n\n  return false;\n};\n\n// 'node_modules' character codes reversed\nconst nmChars = [ 115\x2C 101\x2C 108\x2C 117\x2C 100\x2C 111\x2C 109\x2C 95\x2C 101\x2C 100\x2C 111\x2C 110 ];\nconst nmLen = nmChars.length;\nif (isWindows) {\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n\n    // return root node_modules when path is 'D:\\\\'.\n    // path.resolve will make sure from.length >=3 in Windows.\n    if (StringPrototypeCharCodeAt(from\x2C from.length - 1) ===\n          CHAR_BACKWARD_SLASH &&\n        StringPrototypeCharCodeAt(from\x2C from.length - 2) === CHAR_COLON)\n      return [from + 'node_modules'];\n\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      // The path segment separator check ('\\' and '/') was used to get\n      // node_modules path for every path segment.\n      // Use colon as an extra condition since we can get node_modules\n      // path for drive root like 'C:\\node_modules' and don't need to\n      // parse drive name.\n      if (code === CHAR_BACKWARD_SLASH ||\n          code === CHAR_FORWARD_SLASH ||\n          code === CHAR_COLON) {\n        if (p !== nmLen)\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '\\\\node_modules'\x2C\n          );\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    return paths;\n  };\n} else { // posix\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n    // Return early not only to avoid unnecessary work\x2C but to *avoid* returning\n    // an array of two items for a root: [ '//node_modules'\x2C '/node_modules' ]\n    if (from === '/')\n      return ['/node_modules'];\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (p !== nmLen)\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '/node_modules'\x2C\n          );\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    // Append /node_modules to handle root paths.\n    ArrayPrototypePush(paths\x2C '/node_modules');\n\n    return paths;\n  };\n}\n\nModule._resolveLookupPaths = function(request\x2C parent) {\n  if ((\n    StringPrototypeStartsWith(request\x2C 'node:') &&\n    BuiltinModule.canBeRequiredByUsers(StringPrototypeSlice(request\x2C 5))\n  ) || (\n    BuiltinModule.canBeRequiredByUsers(request) &&\n    BuiltinModule.canBeRequiredWithoutScheme(request)\n  )) {\n    debug('looking for %j in []'\x2C request);\n    return null;\n  }\n\n  // Check for node modules paths.\n  if (StringPrototypeCharAt(request\x2C 0) !== '.' ||\n      (request.length > 1 &&\n      StringPrototypeCharAt(request\x2C 1) !== '.' &&\n      StringPrototypeCharAt(request\x2C 1) !== '/' &&\n      (!isWindows || StringPrototypeCharAt(request\x2C 1) !== '\\\\'))) {\n\n    let paths;\n    if (parent?.paths?.length) {\n      paths = ArrayPrototypeSlice(modulePaths);\n      ArrayPrototypeUnshiftApply(paths\x2C parent.paths);\n    } else {\n      paths = modulePaths;\n    }\n\n    debug('looking for %j in %j'\x2C request\x2C paths);\n    return paths.length > 0 ? paths : null;\n  }\n\n  // In REPL\x2C parent.filename is null.\n  if (!parent || !parent.id || !parent.filename) {\n    // Make require('./path/to/foo') work - normally the path is taken\n    // from realpath(__filename) but in REPL there is no filename\n    const mainPaths = ['.'];\n\n    debug('looking for %j in %j'\x2C request\x2C mainPaths);\n    return mainPaths;\n  }\n\n  debug('RELATIVE: requested: %s from parent.id %s'\x2C request\x2C parent.id);\n\n  const parentDir = [path.dirname(parent.filename)];\n  debug('looking for %j'\x2C parentDir);\n  return parentDir;\n};\n\nfunction emitCircularRequireWarning(prop) {\n  process.emitWarning(\n    `Accessing non-existent property '${String(prop)}' of module exports ` +\n    'inside circular dependency'\x2C\n  );\n}\n\n// A Proxy that can be used as the prototype of a module.exports object and\n// warns when non-existent properties are accessed.\nconst CircularRequirePrototypeWarningProxy = new Proxy({}\x2C {\n  __proto__: null\x2C\n\n  get(target\x2C prop) {\n    // Allow __esModule access in any case because it is used in the output\n    // of transpiled code to determine whether something comes from an\n    // ES module\x2C and is not used as a regular key of `module.exports`.\n    if (prop in target || prop === '__esModule') return target[prop];\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\x2C\n\n  getOwnPropertyDescriptor(target\x2C prop) {\n    if (ObjectPrototypeHasOwnProperty(target\x2C prop) || prop === '__esModule')\n      return ObjectGetOwnPropertyDescriptor(target\x2C prop);\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\x2C\n});\n\nfunction getExportsForCircularRequire(module) {\n  if (module.exports &&\n      !isProxy(module.exports) &&\n      ObjectGetPrototypeOf(module.exports) === ObjectPrototype &&\n      // Exclude transpiled ES6 modules / TypeScript code because those may\n      // employ unusual patterns for accessing 'module.exports'. That should\n      // be okay because ES6 modules have a different approach to circular\n      // dependencies anyway.\n      !module.exports.__esModule) {\n    // This is later unset once the module is done loading.\n    ObjectSetPrototypeOf(\n      module.exports\x2C CircularRequirePrototypeWarningProxy);\n  }\n\n  return module.exports;\n}\n\n// Check the cache for the requested file.\n// 1. If a module already exists in the cache: return its exports object.\n// 2. If the module is native: call\n//    `BuiltinModule.prototype.compileForPublicLoader()` and return the exports.\n// 3. Otherwise\x2C create a new module for the file and save it to the cache.\n//    Then have it load  the file contents before returning its exports\n//    object.\nModule._load = function(request\x2C parent\x2C isMain) {\n  let relResolveCacheIdentifier;\n  if (parent) {\n    debug('Module._load REQUEST %s parent: %s'\x2C request\x2C parent.id);\n    // Fast path for (lazy loaded) modules in the same directory. The indirect\n    // caching is required to allow cache invalidation without changing the old\n    // cache key names.\n    relResolveCacheIdentifier = `${parent.path}\\x00${request}`;\n    const filename = relativeResolveCache[relResolveCacheIdentifier];\n    reportModuleToWatchMode(filename);\n    if (filename !== undefined) {\n      const cachedModule = Module._cache[filename];\n      if (cachedModule !== undefined) {\n        updateChildren(parent\x2C cachedModule\x2C true);\n        if (!cachedModule.loaded)\n          return getExportsForCircularRequire(cachedModule);\n        return cachedModule.exports;\n      }\n      delete relativeResolveCache[relResolveCacheIdentifier];\n    }\n  }\n\n  if (StringPrototypeStartsWith(request\x2C 'node:')) {\n    // Slice 'node:' prefix\n    const id = StringPrototypeSlice(request\x2C 5);\n\n    const module = loadBuiltinModule(id\x2C request);\n    if (!module?.canBeRequiredByUsers) {\n      throw new ERR_UNKNOWN_BUILTIN_MODULE(request);\n    }\n\n    return module.exports;\n  }\n\n  const filename = Module._resolveFilename(request\x2C parent\x2C isMain);\n  const cachedModule = Module._cache[filename];\n  if (cachedModule !== undefined) {\n    updateChildren(parent\x2C cachedModule\x2C true);\n    if (!cachedModule.loaded) {\n      const parseCachedModule = cjsParseCache.get(cachedModule);\n      if (!parseCachedModule || parseCachedModule.loaded)\n        return getExportsForCircularRequire(cachedModule);\n      parseCachedModule.loaded = true;\n    } else {\n      return cachedModule.exports;\n    }\n  }\n\n  const mod = loadBuiltinModule(filename\x2C request);\n  if (mod?.canBeRequiredByUsers &&\n      BuiltinModule.canBeRequiredWithoutScheme(filename)) {\n    return mod.exports;\n  }\n\n  // Don't call updateChildren()\x2C Module constructor already does.\n  const module = cachedModule || new Module(filename\x2C parent);\n\n  if (isMain) {\n    setOwnProperty(process\x2C 'mainModule'\x2C module);\n    setOwnProperty(module.require\x2C 'main'\x2C process.mainModule);\n    module.id = '.';\n  }\n\n  reportModuleToWatchMode(filename);\n\n  Module._cache[filename] = module;\n  if (parent !== undefined) {\n    relativeResolveCache[relResolveCacheIdentifier] = filename;\n  }\n\n  let threw = true;\n  try {\n    module.load(filename);\n    threw = false;\n  } finally {\n    if (threw) {\n      delete Module._cache[filename];\n      if (parent !== undefined) {\n        delete relativeResolveCache[relResolveCacheIdentifier];\n        const children = parent?.children;\n        if (ArrayIsArray(children)) {\n          const index = ArrayPrototypeIndexOf(children\x2C module);\n          if (index !== -1) {\n            ArrayPrototypeSplice(children\x2C index\x2C 1);\n          }\n        }\n      }\n    } else if (module.exports &&\n               !isProxy(module.exports) &&\n               ObjectGetPrototypeOf(module.exports) ===\n                 CircularRequirePrototypeWarningProxy) {\n      ObjectSetPrototypeOf(module.exports\x2C ObjectPrototype);\n    }\n  }\n\n  return module.exports;\n};\n\nModule._resolveFilename = function(request\x2C parent\x2C isMain\x2C options) {\n  if (\n    (\n      StringPrototypeStartsWith(request\x2C 'node:') &&\n      BuiltinModule.canBeRequiredByUsers(StringPrototypeSlice(request\x2C 5))\n    ) || (\n      BuiltinModule.canBeRequiredByUsers(request) &&\n      BuiltinModule.canBeRequiredWithoutScheme(request)\n    )\n  ) {\n    return request;\n  }\n\n  let paths;\n\n  if (typeof options === 'object' && options !== null) {\n    if (ArrayIsArray(options.paths)) {\n      const isRelative = StringPrototypeStartsWith(request\x2C './') ||\n          StringPrototypeStartsWith(request\x2C '../') ||\n          ((isWindows && StringPrototypeStartsWith(request\x2C '.\\\\')) ||\n          StringPrototypeStartsWith(request\x2C '..\\\\'));\n\n      if (isRelative) {\n        paths = options.paths;\n      } else {\n        const fakeParent = new Module(''\x2C null);\n\n        paths = [];\n\n        for (let i = 0; i < options.paths.length; i++) {\n          const path = options.paths[i];\n          fakeParent.paths = Module._nodeModulePaths(path);\n          const lookupPaths = Module._resolveLookupPaths(request\x2C fakeParent);\n\n          for (let j = 0; j < lookupPaths.length; j++) {\n            if (!ArrayPrototypeIncludes(paths\x2C lookupPaths[j]))\n              ArrayPrototypePush(paths\x2C lookupPaths[j]);\n          }\n        }\n      }\n    } else if (options.paths === undefined) {\n      paths = Module._resolveLookupPaths(request\x2C parent);\n    } else {\n      throw new ERR_INVALID_ARG_VALUE('options.paths'\x2C options.paths);\n    }\n  } else {\n    paths = Module._resolveLookupPaths(request\x2C parent);\n  }\n\n  if (request[0] === '#' && (parent?.filename || parent?.id === '<repl>')) {\n    const parentPath = parent?.filename ?? process.cwd() + path.sep;\n    const pkg = readPackageScope(parentPath) || {};\n    if (pkg.data?.imports != null) {\n      try {\n        return finalizeEsmResolution(\n          packageImportsResolve(request\x2C pathToFileURL(parentPath)\x2C\n                                cjsConditions)\x2C parentPath\x2C\n          pkg.path);\n      } catch (e) {\n        if (e.code === 'ERR_MODULE_NOT_FOUND')\n          throw createEsmNotFoundErr(request);\n        throw e;\n      }\n    }\n  }\n\n  // Try module self resolution first\n  const parentPath = trySelfParentPath(parent);\n  const selfResolved = trySelf(parentPath\x2C request);\n  if (selfResolved) {\n    const cacheKey = request + '\\x00' +\n         (paths.length === 1 ? paths[0] : ArrayPrototypeJoin(paths\x2C '\\x00'));\n    Module._pathCache[cacheKey] = selfResolved;\n    return selfResolved;\n  }\n\n  // Look up the filename first\x2C since that's the cache key.\n  const filename = Module._findPath(request\x2C paths\x2C isMain);\n  if (filename) return filename;\n  const requireStack = [];\n  for (let cursor = parent;\n    cursor;\n    cursor = moduleParentCache.get(cursor)) {\n    ArrayPrototypePush(requireStack\x2C cursor.filename || cursor.id);\n  }\n  let message = `Cannot find module '${request}'`;\n  if (requireStack.length > 0) {\n    message = message + '\\nRequire stack:\\n- ' +\n              ArrayPrototypeJoin(requireStack\x2C '\\n- ');\n  }\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  err.code = 'MODULE_NOT_FOUND';\n  err.requireStack = requireStack;\n  throw err;\n};\n\nfunction finalizeEsmResolution(resolved\x2C parentPath\x2C pkgPath) {\n  if (RegExpPrototypeExec(encodedSepRegEx\x2C resolved) !== null)\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved\x2C 'must not include encoded "/" or "\\\\" characters'\x2C parentPath);\n  const filename = fileURLToPath(resolved);\n  const actual = tryFile(filename);\n  if (actual)\n    return actual;\n  const err = createEsmNotFoundErr(filename\x2C\n                                   path.resolve(pkgPath\x2C 'package.json'));\n  throw err;\n}\n\nfunction createEsmNotFoundErr(request\x2C path) {\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(`Cannot find module '${request}'`);\n  err.code = 'MODULE_NOT_FOUND';\n  if (path)\n    err.path = path;\n  // TODO(BridgeAR): Add the requireStack as well.\n  return err;\n}\n\n// Given a file name\x2C pass it to the proper extension handler.\nModule.prototype.load = function(filename) {\n  debug('load %j for module %j'\x2C filename\x2C this.id);\n\n  assert(!this.loaded);\n  this.filename = filename;\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  const extension = findLongestRegisteredExtension(filename);\n  // allow .mjs to be overridden\n  if (StringPrototypeEndsWith(filename\x2C '.mjs') && !Module._extensions['.mjs'])\n    throw new ERR_REQUIRE_ESM(filename\x2C true);\n\n  Module._extensions[extension](this\x2C filename);\n  this.loaded = true;\n\n  const esmLoader = asyncESM.esmLoader;\n  // Create module entry at load time to snapshot exports correctly\n  const exports = this.exports;\n  // Preemptively cache\n  if ((module?.module === undefined ||\n       module.module.getStatus() < kEvaluated) &&\n      !esmLoader.cjsCache.has(this))\n    esmLoader.cjsCache.set(this\x2C exports);\n};\n\n// Loads a module at the given file path. Returns that module's\n// `exports` property.\n// Note: when using the experimental policy mechanism this function is overridden\nModule.prototype.require = function(id) {\n  validateString(id\x2C 'id');\n  if (id === '') {\n    throw new ERR_INVALID_ARG_VALUE('id'\x2C id\x2C\n                                    'must be a non-empty string');\n  }\n  requireDepth++;\n  try {\n    return Module._load(id\x2C this\x2C /* isMain */ false);\n  } finally {\n    requireDepth--;\n  }\n};\n\n// Resolved path to process.argv[1] will be lazily placed here\n// (needed for setting breakpoint when called with --inspect-brk)\nlet resolvedArgv;\nlet hasPausedEntry = false;\n\nfunction wrapSafe(filename\x2C content\x2C cjsModuleInstance) {\n  if (patched) {\n    const wrapper = Module.wrap(content);\n    const script = new Script(wrapper\x2C {\n      filename\x2C\n      lineOffset: 0\x2C\n      importModuleDynamically: async (specifier\x2C _\x2C importAssertions) => {\n        const loader = asyncESM.esmLoader;\n        return loader.import(specifier\x2C normalizeReferrerURL(filename)\x2C\n                             importAssertions);\n      }\x2C\n    });\n\n    // Cache the source map for the module if present.\n    if (script.sourceMapURL) {\n      maybeCacheSourceMap(filename\x2C content\x2C this\x2C false\x2C undefined\x2C script.sourceMapURL);\n    }\n\n    return script.runInThisContext({\n      displayErrors: true\x2C\n    });\n  }\n\n  try {\n    const result = internalCompileFunction(content\x2C [\n      'exports'\x2C\n      'require'\x2C\n      'module'\x2C\n      '__filename'\x2C\n      '__dirname'\x2C\n    ]\x2C {\n      filename\x2C\n      importModuleDynamically(specifier\x2C _\x2C importAssertions) {\n        const loader = asyncESM.esmLoader;\n        return loader.import(specifier\x2C normalizeReferrerURL(filename)\x2C\n                             importAssertions);\n      }\x2C\n    });\n\n    // Cache the source map for the module if present.\n    if (result.sourceMapURL) {\n      maybeCacheSourceMap(filename\x2C content\x2C this\x2C false\x2C undefined\x2C result.sourceMapURL);\n    }\n\n    return result.function;\n  } catch (err) {\n    if (process.mainModule === cjsModuleInstance)\n      enrichCJSError(err\x2C content);\n    throw err;\n  }\n}\n\n// Run the file contents in the correct scope or sandbox. Expose\n// the correct helper variables (require\x2C module\x2C exports) to\n// the file.\n// Returns exception\x2C if any.\nModule.prototype._compile = function(content\x2C filename) {\n  let moduleURL;\n  let redirects;\n  const manifest = policy?.manifest;\n  if (manifest) {\n    moduleURL = pathToFileURL(filename);\n    redirects = manifest.getDependencyMapper(moduleURL);\n    manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  const compiledWrapper = wrapSafe(filename\x2C content\x2C this);\n\n  let inspectorWrapper = null;\n  if (getOptionValue('--inspect-brk') && process._eval == null) {\n    if (!resolvedArgv) {\n      // We enter the repl if we're not given a filename argument.\n      if (process.argv[1]) {\n        try {\n          resolvedArgv = Module._resolveFilename(process.argv[1]\x2C null\x2C false);\n        } catch {\n          // We only expect this codepath to be reached in the case of a\n          // preloaded module (it will fail earlier with the main entry)\n          assert(ArrayIsArray(getOptionValue('--require')));\n        }\n      } else {\n        resolvedArgv = 'repl';\n      }\n    }\n\n    // Set breakpoint on module start\n    if (resolvedArgv && !hasPausedEntry && filename === resolvedArgv) {\n      hasPausedEntry = true;\n      inspectorWrapper = internalBinding('inspector').callAndPauseOnStart;\n    }\n  }\n  const dirname = path.dirname(filename);\n  const require = makeRequireFunction(this\x2C redirects);\n  let result;\n  const exports = this.exports;\n  const thisValue = exports;\n  const module = this;\n  if (requireDepth === 0) statCache = new SafeMap();\n  if (inspectorWrapper) {\n    result = inspectorWrapper(compiledWrapper\x2C thisValue\x2C exports\x2C\n                              require\x2C module\x2C filename\x2C dirname);\n  } else {\n    result = ReflectApply(compiledWrapper\x2C thisValue\x2C\n                          [exports\x2C require\x2C module\x2C filename\x2C dirname]);\n  }\n  hasLoadedAnyUserCJSModule = true;\n  if (requireDepth === 0) statCache = null;\n  return result;\n};\n\n// Native extension for .js\nModule._extensions['.js'] = function(module\x2C filename) {\n  // If already analyzed the source\x2C then it will be cached.\n  const cached = cjsParseCache.get(module);\n  let content;\n  if (cached?.source) {\n    content = cached.source;\n    cached.source = undefined;\n  } else {\n    content = fs.readFileSync(filename\x2C 'utf8');\n  }\n  if (StringPrototypeEndsWith(filename\x2C '.js')) {\n    const pkg = readPackageScope(filename);\n    // Function require shouldn't be used in ES modules.\n    if (pkg?.data?.type === 'module') {\n      const parent = moduleParentCache.get(module);\n      const parentPath = parent?.filename;\n      const packageJsonPath = path.resolve(pkg.path\x2C 'package.json');\n      const usesEsm = hasEsmSyntax(content);\n      const err = new ERR_REQUIRE_ESM(filename\x2C usesEsm\x2C parentPath\x2C\n                                      packageJsonPath);\n      // Attempt to reconstruct the parent require frame.\n      if (Module._cache[parentPath]) {\n        let parentSource;\n        try {\n          parentSource = fs.readFileSync(parentPath\x2C 'utf8');\n        } catch {\n          // Continue regardless of error.\n        }\n        if (parentSource) {\n          const errLine = StringPrototypeSplit(\n            StringPrototypeSlice(err.stack\x2C StringPrototypeIndexOf(\n              err.stack\x2C '    at '))\x2C '\\n'\x2C 1)[0];\n          const { 1: line\x2C 2: col } =\n              RegExpPrototypeExec(/(\\d+):(\\d+)\\)/\x2C errLine) || [];\n          if (line && col) {\n            const srcLine = StringPrototypeSplit(parentSource\x2C '\\n')[line - 1];\n            const frame = `${parentPath}:${line}\\n${srcLine}\\n${\n              StringPrototypeRepeat(' '\x2C col - 1)}^\\n`;\n            setArrowMessage(err\x2C frame);\n          }\n        }\n      }\n      throw err;\n    }\n  }\n  module._compile(content\x2C filename);\n};\n\n\n// Native extension for .json\nModule._extensions['.json'] = function(module\x2C filename) {\n  const content = fs.readFileSync(filename\x2C 'utf8');\n\n  if (policy?.manifest) {\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  try {\n    setOwnProperty(module\x2C 'exports'\x2C JSONParse(stripBOM(content)));\n  } catch (err) {\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n\n\n// Native extension for .node\nModule._extensions['.node'] = function(module\x2C filename) {\n  if (policy?.manifest) {\n    const content = fs.readFileSync(filename);\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n  // Be aware this doesn't use `content`\n  return process.dlopen(module\x2C path.toNamespacedPath(filename));\n};\n\nfunction createRequireFromPath(filename) {\n  // Allow a directory to be passed as the filename\n  const trailingSlash =\n    StringPrototypeEndsWith(filename\x2C '/') ||\n    (isWindows && StringPrototypeEndsWith(filename\x2C '\\\\'));\n\n  const proxyPath = trailingSlash ?\n    path.join(filename\x2C 'noop.js') :\n    filename;\n\n  const m = new Module(proxyPath);\n  m.filename = proxyPath;\n\n  m.paths = Module._nodeModulePaths(m.path);\n  return makeRequireFunction(m\x2C null);\n}\n\nconst createRequireError = 'must be a file URL object\x2C file URL string\x2C or ' +\n  'absolute path string';\n\nfunction createRequire(filename) {\n  let filepath;\n\n  if (isURL(filename) ||\n      (typeof filename === 'string' && !path.isAbsolute(filename))) {\n    try {\n      filepath = fileURLToPath(filename);\n    } catch {\n      throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C\n                                      createRequireError);\n    }\n  } else if (typeof filename !== 'string') {\n    throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C createRequireError);\n  } else {\n    filepath = filename;\n  }\n  return createRequireFromPath(filepath);\n}\n\nModule.createRequire = createRequire;\n\nModule._initPaths = function() {\n  const homeDir = isWindows ? process.env.USERPROFILE : safeGetenv('HOME');\n  const nodePath = isWindows ? process.env.NODE_PATH : safeGetenv('NODE_PATH');\n\n  // process.execPath is $PREFIX/bin/node except on Windows where it is\n  // $PREFIX\\node.exe where $PREFIX is the root of the Node.js installation.\n  const prefixDir = isWindows ?\n    path.resolve(process.execPath\x2C '..') :\n    path.resolve(process.execPath\x2C '..'\x2C '..');\n\n  const paths = [path.resolve(prefixDir\x2C 'lib'\x2C 'node')];\n\n  if (homeDir) {\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_libraries'));\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_modules'));\n  }\n\n  if (nodePath) {\n    ArrayPrototypeUnshiftApply(paths\x2C ArrayPrototypeFilter(\n      StringPrototypeSplit(nodePath\x2C path.delimiter)\x2C\n      Boolean\x2C\n    ));\n  }\n\n  modulePaths = paths;\n\n  // Clone as a shallow copy\x2C for introspection.\n  Module.globalPaths = ArrayPrototypeSlice(modulePaths);\n};\n\nModule._preloadModules = function(requests) {\n  if (!ArrayIsArray(requests))\n    return;\n\n  isPreloading = true;\n\n  // Preloaded modules have a dummy parent module which is deemed to exist\n  // in the current working directory. This seeds the search path for\n  // preloaded modules.\n  const parent = new Module('internal/preload'\x2C null);\n  try {\n    parent.paths = Module._nodeModulePaths(process.cwd());\n  } catch (e) {\n    if (e.code !== 'ENOENT') {\n      isPreloading = false;\n      throw e;\n    }\n  }\n  for (let n = 0; n < requests.length; n++)\n    internalRequire(parent\x2C requests[n]);\n  isPreloading = false;\n};\n\nModule.syncBuiltinESMExports = function syncBuiltinESMExports() {\n  for (const mod of BuiltinModule.map.values()) {\n    if (mod.canBeRequiredByUsers &&\n        BuiltinModule.canBeRequiredWithoutScheme(mod.id)) {\n      mod.syncExports();\n    }\n  }\n};\n\nModule.isBuiltin = function isBuiltin(moduleName) {\n  return allBuiltins.has(moduleName);\n};\n\n// Backwards compatibility\nModule.Module = Module;\n
code-source-info,0x2b3d46cdf380,465,0,45391,C0O0C4O45391,,
code-creation,Function,10,84167,0x2b3d46ce15c8,2972, node:internal/modules/cjs/loader:1:1,0x2b3d46cdf2f8,~
code-source-info,0x2b3d46ce15c8,465,0,45391,C0O0C490O1159C496O1175C502O1199C508O1225C514O1250C520O1272C526O1293C532O1315C538O1342C544O1365C550O1389C556O1414C562O1444C567O1469C573O1480C579O1489C585O1502C590O1518C596O1542C601O1558C607O1592C613O1616C619O1630C625O1649C631O1682C637O1706C642O1715C648O1731C654O1745C660O1768C666O1779C671O1790C676O1805C682O1815C688O1840C694O1869C700O1896C706O1926C712O1952C718O1977C724O2001C730O2025C736O2131C738O2131C743O2131C745O2204C757O2225C763O2235C769O2243C775O2255C781O2273C811O2219C815O2391C819O2391C825O2373C831O2465C835O2465C841O2440C847O2562C851O2562C857O2522C863O2537C869O2552C875O2696C879O2696C885O2597C890O2610C896O2637C902O2653C908O2676C914O2741C918O2741C924O2730C930O2792C934O2792C940O2764C946O2831C950O2831C954O2831C956O2870C960O2870C964O2870C966O2904C970O2904C974O2904C976O2947C980O2947C984O2947C986O2980C990O2972C996O3017C1004O3017C1010O2994C1016O3066C1020O3066C1024O3066C1026O3138C1034O3138C1040O3123C1046O3235C1054O3235C1060O3235C1066O3202C1072O3385C1076O3385C1082O3270C1088O3287C1094O3303C1100O3324C1106O3347C1112O3371C1118O3453C1122O3453C1128O3434C1134O3507C1142O3507C1146O3507C1148O3575C1156O3575C1160O3575C1162O3655C1166O3663C1172O3667C1176O3655C1178O3760C1186O3760C1196O3804C1203O3760C1205O3984C1206O3984C1208O4153C1212O4153C1218O4153C1224O4015C1230O4042C1236O4076C1242O4097C1248O4132C1254O4208C1258O4208C1264O4189C1270O4267C1278O4267C1283O4392C1287O4392C1293O4319C1299O4342C1305O4356C1311O4368C1317O4447C1321O4447C1327O4434C1333O4497C1337O4497C1341O4497C1343O4564C1347O4564C1353O4545C1359O4632C1367O4632C1373O4617C1379O4745C1383O4745C1389O4674C1395O4693C1401O4718C1407O4805C1411O4813C1419O4822C1422O4805C1424O4865C1427O4865C1431O4865C1433O4905C1434O4905C1436O4924C1437O4924C1439O4949C1440O4949C1442O5708C1444O5708C1446O5714C1458O5735C1464O5775C1472O5802C1480O5714C1485O6545C1487O6545C1492O6545C1494O7322C1499O7372C1503O7372C1549O7353C1592O7342C1603O7349C1615O7389C1629O7431C1639O7431C1651O7469C1655O7469C1665O7326C1744O7573C1750O7551C1764O7536C1774O7536C1776O7621C1780O7635C1790O7635C1800O7661C1816O7662C1826O7721C1834O7751C1840O7773C1848O7792C1855O7808C1863O7806C1871O7828C1878O7848C1886O7846C1894O7868C1901O7889C1909O7887C1917O7927C1921O7927C1923O7931C1931O7950C1939O7971C1940O7971C1942O8029C1946O8029C1948O8125C1956O8239C1965O8272C1977O8399C1994O8229C2004O8229C2006O8539C2018O8560C2027O8599C2039O8632C2051O8539C2061O8693C2073O8714C2082O8756C2094O8797C2106O8693C2116O8891C2125O8893C2140O8927C2148O8955C2165O8927C2175O9001C2183O9036C2200O9001C2210O9228C2218O9256C2243O9305C2251O9428C2266O9326C2280O9510C2290O9534C2298O9657C2313O9555C2327O9739C2335O9228C2345O9773C2349O9773C2359O9806C2379O9807C2391O9773C2393O9854C2409O9870C2419O9868C2427O10183C2431O10183C2441O10183C2443O10972C2445O10972C2447O10985C2459O11006C2468O11053C2480O11087C2492O10985C2502O13218C2506O13218C2516O13218C2518O15840C2525O15840C2527O16845C2535O16862C2543O20830C2550O20830C2552O20907C2556O20915C2564O20907C2566O20923C2570O20986C2578O21010C2588O22595C2596O22619C2604O23766C2612O23793C2620O25615C2632O25653C2644O26030C2658O25615C2668O25615C2670O27320C2678O27333C2686O30492C2694O30516C2702O34576C2706O34583C2720O34598C2728O35593C2732O35600C2746O35618C2754O36055C2755O36055C2757O36090C2758O36090C2760O37739C2764O37746C2778O37765C2786O39614C2790O39621C2804O39640C2812O41436C2816O41443C2830O41464C2838O41882C2842O41889C2856O41910C2864O42723C2870O42773C2876O42723C2878O43349C2884O43370C2892O43388C2900O43406C2908O44376C2916O44399C2924O44995C2932O45024C2940O45246C2948O45263C2956O45367C2962O45381C2971O45390,,
code-creation,Eval,10,84500,0x2b3d46ce5ef0,5, node:internal/modules/package_json_reader:1:1,0x2b3d46ce5d48,~
script-source,466,node:internal/modules/package_json_reader,'use strict';\n\nconst { SafeMap } = primordials;\nconst { internalModuleReadJSON } = internalBinding('fs');\nconst { pathToFileURL } = require('url');\nconst { toNamespacedPath } = require('path');\n\nconst cache = new SafeMap();\n\nlet manifest;\n\n/**\n *\n * @param {string} jsonPath\n */\nfunction read(jsonPath) {\n  if (cache.has(jsonPath)) {\n    return cache.get(jsonPath);\n  }\n\n  const { 0: string\x2C 1: containsKeys } = internalModuleReadJSON(\n    toNamespacedPath(jsonPath)\x2C\n  );\n  const result = { string\x2C containsKeys };\n  const { getOptionValue } = require('internal/options');\n  if (string !== undefined) {\n    if (manifest === undefined) {\n      manifest = getOptionValue('--experimental-policy') ?\n        require('internal/process/policy').manifest :\n        null;\n    }\n    if (manifest !== null) {\n      const jsonURL = pathToFileURL(jsonPath);\n      manifest.assertIntegrity(jsonURL\x2C string);\n    }\n  }\n  cache.set(jsonPath\x2C result);\n  return result;\n}\n\nmodule.exports = { read };\n
code-source-info,0x2b3d46ce5ef0,466,0,984,C0O0C4O984,,
code-creation,Function,10,84667,0x2b3d46ce6040,113, node:internal/modules/package_json_reader:1:1,0x2b3d46ce5e68,~
code-source-info,0x2b3d46ce6040,466,0,984,C0O0C29O23C34O83C37O83C42O56C48O132C54O132C59O114C65O177C71O177C76O156C82O209C84O209C89O209C91O229C92O229C94O957C101O976C107O972C112O983,,
code-creation,Eval,10,85167,0x2b3d46ce6808,5, node:internal/process/esm_loader:1:1,0x2b3d46ce6600,~
script-source,467,node:internal/process/esm_loader,'use strict';\n\nconst {\n  ObjectCreate\x2C\n} = primordials;\n\nconst {\n  ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING\x2C\n} = require('internal/errors').codes;\nconst { ESMLoader } = require('internal/modules/esm/loader');\nconst {\n  hasUncaughtExceptionCaptureCallback\x2C\n} = require('internal/process/execution');\nconst { pathToFileURL } = require('internal/url');\nconst {\n  getModuleFromWrap\x2C\n} = require('internal/vm/module');\n\nexports.initializeImportMetaObject = function(wrap\x2C meta) {\n  const { callbackMap } = internalBinding('module_wrap');\n  if (callbackMap.has(wrap)) {\n    const { initializeImportMeta } = callbackMap.get(wrap);\n    if (initializeImportMeta !== undefined) {\n      initializeImportMeta(meta\x2C getModuleFromWrap(wrap) || wrap);\n    }\n  }\n};\n\nexports.importModuleDynamicallyCallback =\nasync function importModuleDynamicallyCallback(wrap\x2C specifier\x2C assertions) {\n  const { callbackMap } = internalBinding('module_wrap');\n  if (callbackMap.has(wrap)) {\n    const { importModuleDynamically } = callbackMap.get(wrap);\n    if (importModuleDynamically !== undefined) {\n      return importModuleDynamically(\n        specifier\x2C getModuleFromWrap(wrap) || wrap\x2C assertions);\n    }\n  }\n  throw new ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING();\n};\n\nconst esmLoader = new ESMLoader();\nexports.esmLoader = esmLoader;\n\n// Module.runMain() causes loadESM() to re-run (which it should do); however\x2C this should NOT cause\n// ESM to be re-initialised; doing so causes duplicate custom loaders to be added to the public\n// esmLoader.\nlet isESMInitialized = false;\n\n/**\n * Causes side-effects: user-defined loader hooks are added to esmLoader.\n * @returns {void}\n */\nasync function initializeLoader() {\n  if (isESMInitialized) { return; }\n\n  const { getOptionValue } = require('internal/options');\n  const customLoaders = getOptionValue('--experimental-loader');\n\n  if (customLoaders.length === 0) return;\n\n  let cwd;\n  try {\n    cwd = process.cwd() + '/';\n  } catch {\n    cwd = 'file:///';\n  }\n\n  // A separate loader instance is necessary to avoid cross-contamination\n  // between internal Node.js and userland. For example\x2C a module with internal\n  // state (such as a counter) should be independent.\n  const internalEsmLoader = new ESMLoader();\n\n  // Importation must be handled by internal loader to avoid poluting userland\n  const keyedExportsList = await internalEsmLoader.import(\n    customLoaders\x2C\n    pathToFileURL(cwd).href\x2C\n    ObjectCreate(null)\x2C\n  );\n\n  // Hooks must then be added to external/public loader\n  // (so they're triggered in userland)\n  await esmLoader.addCustomLoaders(keyedExportsList);\n\n  isESMInitialized = true;\n}\n\nexports.loadESM = async function loadESM(callback) {\n  try {\n    await initializeLoader();\n    await callback(esmLoader);\n  } catch (err) {\n    if (hasUncaughtExceptionCaptureCallback()) {\n      process._fatalException(err);\n      return;\n    }\n    internalBinding('errors').triggerUncaughtException(\n      err\x2C\n      true\x2C /* fromPromise */\n    );\n  }\n};\n
code-source-info,0x2b3d46ce6808,467,0,2986,C0O0C4O2986,,
code-creation,Function,10,85375,0x2b3d46ce6aa8,188, node:internal/process/esm_loader:1:1,0x2b3d46ce6780,~
code-source-info,0x2b3d46ce6aa8,467,0,2986,C0O0C47O25C53O111C59O111C64O137C69O67C75O167C81O167C86O153C92O258C98O258C103O217C109O323C115O323C120O305C126O381C132O381C137O358C143O413C147O448C151O749C155O789C159O1259C162O1259C167O1259C169O1276C171O1294C175O1541C176O1541C178O2630C182O2646C187O2985,,
tick,0x195a4df24,85417,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
tick,0x100f45fd8,85459,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
tick,0x100f45ffc,85459,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
tick,0x1011f0ac4,85459,1,0x100b1d1ec,6,0x0,0x41ccf059096,0x1100482ec,0x2b3d46ce1b01,0x41ccf0590b7,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
code-creation,Eval,10,85667,0x2b3d46ce8048,5, node:internal/modules/esm/loader:1:1,0x2b3d46ce7b78,~
script-source,468,node:internal/modules/esm/loader,'use strict';\n\n// This is needed to avoid cycles in esm/resolve <-> cjs/loader\nrequire('internal/modules/cjs/loader');\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  FunctionPrototypeCall\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  RegExpPrototypeExec\x2C\n  SafePromiseAllReturnArrayLike\x2C\n  SafeWeakMap\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToUpperCase\x2C\n  globalThis\x2C\n} = primordials;\nconst { MessageChannel } = require('internal/worker/io');\n\nconst {\n  ERR_LOADER_CHAIN_INCOMPLETE\x2C\n  ERR_INTERNAL_ASSERTION\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_RETURN_PROPERTY_VALUE\x2C\n  ERR_INVALID_RETURN_VALUE\x2C\n  ERR_UNKNOWN_MODULE_FORMAT\x2C\n} = require('internal/errors').codes;\nconst { pathToFileURL\x2C isURL\x2C URL } = require('internal/url');\nconst { emitExperimentalWarning } = require('internal/util');\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst {\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst ModuleMap = require('internal/modules/esm/module_map');\nconst ModuleJob = require('internal/modules/esm/module_job');\n\nconst {\n  defaultResolve\x2C\n  DEFAULT_CONDITIONS\x2C\n} = require('internal/modules/esm/resolve');\nconst {\n  initializeImportMeta\x2C\n} = require('internal/modules/esm/initialize_import_meta');\nconst { defaultLoad } = require('internal/modules/esm/load');\nconst { translators } = require(\n  'internal/modules/esm/translators');\nconst { getOptionValue } = require('internal/options');\n\n/**\n * @typedef {object} ExportedHooks\n * @property {Function} globalPreload Global preload hook.\n * @property {Function} resolve Resolve hook.\n * @property {Function} load Load hook.\n */\n\n/**\n * @typedef {Record<string\x2C any>} ModuleExports\n */\n\n/**\n * @typedef {object} KeyedExports\n * @property {ModuleExports} exports The contents of the module.\n * @property {URL['href']} url The URL of the module.\n */\n\n/**\n * @typedef {object} KeyedHook\n * @property {Function} fn The hook function.\n * @property {URL['href']} url The URL of the module.\n */\n\n/**\n * @typedef {'builtin'|'commonjs'|'json'|'module'|'wasm'} ModuleFormat\n */\n\n/**\n * @typedef {ArrayBuffer|TypedArray|string} ModuleSource\n */\n\n// [2] `validate...()`s throw the wrong error\n\nlet emittedSpecifierResolutionWarning = false;\n\n/**\n * A utility function to iterate through a hook chain\x2C track advancement in the\n * chain\x2C and generate and supply the `next<HookName>` argument to the custom\n * hook.\n * @param {KeyedHook[]} chain The whole hook chain.\n * @param {object} meta Properties that change as the current hook advances\n * along the chain.\n * @param {boolean} meta.chainFinished Whether the end of the chain has been\n * reached AND invoked.\n * @param {string} meta.hookErrIdentifier A user-facing identifier to help\n *  pinpoint where an error occurred. Ex "file:///foo.mjs 'resolve'".\n * @param {number} meta.hookIndex A non-negative integer tracking the current\n * position in the hook chain.\n * @param {string} meta.hookName The kind of hook the chain is (ex 'resolve')\n * @param {boolean} meta.shortCircuited Whether a hook signaled a short-circuit.\n * @param {(hookErrIdentifier\x2C hookArgs) => void} validate A wrapper function\n *  containing all validation of a custom loader hook's intermediary output. Any\n *  validation within MUST throw.\n * @returns {function next<HookName>(...hookArgs)} The next hook in the chain.\n */\nfunction nextHookFactory(chain\x2C meta\x2C { validateArgs\x2C validateOutput }) {\n  // First\x2C prepare the current\n  const { hookName } = meta;\n  const {\n    fn: hook\x2C\n    url: hookFilePath\x2C\n  } = chain[meta.hookIndex];\n\n  // ex 'nextResolve'\n  const nextHookName = `next${\n    StringPrototypeToUpperCase(hookName[0]) +\n    StringPrototypeSlice(hookName\x2C 1)\n  }`;\n\n  // When hookIndex is 0\x2C it's reached the default\x2C which does not call next()\n  // so feed it a noop that blows up if called\x2C so the problem is obvious.\n  const generatedHookIndex = meta.hookIndex;\n  let nextNextHook;\n  if (meta.hookIndex > 0) {\n    // Now\x2C prepare the next: decrement the pointer so the next call to the\n    // factory generates the next link in the chain.\n    meta.hookIndex--;\n\n    nextNextHook = nextHookFactory(chain\x2C meta\x2C { validateArgs\x2C validateOutput });\n  } else {\n    // eslint-disable-next-line func-name-matching\n    nextNextHook = function chainAdvancedTooFar() {\n      throw new ERR_INTERNAL_ASSERTION(\n        `ESM custom loader '${hookName}' advanced beyond the end of the chain.`\x2C\n      );\n    };\n  }\n\n  return ObjectDefineProperty(\n    async (arg0 = undefined\x2C context) => {\n      // Update only when hook is invoked to avoid fingering the wrong filePath\n      meta.hookErrIdentifier = `${hookFilePath} '${hookName}'`;\n\n      validateArgs(`${meta.hookErrIdentifier} hook's ${nextHookName}()`\x2C arg0\x2C context);\n\n      const outputErrIdentifier = `${chain[generatedHookIndex].url} '${hookName}' hook's ${nextHookName}()`;\n\n      // Set when next<HookName> is actually called\x2C not just generated.\n      if (generatedHookIndex === 0) { meta.chainFinished = true; }\n\n      if (context) { // `context` has already been validated\x2C so no fancy check needed.\n        ObjectAssign(meta.context\x2C context);\n      }\n\n      const output = await hook(arg0\x2C meta.context\x2C nextNextHook);\n\n      validateOutput(outputErrIdentifier\x2C output);\n\n      if (output?.shortCircuit === true) { meta.shortCircuited = true; }\n      return output;\n\n    }\x2C\n    'name'\x2C\n    { __proto__: null\x2C value: nextHookName }\x2C\n  );\n}\n\n/**\n * An ESMLoader instance is used as the main entry point for loading ES modules.\n * Currently\x2C this is a singleton -- there is only one used for loading\n * the main module and everything in its dependency graph.\n */\nclass ESMLoader {\n  #hooks = {\n    /**\n     * Prior to ESM loading. These are called once before any modules are started.\n     * @private\n     * @property {KeyedHook[]} globalPreload Last-in-first-out list of preload hooks.\n     */\n    globalPreload: []\x2C\n\n    /**\n     * Phase 2 of 2 in ESM loading (phase 1 is below).\n     * @private\n     * @property {KeyedHook[]} load Last-in-first-out collection of loader hooks.\n     */\n    load: [\n      {\n        fn: defaultLoad\x2C\n        url: 'node:internal/modules/esm/load'\x2C\n      }\x2C\n    ]\x2C\n\n    /**\n     * Phase 1 of 2 in ESM loading.\n     * @private\n     * @property {KeyedHook[]} resolve Last-in-first-out collection of resolve hooks.\n     */\n    resolve: [\n      {\n        fn: defaultResolve\x2C\n        url: 'node:internal/modules/esm/resolve'\x2C\n      }\x2C\n    ]\x2C\n  };\n\n  #importMetaInitializer = initializeImportMeta;\n\n  /**\n   * Map of already-loaded CJS modules to use\n   */\n  cjsCache = new SafeWeakMap();\n\n  /**\n   * The index for assigning unique URLs to anonymous module evaluation\n   */\n  evalIndex = 0;\n\n  /**\n   * Registry of loaded modules\x2C akin to `require.cache`\n   */\n  moduleMap = new ModuleMap();\n\n  /**\n   * Methods which translate input code or other information into ES modules\n   */\n  translators = translators;\n\n  constructor() {\n    if (getOptionValue('--experimental-loader').length > 0) {\n      emitExperimentalWarning('Custom ESM Loaders');\n    }\n    if (getOptionValue('--experimental-network-imports')) {\n      emitExperimentalWarning('Network Imports');\n    }\n    if (\n      !emittedSpecifierResolutionWarning &&\n      getOptionValue('--experimental-specifier-resolution') === 'node'\n    ) {\n      process.emitWarning(\n        'The Node.js specifier resolution flag is experimental. It could change or be removed at any time.'\x2C\n        'ExperimentalWarning'\x2C\n      );\n      emittedSpecifierResolutionWarning = true;\n    }\n  }\n\n  /**\n   *\n   * @param {ModuleExports} exports\n   * @returns {ExportedHooks}\n   */\n  static pluckHooks({\n    globalPreload\x2C\n    resolve\x2C\n    load\x2C\n    // obsolete hooks:\n    dynamicInstantiate\x2C\n    getFormat\x2C\n    getGlobalPreloadCode\x2C\n    getSource\x2C\n    transformSource\x2C\n  }) {\n    const obsoleteHooks = [];\n    const acceptedHooks = ObjectCreate(null);\n\n    if (getGlobalPreloadCode) {\n      globalPreload ??= getGlobalPreloadCode;\n\n      process.emitWarning(\n        'Loader hook "getGlobalPreloadCode" has been renamed to "globalPreload"'\x2C\n      );\n    }\n    if (dynamicInstantiate) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'dynamicInstantiate'\x2C\n    );\n    if (getFormat) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'getFormat'\x2C\n    );\n    if (getSource) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'getSource'\x2C\n    );\n    if (transformSource) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'transformSource'\x2C\n    );\n\n    if (obsoleteHooks.length) process.emitWarning(\n      `Obsolete loader hook(s) supplied and will be ignored: ${\n        ArrayPrototypeJoin(obsoleteHooks\x2C '\x2C ')\n      }`\x2C\n      'DeprecationWarning'\x2C\n    );\n\n    if (globalPreload) {\n      acceptedHooks.globalPreload = globalPreload;\n    }\n    if (resolve) {\n      acceptedHooks.resolve = resolve;\n    }\n    if (load) {\n      acceptedHooks.load = load;\n    }\n\n    return acceptedHooks;\n  }\n\n  /**\n   * Collect custom/user-defined hook(s). After all hooks have been collected\x2C\n   * calls global preload hook(s).\n   * @param {KeyedExports} customLoaders\n   *  A list of exports from user-defined loaders (as returned by\n   *  ESMLoader.import()).\n   */\n  addCustomLoaders(\n    customLoaders = []\x2C\n  ) {\n    for (let i = 0; i < customLoaders.length; i++) {\n      const {\n        exports\x2C\n        url\x2C\n      } = customLoaders[i];\n      const {\n        globalPreload\x2C\n        resolve\x2C\n        load\x2C\n      } = ESMLoader.pluckHooks(exports);\n\n      if (globalPreload) {\n        ArrayPrototypePush(\n          this.#hooks.globalPreload\x2C\n          {\n            fn: globalPreload\x2C\n            url\x2C\n          }\x2C\n        );\n      }\n      if (resolve) {\n        ArrayPrototypePush(\n          this.#hooks.resolve\x2C\n          {\n            fn: resolve\x2C\n            url\x2C\n          }\x2C\n        );\n      }\n      if (load) {\n        ArrayPrototypePush(\n          this.#hooks.load\x2C\n          {\n            fn: load\x2C\n            url\x2C\n          }\x2C\n        );\n      }\n    }\n\n    this.preload();\n  }\n\n  async eval(\n    source\x2C\n    url = pathToFileURL(`${process.cwd()}/[eval${++this.evalIndex}]`).href\x2C\n  ) {\n    const evalInstance = (url) => {\n      const { ModuleWrap\x2C callbackMap } = internalBinding('module_wrap');\n      const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n      callbackMap.set(module\x2C {\n        importModuleDynamically: (specifier\x2C { url }\x2C importAssertions) => {\n          return this.import(specifier\x2C url\x2C importAssertions);\n        }\x2C\n      });\n\n      return module;\n    };\n    const job = new ModuleJob(\n      this\x2C url\x2C undefined\x2C evalInstance\x2C false\x2C false);\n    this.moduleMap.set(url\x2C undefined\x2C job);\n    const { module } = await job.run();\n\n    return {\n      namespace: module.getNamespace()\x2C\n    };\n  }\n\n  /**\n   * Get a (possibly still pending) module job from the cache\x2C\n   * or create one and return its Promise.\n   * @param {string} specifier The string after `from` in an `import` statement\x2C\n   *                           or the first parameter of an `import()`\n   *                           expression\n   * @param {string | undefined} parentURL The URL of the module importing this\n   *                                     one\x2C unless this is the Node.js entry\n   *                                     point.\n   * @param {Record<string\x2C string>} importAssertions Validations for the\n   *                                                  module import.\n   * @returns {Promise<ModuleJob>} The (possibly pending) module job\n   */\n  async getModuleJob(specifier\x2C parentURL\x2C importAssertions) {\n    let importAssertionsForResolve;\n\n    // By default\x2C `this.#hooks.load` contains just the Node default load hook\n    if (this.#hooks.load.length !== 1) {\n      // We can skip cloning if there are no user-provided loaders because\n      // the Node.js default resolve hook does not use import assertions.\n      importAssertionsForResolve = {\n        __proto__: null\x2C\n        ...importAssertions\x2C\n      };\n    }\n\n    const { format\x2C url } =\n      await this.resolve(specifier\x2C parentURL\x2C importAssertionsForResolve);\n\n    let job = this.moduleMap.get(url\x2C importAssertions.type);\n\n    // CommonJS will set functions for lazy job evaluation.\n    if (typeof job === 'function') {\n      this.moduleMap.set(url\x2C undefined\x2C job = job());\n    }\n\n    if (job === undefined) {\n      job = this.#createModuleJob(url\x2C importAssertions\x2C parentURL\x2C format);\n    }\n\n    return job;\n  }\n\n  /**\n   * Create and cache an object representing a loaded module.\n   * @param {string} url The absolute URL that was resolved for this module\n   * @param {Record<string\x2C string>} importAssertions Validations for the\n   *                                                  module import.\n   * @param {string} [parentURL] The absolute URL of the module importing this\n   *                             one\x2C unless this is the Node.js entry point\n   * @param {string} [format] The format hint possibly returned by the\n   *                          `resolve` hook\n   * @returns {Promise<ModuleJob>} The (possibly pending) module job\n   */\n  #createModuleJob(url\x2C importAssertions\x2C parentURL\x2C format) {\n    const moduleProvider = async (url\x2C isMain) => {\n      const {\n        format: finalFormat\x2C\n        responseURL\x2C\n        source\x2C\n      } = await this.load(url\x2C {\n        format\x2C\n        importAssertions\x2C\n      });\n\n      const translator = translators.get(finalFormat);\n\n      if (!translator) {\n        throw new ERR_UNKNOWN_MODULE_FORMAT(finalFormat\x2C responseURL);\n      }\n\n      return FunctionPrototypeCall(translator\x2C this\x2C responseURL\x2C source\x2C isMain);\n    };\n\n    const inspectBrk = (\n      parentURL === undefined &&\n      getOptionValue('--inspect-brk')\n    );\n\n    if (process.env.WATCH_REPORT_DEPENDENCIES && process.send) {\n      process.send({ 'watch:import': [url] });\n    }\n\n    const job = new ModuleJob(\n      this\x2C\n      url\x2C\n      importAssertions\x2C\n      moduleProvider\x2C\n      parentURL === undefined\x2C\n      inspectBrk\x2C\n    );\n\n    this.moduleMap.set(url\x2C importAssertions.type\x2C job);\n\n    return job;\n  }\n\n  /**\n   * This method is usually called indirectly as part of the loading processes.\n   * Internally\x2C it is used directly to add loaders. Use directly with caution.\n   *\n   * This method must NOT be renamed: it functions as a dynamic import on a\n   * loader module.\n   * @param {string | string[]} specifiers Path(s) to the module.\n   * @param {string} parentURL Path of the parent importing the module.\n   * @param {Record<string\x2C string>} importAssertions Validations for the\n   *                                                  module import.\n   * @returns {Promise<ExportedHooks | KeyedExports[]>}\n   *  A collection of module export(s) or a list of collections of module\n   *  export(s).\n   */\n  async import(specifiers\x2C parentURL\x2C importAssertions) {\n    // For loaders\x2C `import` is passed multiple things to process\x2C it returns a\n    // list pairing the url and exports collected. This is especially useful for\n    // error messaging\x2C to identity from where an export came. But\x2C in most\n    // cases\x2C only a single url is being "imported" (ex `import()`)\x2C so there is\n    // only 1 possible url from which the exports were collected and it is\n    // already known to the caller. Nesting that in a list would only ever\n    // create redundant work for the caller\x2C so it is later popped off the\n    // internal list.\n    const wasArr = ArrayIsArray(specifiers);\n    if (!wasArr) { specifiers = [specifiers]; }\n\n    const count = specifiers.length;\n    const jobs = new Array(count);\n\n    for (let i = 0; i < count; i++) {\n      jobs[i] = this.getModuleJob(specifiers[i]\x2C parentURL\x2C importAssertions)\n        .then((job) => job.run())\n        .then(({ module }) => module.getNamespace());\n    }\n\n    const namespaces = await SafePromiseAllReturnArrayLike(jobs);\n\n    if (!wasArr) { return namespaces[0]; } // We can skip the pairing below\n\n    for (let i = 0; i < count; i++) {\n      namespaces[i] = {\n        __proto__: null\x2C\n        url: specifiers[i]\x2C\n        exports: namespaces[i]\x2C\n      };\n    }\n\n    return namespaces;\n  }\n\n  /**\n   * Provide source that is understood by one of Node's translators.\n   *\n   * Internally\x2C this behaves like a backwards iterator\x2C wherein the stack of\n   * hooks starts at the top and each call to `nextLoad()` moves down 1 step\n   * until it reaches the bottom or short-circuits.\n   * @param {URL['href']} url The URL/path of the module to be loaded\n   * @param {object} context Metadata about the module\n   * @returns {{ format: ModuleFormat\x2C source: ModuleSource }}\n   */\n  async load(url\x2C context = {}) {\n    const chain = this.#hooks.load;\n    const meta = {\n      chainFinished: null\x2C\n      context\x2C\n      hookErrIdentifier: ''\x2C\n      hookIndex: chain.length - 1\x2C\n      hookName: 'load'\x2C\n      shortCircuited: false\x2C\n    };\n\n    const validateArgs = (hookErrIdentifier\x2C nextUrl\x2C ctx) => {\n      if (typeof nextUrl !== 'string') {\n        // non-strings can be coerced to a url string\n        // validateString() throws a less-specific error\n        throw new ERR_INVALID_ARG_TYPE(\n          `${hookErrIdentifier} url`\x2C\n          'a url string'\x2C\n          nextUrl\x2C\n        );\n      }\n\n      // Try to avoid expensive URL instantiation for known-good urls\n      if (!this.moduleMap.has(nextUrl)) {\n        try {\n          new URL(nextUrl);\n        } catch {\n          throw new ERR_INVALID_ARG_VALUE(\n            `${hookErrIdentifier} url`\x2C\n            nextUrl\x2C\n            'should be a url string'\x2C\n          );\n        }\n      }\n\n      if (ctx) validateObject(ctx\x2C `${hookErrIdentifier} context`);\n    };\n    const validateOutput = (hookErrIdentifier\x2C output) => {\n      if (typeof output !== 'object' || output === null) { // [2]\n        throw new ERR_INVALID_RETURN_VALUE(\n          'an object'\x2C\n          hookErrIdentifier\x2C\n          output\x2C\n        );\n      }\n    };\n\n    const nextLoad = nextHookFactory(chain\x2C meta\x2C { validateArgs\x2C validateOutput });\n\n    const loaded = await nextLoad(url\x2C context);\n    const { hookErrIdentifier } = meta; // Retrieve the value after all settled\n\n    validateOutput(hookErrIdentifier\x2C loaded);\n\n    if (loaded?.shortCircuit === true) { meta.shortCircuited = true; }\n\n    if (!meta.chainFinished && !meta.shortCircuited) {\n      throw new ERR_LOADER_CHAIN_INCOMPLETE(hookErrIdentifier);\n    }\n\n    const {\n      format\x2C\n      source\x2C\n    } = loaded;\n    let responseURL = loaded.responseURL;\n\n    if (responseURL === undefined) {\n      responseURL = url;\n    }\n\n    let responseURLObj;\n    if (typeof responseURL === 'string') {\n      try {\n        responseURLObj = new URL(responseURL);\n      } catch {\n        // responseURLObj not defined will throw in next branch.\n      }\n    }\n\n    if (responseURLObj?.href !== responseURL) {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'undefined or a fully resolved URL string'\x2C\n        hookErrIdentifier\x2C\n        'responseURL'\x2C\n        responseURL\x2C\n      );\n    }\n\n    if (format == null) {\n      const dataUrl = RegExpPrototypeExec(\n        /^data:([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\n        url\x2C\n      );\n\n      throw new ERR_UNKNOWN_MODULE_FORMAT(\n        dataUrl ? dataUrl[1] : format\x2C\n        url);\n    }\n\n    if (typeof format !== 'string') { // [2]\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'a string'\x2C\n        hookErrIdentifier\x2C\n        'format'\x2C\n        format\x2C\n      );\n    }\n\n    if (\n      source != null &&\n      typeof source !== 'string' &&\n      !isAnyArrayBuffer(source) &&\n      !isArrayBufferView(source)\n    ) {\n      throw ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'a string\x2C an ArrayBuffer\x2C or a TypedArray'\x2C\n        hookErrIdentifier\x2C\n        'source'\x2C\n        source\x2C\n      );\n    }\n\n    return {\n      __proto__: null\x2C\n      format\x2C\n      responseURL\x2C\n      source\x2C\n    };\n  }\n\n  preload() {\n    for (let i = this.#hooks.globalPreload.length - 1; i >= 0; i--) {\n      const channel = new MessageChannel();\n      const {\n        port1: insidePreload\x2C\n        port2: insideLoader\x2C\n      } = channel;\n\n      insidePreload.unref();\n      insideLoader.unref();\n\n      const {\n        fn: preload\x2C\n        url: specifier\x2C\n      } = this.#hooks.globalPreload[i];\n\n      const preloaded = preload({\n        port: insideLoader\x2C\n      });\n\n      if (preloaded == null) { return; }\n\n      const hookErrIdentifier = `${specifier} globalPreload`;\n\n      if (typeof preloaded !== 'string') { // [2]\n        throw new ERR_INVALID_RETURN_VALUE(\n          'a string'\x2C\n          hookErrIdentifier\x2C\n          preload\x2C\n        );\n      }\n      const { compileFunction } = require('vm');\n      const preloadInit = compileFunction(\n        preloaded\x2C\n        ['getBuiltin'\x2C 'port'\x2C 'setImportMetaCallback']\x2C\n        {\n          filename: '<preload>'\x2C\n        }\x2C\n      );\n      const { BuiltinModule } = require('internal/bootstrap/loaders');\n      // We only allow replacing the importMetaInitializer during preload\x2C\n      // after preload is finished\x2C we disable the ability to replace it\n      //\n      // This exposes accidentally setting the initializer too late by\n      // throwing an error.\n      let finished = false;\n      let replacedImportMetaInitializer = false;\n      let next = this.#importMetaInitializer;\n      try {\n        // Calls the compiled preload source text gotten from the hook\n        // Since the parameters are named we use positional parameters\n        // see compileFunction above to cross reference the names\n        FunctionPrototypeCall(\n          preloadInit\x2C\n          globalThis\x2C\n          // Param getBuiltin\n          (builtinName) => {\n            if (BuiltinModule.canBeRequiredByUsers(builtinName) &&\n                BuiltinModule.canBeRequiredWithoutScheme(builtinName)) {\n              return require(builtinName);\n            }\n            throw new ERR_INVALID_ARG_VALUE('builtinName'\x2C builtinName);\n          }\x2C\n          // Param port\n          insidePreload\x2C\n          // Param setImportMetaCallback\n          (fn) => {\n            if (finished || typeof fn !== 'function') {\n              throw new ERR_INVALID_ARG_TYPE('fn'\x2C fn);\n            }\n            replacedImportMetaInitializer = true;\n            const parent = next;\n            next = (meta\x2C context) => {\n              return fn(meta\x2C context\x2C parent);\n            };\n          });\n      } finally {\n        finished = true;\n        if (replacedImportMetaInitializer) {\n          this.#importMetaInitializer = next;\n        }\n      }\n    }\n  }\n\n  importMetaInitialize(meta\x2C context) {\n    this.#importMetaInitializer(meta\x2C context);\n  }\n\n  /**\n   * Resolve the location of the module.\n   *\n   * Internally\x2C this behaves like a backwards iterator\x2C wherein the stack of\n   * hooks starts at the top and each call to `nextResolve()` moves down 1 step\n   * until it reaches the bottom or short-circuits.\n   * @param {string} originalSpecifier The specified URL path of the module to\n   *                                   be resolved.\n   * @param {string} [parentURL] The URL path of the module's parent.\n   * @param {ImportAssertions} importAssertions Assertions from the import\n   *                                              statement or expression.\n   * @returns {{ format: string\x2C url: URL['href'] }}\n   */\n  async resolve(originalSpecifier\x2C parentURL\x2C importAssertions) {\n    const isMain = parentURL === undefined;\n\n    if (\n      !isMain &&\n      typeof parentURL !== 'string' &&\n      !isURL(parentURL)\n    ) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'parentURL'\x2C\n        ['string'\x2C 'URL']\x2C\n        parentURL\x2C\n      );\n    }\n    const chain = this.#hooks.resolve;\n    const context = {\n      conditions: DEFAULT_CONDITIONS\x2C\n      importAssertions\x2C\n      parentURL\x2C\n    };\n    const meta = {\n      chainFinished: null\x2C\n      context\x2C\n      hookErrIdentifier: ''\x2C\n      hookIndex: chain.length - 1\x2C\n      hookName: 'resolve'\x2C\n      shortCircuited: false\x2C\n    };\n\n    const validateArgs = (hookErrIdentifier\x2C suppliedSpecifier\x2C ctx) => {\n      validateString(\n        suppliedSpecifier\x2C\n        `${hookErrIdentifier} specifier`\x2C\n      ); // non-strings can be coerced to a url string\n\n      if (ctx) validateObject(ctx\x2C `${hookErrIdentifier} context`);\n    };\n    const validateOutput = (hookErrIdentifier\x2C output) => {\n      if (typeof output !== 'object' || output === null) { // [2]\n        throw new ERR_INVALID_RETURN_VALUE(\n          'an object'\x2C\n          hookErrIdentifier\x2C\n          output\x2C\n        );\n      }\n    };\n\n    const nextResolve = nextHookFactory(chain\x2C meta\x2C { validateArgs\x2C validateOutput });\n\n    const resolution = await nextResolve(originalSpecifier\x2C context);\n    const { hookErrIdentifier } = meta; // Retrieve the value after all settled\n\n    validateOutput(hookErrIdentifier\x2C resolution);\n\n    if (resolution?.shortCircuit === true) { meta.shortCircuited = true; }\n\n    if (!meta.chainFinished && !meta.shortCircuited) {\n      throw new ERR_LOADER_CHAIN_INCOMPLETE(hookErrIdentifier);\n    }\n\n    const {\n      format\x2C\n      url\x2C\n    } = resolution;\n\n    if (\n      format != null &&\n      typeof format !== 'string' // [2]\n    ) {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'a string'\x2C\n        hookErrIdentifier\x2C\n        'format'\x2C\n        format\x2C\n      );\n    }\n\n    if (typeof url !== 'string') {\n      // non-strings can be coerced to a url string\n      // validateString() throws a less-specific error\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'a url string'\x2C\n        hookErrIdentifier\x2C\n        'url'\x2C\n        url\x2C\n      );\n    }\n\n    // Try to avoid expensive URL instantiation for known-good urls\n    if (!this.moduleMap.has(url)) {\n      try {\n        new URL(url);\n      } catch {\n        throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n          'a url string'\x2C\n          hookErrIdentifier\x2C\n          'url'\x2C\n          url\x2C\n        );\n      }\n    }\n\n    return {\n      __proto__: null\x2C\n      format\x2C\n      url\x2C\n    };\n  }\n}\n\nObjectSetPrototypeOf(ESMLoader.prototype\x2C null);\n\nexports.ESMLoader = ESMLoader;\n
code-source-info,0x2b3d46ce8048,468,0,26117,C0O0C4O26117,,
code-creation,Function,10,87084,0x2b3d46ce8940,677, node:internal/modules/esm/loader:1:1,0x2b3d46ce7fc0,~
code-source-info,0x2b3d46ce8940,468,0,26117,C0O0C140O79C146O79C150O130C156O139C162O155C168O177C174O199C180O224C186O240C192O256C198O280C203O304C209O327C215O360C221O375C227O399C233O429C239O485C245O485C250O466C256O729C262O729C267O755C272O527C278O558C284O584C290O608C296O633C302O670C308O698C314O801C320O801C325O771C331O786C337O793C343O862C349O862C354O834C360O941C366O941C371O898C377O918C383O1021C389O1021C394O983C400O1001C406O1071C412O1071C416O1071C418O1133C424O1133C428O1133C430O1230C436O1230C441O1188C447O1206C453O1307C459O1307C464O1281C470O1387C476O1387C481O1371C487O1449C493O1449C498O1433C504O1524C510O1524C515O1505C521O2335C522O2335C657O26067C664O26036C669O26086C671O26104C676O26116,,
code-creation,Function,10,87084,0x2b3d46ce8f10,144,<instance_members_initializer> node:internal/modules/esm/loader:181:1,0x2b3d46ce8468,~
code-source-info,0x2b3d46ce8f10,468,5756,26034,C3O5785C8O6191C24O6213C42O6457C58O6479C85O6594C95O6688C102O6688C111O6806C116O6893C123O6893C132O7016C143O26034,,
tick,0x195a849cc,87125,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x2b3d46ce6af9,0x41ccf0590b7,0x1100482ec,0x2b3d46ce1b01,0x41ccf0590b7,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
code-creation,Eval,10,87375,0x2b3d46ceb158,5, node:internal/modules/esm/module_map:1:1,0x2b3d46ceaf58,~
script-source,469,node:internal/modules/esm/module_map,'use strict';\n\nconst ModuleJob = require('internal/modules/esm/module_job');\nconst { kImplicitAssertType } = require('internal/modules/esm/assert');\nconst {\n  ObjectCreate\x2C\n  SafeMap\x2C\n} = primordials;\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { ERR_INVALID_ARG_TYPE } = require('internal/errors').codes;\nconst { validateString } = require('internal/validators');\n\n// Tracks the state of the loader-level module cache\nclass ModuleMap extends SafeMap {\n  constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  get(url\x2C type = kImplicitAssertType) {\n    validateString(url\x2C 'url');\n    validateString(type\x2C 'type');\n    return super.get(url)?.[type];\n  }\n  set(url\x2C type = kImplicitAssertType\x2C job) {\n    validateString(url\x2C 'url');\n    validateString(type\x2C 'type');\n    if (job instanceof ModuleJob !== true &&\n        typeof job !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE('job'\x2C 'ModuleJob'\x2C job);\n    }\n    debug(`Storing ${url} (${\n      type === kImplicitAssertType ? 'implicit type' : type\n    }) in ModuleMap`);\n    const cachedJobsForUrl = super.get(url) ?? ObjectCreate(null);\n    cachedJobsForUrl[type] = job;\n    return super.set(url\x2C cachedJobsForUrl);\n  }\n  has(url\x2C type = kImplicitAssertType) {\n    validateString(url\x2C 'url');\n    validateString(type\x2C 'type');\n    return super.get(url)?.[type] !== undefined;\n  }\n}\nmodule.exports = ModuleMap;\n
code-source-info,0x2b3d46ceb158,469,0,1444,C0O0C4O1444,,
code-creation,Function,10,87459,0x2b3d46ceb590,175, node:internal/modules/esm/module_map:1:1,0x2b3d46ceb0d0,~
code-source-info,0x2b3d46ceb590,469,0,1444,C0O0C23O33C26O33C30O33C32O109C35O109C40O85C46O159C52O175C57O213C60O213C65O246C78O247C84O213C86O324C89O324C94O350C99O299C105O385C108O385C113O366C123O495C167O1416C169O1431C174O1443,,
code-creation,Eval,10,87709,0x2b3d46cec0b8,5, node:internal/modules/esm/module_job:1:1,0x2b3d46cebde0,~
script-source,470,node:internal/modules/esm/module_job,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSome\x2C\n  FunctionPrototype\x2C\n  ObjectCreate\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseResolve\x2C\n  PromisePrototypeThen\x2C\n  ReflectApply\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  SafePromiseAllReturnArrayLike\x2C\n  SafePromiseAllReturnVoid\x2C\n  SafeSet\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\nconst { ModuleWrap } = internalBinding('module_wrap');\n\nconst { decorateErrorStack } = require('internal/util');\nconst {\n  getSourceMapsEnabled\x2C\n} = require('internal/source_map/source_map_cache');\nconst assert = require('internal/assert');\nconst resolvedPromise = PromiseResolve();\n\nconst noop = FunctionPrototype;\n\nlet hasPausedEntry = false;\n\nconst CJSGlobalLike = [\n  'require'\x2C\n  'module'\x2C\n  'exports'\x2C\n  '__filename'\x2C\n  '__dirname'\x2C\n];\nconst isCommonJSGlobalLikeNotDefinedError = (errorMessage) =>\n  ArrayPrototypeSome(\n    CJSGlobalLike\x2C\n    (globalLike) => errorMessage === `${globalLike} is not defined`\x2C\n  );\n\n/* A ModuleJob tracks the loading of a single Module\x2C and the ModuleJobs of\n * its dependencies\x2C over time. */\nclass ModuleJob {\n  // `loader` is the Loader instance used for loading dependencies.\n  // `moduleProvider` is a function\n  constructor(loader\x2C url\x2C importAssertions = ObjectCreate(null)\x2C\n              moduleProvider\x2C isMain\x2C inspectBrk) {\n    this.loader = loader;\n    this.importAssertions = importAssertions;\n    this.isMain = isMain;\n    this.inspectBrk = inspectBrk;\n\n    this.module = undefined;\n    // Expose the promise to the ModuleWrap directly for linking below.\n    // `this.module` is also filled in below.\n    this.modulePromise = ReflectApply(moduleProvider\x2C loader\x2C [url\x2C isMain]);\n\n    // Wait for the ModuleWrap instance being linked with all dependencies.\n    const link = async () => {\n      this.module = await this.modulePromise;\n      assert(this.module instanceof ModuleWrap);\n\n      // Explicitly keeping track of dependency jobs is needed in order\n      // to flatten out the dependency graph below in `_instantiate()`\x2C\n      // so that circular dependencies can't cause a deadlock by two of\n      // these `link` callbacks depending on each other.\n      const dependencyJobs = [];\n      const promises = this.module.link(async (specifier\x2C assertions) => {\n        const jobPromise = this.loader.getModuleJob(specifier\x2C url\x2C assertions);\n        ArrayPrototypePush(dependencyJobs\x2C jobPromise);\n        const job = await jobPromise;\n        return job.modulePromise;\n      });\n\n      if (promises !== undefined)\n        await SafePromiseAllReturnVoid(promises);\n\n      return SafePromiseAllReturnArrayLike(dependencyJobs);\n    };\n    // Promise for the list of all dependencyJobs.\n    this.linked = link();\n    // This promise is awaited later anyway\x2C so silence\n    // 'unhandled rejection' warnings.\n    PromisePrototypeThen(this.linked\x2C undefined\x2C noop);\n\n    // instantiated == deep dependency jobs wrappers are instantiated\x2C\n    // and module wrapper is instantiated.\n    this.instantiated = undefined;\n  }\n\n  instantiate() {\n    if (this.instantiated === undefined) {\n      this.instantiated = this._instantiate();\n    }\n    return this.instantiated;\n  }\n\n  async _instantiate() {\n    const jobsInGraph = new SafeSet();\n    const addJobsToDependencyGraph = async (moduleJob) => {\n      if (jobsInGraph.has(moduleJob)) {\n        return;\n      }\n      jobsInGraph.add(moduleJob);\n      const dependencyJobs = await moduleJob.linked;\n      return SafePromiseAllReturnVoid(dependencyJobs\x2C addJobsToDependencyGraph);\n    };\n    await addJobsToDependencyGraph(this);\n\n    try {\n      if (!hasPausedEntry && this.inspectBrk) {\n        hasPausedEntry = true;\n        const initWrapper = internalBinding('inspector').callAndPauseOnStart;\n        initWrapper(this.module.instantiate\x2C this.module);\n      } else {\n        this.module.instantiate();\n      }\n    } catch (e) {\n      decorateErrorStack(e);\n      // TODO(@bcoe): Add source map support to exception that occurs as result\n      // of missing named export. This is currently not possible because\n      // stack trace originates in module_job\x2C not the file itself. A hidden\n      // symbol with filename could be set in node_errors.cc to facilitate this.\n      if (!getSourceMapsEnabled() &&\n          StringPrototypeIncludes(e.message\x2C\n                                  ' does not provide an export named')) {\n        const splitStack = StringPrototypeSplit(e.stack\x2C '\\n');\n        const parentFileUrl = RegExpPrototypeSymbolReplace(\n          /:\\d+$/\x2C\n          splitStack[0]\x2C\n          ''\x2C\n        );\n        const { 1: childSpecifier\x2C 2: name } = RegExpPrototypeExec(\n          /module '(.*)' does not provide an export named '(.+)'/\x2C\n          e.message);\n        const { url: childFileURL } = await this.loader.resolve(\n          childSpecifier\x2C parentFileUrl\x2C\n        );\n        let format;\n        try {\n          // This might throw for non-CommonJS modules because we aren't passing\n          // in the import assertions and some formats require them; but we only\n          // care about CommonJS for the purposes of this error message.\n          ({ format } =\n            await this.loader.load(childFileURL));\n        } catch {\n          // Continue regardless of error.\n        }\n\n        if (format === 'commonjs') {\n          const importStatement = splitStack[1];\n          // TODO(@ctavan): The original error stack only provides the single\n          // line which causes the error. For multi-line import statements we\n          // cannot generate an equivalent object destructuring assignment by\n          // just parsing the error stack.\n          const oneLineNamedImports = RegExpPrototypeExec(/{.*}/\x2C importStatement);\n          const destructuringAssignment = oneLineNamedImports &&\n            RegExpPrototypeSymbolReplace(/\\s+as\\s+/g\x2C oneLineNamedImports\x2C ': ');\n          e.message = `Named export '${name}' not found. The requested module` +\n            ` '${childSpecifier}' is a CommonJS module\x2C which may not support` +\n            ' all module.exports as named exports.\\nCommonJS modules can ' +\n            'always be imported via the default export\x2C for example using:' +\n            `\\n\\nimport pkg from '${childSpecifier}';\\n${\n              destructuringAssignment ?\n                `const ${destructuringAssignment} = pkg;\\n` : ''}`;\n          const newStack = StringPrototypeSplit(e.stack\x2C '\\n');\n          newStack[3] = `SyntaxError: ${e.message}`;\n          e.stack = ArrayPrototypeJoin(newStack\x2C '\\n');\n        }\n      }\n      throw e;\n    }\n\n    for (const dependencyJob of jobsInGraph) {\n      // Calling `this.module.instantiate()` instantiates not only the\n      // ModuleWrap in this module\x2C but all modules in the graph.\n      dependencyJob.instantiated = resolvedPromise;\n    }\n  }\n\n  async run() {\n    await this.instantiate();\n    const timeout = -1;\n    const breakOnSigint = false;\n    try {\n      await this.module.evaluate(timeout\x2C breakOnSigint);\n    } catch (e) {\n      if (e?.name === 'ReferenceError' &&\n          isCommonJSGlobalLikeNotDefinedError(e.message)) {\n        e.message += ' in ES module scope';\n\n        if (StringPrototypeStartsWith(e.message\x2C 'require ')) {\n          e.message += '\x2C you can use import instead';\n        }\n\n        const packageConfig =\n          StringPrototypeStartsWith(this.module.url\x2C 'file://') &&\n            RegExpPrototypeExec(/\\.js(\\?[^#]*)?(#.*)?$/\x2C this.module.url) !== null &&\n            require('internal/modules/esm/resolve')\n              .getPackageScopeConfig(this.module.url);\n        if (packageConfig.type === 'module') {\n          e.message +=\n            '\\nThis file is being treated as an ES module because it has a ' +\n            `'.js' file extension and '${packageConfig.pjsonPath}' contains ` +\n            '"type": "module". To treat it as a CommonJS script\x2C rename it ' +\n            'to use the \\'.cjs\\' file extension.';\n        }\n      }\n      throw e;\n    }\n    return { __proto__: null\x2C module: this.module };\n  }\n}\nObjectSetPrototypeOf(ModuleJob.prototype\x2C null);\nmodule.exports = ModuleJob;\n
code-source-info,0x2b3d46cec0b8,470,0,8165,C0O0C4O8165,,
code-creation,Function,10,88167,0x2b3d46cec5a0,325, node:internal/modules/esm/module_job:1:1,0x2b3d46cec030,~
code-source-info,0x2b3d46cec5a0,470,0,8165,C0O0C82O25C88O47C94O69C100O91C105O112C111O128C116O152C121O170C127O194C133O210C139O233C145O265C151O298C157O326C163O337C169O364C175O388C181O456C187O456C192O441C198O520C204O520C209O497C215O582C221O582C226O556C232O646C238O646C242O646C244O698C247O698C249O730C251O730C253O771C254O771C256O801C260O801C262O919C266O919C305O8119C312O8088C317O8137C319O8152C324O8164,,
code-creation,Eval,10,88292,0x2b3d46cee200,5, node:internal/modules/esm/assert:1:1,0x2b3d46cedfd8,~
script-source,471,node:internal/modules/esm/assert,'use strict';\n\nconst {\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ObjectCreate\x2C\n  ObjectKeys\x2C\n  ObjectValues\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n} = primordials;\nconst { validateString } = require('internal/validators');\n\nconst {\n  ERR_IMPORT_ASSERTION_TYPE_FAILED\x2C\n  ERR_IMPORT_ASSERTION_TYPE_MISSING\x2C\n  ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED\x2C\n} = require('internal/errors').codes;\n\n// The HTML spec has an implied default type of `'javascript'`.\nconst kImplicitAssertType = 'javascript';\n\nlet alreadyWarned = false;\n\n/**\n * Define a map of module formats to import assertion types (the value of\n * `type` in `assert { type: 'json' }`).\n * @type {Map<string\x2C string>}\n */\nconst formatTypeMap = {\n  '__proto__': null\x2C\n  'builtin': kImplicitAssertType\x2C\n  'commonjs': kImplicitAssertType\x2C\n  'json': 'json'\x2C\n  'module': kImplicitAssertType\x2C\n  'wasm': kImplicitAssertType\x2C // It's unclear whether the HTML spec will require an assertion type or not for Wasm; see https://github.com/WebAssembly/esm-integration/issues/42\n};\n\n/**\n * The HTML spec disallows the default type to be explicitly specified\n * (for now); so `import './file.js'` is okay but\n * `import './file.js' assert { type: 'javascript' }` throws.\n * @type {Array<string\x2C string>}\n */\nconst supportedAssertionTypes = ArrayPrototypeFilter(\n  ObjectValues(formatTypeMap)\x2C\n  (type) => type !== kImplicitAssertType);\n\n\n/**\n * Test a module's import assertions.\n * @param {string} url The URL of the imported module\x2C for error reporting.\n * @param {string} format One of Node's supported translators\n * @param {Record<string\x2C string>} importAssertions Validations for the\n *                                                  module import.\n * @returns {true}\n * @throws {TypeError} If the format and assertion type are incompatible.\n */\nfunction validateAssertions(url\x2C format\x2C\n                            importAssertions = ObjectCreate(null)) {\n  const validType = formatTypeMap[format];\n\n  if (!alreadyWarned && ObjectKeys(importAssertions).length !== 0) {\n    alreadyWarned = true;\n    process.emitWarning(\n      'Import assertions are not a stable feature of the JavaScript language. ' +\n      'Avoid relying on their current behavior and syntax as those might change ' +\n      'in a future version of Node.js.'\x2C\n      'ExperimentalWarning'\x2C\n    );\n  }\n\n  switch (validType) {\n    case undefined:\n      // Ignore assertions for module formats we don't recognize\x2C to allow new\n      // formats in the future.\n      return true;\n\n    case kImplicitAssertType:\n      // This format doesn't allow an import assertion type\x2C so the property\n      // must not be set on the import assertions object.\n      if (!ObjectPrototypeHasOwnProperty(importAssertions\x2C 'type')) {\n        return true;\n      }\n      return handleInvalidType(url\x2C importAssertions.type);\n\n    case importAssertions.type:\n      // The asserted type is the valid type for this format.\n      return true;\n\n    default:\n      // There is an expected type for this format\x2C but the value of\n      // `importAssertions.type` might not have been it.\n      if (!ObjectPrototypeHasOwnProperty(importAssertions\x2C 'type')) {\n        // `type` wasn't specified at all.\n        throw new ERR_IMPORT_ASSERTION_TYPE_MISSING(url\x2C validType);\n      }\n      return handleInvalidType(url\x2C importAssertions.type);\n  }\n}\n\n/**\n * Throw the correct error depending on what's wrong with the type assertion.\n * @param {string} url The resolved URL for the module to be imported\n * @param {string} type The value of the import assertion `type` property\n */\nfunction handleInvalidType(url\x2C type) {\n  // `type` might have not been a string.\n  validateString(type\x2C 'type');\n\n  // `type` might not have been one of the types we understand.\n  if (!ArrayPrototypeIncludes(supportedAssertionTypes\x2C type)) {\n    throw new ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED(type);\n  }\n\n  // `type` was the wrong value for this format.\n  throw new ERR_IMPORT_ASSERTION_TYPE_FAILED(url\x2C type);\n}\n\n\nmodule.exports = {\n  kImplicitAssertType\x2C\n  validateAssertions\x2C\n};\n
code-source-info,0x2b3d46cee200,471,0,4041,C0O0C4O4041,,
code-creation,Function,10,88792,0x2b3d46cee4e0,220, node:internal/modules/esm/assert:1:1,0x2b3d46cee178,~
code-source-info,0x2b3d46cee4e0,471,0,4041,C0O0C56O25C61O49C67O75C73O91C79O105C84O121C90O196C93O196C98O177C104O355C107O355C112O381C117O239C123O275C129O312C135O482C137O482C139O517C140O517C142O701C149O737C155O772C161O823C167O854C173O701C175O1282C178O1306C188O1282C193O1282C195O3974C202O3995C208O4018C214O3989C219O4040,,
code-creation,LazyCompile,10,88875,0x2b3d46ceeb70,9, node:internal/modules/esm/assert:46:3,0x2b3d46cee2d0,~
code-source-info,0x2b3d46ceeb70,471,1337,1375,C0O1352C2O1356C4O1352C8O1375,,
tick,0x10113ddd8,89250,1,0x100b1d1ec,2,0x0,0x41ccf059096,0x1100482ec,0x2b3d46ce8af4,0x41ccf0590b7,0x1100482ec,0x2b3d46ce6af9,0x41ccf0590b7,0x1100482ec,0x2b3d46ce1b01,0x41ccf0590b7,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
code-creation,Eval,10,89667,0x2b3d46cf1800,5, node:internal/modules/esm/resolve:1:1,0x2b3d46cf0350,~
script-source,472,node:internal/modules/esm/resolve,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeShift\x2C\n  JSONParse\x2C\n  JSONStringify\x2C\n  ObjectFreeze\x2C\n  ObjectGetOwnPropertyNames\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExp\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst internalFS = require('internal/fs/utils');\nconst { BuiltinModule } = require('internal/bootstrap/loaders');\nconst {\n  realpathSync\x2C\n  statSync\x2C\n  Stats\x2C\n} = require('fs');\nconst { getOptionValue } = require('internal/options');\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\nconst { sep\x2C relative\x2C resolve } = require('path');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\nconst experimentalNetworkImports =\n  getOptionValue('--experimental-network-imports');\nconst typeFlag = getOptionValue('--input-type');\nconst { URL\x2C pathToFileURL\x2C fileURLToPath } = require('internal/url');\nconst {\n  ERR_INPUT_TYPE_NOT_ALLOWED\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_MODULE_SPECIFIER\x2C\n  ERR_INVALID_PACKAGE_CONFIG\x2C\n  ERR_INVALID_PACKAGE_TARGET\x2C\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\n  ERR_MODULE_NOT_FOUND\x2C\n  ERR_PACKAGE_IMPORT_NOT_DEFINED\x2C\n  ERR_PACKAGE_PATH_NOT_EXPORTED\x2C\n  ERR_UNSUPPORTED_DIR_IMPORT\x2C\n  ERR_NETWORK_IMPORT_DISALLOWED\x2C\n} = require('internal/errors').codes;\n\nconst { Module: CJSModule } = require('internal/modules/cjs/loader');\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst { getPackageConfig\x2C getPackageScopeConfig } = require('internal/modules/esm/package_config');\n\n/**\n * @typedef {import('internal/modules/esm/package_config.js').PackageConfig} PackageConfig\n */\n\n\nconst userConditions = getOptionValue('--conditions');\nconst noAddons = getOptionValue('--no-addons');\nconst addonConditions = noAddons ? [] : ['node-addons'];\n\nconst DEFAULT_CONDITIONS = ObjectFreeze([\n  'node'\x2C\n  'import'\x2C\n  ...addonConditions\x2C\n  ...userConditions\x2C\n]);\n\nconst DEFAULT_CONDITIONS_SET = new SafeSet(DEFAULT_CONDITIONS);\n\nconst emittedPackageWarnings = new SafeSet();\n\nfunction emitTrailingSlashPatternDeprecation(match\x2C pjsonUrl\x2C base) {\n  const pjsonPath = fileURLToPath(pjsonUrl);\n  if (emittedPackageWarnings.has(pjsonPath + '|' + match))\n    return;\n  emittedPackageWarnings.add(pjsonPath + '|' + match);\n  process.emitWarning(\n    `Use of deprecated trailing slash pattern mapping "${match}" in the ` +\n    `"exports" field module resolution of the package at ${pjsonPath}${\n      base ? ` imported from ${fileURLToPath(base)}` :\n        ''}. Mapping specifiers ending in "/" is no longer supported.`\x2C\n    'DeprecationWarning'\x2C\n    'DEP0155'\x2C\n  );\n}\n\nconst doubleSlashRegEx = /[/\\\\][/\\\\]/;\n\nfunction emitInvalidSegmentDeprecation(target\x2C request\x2C match\x2C pjsonUrl\x2C internal\x2C base\x2C isTarget) {\n  if (!pendingDeprecation) { return; }\n  const pjsonPath = fileURLToPath(pjsonUrl);\n  const double = RegExpPrototypeExec(doubleSlashRegEx\x2C isTarget ? target : request) !== null;\n  process.emitWarning(\n    `Use of deprecated ${double ? 'double slash' :\n      'leading or trailing slash matching'} resolving "${target}" for module ` +\n      `request "${request}" ${request !== match ? `matched to "${match}" ` : ''\n      }in the "${internal ? 'imports' : 'exports'}" field module resolution of the package at ${\n        pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ''}.`\x2C\n    'DeprecationWarning'\x2C\n    'DEP0166'\x2C\n  );\n}\n\n/**\n * @param {URL} url\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n * @param {string} main\n * @returns {void}\n */\nfunction emitLegacyIndexDeprecation(url\x2C packageJSONUrl\x2C base\x2C main) {\n  const format = defaultGetFormatWithoutErrors(url);\n  if (format !== 'module')\n    return;\n  const path = fileURLToPath(url);\n  const pkgPath = fileURLToPath(new URL('.'\x2C packageJSONUrl));\n  const basePath = fileURLToPath(base);\n  if (main)\n    process.emitWarning(\n      `Package ${pkgPath} has a "main" field set to ${JSONStringify(main)}\x2C ` +\n      `excluding the full filename and extension to the resolved file at "${\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${\n        basePath}.\\n Automatic extension resolution of the "main" field is ` +\n      'deprecated for ES modules.'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0151'\x2C\n    );\n  else\n    process.emitWarning(\n      `No "main" or "exports" field defined in the package.json for ${pkgPath\n      } resolving the main entry point "${\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${basePath\n      }.\\nDefault "index" lookups for the main are deprecated for ES modules.`\x2C\n      'DeprecationWarning'\x2C\n      'DEP0151'\x2C\n    );\n}\n\n/**\n * @param {string[]} [conditions]\n * @returns {Set<string>}\n */\nfunction getConditionsSet(conditions) {\n  if (conditions !== undefined && conditions !== DEFAULT_CONDITIONS) {\n    if (!ArrayIsArray(conditions)) {\n      throw new ERR_INVALID_ARG_VALUE('conditions'\x2C conditions\x2C\n                                      'expected an array');\n    }\n    return new SafeSet(conditions);\n  }\n  return DEFAULT_CONDITIONS_SET;\n}\n\nconst realpathCache = new SafeMap();\n\n/**\n * @param {string | URL} path\n * @returns {import('fs').Stats}\n */\nconst tryStatSync =\n  (path) => statSync(path\x2C { throwIfNoEntry: false }) ?? new Stats();\n\n/**\n * @param {string | URL} url\n * @returns {boolean}\n */\nfunction fileExists(url) {\n  return statSync(url\x2C { throwIfNoEntry: false })?.isFile() ?? false;\n}\n\n/**\n * Legacy CommonJS main resolution:\n * 1. let M = pkg_url + (json main field)\n * 2. TRY(M\x2C M.js\x2C M.json\x2C M.node)\n * 3. TRY(M/index.js\x2C M/index.json\x2C M/index.node)\n * 4. TRY(pkg_url/index.js\x2C pkg_url/index.json\x2C pkg_url/index.node)\n * 5. NOT_FOUND\n * @param {URL} packageJSONUrl\n * @param {PackageConfig} packageConfig\n * @param {string | URL | undefined} base\n * @returns {URL}\n */\nfunction legacyMainResolve(packageJSONUrl\x2C packageConfig\x2C base) {\n  let guess;\n  if (packageConfig.main !== undefined) {\n    // Note: fs check redundances will be handled by Descriptor cache here.\n    if (fileExists(guess = new URL(`./${packageConfig.main}`\x2C\n                                   packageJSONUrl))) {\n      return guess;\n    } else if (fileExists(guess = new URL(`./${packageConfig.main}.js`\x2C\n                                          packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.json`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.node`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.js`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.json`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.node`\x2C\n                                        packageJSONUrl)));\n    else guess = undefined;\n    if (guess) {\n      emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C\n                                 packageConfig.main);\n      return guess;\n    }\n    // Fallthrough.\n  }\n  if (fileExists(guess = new URL('./index.js'\x2C packageJSONUrl)));\n  // So fs.\n  else if (fileExists(guess = new URL('./index.json'\x2C packageJSONUrl)));\n  else if (fileExists(guess = new URL('./index.node'\x2C packageJSONUrl)));\n  else guess = undefined;\n  if (guess) {\n    emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C packageConfig.main);\n    return guess;\n  }\n  // Not found.\n  throw new ERR_MODULE_NOT_FOUND(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C fileURLToPath(base));\n}\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveExtensionsWithTryExactName(search) {\n  if (fileExists(search)) return search;\n  return resolveExtensions(search);\n}\n\nconst extensions = ['.js'\x2C '.json'\x2C '.node'\x2C '.mjs'];\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveExtensions(search) {\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const guess = new URL(`${search.pathname}${extension}`\x2C search);\n    if (fileExists(guess)) return guess;\n  }\n  return undefined;\n}\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveDirectoryEntry(search) {\n  const dirPath = fileURLToPath(search);\n  const pkgJsonPath = resolve(dirPath\x2C 'package.json');\n  if (fileExists(pkgJsonPath)) {\n    const pkgJson = packageJsonReader.read(pkgJsonPath);\n    if (pkgJson.containsKeys) {\n      const { main } = JSONParse(pkgJson.string);\n      if (main != null) {\n        const mainUrl = pathToFileURL(resolve(dirPath\x2C main));\n        return resolveExtensionsWithTryExactName(mainUrl);\n      }\n    }\n  }\n  return resolveExtensions(new URL('index'\x2C search));\n}\n\nconst encodedSepRegEx = /%2F|%5C/i;\n/**\n * @param {URL} resolved\n * @param {string | URL | undefined} base\n * @param {boolean} preserveSymlinks\n * @returns {URL | undefined}\n */\nfunction finalizeResolution(resolved\x2C base\x2C preserveSymlinks) {\n  if (RegExpPrototypeExec(encodedSepRegEx\x2C resolved.pathname) !== null)\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved.pathname\x2C 'must not include encoded "/" or "\\\\" characters'\x2C\n      fileURLToPath(base));\n\n  let path = fileURLToPath(resolved);\n  if (getOptionValue('--experimental-specifier-resolution') === 'node') {\n    let file = resolveExtensionsWithTryExactName(resolved);\n\n    // Directory\n    if (file === undefined) {\n      file = StringPrototypeEndsWith(path\x2C '/') ?\n        (resolveDirectoryEntry(resolved) || resolved) : resolveDirectoryEntry(new URL(`${resolved}/`));\n\n      if (file === resolved) return file;\n\n      if (file === undefined) {\n        throw new ERR_MODULE_NOT_FOUND(\n          resolved.pathname\x2C fileURLToPath(base)\x2C 'module');\n      }\n    }\n\n    path = file;\n  }\n\n  const stats = tryStatSync(StringPrototypeEndsWith(path\x2C '/') ?\n    StringPrototypeSlice(path\x2C -1) : path);\n  if (stats.isDirectory()) {\n    const err = new ERR_UNSUPPORTED_DIR_IMPORT(path\x2C fileURLToPath(base));\n    err.url = String(resolved);\n    throw err;\n  } else if (!stats.isFile()) {\n    if (process.env.WATCH_REPORT_DEPENDENCIES && process.send) {\n      process.send({ 'watch:require': [path || resolved.pathname] });\n    }\n    throw new ERR_MODULE_NOT_FOUND(\n      path || resolved.pathname\x2C base && fileURLToPath(base)\x2C 'module');\n  }\n\n  if (!preserveSymlinks) {\n    const real = realpathSync(path\x2C {\n      [internalFS.realpathCacheKey]: realpathCache\x2C\n    });\n    const { search\x2C hash } = resolved;\n    resolved =\n        pathToFileURL(real + (StringPrototypeEndsWith(path\x2C sep) ? '/' : ''));\n    resolved.search = search;\n    resolved.hash = hash;\n  }\n\n  return resolved;\n}\n\n/**\n * @param {string} specifier\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n */\nfunction importNotDefined(specifier\x2C packageJSONUrl\x2C base) {\n  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(\n    specifier\x2C packageJSONUrl && fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C\n    fileURLToPath(base));\n}\n\n/**\n * @param {string} subpath\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n */\nfunction exportsNotFound(subpath\x2C packageJSONUrl\x2C base) {\n  return new ERR_PACKAGE_PATH_NOT_EXPORTED(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C\n    base && fileURLToPath(base));\n}\n\n/**\n *\n * @param {string} request\n * @param {string} match\n * @param {URL} packageJSONUrl\n * @param {boolean} internal\n * @param {string | URL | undefined} base\n */\nfunction throwInvalidSubpath(request\x2C match\x2C packageJSONUrl\x2C internal\x2C base) {\n  const reason = `request is not a valid match in pattern "${match}" for the "${\n    internal ? 'imports' : 'exports'}" resolution of ${\n    fileURLToPath(packageJSONUrl)}`;\n  throw new ERR_INVALID_MODULE_SPECIFIER(request\x2C reason\x2C\n                                         base && fileURLToPath(base));\n}\n\nfunction invalidPackageTarget(\n  subpath\x2C target\x2C packageJSONUrl\x2C internal\x2C base) {\n  if (typeof target === 'object' && target !== null) {\n    target = JSONStringify(target\x2C null\x2C '');\n  } else {\n    target = `${target}`;\n  }\n  return new ERR_INVALID_PACKAGE_TARGET(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C target\x2C\n    internal\x2C base && fileURLToPath(base));\n}\n\nconst invalidSegmentRegEx = /(^|\\\\|\\/)((\\.|%2e)(\\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\\\|\\/|$)/i;\nconst deprecatedInvalidSegmentRegEx = /(^|\\\\|\\/)((\\.|%2e)(\\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\\\|\\/|$)/i;\nconst invalidPackageNameRegEx = /^\\.|%|\\\\/;\nconst patternRegEx = /\\*/g;\n\n/**\n *\n * @param {string} target\n * @param {*} subpath\n * @param {*} match\n * @param {*} packageJSONUrl\n * @param {*} base\n * @param {*} pattern\n * @param {*} internal\n * @param {*} isPathMap\n * @param {*} conditions\n * @returns {URL}\n */\nfunction resolvePackageTargetString(\n  target\x2C\n  subpath\x2C\n  match\x2C\n  packageJSONUrl\x2C\n  base\x2C\n  pattern\x2C\n  internal\x2C\n  isPathMap\x2C\n  conditions\x2C\n) {\n\n  if (subpath !== '' && !pattern && target[target.length - 1] !== '/')\n    throw invalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  if (!StringPrototypeStartsWith(target\x2C './')) {\n    if (internal && !StringPrototypeStartsWith(target\x2C '../') &&\n        !StringPrototypeStartsWith(target\x2C '/')) {\n      let isURL = false;\n      try {\n        new URL(target);\n        isURL = true;\n      } catch {\n        // Continue regardless of error.\n      }\n      if (!isURL) {\n        const exportTarget = pattern ?\n          RegExpPrototypeSymbolReplace(patternRegEx\x2C target\x2C () => subpath) :\n          target + subpath;\n        return packageResolve(\n          exportTarget\x2C packageJSONUrl\x2C conditions);\n      }\n    }\n    throw invalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n  }\n\n  if (RegExpPrototypeExec(invalidSegmentRegEx\x2C StringPrototypeSlice(target\x2C 2)) !== null) {\n    if (RegExpPrototypeExec(deprecatedInvalidSegmentRegEx\x2C StringPrototypeSlice(target\x2C 2)) === null) {\n      if (!isPathMap) {\n        const request = pattern ?\n          StringPrototypeReplace(match\x2C '*'\x2C () => subpath) :\n          match + subpath;\n        const resolvedTarget = pattern ?\n          RegExpPrototypeSymbolReplace(patternRegEx\x2C target\x2C () => subpath) :\n          target;\n        emitInvalidSegmentDeprecation(resolvedTarget\x2C request\x2C match\x2C packageJSONUrl\x2C internal\x2C base\x2C true);\n      }\n    } else {\n      throw invalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n    }\n  }\n\n  const resolved = new URL(target\x2C packageJSONUrl);\n  const resolvedPath = resolved.pathname;\n  const packagePath = new URL('.'\x2C packageJSONUrl).pathname;\n\n  if (!StringPrototypeStartsWith(resolvedPath\x2C packagePath))\n    throw invalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  if (subpath === '') return resolved;\n\n  if (RegExpPrototypeExec(invalidSegmentRegEx\x2C subpath) !== null) {\n    const request = pattern ? StringPrototypeReplace(match\x2C '*'\x2C () => subpath) : match + subpath;\n    if (RegExpPrototypeExec(deprecatedInvalidSegmentRegEx\x2C subpath) === null) {\n      if (!isPathMap) {\n        const resolvedTarget = pattern ?\n          RegExpPrototypeSymbolReplace(patternRegEx\x2C target\x2C () => subpath) :\n          target;\n        emitInvalidSegmentDeprecation(resolvedTarget\x2C request\x2C match\x2C packageJSONUrl\x2C internal\x2C base\x2C false);\n      }\n    } else {\n      throwInvalidSubpath(request\x2C match\x2C packageJSONUrl\x2C internal\x2C base);\n    }\n  }\n\n  if (pattern) {\n    return new URL(\n      RegExpPrototypeSymbolReplace(patternRegEx\x2C resolved.href\x2C () => subpath)\x2C\n    );\n  }\n\n  return new URL(subpath\x2C resolved);\n}\n\n/**\n * @param {string} key\n * @returns {boolean}\n */\nfunction isArrayIndex(key) {\n  const keyNum = +key;\n  if (`${keyNum}` !== key) return false;\n  return keyNum >= 0 && keyNum < 0xFFFF_FFFF;\n}\n\n/**\n *\n * @param {*} packageJSONUrl\n * @param {string|[string]} target\n * @param {*} subpath\n * @param {*} packageSubpath\n * @param {*} base\n * @param {*} pattern\n * @param {*} internal\n * @param {*} isPathMap\n * @param {*} conditions\n * @returns {URL|null}\n */\nfunction resolvePackageTarget(packageJSONUrl\x2C target\x2C subpath\x2C packageSubpath\x2C\n                              base\x2C pattern\x2C internal\x2C isPathMap\x2C conditions) {\n  if (typeof target === 'string') {\n    return resolvePackageTargetString(\n      target\x2C subpath\x2C packageSubpath\x2C packageJSONUrl\x2C base\x2C pattern\x2C internal\x2C\n      isPathMap\x2C conditions);\n  } else if (ArrayIsArray(target)) {\n    if (target.length === 0) {\n      return null;\n    }\n\n    let lastException;\n    for (let i = 0; i < target.length; i++) {\n      const targetItem = target[i];\n      let resolveResult;\n      try {\n        resolveResult = resolvePackageTarget(\n          packageJSONUrl\x2C targetItem\x2C subpath\x2C packageSubpath\x2C base\x2C pattern\x2C\n          internal\x2C isPathMap\x2C conditions);\n      } catch (e) {\n        lastException = e;\n        if (e.code === 'ERR_INVALID_PACKAGE_TARGET') {\n          continue;\n        }\n        throw e;\n      }\n      if (resolveResult === undefined) {\n        continue;\n      }\n      if (resolveResult === null) {\n        lastException = null;\n        continue;\n      }\n      return resolveResult;\n    }\n    if (lastException === undefined || lastException === null)\n      return lastException;\n    throw lastException;\n  } else if (typeof target === 'object' && target !== null) {\n    const keys = ObjectGetOwnPropertyNames(target);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (isArrayIndex(key)) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(\n          fileURLToPath(packageJSONUrl)\x2C base\x2C\n          '"exports" cannot contain numeric property keys.');\n      }\n    }\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key === 'default' || conditions.has(key)) {\n        const conditionalTarget = target[key];\n        const resolveResult = resolvePackageTarget(\n          packageJSONUrl\x2C conditionalTarget\x2C subpath\x2C packageSubpath\x2C base\x2C\n          pattern\x2C internal\x2C isPathMap\x2C conditions);\n        if (resolveResult === undefined)\n          continue;\n        return resolveResult;\n      }\n    }\n    return undefined;\n  } else if (target === null) {\n    return null;\n  }\n  throw invalidPackageTarget(packageSubpath\x2C target\x2C packageJSONUrl\x2C internal\x2C\n                             base);\n}\n\n/**\n *\n * @param {import('internal/modules/esm/package_config.js').Exports} exports\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n * @returns {boolean}\n */\nfunction isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base) {\n  if (typeof exports === 'string' || ArrayIsArray(exports)) return true;\n  if (typeof exports !== 'object' || exports === null) return false;\n\n  const keys = ObjectGetOwnPropertyNames(exports);\n  let isConditionalSugar = false;\n  let i = 0;\n  for (let j = 0; j < keys.length; j++) {\n    const key = keys[j];\n    const curIsConditionalSugar = key === '' || key[0] !== '.';\n    if (i++ === 0) {\n      isConditionalSugar = curIsConditionalSugar;\n    } else if (isConditionalSugar !== curIsConditionalSugar) {\n      throw new ERR_INVALID_PACKAGE_CONFIG(\n        fileURLToPath(packageJSONUrl)\x2C base\x2C\n        '"exports" cannot contain some keys starting with \\'.\\' and some not.' +\n        ' The exports object must either be an object of package subpath keys' +\n        ' or an object of main entry condition name keys only.');\n    }\n  }\n  return isConditionalSugar;\n}\n\n/**\n * @param {URL} packageJSONUrl\n * @param {string} packageSubpath\n * @param {PackageConfig} packageConfig\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageExportsResolve(\n  packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions) {\n  let exports = packageConfig.exports;\n  if (isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base))\n    exports = { '.': exports };\n\n  if (ObjectPrototypeHasOwnProperty(exports\x2C packageSubpath) &&\n      !StringPrototypeIncludes(packageSubpath\x2C '*') &&\n      !StringPrototypeEndsWith(packageSubpath\x2C '/')) {\n    const target = exports[packageSubpath];\n    const resolveResult = resolvePackageTarget(\n      packageJSONUrl\x2C target\x2C ''\x2C packageSubpath\x2C base\x2C false\x2C false\x2C false\x2C\n      conditions\x2C\n    );\n\n    if (resolveResult == null) {\n      throw exportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n    }\n\n    return resolveResult;\n  }\n\n  let bestMatch = '';\n  let bestMatchSubpath;\n  const keys = ObjectGetOwnPropertyNames(exports);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const patternIndex = StringPrototypeIndexOf(key\x2C '*');\n    if (patternIndex !== -1 &&\n        StringPrototypeStartsWith(packageSubpath\x2C\n                                  StringPrototypeSlice(key\x2C 0\x2C patternIndex))) {\n      // When this reaches EOL\x2C this can throw at the top of the whole function:\n      //\n      // if (StringPrototypeEndsWith(packageSubpath\x2C '/'))\n      //   throwInvalidSubpath(packageSubpath)\n      //\n      // To match "imports" and the spec.\n      if (StringPrototypeEndsWith(packageSubpath\x2C '/'))\n        emitTrailingSlashPatternDeprecation(packageSubpath\x2C packageJSONUrl\x2C\n                                            base);\n      const patternTrailer = StringPrototypeSlice(key\x2C patternIndex + 1);\n      if (packageSubpath.length >= key.length &&\n          StringPrototypeEndsWith(packageSubpath\x2C patternTrailer) &&\n          patternKeyCompare(bestMatch\x2C key) === 1 &&\n          StringPrototypeLastIndexOf(key\x2C '*') === patternIndex) {\n        bestMatch = key;\n        bestMatchSubpath = StringPrototypeSlice(\n          packageSubpath\x2C patternIndex\x2C\n          packageSubpath.length - patternTrailer.length);\n      }\n    }\n  }\n\n  if (bestMatch) {\n    const target = exports[bestMatch];\n    const resolveResult = resolvePackageTarget(\n      packageJSONUrl\x2C\n      target\x2C\n      bestMatchSubpath\x2C\n      bestMatch\x2C\n      base\x2C\n      true\x2C\n      false\x2C\n      StringPrototypeEndsWith(packageSubpath\x2C '/')\x2C\n      conditions);\n\n    if (resolveResult == null) {\n      throw exportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n    }\n    return resolveResult;\n  }\n\n  throw exportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n}\n\nfunction patternKeyCompare(a\x2C b) {\n  const aPatternIndex = StringPrototypeIndexOf(a\x2C '*');\n  const bPatternIndex = StringPrototypeIndexOf(b\x2C '*');\n  const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;\n  const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;\n  if (baseLenA > baseLenB) return -1;\n  if (baseLenB > baseLenA) return 1;\n  if (aPatternIndex === -1) return 1;\n  if (bPatternIndex === -1) return -1;\n  if (a.length > b.length) return -1;\n  if (b.length > a.length) return 1;\n  return 0;\n}\n\n/**\n * @param {string} name\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageImportsResolve(name\x2C base\x2C conditions) {\n  if (name === '#' || StringPrototypeStartsWith(name\x2C '#/') ||\n      StringPrototypeEndsWith(name\x2C '/')) {\n    const reason = 'is not a valid internal imports specifier name';\n    throw new ERR_INVALID_MODULE_SPECIFIER(name\x2C reason\x2C fileURLToPath(base));\n  }\n  let packageJSONUrl;\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    const imports = packageConfig.imports;\n    if (imports) {\n      if (ObjectPrototypeHasOwnProperty(imports\x2C name) &&\n          !StringPrototypeIncludes(name\x2C '*')) {\n        const resolveResult = resolvePackageTarget(\n          packageJSONUrl\x2C imports[name]\x2C ''\x2C name\x2C base\x2C false\x2C true\x2C false\x2C\n          conditions\x2C\n        );\n        if (resolveResult != null) {\n          return resolveResult;\n        }\n      } else {\n        let bestMatch = '';\n        let bestMatchSubpath;\n        const keys = ObjectGetOwnPropertyNames(imports);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const patternIndex = StringPrototypeIndexOf(key\x2C '*');\n          if (patternIndex !== -1 &&\n              StringPrototypeStartsWith(name\x2C\n                                        StringPrototypeSlice(key\x2C 0\x2C\n                                                             patternIndex))) {\n            const patternTrailer = StringPrototypeSlice(key\x2C patternIndex + 1);\n            if (name.length >= key.length &&\n                StringPrototypeEndsWith(name\x2C patternTrailer) &&\n                patternKeyCompare(bestMatch\x2C key) === 1 &&\n                StringPrototypeLastIndexOf(key\x2C '*') === patternIndex) {\n              bestMatch = key;\n              bestMatchSubpath = StringPrototypeSlice(\n                name\x2C patternIndex\x2C name.length - patternTrailer.length);\n            }\n          }\n        }\n\n        if (bestMatch) {\n          const target = imports[bestMatch];\n          const resolveResult = resolvePackageTarget(packageJSONUrl\x2C target\x2C\n                                                     bestMatchSubpath\x2C\n                                                     bestMatch\x2C base\x2C true\x2C\n                                                     true\x2C false\x2C conditions);\n          if (resolveResult != null) {\n            return resolveResult;\n          }\n        }\n      }\n    }\n  }\n  throw importNotDefined(name\x2C packageJSONUrl\x2C base);\n}\n\n/**\n * @param {URL} url\n * @returns {import('internal/modules/esm/package_config.js').PackageType}\n */\nfunction getPackageType(url) {\n  const packageConfig = getPackageScopeConfig(url);\n  return packageConfig.type;\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @returns {{ packageName: string\x2C packageSubpath: string\x2C isScoped: boolean }}\n */\nfunction parsePackageName(specifier\x2C base) {\n  let separatorIndex = StringPrototypeIndexOf(specifier\x2C '/');\n  let validPackageName = true;\n  let isScoped = false;\n  if (specifier[0] === '@') {\n    isScoped = true;\n    if (separatorIndex === -1 || specifier.length === 0) {\n      validPackageName = false;\n    } else {\n      separatorIndex = StringPrototypeIndexOf(\n        specifier\x2C '/'\x2C separatorIndex + 1);\n    }\n  }\n\n  const packageName = separatorIndex === -1 ?\n    specifier : StringPrototypeSlice(specifier\x2C 0\x2C separatorIndex);\n\n  // Package name cannot have leading . and cannot have percent-encoding or\n  // \\\\ separators.\n  if (RegExpPrototypeExec(invalidPackageNameRegEx\x2C packageName) !== null)\n    validPackageName = false;\n\n  if (!validPackageName) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      specifier\x2C 'is not a valid package name'\x2C fileURLToPath(base));\n  }\n\n  const packageSubpath = '.' + (separatorIndex === -1 ? '' :\n    StringPrototypeSlice(specifier\x2C separatorIndex));\n\n  return { packageName\x2C packageSubpath\x2C isScoped };\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {resolved: URL\x2C format? : string}\n */\nfunction packageResolve(specifier\x2C base\x2C conditions) {\n  if (BuiltinModule.canBeRequiredByUsers(specifier) &&\n      BuiltinModule.canBeRequiredWithoutScheme(specifier)) {\n    return new URL('node:' + specifier);\n  }\n\n  const { packageName\x2C packageSubpath\x2C isScoped } =\n    parsePackageName(specifier\x2C base);\n\n  // ResolveSelf\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    const packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    if (packageConfig.name === packageName &&\n        packageConfig.exports !== undefined && packageConfig.exports !== null) {\n      return packageExportsResolve(\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions);\n    }\n  }\n\n  let packageJSONUrl =\n    new URL('./node_modules/' + packageName + '/package.json'\x2C base);\n  let packageJSONPath = fileURLToPath(packageJSONUrl);\n  let lastPath;\n  do {\n    const stat = tryStatSync(StringPrototypeSlice(packageJSONPath\x2C 0\x2C\n                                                  packageJSONPath.length - 13));\n    if (!stat.isDirectory()) {\n      lastPath = packageJSONPath;\n      packageJSONUrl = new URL((isScoped ?\n        '../../../../node_modules/' : '../../../node_modules/') +\n        packageName + '/package.json'\x2C packageJSONUrl);\n      packageJSONPath = fileURLToPath(packageJSONUrl);\n      continue;\n    }\n\n    // Package match.\n    const packageConfig = getPackageConfig(packageJSONPath\x2C specifier\x2C base);\n    if (packageConfig.exports !== undefined && packageConfig.exports !== null) {\n      return packageExportsResolve(\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions);\n    }\n    if (packageSubpath === '.') {\n      return legacyMainResolve(\n        packageJSONUrl\x2C\n        packageConfig\x2C\n        base\x2C\n      );\n    }\n\n    return new URL(packageSubpath\x2C packageJSONUrl);\n    // Cross-platform root check.\n  } while (packageJSONPath.length !== lastPath.length);\n\n  // eslint can't handle the above code.\n  // eslint-disable-next-line no-unreachable\n  throw new ERR_MODULE_NOT_FOUND(packageName\x2C fileURLToPath(base));\n}\n\n/**\n * @param {string} specifier\n * @returns {boolean}\n */\nfunction isBareSpecifier(specifier) {\n  return specifier[0] && specifier[0] !== '/' && specifier[0] !== '.';\n}\n\nfunction isRelativeSpecifier(specifier) {\n  if (specifier[0] === '.') {\n    if (specifier.length === 1 || specifier[1] === '/') return true;\n    if (specifier[1] === '.') {\n      if (specifier.length === 2 || specifier[2] === '/') return true;\n    }\n  }\n  return false;\n}\n\nfunction shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n  if (specifier === '') return false;\n  if (specifier[0] === '/') return true;\n  return isRelativeSpecifier(specifier);\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @param {boolean} preserveSymlinks\n * @returns {url: URL\x2C format?: string}\n */\nfunction moduleResolve(specifier\x2C base\x2C conditions\x2C preserveSymlinks) {\n  const isRemote = base.protocol === 'http:' ||\n    base.protocol === 'https:';\n  // Order swapped from spec for minor perf gain.\n  // Ok since relative URLs cannot parse as URLs.\n  let resolved;\n  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n    resolved = new URL(specifier\x2C base);\n  } else if (!isRemote && specifier[0] === '#') {\n    resolved = packageImportsResolve(specifier\x2C base\x2C conditions);\n  } else {\n    try {\n      resolved = new URL(specifier);\n    } catch {\n      if (!isRemote) {\n        resolved = packageResolve(specifier\x2C base\x2C conditions);\n      }\n    }\n  }\n  if (resolved.protocol !== 'file:') {\n    return resolved;\n  }\n  return finalizeResolution(resolved\x2C base\x2C preserveSymlinks);\n}\n\n/**\n * Try to resolve an import as a CommonJS module\n * @param {string} specifier\n * @param {string} parentURL\n * @returns {boolean|string}\n */\nfunction resolveAsCommonJS(specifier\x2C parentURL) {\n  try {\n    const parent = fileURLToPath(parentURL);\n    const tmpModule = new CJSModule(parent\x2C null);\n    tmpModule.paths = CJSModule._nodeModulePaths(parent);\n\n    let found = CJSModule._resolveFilename(specifier\x2C tmpModule\x2C false);\n\n    // If it is a relative specifier return the relative path\n    // to the parent\n    if (isRelativeSpecifier(specifier)) {\n      found = relative(parent\x2C found);\n      // Add '.separator if the path does not start with '..separator'\n      // This should be a safe assumption because when loading\n      // esm modules there should be always a file specified so\n      // there should not be a specifier like '..' or '.'\n      if (!StringPrototypeStartsWith(found\x2C `..${sep}`)) {\n        found = `.${sep}${found}`;\n      }\n    } else if (isBareSpecifier(specifier)) {\n      // If it is a bare specifier return the relative path within the\n      // module\n      const pkg = StringPrototypeSplit(specifier\x2C '/')[0];\n      const index = StringPrototypeIndexOf(found\x2C pkg);\n      if (index !== -1) {\n        found = StringPrototypeSlice(found\x2C index);\n      }\n    }\n    // Normalize the path separator to give a valid suggestion\n    // on Windows\n    if (process.platform === 'win32') {\n      found = RegExpPrototypeSymbolReplace(new RegExp(`\\\\${sep}`\x2C 'g')\x2C\n                                           found\x2C '/');\n    }\n    return found;\n  } catch {\n    return false;\n  }\n}\n\n// TODO(@JakobJingleheimer): de-dupe `specifier` & `parsed`\nfunction checkIfDisallowedImport(specifier\x2C parsed\x2C parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n    if (\n      parentProtocol === 'http:' ||\n      parentProtocol === 'https:'\n    ) {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n        // data: and blob: disallowed due to allowing file: access via\n        // indirection\n        if (parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier\x2C\n            parsedParentURL\x2C\n            'remote imports cannot import from a local location.'\x2C\n          );\n        }\n\n        return { url: parsed.href };\n      }\n      if (BuiltinModule.canBeRequiredByUsers(specifier) &&\n          BuiltinModule.canBeRequiredWithoutScheme(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier\x2C\n          parsedParentURL\x2C\n          'remote imports cannot import from a local location.'\x2C\n        );\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier\x2C\n        parsedParentURL\x2C\n        'only relative and absolute specifiers are supported.'\x2C\n      );\n    }\n  }\n}\n\n\nasync function defaultResolve(specifier\x2C context = {}) {\n  let { parentURL\x2C conditions } = context;\n  if (parentURL && policy?.manifest) {\n    const redirects = policy.manifest.getDependencyMapper(parentURL);\n    if (redirects) {\n      const { resolve\x2C reaction } = redirects;\n      const destination = resolve(specifier\x2C new SafeSet(conditions));\n      let missing = true;\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        return { url: href };\n      }\n      if (missing) {\n        // Prevent network requests from firing if resolution would be banned.\n        // Network requests can extract data by doing things like putting\n        // secrets in query params\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          parentURL\x2C\n          specifier\x2C\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C '))\x2C\n        );\n      }\n    }\n  }\n\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  let parsed;\n  try {\n    if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n      parsed = new URL(specifier\x2C parsedParentURL);\n    } else {\n      parsed = new URL(specifier);\n    }\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const protocol = parsed.protocol;\n    if (protocol === 'data:' ||\n      (experimentalNetworkImports &&\n        (\n          protocol === 'https:' ||\n          protocol === 'http:'\n        )\n      )\n    ) {\n      return { __proto__: null\x2C url: parsed.href };\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns\x2C DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier\x2C\n    parsed\x2C\n    parsedParentURL\x2C\n  );\n\n  if (maybeReturn) return maybeReturn;\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return { url: specifier };\n\n\n  const isMain = parentURL === undefined;\n  if (isMain) {\n    parentURL = pathToFileURL(`${process.cwd()}/`).href;\n\n    // This is the initial entry point to the program\x2C and --input-type has\n    // been passed as an option; but --input-type can only be used with\n    // --eval\x2C --print or STDIN string input. It is not allowed with file\n    // input\x2C to avoid user confusion over how expansive the effect of the\n    // flag should be (i.e. entry point only\x2C package scope surrounding the\n    // entry point\x2C etc.).\n    if (typeFlag) throw new ERR_INPUT_TYPE_NOT_ALLOWED();\n  }\n\n  conditions = getConditionsSet(conditions);\n  let url;\n  try {\n    url = moduleResolve(\n      specifier\x2C\n      parentURL\x2C\n      conditions\x2C\n      isMain ? preserveSymlinksMain : preserveSymlinks\x2C\n    );\n  } catch (error) {\n    // Try to give the user a hint of what would have been the\n    // resolved CommonJS module\n    if (error.code === 'ERR_MODULE_NOT_FOUND' ||\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT') {\n      if (StringPrototypeStartsWith(specifier\x2C 'file://')) {\n        specifier = fileURLToPath(specifier);\n      }\n      const found = resolveAsCommonJS(specifier\x2C parentURL);\n      if (found) {\n        // Modify the stack and message string to include the hint\n        const lines = StringPrototypeSplit(error.stack\x2C '\\n');\n        const hint = `Did you mean to import ${found}?`;\n        error.stack =\n          ArrayPrototypeShift(lines) + '\\n' +\n          hint + '\\n' +\n          ArrayPrototypeJoin(lines\x2C '\\n');\n        error.message += `\\n${hint}`;\n      }\n    }\n    throw error;\n  }\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems\x2C silencing them\n    url: url.href\x2C\n    format: defaultGetFormatWithoutErrors(url\x2C context)\x2C\n  };\n}\n\nmodule.exports = {\n  DEFAULT_CONDITIONS\x2C\n  defaultResolve\x2C\n  encodedSepRegEx\x2C\n  getPackageScopeConfig\x2C\n  getPackageType\x2C\n  packageExportsResolve\x2C\n  packageImportsResolve\x2C\n};\n\n// cycle\nconst {\n  defaultGetFormatWithoutErrors\x2C\n} = require('internal/modules/esm/get_format');\n\nif (policy) {\n  const $defaultResolve = defaultResolve;\n  module.exports.defaultResolve = async function defaultResolve(\n    specifier\x2C\n    context\x2C\n  ) {\n    const ret = await $defaultResolve(specifier\x2C context);\n    // This is a preflight check to avoid data exfiltration by query params etc.\n    policy.manifest.mightAllow(ret.url\x2C () =>\n      new ERR_MANIFEST_DEPENDENCY_MISSING(\n        context.parentURL\x2C\n        specifier\x2C\n        context.conditions\x2C\n      )\x2C\n    );\n    return ret;\n  };\n}\n
code-source-info,0x2b3d46cf1800,472,0,39084,C0O0C4O39084,,
code-creation,Function,10,91584,0x2b3d46cf27e0,1175, node:internal/modules/esm/resolve:1:1,0x2b3d46cf1778,~
code-source-info,0x2b3d46cf27e0,472,0,39084,C0O0C391O25C397O41C403O63C409O86C415O99C421O116C426O132C432O161C438O194C444O204C450O227C456O259C461O270C467O281C473O291C479O318C485O345C491O371C497O401C503O427C509O451C515O475C521O538C524O538C528O538C530O594C533O594C538O576C544O682C547O682C552O643C558O659C564O671C570O724C573O724C578O705C584O780C590O780C594O780C596O887C602O887C611O931C618O887C620O1011C623O1011C628O984C634O989C640O999C646O1053C652O1053C656O1053C658O1121C664O1121C668O1121C670O1202C676O1202C680O1202C682O1269C688O1269C692O1269C694O1347C697O1347C702O1309C708O1314C714O1329C720O1720C723O1720C728O1746C733O1382C739O1412C745O1437C751O1469C757O1499C763O1529C769O1564C775O1588C781O1622C787O1655C793O1685C799O1785C802O1785C807O1771C813O1851C816O1851C820O1851C822O1952C825O1952C830O1908C836O1926C842O2125C848O2125C853O2174C859O2174C864O2229C875O2290C882O2332C883O2332C937O2354C988O2290C992O2290C994O2406C1002O2406C1007O2406C1009O2471C1012O2471C1017O2471C1019O3100C1023O3100C1025O5539C1027O5539C1032O5539C1034O5648C1038O5648C1040O8316C1044O8316C1046O9290C1050O9290C1052O12791C1056O12791C1058O13001C1062O13001C1064O13204C1068O13204C1070O13237C1074O13237C1076O38313C1083O38334C1089O38356C1095O38374C1101O38393C1107O38418C1113O38436C1119O38461C1125O38328C1129O38542C1132O38542C1137O38507C1143O38587C1154O38627C1156O38627C1158O38652C1167O38675C1174O39083,,
tick,0x195a4aa2c,91750,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x2b3d46ce8af4,0x41ccf0590b7,0x1100482ec,0x2b3d46ce6af9,0x41ccf0590b7,0x1100482ec,0x2b3d46ce1b01,0x41ccf0590b7,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
code-creation,Eval,10,92000,0x2b3d46cf5b78,5, node:internal/modules/esm/package_config:1:1,0x2b3d46cf5990,~
script-source,473,node:internal/modules/esm/package_config,'use strict';\n\nconst {\n  JSONParse\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  SafeMap\x2C\n  StringPrototypeEndsWith\x2C\n} = primordials;\nconst { URL\x2C fileURLToPath } = require('internal/url');\nconst {\n  ERR_INVALID_PACKAGE_CONFIG\x2C\n} = require('internal/errors').codes;\n\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst { filterOwnProperties } = require('internal/util');\n\n\n/**\n * @typedef {string | string[] | Record<string\x2C unknown>} Exports\n * @typedef {'module' | 'commonjs'} PackageType\n * @typedef {{\n *   pjsonPath: string\x2C\n *   exports?: ExportConfig\x2C\n *   name?: string\x2C\n *   main?: string\x2C\n *   type?: PackageType\x2C\n * }} PackageConfig\n */\n\n/** @type {Map<string\x2C PackageConfig>} */\nconst packageJSONCache = new SafeMap();\n\n\n/**\n * @param {string} path\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @returns {PackageConfig}\n */\nfunction getPackageConfig(path\x2C specifier\x2C base) {\n  const existing = packageJSONCache.get(path);\n  if (existing !== undefined) {\n    return existing;\n  }\n  const source = packageJsonReader.read(path).string;\n  if (source === undefined) {\n    const packageConfig = {\n      pjsonPath: path\x2C\n      exists: false\x2C\n      main: undefined\x2C\n      name: undefined\x2C\n      type: 'none'\x2C\n      exports: undefined\x2C\n      imports: undefined\x2C\n    };\n    packageJSONCache.set(path\x2C packageConfig);\n    return packageConfig;\n  }\n\n  let packageJSON;\n  try {\n    packageJSON = JSONParse(source);\n  } catch (error) {\n    throw new ERR_INVALID_PACKAGE_CONFIG(\n      path\x2C\n      (base ? `"${specifier}" from ` : '') + fileURLToPath(base || specifier)\x2C\n      error.message\x2C\n    );\n  }\n\n  let { imports\x2C main\x2C name\x2C type } = filterOwnProperties(packageJSON\x2C ['imports'\x2C 'main'\x2C 'name'\x2C 'type']);\n  const exports = ObjectPrototypeHasOwnProperty(packageJSON\x2C 'exports') ? packageJSON.exports : undefined;\n  if (typeof imports !== 'object' || imports === null) {\n    imports = undefined;\n  }\n  if (typeof main !== 'string') {\n    main = undefined;\n  }\n  if (typeof name !== 'string') {\n    name = undefined;\n  }\n  // Ignore unknown types for forwards compatibility\n  if (type !== 'module' && type !== 'commonjs') {\n    type = 'none';\n  }\n\n  const packageConfig = {\n    pjsonPath: path\x2C\n    exists: true\x2C\n    main\x2C\n    name\x2C\n    type\x2C\n    exports\x2C\n    imports\x2C\n  };\n  packageJSONCache.set(path\x2C packageConfig);\n  return packageConfig;\n}\n\n\n/**\n * @param {URL | string} resolved\n * @returns {PackageConfig}\n */\nfunction getPackageScopeConfig(resolved) {\n  let packageJSONUrl = new URL('./package.json'\x2C resolved);\n  while (true) {\n    const packageJSONPath = packageJSONUrl.pathname;\n    if (StringPrototypeEndsWith(packageJSONPath\x2C 'node_modules/package.json')) {\n      break;\n    }\n    const packageConfig = getPackageConfig(fileURLToPath(packageJSONUrl)\x2C resolved);\n    if (packageConfig.exists) {\n      return packageConfig;\n    }\n\n    const lastPackageJSONUrl = packageJSONUrl;\n    packageJSONUrl = new URL('../package.json'\x2C packageJSONUrl);\n\n    // Terminates at root where ../package.json equals ../../package.json\n    // (can't just check "/package.json" for Windows support).\n    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {\n      break;\n    }\n  }\n  const packageJSONPath = fileURLToPath(packageJSONUrl);\n  const packageConfig = {\n    pjsonPath: packageJSONPath\x2C\n    exists: false\x2C\n    main: undefined\x2C\n    name: undefined\x2C\n    type: 'none'\x2C\n    exports: undefined\x2C\n    imports: undefined\x2C\n  };\n  packageJSONCache.set(packageJSONPath\x2C packageConfig);\n  return packageConfig;\n}\n\n\nmodule.exports = {\n  getPackageConfig\x2C\n  getPackageScopeConfig\x2C\n};\n
code-source-info,0x2b3d46cf5b78,473,0,3628,C0O0C4O3628,,
code-creation,Function,10,92167,0x2b3d46cf5d68,162, node:internal/modules/esm/package_config:1:1,0x2b3d46cf5af0,~
code-source-info,0x2b3d46cf5d68,473,0,3628,C0O0C43O25C49O38C55O71C60O82C66O155C69O155C74O132C80O137C86O222C89O222C94O248C99O190C105O283C108O283C112O283C114O364C117O364C122O340C128O735C130O735C135O735C137O3561C144O3582C150O3602C156O3576C161O3627,,
code-creation,Eval,10,92334,0x2b3d46cf6a00,5, node:internal/modules/esm/get_format:1:1,0x2b3d46cf6788,~
script-source,474,node:internal/modules/esm/get_format,'use strict';\nconst {\n  RegExpPrototypeExec\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  StringPrototypeSlice\x2C\n} = primordials;\nconst { basename\x2C extname\x2C relative } = require('path');\nconst { getOptionValue } = require('internal/options');\nconst { fetchModule } = require('internal/modules/esm/fetch_module');\nconst {\n  extensionFormatMap\x2C\n  getLegacyExtensionFormat\x2C\n  mimeToFormat\x2C\n} = require('internal/modules/esm/formats');\n\nconst experimentalNetworkImports =\n  getOptionValue('--experimental-network-imports');\nconst experimentalSpecifierResolution =\n  getOptionValue('--experimental-specifier-resolution');\nconst { getPackageType\x2C getPackageScopeConfig } = require('internal/modules/esm/resolve');\nconst { fileURLToPath } = require('internal/url');\nconst { ERR_UNKNOWN_FILE_EXTENSION } = require('internal/errors').codes;\n\nconst protocolHandlers = {\n  '__proto__': null\x2C\n  'data:': getDataProtocolModuleFormat\x2C\n  'file:': getFileProtocolModuleFormat\x2C\n  'http:': getHttpProtocolModuleFormat\x2C\n  'https:': getHttpProtocolModuleFormat\x2C\n  'node:'() { return 'builtin'; }\x2C\n};\n\n/**\n * @param {URL} parsed\n * @returns {string | null}\n */\nfunction getDataProtocolModuleFormat(parsed) {\n  const { 1: mime } = RegExpPrototypeExec(\n    /^([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\n    parsed.pathname\x2C\n  ) || [ null\x2C null\x2C null ];\n\n  return mimeToFormat(mime);\n}\n\n/**\n * @param {URL} url\n * @param {{parentURL: string}} context\n * @param {boolean} ignoreErrors\n * @returns {string}\n */\nfunction getFileProtocolModuleFormat(url\x2C context\x2C ignoreErrors) {\n  const filepath = fileURLToPath(url);\n  const ext = extname(filepath);\n  if (ext === '.js') {\n    return getPackageType(url) === 'module' ? 'module' : 'commonjs';\n  }\n\n  const format = extensionFormatMap[ext];\n  if (format) return format;\n\n  if (experimentalSpecifierResolution !== 'node') {\n    // Explicit undefined return indicates load hook should rerun format check\n    if (ignoreErrors) return undefined;\n    let suggestion = '';\n    if (getPackageType(url) === 'module' && ext === '') {\n      const config = getPackageScopeConfig(url);\n      const fileBasename = basename(filepath);\n      const relativePath = StringPrototypeSlice(relative(config.pjsonPath\x2C filepath)\x2C 1);\n      suggestion = 'Loading extensionless files is not supported inside of ' +\n        '"type":"module" package.json contexts. The package.json file ' +\n        `${config.pjsonPath} caused this "type":"module" context. Try ` +\n        `changing ${filepath} to have a file extension. Note the "bin" ` +\n        'field of package.json can point to a file with an extension\x2C for example ' +\n        `{"type":"module"\x2C"bin":{"${fileBasename}":"${relativePath}.js"}}`;\n    }\n    throw new ERR_UNKNOWN_FILE_EXTENSION(ext\x2C filepath\x2C suggestion);\n  }\n\n  return getLegacyExtensionFormat(ext) ?? null;\n}\n\n/**\n * @param {URL} url\n * @param {{parentURL: string}} context\n * @returns {Promise<string> | undefined} only works when enabled\n */\nfunction getHttpProtocolModuleFormat(url\x2C context) {\n  if (experimentalNetworkImports) {\n    return PromisePrototypeThen(\n      PromiseResolve(fetchModule(url\x2C context))\x2C\n      (entry) => {\n        return mimeToFormat(entry.headers['content-type']);\n      }\x2C\n    );\n  }\n}\n\n/**\n * @param {URL} url\n * @param {{parentURL: string}} context\n * @returns {Promise<string> | string | undefined} only works when enabled\n */\nfunction defaultGetFormatWithoutErrors(url\x2C context) {\n  const protocol = url.protocol;\n  if (!ObjectPrototypeHasOwnProperty(protocolHandlers\x2C protocol)) {\n    return null;\n  }\n  return protocolHandlers[protocol](url\x2C context\x2C true);\n}\n\n/**\n * @param {URL} url\n * @param {{parentURL: string}} context\n * @returns {Promise<string> | string | undefined} only works when enabled\n */\nfunction defaultGetFormat(url\x2C context) {\n  const protocol = url.protocol;\n  if (!ObjectPrototypeHasOwnProperty(protocolHandlers\x2C protocol)) {\n    return null;\n  }\n  return protocolHandlers[protocol](url\x2C context\x2C false);\n}\n\nmodule.exports = {\n  defaultGetFormat\x2C\n  defaultGetFormatWithoutErrors\x2C\n  extensionFormatMap\x2C\n};\n
code-source-info,0x2b3d46cf6a00,474,0,4106,C0O0C4O4106,,
code-creation,Function,10,92542,0x2b3d46cf6e68,339, node:internal/modules/esm/get_format:1:1,0x2b3d46cf6978,~
code-source-info,0x2b3d46cf6e68,474,0,4106,C0O0C87O24C93O47C99O80C105O104C111O122C117O201C120O201C125O169C131O179C137O188C143O245C146O245C151O226C156O298C159O298C164O282C170O422C173O422C178O354C184O376C190O404C196O501C199O501C203O501C205O593C208O593C212O593C214O698C217O698C222O656C228O672C234O765C237O765C242O747C248O829C251O829C256O855C261O798C267O889C274O923C280O963C286O1003C292O1044C296O1075C306O889C308O4009C315O4030C321O4050C327O4083C333O4024C338O4105,,
code-creation,Eval,10,92750,0x2b3d46cf7cb8,5, node:internal/modules/esm/fetch_module:1:1,0x2b3d46cf79d0,~
script-source,475,node:internal/modules/esm/fetch_module,'use strict';\nconst {\n  ObjectPrototypeHasOwnProperty\x2C\n  PromisePrototypeThen\x2C\n  SafeMap\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst {\n  Buffer: { concat: BufferConcat }\x2C\n} = require('buffer');\nconst {\n  ERR_NETWORK_IMPORT_DISALLOWED\x2C\n  ERR_NETWORK_IMPORT_BAD_RESPONSE\x2C\n  ERR_MODULE_NOT_FOUND\x2C\n} = require('internal/errors').codes;\nconst { URL } = require('internal/url');\nconst net = require('net');\nconst { once } = require('events');\nconst { compose } = require('stream');\n/**\n * @typedef CacheEntry\n * @property {Promise<string> | string} resolvedHREF Parsed HREF of the request.\n * @property {Record<string\x2C string>} headers HTTP headers of the response.\n * @property {Promise<Buffer> | Buffer} body Response body.\n */\n\n/**\n * Only for GET requests\x2C other requests would need new Map\n * HTTP cache semantics keep diff caches\n *\n * It caches either the promise or the cache entry since import.meta.url needs\n * the value synchronously for the response location after all redirects.\n *\n * Maps HREF to pending cache entry\n * @type {Map<string\x2C Promise<CacheEntry> | CacheEntry>}\n */\nconst cacheForGET = new SafeMap();\n\n// [1] The V8 snapshot doesn't like some C++ APIs to be loaded eagerly. Do it\n// lazily/at runtime and not top level of an internal module.\n\n// [2] Creating a new agent instead of using the gloabl agent improves\n// performance and precludes the agent becoming tainted.\n\nlet HTTPSAgent;\nfunction HTTPSGet(url\x2C opts) {\n  const https = require('https'); // [1]\n  HTTPSAgent ??= new https.Agent({ // [2]\n    keepAlive: true\x2C\n  });\n  return https.get(url\x2C {\n    agent: HTTPSAgent\x2C\n    ...opts\x2C\n  });\n}\n\nlet HTTPAgent;\nfunction HTTPGet(url\x2C opts) {\n  const http = require('http'); // [1]\n  HTTPAgent ??= new http.Agent({ // [2]\n    keepAlive: true\x2C\n  });\n  return http.get(url\x2C {\n    agent: HTTPAgent\x2C\n    ...opts\x2C\n  });\n}\n\nfunction dnsLookup(name\x2C opts) {\n  // eslint-disable-next-line no-func-assign\n  dnsLookup = require('dns/promises').lookup;\n  return dnsLookup(name\x2C opts);\n}\n\nlet zlib;\nfunction createBrotliDecompress() {\n  zlib ??= require('zlib'); // [1]\n  // eslint-disable-next-line no-func-assign\n  createBrotliDecompress = zlib.createBrotliDecompress;\n  return createBrotliDecompress();\n}\n\nfunction createUnzip() {\n  zlib ??= require('zlib'); // [1]\n  // eslint-disable-next-line no-func-assign\n  createUnzip = zlib.createUnzip;\n  return createUnzip();\n}\n\n/**\n * Redirection status code as per section 6.4 of RFC 7231:\n * https://datatracker.ietf.org/doc/html/rfc7231#section-6.4\n * and RFC 7238:\n * https://datatracker.ietf.org/doc/html/rfc7238\n * @param {number} statusCode\n * @returns {boolean}\n */\nfunction isRedirect(statusCode) {\n  switch (statusCode) {\n    case 300: // Multiple Choices\n    case 301: // Moved Permanently\n    case 302: // Found\n    case 303: // See Other\n    case 307: // Temporary Redirect\n    case 308: // Permanent Redirect\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * @param {URL} parsed\n * @returns {Promise<CacheEntry> | CacheEntry}\n */\nfunction fetchWithRedirects(parsed) {\n  const existing = cacheForGET.get(parsed.href);\n  if (existing) {\n    return existing;\n  }\n  const handler = parsed.protocol === 'http:' ? HTTPGet : HTTPSGet;\n  const result = (async () => {\n    const req = handler(parsed\x2C {\n      headers: { Accept: '*/*' }\x2C\n    });\n    // Note that `once` is used here to handle `error` and that it hits the\n    // `finally` on network error/timeout.\n    const { 0: res } = await once(req\x2C 'response');\n    try {\n      const hasLocation = ObjectPrototypeHasOwnProperty(res.headers\x2C 'location');\n      if (isRedirect(res.statusCode) && hasLocation) {\n        const location = new URL(res.headers.location\x2C parsed);\n        if (location.protocol !== 'http:' && location.protocol !== 'https:') {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            res.headers.location\x2C\n            parsed.href\x2C\n            'cannot redirect to non-network location'\x2C\n          );\n        }\n        const entry = await fetchWithRedirects(location);\n        cacheForGET.set(parsed.href\x2C entry);\n        return entry;\n      }\n      if (res.statusCode === 404) {\n        const err = new ERR_MODULE_NOT_FOUND(parsed.href\x2C null);\n        err.message = `Cannot find module '${parsed.href}'\x2C HTTP 404`;\n        throw err;\n      }\n      // This condition catches all unsupported status codes\x2C including\n      // 3xx redirection codes without `Location` HTTP header.\n      if (res.statusCode < 200 || res.statusCode >= 300) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          res.headers.location\x2C\n          parsed.href\x2C\n          'cannot redirect to non-network location');\n      }\n      const { headers } = res;\n      const contentType = headers['content-type'];\n      if (!contentType) {\n        throw new ERR_NETWORK_IMPORT_BAD_RESPONSE(\n          parsed.href\x2C\n          "the 'Content-Type' header is required"\x2C\n        );\n      }\n      /**\n       * @type {CacheEntry}\n       */\n      const entry = {\n        resolvedHREF: parsed.href\x2C\n        headers: {\n          'content-type': res.headers['content-type']\x2C\n        }\x2C\n        body: (async () => {\n          let bodyStream = res;\n          if (res.headers['content-encoding'] === 'br') {\n            bodyStream = compose(res\x2C createBrotliDecompress());\n          } else if (\n            res.headers['content-encoding'] === 'gzip' ||\n            res.headers['content-encoding'] === 'deflate'\n          ) {\n            bodyStream = compose(res\x2C createUnzip());\n          }\n          const buffers = await bodyStream.toArray();\n          const body = BufferConcat(buffers);\n          entry.body = body;\n          return body;\n        })()\x2C\n      };\n      cacheForGET.set(parsed.href\x2C entry);\n      await entry.body;\n      return entry;\n    } finally {\n      req.destroy();\n    }\n  })();\n  cacheForGET.set(parsed.href\x2C result);\n  return result;\n}\n\nconst allowList = new net.BlockList();\nallowList.addAddress('::1'\x2C 'ipv6');\nallowList.addRange('127.0.0.1'\x2C '127.255.255.255');\n\n/**\n * Returns if an address has local status by if it is going to a local\n * interface or is an address resolved by DNS to be a local interface\n * @param {string} hostname url.hostname to test\n * @returns {Promise<boolean>}\n */\nasync function isLocalAddress(hostname) {\n  try {\n    if (\n      StringPrototypeStartsWith(hostname\x2C '[') &&\n      StringPrototypeEndsWith(hostname\x2C ']')\n    ) {\n      hostname = StringPrototypeSlice(hostname\x2C 1\x2C -1);\n    }\n    const addr = await dnsLookup(hostname\x2C { verbatim: true });\n    const ipv = addr.family === 4 ? 'ipv4' : 'ipv6';\n    return allowList.check(addr.address\x2C ipv);\n  } catch {\n    // If it errored\x2C the answer is no.\n  }\n  return false;\n}\n\n/**\n * Fetches a location with a shared cache following redirects.\n * Does not respect HTTP cache headers.\n *\n * This splits the header and body Promises so that things only needing\n * headers don't need to wait on the body.\n *\n * In cases where the request & response have already settled\x2C this returns the\n * cache value synchronously.\n * @param {URL} parsed\n * @param {ESModuleContext} context\n * @returns {ReturnType<typeof fetchWithRedirects>}\n */\nfunction fetchModule(parsed\x2C { parentURL }) {\n  const { href } = parsed;\n  const existing = cacheForGET.get(href);\n  if (existing) {\n    return existing;\n  }\n  if (parsed.protocol === 'http:') {\n    return PromisePrototypeThen(isLocalAddress(parsed.hostname)\x2C (is) => {\n      if (is !== true) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          href\x2C\n          parentURL\x2C\n          'http can only be used to load local resources (use https instead).'\x2C\n        );\n      }\n      return fetchWithRedirects(parsed);\n    });\n  }\n  return fetchWithRedirects(parsed);\n}\n\nmodule.exports = {\n  fetchModule\x2C\n};\n
code-source-info,0x2b3d46cf7cb8,475,0,7825,C0O0C4O7825,,
code-creation,Function,10,93084,0x2b3d46cf8170,355, node:internal/modules/esm/fetch_module:1:1,0x2b3d46cf7c30,~
code-source-info,0x2b3d46cf8170,475,0,7825,C0O0C113O24C119O57C125O81C130O92C136O119C142O143C148O235C154O235C159O235C164O215C170O358C176O358C181O384C186O264C192O297C198O332C204O408C210O408C215O400C221O445C227O445C232O478C238O478C243O469C249O517C255O517C260O505C266O1166C268O1166C273O1166C275O1456C276O1456C278O1684C279O1684C281O2063C282O2063C284O5967C289O5959C294O5959C296O5980C299O5990C310O5990C316O6017C319O6027C330O6027C336O7788C343O7809C349O7803C354O7824,,
code-creation,LazyCompile,10,93125,0x2b3d46cf8e78,37,get BlockList node:net:2248:16,0x30e7677316c8,~
code-source-info,0x2b3d46cf8e78,458,62070,62159,C0O62079C14O62093C19O62122C26O62089C32O62138C36O62155,,
code-creation,Eval,10,93250,0x2b3d46cf9348,5, node:internal/blocklist:1:1,0x2b3d46cf9160,~
script-source,476,node:internal/blocklist,'use strict';\n\nconst {\n  Boolean\x2C\n  ObjectSetPrototypeOf\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  BlockList: BlockListHandle\x2C\n} = internalBinding('block_list');\n\nconst {\n  customInspectSymbol: kInspect\x2C\n} = require('internal/util');\n\nconst {\n  SocketAddress\x2C\n  kHandle: kSocketAddressHandle\x2C\n} = require('internal/socketaddress');\n\nconst {\n  JSTransferable\x2C\n  kClone\x2C\n  kDeserialize\x2C\n} = require('internal/worker/js_transferable');\n\nconst { inspect } = require('internal/util/inspect');\n\nconst kHandle = Symbol('kHandle');\nconst { owner_symbol } = internalBinding('symbols');\n\nconst {\n  ERR_INVALID_ARG_VALUE\x2C\n} = require('internal/errors').codes;\n\nconst { validateInt32\x2C validateString } = require('internal/validators');\n\nclass BlockList extends JSTransferable {\n  constructor() {\n    super();\n    this[kHandle] = new BlockListHandle();\n    this[kHandle][owner_symbol] = this;\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0)\n      return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\x2C\n    };\n\n    return `BlockList ${inspect({\n      rules: this.rules\x2C\n    }\x2C opts)}`;\n  }\n\n  addAddress(address\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(address)) {\n      validateString(address\x2C 'address');\n      validateString(family\x2C 'family');\n      address = new SocketAddress({\n        address\x2C\n        family\x2C\n      });\n    }\n    this[kHandle].addAddress(address[kSocketAddressHandle]);\n  }\n\n  addRange(start\x2C end\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(start)) {\n      validateString(start\x2C 'start');\n      validateString(family\x2C 'family');\n      start = new SocketAddress({\n        address: start\x2C\n        family\x2C\n      });\n    }\n    if (!SocketAddress.isSocketAddress(end)) {\n      validateString(end\x2C 'end');\n      validateString(family\x2C 'family');\n      end = new SocketAddress({\n        address: end\x2C\n        family\x2C\n      });\n    }\n    const ret = this[kHandle].addRange(\n      start[kSocketAddressHandle]\x2C\n      end[kSocketAddressHandle]);\n    if (ret === false)\n      throw new ERR_INVALID_ARG_VALUE('start'\x2C start\x2C 'must come before end');\n  }\n\n  addSubnet(network\x2C prefix\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(network)) {\n      validateString(network\x2C 'network');\n      validateString(family\x2C 'family');\n      network = new SocketAddress({\n        address: network\x2C\n        family\x2C\n      });\n    }\n    switch (network.family) {\n      case 'ipv4':\n        validateInt32(prefix\x2C 'prefix'\x2C 0\x2C 32);\n        break;\n      case 'ipv6':\n        validateInt32(prefix\x2C 'prefix'\x2C 0\x2C 128);\n        break;\n    }\n    this[kHandle].addSubnet(network[kSocketAddressHandle]\x2C prefix);\n  }\n\n  check(address\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(address)) {\n      validateString(address\x2C 'address');\n      validateString(family\x2C 'family');\n      try {\n        address = new SocketAddress({\n          address\x2C\n          family\x2C\n        });\n      } catch {\n        // Ignore the error. If it's not a valid address\x2C return false.\n        return false;\n      }\n    }\n    return Boolean(this[kHandle].check(address[kSocketAddressHandle]));\n  }\n\n  get rules() {\n    return this[kHandle].getRules();\n  }\n\n  [kClone]() {\n    const handle = this[kHandle];\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/blocklist:InternalBlockList'\x2C\n    };\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kHandle][owner_symbol] = this;\n  }\n}\n\nclass InternalBlockList extends JSTransferable {\n  constructor(handle) {\n    super();\n    this[kHandle] = handle;\n    if (handle !== undefined)\n      handle[owner_symbol] = this;\n  }\n}\n\nInternalBlockList.prototype.constructor = BlockList.prototype.constructor;\nObjectSetPrototypeOf(InternalBlockList.prototype\x2C BlockList.prototype);\n\nmodule.exports = {\n  BlockList\x2C\n  InternalBlockList\x2C\n};\n
code-source-info,0x2b3d46cf9348,476,0,3880,C0O0C4O3880,,
code-creation,Function,10,93459,0x2b3d46cf9d50,359, node:internal/blocklist:1:1,0x2b3d46cf92c0,~
code-source-info,0x2b3d46cf9d50,476,0,3880,C0O0C35O25C41O36C46O60C51O128C54O128C59O107C65O205C68O205C73O191C78O294C81O294C86O242C92O268C98O386C101O386C106O340C111O358C116O368C121O451C124O451C129O439C135O502C138O502C142O502C144O546C147O546C152O529C158O612C161O612C166O638C171O585C177O689C180O689C185O655C191O670C197O746C204O885C241O3226C251O3387C278O3522C301O3694C306O3728C311O3738C315O3716C319O3790C324O3811C329O3751C334O3824C341O3845C347O3858C353O3839C358O3879,,
tick,0x195a4aa2c,93792,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x2b3d46cf2c4c,0x41ccf0590b7,0x1100482ec,0x2b3d46ce8af4,0x41ccf0590b7,0x1100482ec,0x2b3d46ce6af9,0x41ccf0590b7,0x1100482ec,0x2b3d46ce1b01,0x41ccf0590b7,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
tick,0x1014b7ef0,94000,0,0x0,0,0x41ccf0589bd,0x2b3d46cf9d86,0x41ccf0590b7,0x1100482ec,0x2b3d46cf8e86,0x2b3d46cf828c,0x41ccf0590b7,0x1100482ec,0x2b3d46cf6f07,0x41ccf0590b7,0x1100482ec,0x2b3d46cf2c4c,0x41ccf0590b7,0x1100482ec,0x2b3d46ce8af4,0x41ccf0590b7,0x1100482ec,0x2b3d46ce6af9,0x41ccf0590b7,0x1100482ec,0x2b3d46ce1b01,0x41ccf0590b7,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
code-creation,Eval,10,94042,0x2b3d46cfb638,5, node:internal/socketaddress:1:1,0x2b3d46cfb430,~
script-source,477,node:internal/socketaddress,'use strict';\n\nconst {\n  ObjectSetPrototypeOf\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  SocketAddress: _SocketAddress\x2C\n  AF_INET\x2C\n  AF_INET6\x2C\n} = internalBinding('block_list');\n\nconst {\n  validateObject\x2C\n  validateString\x2C\n  validatePort\x2C\n  validateUint32\x2C\n} = require('internal/validators');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  customInspectSymbol: kInspect\x2C\n  kEmptyObject\x2C\n} = require('internal/util');\n\nconst { inspect } = require('internal/util/inspect');\n\nconst {\n  JSTransferable\x2C\n  kClone\x2C\n  kDeserialize\x2C\n} = require('internal/worker/js_transferable');\n\nconst kHandle = Symbol('kHandle');\nconst kDetail = Symbol('kDetail');\n\nclass SocketAddress extends JSTransferable {\n  static isSocketAddress(value) {\n    return value?.[kHandle] !== undefined;\n  }\n\n  constructor(options = kEmptyObject) {\n    super();\n    validateObject(options\x2C 'options');\n    let { family = 'ipv4' } = options;\n    const {\n      address = (family === 'ipv4' ? '127.0.0.1' : '::')\x2C\n      port = 0\x2C\n      flowlabel = 0\x2C\n    } = options;\n\n    let type;\n    if (typeof family?.toLowerCase === 'function')\n      family = family.toLowerCase();\n    switch (family) {\n      case 'ipv4':\n        type = AF_INET;\n        break;\n      case 'ipv6':\n        type = AF_INET6;\n        break;\n      default:\n        throw new ERR_INVALID_ARG_VALUE('options.family'\x2C options.family);\n    }\n\n    validateString(address\x2C 'options.address');\n    validatePort(port\x2C 'options.port');\n    validateUint32(flowlabel\x2C 'options.flowlabel'\x2C false);\n\n    this[kHandle] = new _SocketAddress(address\x2C port\x2C type\x2C flowlabel);\n    this[kDetail] = this[kHandle].detail({\n      address: undefined\x2C\n      port: undefined\x2C\n      family: undefined\x2C\n      flowlabel: undefined\x2C\n    });\n  }\n\n  get address() {\n    return this[kDetail].address;\n  }\n\n  get port() {\n    return this[kDetail].port;\n  }\n\n  get family() {\n    return this[kDetail].family === AF_INET ? 'ipv4' : 'ipv6';\n  }\n\n  get flowlabel() {\n    // The flow label can be changed internally.\n    return this[kHandle].flowlabel();\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0)\n      return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\x2C\n    };\n\n    return `SocketAddress ${inspect(this.toJSON()\x2C opts)}`;\n  }\n\n  [kClone]() {\n    const handle = this[kHandle];\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/socketaddress:InternalSocketAddress'\x2C\n    };\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kDetail] = handle.detail({\n      address: undefined\x2C\n      port: undefined\x2C\n      family: undefined\x2C\n      flowlabel: undefined\x2C\n    });\n  }\n\n  toJSON() {\n    return {\n      address: this.address\x2C\n      port: this.port\x2C\n      family: this.family\x2C\n      flowlabel: this.flowlabel\x2C\n    };\n  }\n}\n\nclass InternalSocketAddress extends JSTransferable {\n  constructor(handle) {\n    super();\n    this[kHandle] = handle;\n    this[kDetail] = this[kHandle]?.detail({\n      address: undefined\x2C\n      port: undefined\x2C\n      family: undefined\x2C\n      flowlabel: undefined\x2C\n    });\n  }\n}\n\nInternalSocketAddress.prototype.constructor =\n  SocketAddress.prototype.constructor;\nObjectSetPrototypeOf(InternalSocketAddress.prototype\x2C SocketAddress.prototype);\n\nmodule.exports = {\n  SocketAddress\x2C\n  InternalSocketAddress\x2C\n  kHandle\x2C\n};\n
code-source-info,0x2b3d46cfb638,477,0,3388,C0O0C4O3388,,
code-creation,Function,10,94250,0x2b3d46cfc168,375, node:internal/socketaddress:1:1,0x2b3d46cfb5b0,~
code-source-info,0x2b3d46cfc168,477,0,3388,C0O0C41O25C46O49C51O143C54O143C59O100C65O118C71O129C77O257C80O257C85O185C91O203C97O221C103O237C109O345C112O345C117O345C122O313C128O435C131O435C136O405C141O417C147O482C150O482C155O470C161O573C164O573C169O527C174O545C179O555C184O634C187O634C191O634C193O669C196O669C200O669C202O717C235O2097C245O2340C255O2509C288O2904C311O3169C316O3209C321O3219C325O3191C329O3275C334O3300C339O3232C344O3313C351O3334C357O3351C363O3376C369O3328C374O3387,,
code-creation,LazyCompile,10,94334,0x2b3d46cfcbe0,72,BlockList node:internal/blocklist:40:14,0x2b3d46cf9378,~
code-source-info,0x2b3d46cfcbe0,476,776,880,C3O785C11O785C23O798C28O803C33O818C36O814C41O812C45O841C50O846C52O845C58O855C64O869C71O879,,
code-creation,LazyCompile,10,94375,0x2b3d46cfd368,115,addAddress node:internal/blocklist:60:13,0x2b3d46cf9418,~
code-source-info,0x2b3d46cfd368,476,1152,1463,C14O1185C19O1204C24O1204C31O1238C39O1238C44O1280C52O1280C57O1320C69O1358C75O1375C81O1330C87O1403C89O1408C91O1407C95O1417C102O1436C104O1435C108O1417C114O1462,,
code-creation,LazyCompile,10,94417,0x2b3d46cfd4e8,20,isSocketAddress node:internal/socketaddress:44:25,0x2b3d46cfb6b8,~
code-source-info,0x2b3d46cfd4e8,477,758,814,C0O772C9O787C11O786C18O796C19O810,,
code-creation,LazyCompile,10,94459,0x2b3d46cfdcb8,326,SocketAddress node:internal/socketaddress:48:14,0x2b3d46cfb668,~
code-source-info,0x2b3d46cfdcb8,477,829,1787,C9O840C16O860C24O860C36O873C44O873C49O919C61O966C72O984C84O1024C92O1040C100O1081C102O1091C109O1108C120O1160C125O1160C130O1179C149O1224C154O1248C156O1282C161O1307C163O1337C171O1395C178O1343C183O1337C184O1415C192O1415C197O1463C205O1463C210O1503C223O1503C228O1563C233O1568C238O1583C255O1579C260O1577C264O1635C269O1640C277O1656C279O1655C283O1665C294O1689C299O1712C304O1737C309O1765C313O1665C318O1649C325O1786,,
code-creation,LazyCompile,10,94500,0x2b3d46cfdfe0,128, node:internal/validators:246:3,0x1012a394be98,~
code-source-info,0x2b3d46cfdfe0,22,6266,6821,C16O6324C27O6324C33O6410C44O6410C50O6494C61O6494C67O6556C75O6603C79O6617C82O6617C96O6692C104O6757C120O6763C125O6757C127O6820,,
code-creation,LazyCompile,10,94542,0x2b3d46cfe178,27,getOwnPropertyValueOrDefault node:internal/validators:227:38,0x1012a394be48,~
code-source-info,0x2b3d46cfe178,22,5857,6001,C0O5890C7O5917C10O5917C23O5993C26O5999,,
code-creation,LazyCompile,10,94584,0x2b3d46cfe2c0,129,validatePort node:internal/validators:403:22,0x1012a394c168,~
code-source-info,0x2b3d46cfe2c0,22,10859,11217,C24O10903C44O11000C47O11000C52O11025C58O11033C65O11049C70O11060C72O11066C75O11055C86O11087C92O11111C99O11121C101O11139C117O11145C122O11139C123O11199C125O11211C128O11215,,
code-creation,LazyCompile,10,94584,0x2b3d46cfe4f8,148, node:internal/validators:137:40,0x1012a394bbd0,~
code-source-info,0x2b3d46cfe4f8,22,3512,3944,C16O3551C22O3588C38O3594C43O3588C44O3649C49O3654C55O3684C71O3690C76O3684C77O3757C87O3817C90O3834C92O3844C99O3859C104O3872C114O3911C127O3924C140O3878C145O3872C147O3943,,
code-creation,LazyCompile,10,94667,0x2b3d46cfe7e0,229,addRange node:internal/blocklist:72:11,0x2b3d46cf9468,~
code-source-info,0x2b3d46cfe7e0,476,1475,2145,C17O1511C22O1530C27O1530C34O1562C42O1562C47O1600C55O1600C60O1640C72O1685C78O1700C84O1648C90O1728C95O1747C100O1747C107O1777C115O1777C120O1811C128O1811C133O1851C145O1894C151O1907C157O1857C163O1947C165O1952C167O1951C171O1961C178O1983C180O1982C186O2016C188O2015C192O1961C199O2044C200O2052C205O2069C221O2075C226O2069C228O2144,,
code-creation,Eval,10,94709,0x2b3d46cfecb8,5, node:internal/modules/esm/formats:1:1,0x2b3d46cfeb40,~
script-source,478,node:internal/modules/esm/formats,'use strict';\n\nconst {\n  RegExpPrototypeExec\x2C\n} = primordials;\nconst { getOptionValue } = require('internal/options');\n\n\nconst experimentalWasmModules = getOptionValue('--experimental-wasm-modules');\n\nconst extensionFormatMap = {\n  '__proto__': null\x2C\n  '.cjs': 'commonjs'\x2C\n  '.js': 'module'\x2C\n  '.json': 'json'\x2C\n  '.mjs': 'module'\x2C\n};\n\nconst legacyExtensionFormatMap = {\n  '__proto__': null\x2C\n  '.cjs': 'commonjs'\x2C\n  '.js': 'commonjs'\x2C\n  '.json': 'commonjs'\x2C\n  '.mjs': 'module'\x2C\n  '.node': 'commonjs'\x2C\n};\n\nif (experimentalWasmModules) {\n  extensionFormatMap['.wasm'] = legacyExtensionFormatMap['.wasm'] = 'wasm';\n}\n\n/**\n * @param {string} mime\n * @returns {string | null}\n */\nfunction mimeToFormat(mime) {\n  if (\n    RegExpPrototypeExec(\n      /\\s*(text|application)\\/javascript\\s*(;\\s*charset=utf-?8\\s*)?/i\x2C\n      mime\x2C\n    ) !== null\n  ) return 'module';\n  if (mime === 'application/json') return 'json';\n  if (experimentalWasmModules && mime === 'application/wasm') return 'wasm';\n  return null;\n}\n\nfunction getLegacyExtensionFormat(ext) {\n  return legacyExtensionFormatMap[ext];\n}\n\nmodule.exports = {\n  extensionFormatMap\x2C\n  getLegacyExtensionFormat\x2C\n  legacyExtensionFormatMap\x2C\n  mimeToFormat\x2C\n};\n
code-source-info,0x2b3d46cfecb8,478,0,1200,C0O0C4O1200,,
code-creation,Function,10,94792,0x2b3d46cfef70,120, node:internal/modules/esm/formats:1:1,0x2b3d46cfec30,~
code-source-info,0x2b3d46cfef70,478,0,1200,C0O0C24O25C30O90C33O90C38O71C43O153C46O153C50O153C52O228C57O368C61O368C63O504C67O537C73O601C79O565C83O1084C90O1105C96O1127C102O1155C108O1183C114O1099C119O1199,,
code-creation,Eval,10,94875,0x2b3d46cff600,5, node:internal/modules/esm/initialize_import_meta:1:1,0x2b3d46cff468,~
script-source,479,node:internal/modules/esm/initialize_import_meta,'use strict';\n\nconst { getOptionValue } = require('internal/options');\nconst experimentalImportMetaResolve =\n  getOptionValue('--experimental-import-meta-resolve');\nconst {\n  PromisePrototypeThen\x2C\n  PromiseReject\x2C\n} = primordials;\nconst asyncESM = require('internal/process/esm_loader');\n\nfunction createImportMetaResolve(defaultParentUrl) {\n  return async function resolve(specifier\x2C parentUrl = defaultParentUrl) {\n    return PromisePrototypeThen(\n      asyncESM.esmLoader.resolve(specifier\x2C parentUrl)\x2C\n      ({ url }) => url\x2C\n      (error) => (\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT' ?\n          error.url : PromiseReject(error))\x2C\n    );\n  };\n}\n\n/**\n * @param {object} meta\n * @param {{url: string}} context\n */\nfunction initializeImportMeta(meta\x2C context) {\n  const { url } = context;\n\n  // Alphabetical\n  if (experimentalImportMetaResolve) {\n    meta.resolve = createImportMetaResolve(url);\n  }\n\n  meta.url = url;\n}\n\nmodule.exports = {\n  initializeImportMeta\x2C\n};\n
code-source-info,0x2b3d46cff600,479,0,982,C0O0C4O982,,
code-creation,Function,10,94917,0x2b3d46cff7c8,90, node:internal/modules/esm/initialize_import_meta:1:1,0x2b3d46cff578,~
code-source-info,0x2b3d46cff7c8,479,0,982,C0O0C28O42C31O42C36O23C41O111C44O111C48O111C50O175C56O199C62O248C65O248C69O248C71O936C78O957C84O951C89O981,,
new,MemoryChunk,0x1fa4d1d40000,262144
code-creation,Eval,10,95084,0x1fa4d1d41168,5, node:internal/modules/esm/load:1:1,0x2b3d46cffdf8,~
script-source,480,node:internal/modules/esm/load,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  RegExpPrototypeExec\x2C\n  decodeURIComponent\x2C\n} = primordials;\n\nconst { defaultGetFormat } = require('internal/modules/esm/get_format');\nconst { validateAssertions } = require('internal/modules/esm/assert');\nconst { getOptionValue } = require('internal/options');\nconst { fetchModule } = require('internal/modules/esm/fetch_module');\n\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\nconst experimentalNetworkImports =\n  getOptionValue('--experimental-network-imports');\n\nconst { Buffer: { from: BufferFrom } } = require('buffer');\n\nconst { readFile: readFileAsync } = require('internal/fs/promises').exports;\nconst { URL } = require('internal/url');\nconst {\n  ERR_INVALID_URL\x2C\n  ERR_UNSUPPORTED_ESM_URL_SCHEME\x2C\n} = require('internal/errors').codes;\n\nconst DATA_URL_PATTERN = /^[^/]+\\/[^\x2C;]+(?:[^\x2C]*?)(;base64)?\x2C([\\s\\S]*)$/;\n\nasync function getSource(url\x2C context) {\n  const parsed = new URL(url);\n  let responseURL = url;\n  let source;\n  if (parsed.protocol === 'file:') {\n    source = await readFileAsync(parsed);\n  } else if (parsed.protocol === 'data:') {\n    const match = RegExpPrototypeExec(DATA_URL_PATTERN\x2C parsed.pathname);\n    if (!match) {\n      throw new ERR_INVALID_URL(url);\n    }\n    const { 1: base64\x2C 2: body } = match;\n    source = BufferFrom(decodeURIComponent(body)\x2C base64 ? 'base64' : 'utf8');\n  } else if (experimentalNetworkImports && (\n    parsed.protocol === 'https:' ||\n    parsed.protocol === 'http:'\n  )) {\n    const res = await fetchModule(parsed\x2C context);\n    source = await res.body;\n    responseURL = res.resolvedHREF;\n  } else {\n    const supportedSchemes = ['file'\x2C 'data'];\n    if (experimentalNetworkImports) {\n      ArrayPrototypePush(supportedSchemes\x2C 'http'\x2C 'https');\n    }\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed\x2C supportedSchemes);\n  }\n  if (policy?.manifest) {\n    policy.manifest.assertIntegrity(parsed\x2C source);\n  }\n  return { __proto__: null\x2C responseURL\x2C source };\n}\n\n\n/**\n * Node.js default load hook.\n * @param {string} url\n * @param {object} context\n * @returns {object}\n */\nasync function defaultLoad(url\x2C context) {\n  let responseURL = url;\n  const { importAssertions } = context;\n  let {\n    format\x2C\n    source\x2C\n  } = context;\n\n  const urlInstance = new URL(url);\n\n  throwIfUnsupportedURLScheme(urlInstance\x2C experimentalNetworkImports);\n\n  format ??= await defaultGetFormat(urlInstance\x2C context);\n\n  validateAssertions(url\x2C format\x2C importAssertions);\n\n  if (\n    format === 'builtin' ||\n    format === 'commonjs'\n  ) {\n    source = null;\n  } else if (source == null) {\n    ({ responseURL\x2C source } = await getSource(url\x2C context));\n  }\n\n  return {\n    __proto__: null\x2C\n    format\x2C\n    responseURL\x2C\n    source\x2C\n  };\n}\n\n/**\n * throws an error if the protocol is not one of the protocols\n * that can be loaded in the default loader\n * @param {URL} parsed\n * @param {boolean} experimentalNetworkImports\n */\nfunction throwIfUnsupportedURLScheme(parsed\x2C experimentalNetworkImports) {\n  // Avoid accessing the `protocol` property due to the lazy getters.\n  const protocol = parsed?.protocol;\n  if (\n    protocol &&\n    protocol !== 'file:' &&\n    protocol !== 'data:' &&\n    protocol !== 'node:' &&\n    (\n      !experimentalNetworkImports ||\n      (\n        protocol !== 'https:' &&\n        protocol !== 'http:'\n      )\n    )\n  ) {\n    const schemes = ['file'\x2C 'data'\x2C 'node'];\n    if (experimentalNetworkImports) {\n      ArrayPrototypePush(schemes\x2C 'https'\x2C 'http');\n    }\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed\x2C schemes);\n  }\n}\n\nmodule.exports = {\n  defaultLoad\x2C\n};\n
code-source-info,0x1fa4d1d41168,480,0,3692,C0O0C4O3692,,
code-creation,Function,10,95292,0x1fa4d1d41400,269, node:internal/modules/esm/load:1:1,0x2b3d46cfffb8,~
code-source-info,0x1fa4d1d41400,480,0,3692,C0O0C64O25C70O47C76O70C82O137C85O137C90O116C96O212C99O212C104O189C110O279C113O279C118O260C123O332C126O332C131O316C137O445C140O445C149O489C156O445C158O571C161O571C165O571C167O663C170O663C175O663C180O646C186O719C189O719C194O750C199O701C205O776C208O776C213O768C219O866C222O866C227O892C232O811C238O830C244O926C248O926C250O3655C257O3676C263O3670C268O3691,,
code-creation,Eval,10,95792,0x1fa4d1d43aa8,5, node:internal/fs/promises:1:1,0x1fa4d1d42570,~
script-source,481,node:internal/fs/promises,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  ArrayPrototypePop\x2C\n  Error\x2C\n  MathMax\x2C\n  MathMin\x2C\n  NumberIsSafeInteger\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  PromiseReject\x2C\n  SafeArrayIterator\x2C\n  SafePromisePrototypeFinally\x2C\n  Symbol\x2C\n  Uint8Array\x2C\n  FunctionPrototypeBind\x2C\n} = primordials;\n\nconst { fs: constants } = internalBinding('constants');\nconst {\n  F_OK\x2C\n  O_SYMLINK\x2C\n  O_WRONLY\x2C\n  S_IFMT\x2C\n  S_IFREG\x2C\n} = constants;\n\nconst binding = internalBinding('fs');\nconst { Buffer } = require('buffer');\n\nconst {\n  codes: {\n    ERR_FS_FILE_TOO_LARGE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_STATE\x2C\n    ERR_METHOD_NOT_IMPLEMENTED\x2C\n  }\x2C\n  AbortError\x2C\n  aggregateTwoErrors\x2C\n} = require('internal/errors');\nconst { isArrayBufferView } = require('internal/util/types');\nconst { rimrafPromises } = require('internal/fs/rimraf');\nconst {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n    kReadFileBufferLength\x2C\n    kReadFileUnknownBufferLength\x2C\n    kWriteFileMaxChunkSize\x2C\n  }\x2C\n  copyObject\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getStatFsFromBinding\x2C\n  getStatsFromBinding\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validateRmOptions\x2C\n  validateRmdirOptions\x2C\n  validatePrimitiveStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\x2C\n} = require('internal/fs/utils');\nconst { opendir } = require('internal/fs/dir');\nconst {\n  parseFileMode\x2C\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateInteger\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst pathModule = require('path');\nconst {\n  kEmptyObject\x2C\n  lazyDOMException\x2C\n  promisify\x2C\n} = require('internal/util');\nconst { EventEmitterMixin } = require('internal/event_target');\nconst { StringDecoder } = require('string_decoder');\nconst { watch } = require('internal/fs/watchers');\nconst { isIterable } = require('internal/streams/utils');\nconst assert = require('internal/assert');\n\nconst kHandle = Symbol('kHandle');\nconst kFd = Symbol('kFd');\nconst kRefs = Symbol('kRefs');\nconst kClosePromise = Symbol('kClosePromise');\nconst kCloseResolve = Symbol('kCloseResolve');\nconst kCloseReject = Symbol('kCloseReject');\nconst kRef = Symbol('kRef');\nconst kUnref = Symbol('kUnref');\nconst kLocked = Symbol('kLocked');\n\nconst { kUsePromises } = binding;\nconst { Interface } = require('internal/readline/interface');\nconst {\n  JSTransferable\x2C kDeserialize\x2C kTransfer\x2C kTransferList\x2C\n} = require('internal/worker/js_transferable');\n\nconst getDirectoryEntriesPromise = promisify(getDirents);\nconst validateRmOptionsPromise = promisify(validateRmOptions);\n\nlet cpPromises;\nfunction lazyLoadCpPromises() {\n  return cpPromises ??= require('internal/fs/cp/cp').cpFn;\n}\n\n// Lazy loaded to avoid circular dependency.\nlet fsStreams;\nfunction lazyFsStreams() {\n  return fsStreams ??= require('internal/fs/streams');\n}\n\nclass FileHandle extends EventEmitterMixin(JSTransferable) {\n  /**\n   * @param {InternalFSBinding.FileHandle | undefined} filehandle\n   */\n  constructor(filehandle) {\n    super();\n    this[kHandle] = filehandle;\n    this[kFd] = filehandle ? filehandle.fd : -1;\n\n    this[kRefs] = 1;\n    this[kClosePromise] = null;\n  }\n\n  getAsyncId() {\n    return this[kHandle].getAsyncId();\n  }\n\n  get fd() {\n    return this[kFd];\n  }\n\n  appendFile(data\x2C options) {\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\n  }\n\n  chmod(mode) {\n    return fsCall(fchmod\x2C this\x2C mode);\n  }\n\n  chown(uid\x2C gid) {\n    return fsCall(fchown\x2C this\x2C uid\x2C gid);\n  }\n\n  datasync() {\n    return fsCall(fdatasync\x2C this);\n  }\n\n  sync() {\n    return fsCall(fsync\x2C this);\n  }\n\n  read(buffer\x2C offset\x2C length\x2C position) {\n    return fsCall(read\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\n  }\n\n  readv(buffers\x2C position) {\n    return fsCall(readv\x2C this\x2C buffers\x2C position);\n  }\n\n  readFile(options) {\n    return fsCall(readFile\x2C this\x2C options);\n  }\n\n  readLines(options = undefined) {\n    return new Interface({\n      input: this.createReadStream(options)\x2C\n      crlfDelay: Infinity\x2C\n    });\n  }\n\n  stat(options) {\n    return fsCall(fstat\x2C this\x2C options);\n  }\n\n  truncate(len = 0) {\n    return fsCall(ftruncate\x2C this\x2C len);\n  }\n\n  utimes(atime\x2C mtime) {\n    return fsCall(futimes\x2C this\x2C atime\x2C mtime);\n  }\n\n  write(buffer\x2C offset\x2C length\x2C position) {\n    return fsCall(write\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\n  }\n\n  writev(buffers\x2C position) {\n    return fsCall(writev\x2C this\x2C buffers\x2C position);\n  }\n\n  writeFile(data\x2C options) {\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\n  }\n\n  close = () => {\n    if (this[kFd] === -1) {\n      return PromiseResolve();\n    }\n\n    if (this[kClosePromise]) {\n      return this[kClosePromise];\n    }\n\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      this[kClosePromise] = SafePromisePrototypeFinally(\n        this[kHandle].close()\x2C\n        () => { this[kClosePromise] = undefined; }\x2C\n      );\n    } else {\n      this[kClosePromise] = SafePromisePrototypeFinally(\n        new Promise((resolve\x2C reject) => {\n          this[kCloseResolve] = resolve;\n          this[kCloseReject] = reject;\n        })\x2C () => {\n          this[kClosePromise] = undefined;\n          this[kCloseReject] = undefined;\n          this[kCloseResolve] = undefined;\n        }\x2C\n      );\n    }\n\n    this.emit('close');\n    return this[kClosePromise];\n  };\n\n  /**\n   * @typedef {import('../webstreams/readablestream').ReadableStream\n   * } ReadableStream\n   * @returns {ReadableStream}\n   */\n  readableWebStream(options = kEmptyObject) {\n    if (this[kFd] === -1)\n      throw new ERR_INVALID_STATE('The FileHandle is closed');\n    if (this[kClosePromise])\n      throw new ERR_INVALID_STATE('The FileHandle is closing');\n    if (this[kLocked])\n      throw new ERR_INVALID_STATE('The FileHandle is locked');\n    this[kLocked] = true;\n\n    if (options.type !== undefined) {\n      validateString(options.type\x2C 'options.type');\n    }\n\n    let readable;\n\n    if (options.type !== 'bytes') {\n      const {\n        newReadableStreamFromStreamBase\x2C\n      } = require('internal/webstreams/adapters');\n      readable = newReadableStreamFromStreamBase(\n        this[kHandle]\x2C\n        undefined\x2C\n        { ondone: () => this[kUnref]() });\n\n      const {\n        readableStreamCancel\x2C\n      } = require('internal/webstreams/readablestream');\n      this[kRef]();\n      this.once('close'\x2C () => {\n        readableStreamCancel(readable);\n      });\n    } else {\n      const {\n        readableStreamCancel\x2C\n        ReadableStream\x2C\n      } = require('internal/webstreams/readablestream');\n\n      const readFn = FunctionPrototypeBind(this.read\x2C this);\n      const ondone = FunctionPrototypeBind(this[kUnref]\x2C this);\n\n      readable = new ReadableStream({\n        type: 'bytes'\x2C\n        autoAllocateChunkSize: 16384\x2C\n\n        async pull(controller) {\n          const view = controller.byobRequest.view;\n          const { bytesRead } = await readFn(view\x2C view.byteOffset\x2C view.byteLength);\n\n          if (bytesRead === 0) {\n            ondone();\n            controller.close();\n          }\n\n          controller.byobRequest.respond(bytesRead);\n        }\x2C\n\n        cancel() {\n          ondone();\n        }\x2C\n      });\n\n      this[kRef]();\n\n      this.once('close'\x2C () => {\n        readableStreamCancel(readable);\n      });\n    }\n\n    return readable;\n  }\n\n  /**\n   * @typedef {import('./streams').ReadStream\n   * } ReadStream\n   * @param {{\n   *   encoding?: string;\n   *   autoClose?: boolean;\n   *   emitClose?: boolean;\n   *   start: number;\n   *   end?: number;\n   *   highWaterMark?: number;\n   *   }} [options]\n   * @returns {ReadStream}\n   */\n  createReadStream(options = undefined) {\n    const { ReadStream } = lazyFsStreams();\n    return new ReadStream(undefined\x2C { ...options\x2C fd: this });\n  }\n\n  /**\n   * @typedef {import('./streams').WriteStream\n   * } WriteStream\n   * @param {{\n   *   encoding?: string;\n   *   autoClose?: boolean;\n   *   emitClose?: boolean;\n   *   start: number;\n   *   }} [options]\n   * @returns {WriteStream}\n   */\n  createWriteStream(options = undefined) {\n    const { WriteStream } = lazyFsStreams();\n    return new WriteStream(undefined\x2C { ...options\x2C fd: this });\n  }\n\n  [kTransfer]() {\n    if (this[kClosePromise] || this[kRefs] > 1) {\n      throw lazyDOMException('Cannot transfer FileHandle while in use'\x2C\n                             'DataCloneError');\n    }\n\n    const handle = this[kHandle];\n    this[kFd] = -1;\n    this[kHandle] = null;\n    this[kRefs] = 0;\n\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/fs/promises:FileHandle'\x2C\n    };\n  }\n\n  [kTransferList]() {\n    return [ this[kHandle] ];\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kFd] = handle.fd;\n  }\n\n  [kRef]() {\n    this[kRefs]++;\n  }\n\n  [kUnref]() {\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      PromisePrototypeThen(\n        this[kHandle].close()\x2C\n        this[kCloseResolve]\x2C\n        this[kCloseReject]\x2C\n      );\n    }\n  }\n}\n\nasync function handleFdClose(fileOpPromise\x2C closeFunc) {\n  return PromisePrototypeThen(\n    fileOpPromise\x2C\n    (result) => PromisePrototypeThen(closeFunc()\x2C () => result)\x2C\n    (opError) =>\n      PromisePrototypeThen(\n        closeFunc()\x2C\n        () => PromiseReject(opError)\x2C\n        (closeError) => PromiseReject(aggregateTwoErrors(closeError\x2C opError))\x2C\n      )\x2C\n  );\n}\n\nasync function fsCall(fn\x2C handle\x2C ...args) {\n  assert(handle[kRefs] !== undefined\x2C\n         'handle must be an instance of FileHandle');\n\n  if (handle.fd === -1) {\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new Error('file closed');\n    err.code = 'EBADF';\n    err.syscall = fn.name;\n    throw err;\n  }\n\n  try {\n    handle[kRef]();\n    return await fn(handle\x2C ...new SafeArrayIterator(args));\n  } finally {\n    handle[kUnref]();\n  }\n}\n\nfunction checkAborted(signal) {\n  if (signal?.aborted)\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\n}\n\nasync function writeFileHandle(filehandle\x2C data\x2C signal\x2C encoding) {\n  checkAborted(signal);\n  if (isCustomIterable(data)) {\n    for await (const buf of data) {\n      checkAborted(signal);\n      const toWrite =\n        isArrayBufferView(buf) ? buf : Buffer.from(buf\x2C encoding || 'utf8');\n      let remaining = toWrite.byteLength;\n      while (remaining > 0) {\n        const writeSize = MathMin(kWriteFileMaxChunkSize\x2C remaining);\n        const { bytesWritten } = await write(\n          filehandle\x2C toWrite\x2C toWrite.byteLength - remaining\x2C writeSize);\n        remaining -= bytesWritten;\n        checkAborted(signal);\n      }\n    }\n    return;\n  }\n  data = new Uint8Array(data.buffer\x2C data.byteOffset\x2C data.byteLength);\n  let remaining = data.byteLength;\n  if (remaining === 0) return;\n  do {\n    checkAborted(signal);\n    const { bytesWritten } =\n      await write(filehandle\x2C data\x2C 0\x2C\n                  MathMin(kWriteFileMaxChunkSize\x2C data.byteLength));\n    remaining -= bytesWritten;\n    data = new Uint8Array(\n      data.buffer\x2C\n      data.byteOffset + bytesWritten\x2C\n      data.byteLength - bytesWritten\x2C\n    );\n  } while (remaining > 0);\n}\n\nasync function readFileHandle(filehandle\x2C options) {\n  const signal = options?.signal;\n  const encoding = options?.encoding;\n  const decoder = encoding && new StringDecoder(encoding);\n\n  checkAborted(signal);\n\n  const statFields = await binding.fstat(filehandle.fd\x2C false\x2C kUsePromises);\n\n  checkAborted(signal);\n\n  let size = 0;\n  let length = 0;\n  if ((statFields[1/* mode */] & S_IFMT) === S_IFREG) {\n    size = statFields[8/* size */];\n    length = encoding ? MathMin(size\x2C kReadFileBufferLength) : size;\n  }\n  if (length === 0) {\n    length = kReadFileUnknownBufferLength;\n  }\n\n  if (size > kIoMaxLength)\n    throw new ERR_FS_FILE_TOO_LARGE(size);\n\n  let totalRead = 0;\n  let buffer = Buffer.allocUnsafeSlow(length);\n  let result = '';\n  let offset = 0;\n  let buffers;\n  const chunkedRead = length > kReadFileBufferLength;\n\n  while (true) {\n    checkAborted(signal);\n\n    if (chunkedRead) {\n      length = MathMin(size - totalRead\x2C kReadFileBufferLength);\n    }\n\n    const bytesRead = (await binding.read(filehandle.fd\x2C buffer\x2C offset\x2C\n                                          length\x2C -1\x2C kUsePromises)) ?? 0;\n    totalRead += bytesRead;\n\n    if (bytesRead === 0 ||\n        totalRead === size ||\n        (bytesRead !== buffer.length && !chunkedRead)) {\n      const singleRead = bytesRead === totalRead;\n\n      const bytesToCheck = chunkedRead ? totalRead : bytesRead;\n\n      if (bytesToCheck !== buffer.length) {\n        buffer = buffer.subarray(0\x2C bytesToCheck);\n      }\n\n      if (!encoding) {\n        if (size === 0 && !singleRead) {\n          ArrayPrototypePush(buffers\x2C buffer);\n          return Buffer.concat(buffers\x2C totalRead);\n        }\n        return buffer;\n      }\n\n      if (singleRead) {\n        return buffer.toString(encoding);\n      }\n      result += decoder.end(buffer);\n      return result;\n    }\n\n    if (encoding) {\n      result += decoder.write(buffer);\n    } else if (size !== 0) {\n      offset = totalRead;\n    } else {\n      buffers ??= [];\n      // Unknown file size requires chunks.\n      ArrayPrototypePush(buffers\x2C buffer);\n      buffer = Buffer.allocUnsafeSlow(kReadFileUnknownBufferLength);\n    }\n  }\n}\n\n// All of the functions are defined as async in order to ensure that errors\n// thrown cause promise rejections rather than being thrown synchronously.\nasync function access(path\x2C mode = F_OK) {\n  path = getValidatedPath(path);\n\n  mode = getValidMode(mode\x2C 'access');\n  return binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C\n                        kUsePromises);\n}\n\nasync function cp(src\x2C dest\x2C options) {\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  return lazyLoadCpPromises()(src\x2C dest\x2C options);\n}\n\nasync function copyFile(src\x2C dest\x2C mode) {\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n  mode = getValidMode(mode\x2C 'copyFile');\n  return binding.copyFile(pathModule.toNamespacedPath(src)\x2C\n                          pathModule.toNamespacedPath(dest)\x2C\n                          mode\x2C\n                          kUsePromises);\n}\n\n// Note that unlike fs.open() which uses numeric file descriptors\x2C\n// fsPromises.open() uses the fs.FileHandle class.\nasync function open(path\x2C flags\x2C mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n  return new FileHandle(\n    await binding.openFileHandle(pathModule.toNamespacedPath(path)\x2C\n                                 flagsNumber\x2C mode\x2C kUsePromises));\n}\n\nasync function read(handle\x2C bufferOrParams\x2C offset\x2C length\x2C position) {\n  let buffer = bufferOrParams;\n  if (!isArrayBufferView(buffer)) {\n    // This is fh.read(params)\n    ({\n      buffer = Buffer.alloc(16384)\x2C\n      offset = 0\x2C\n      length = buffer.byteLength - offset\x2C\n      position = null\x2C\n    } = bufferOrParams ?? kEmptyObject);\n\n    validateBuffer(buffer);\n  }\n\n  if (offset !== null && typeof offset === 'object') {\n    // This is fh.read(buffer\x2C options)\n    ({\n      offset = 0\x2C\n      length = buffer.byteLength - offset\x2C\n      position = null\x2C\n    } = offset);\n  }\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0)\n    return { bytesRead: length\x2C buffer };\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (!NumberIsSafeInteger(position))\n    position = -1;\n\n  const bytesRead = (await binding.read(handle.fd\x2C buffer\x2C offset\x2C length\x2C\n                                        position\x2C kUsePromises)) || 0;\n\n  return { bytesRead\x2C buffer };\n}\n\nasync function readv(handle\x2C buffers\x2C position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const bytesRead = (await binding.readBuffers(handle.fd\x2C buffers\x2C position\x2C\n                                               kUsePromises)) || 0;\n  return { bytesRead\x2C buffers };\n}\n\nasync function write(handle\x2C buffer\x2C offsetOrOptions\x2C length\x2C position) {\n  if (buffer?.byteLength === 0)\n    return { bytesWritten: 0\x2C buffer };\n\n  let offset = offsetOrOptions;\n  if (isArrayBufferView(buffer)) {\n    if (typeof offset === 'object') {\n      ({\n        offset = 0\x2C\n        length = buffer.byteLength - offset\x2C\n        position = null\x2C\n      } = offsetOrOptions ?? kEmptyObject);\n    }\n\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n    const bytesWritten =\n      (await binding.writeBuffer(handle.fd\x2C buffer\x2C offset\x2C\n                                 length\x2C position\x2C kUsePromises)) || 0;\n    return { bytesWritten\x2C buffer };\n  }\n\n  validatePrimitiveStringAfterArrayBufferView(buffer\x2C 'buffer');\n  validateEncoding(buffer\x2C length);\n  const bytesWritten = (await binding.writeString(handle.fd\x2C buffer\x2C offset\x2C\n                                                  length\x2C kUsePromises)) || 0;\n  return { bytesWritten\x2C buffer };\n}\n\nasync function writev(handle\x2C buffers\x2C position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  if (buffers.length === 0) {\n    return { bytesWritten: 0\x2C buffers };\n  }\n\n  const bytesWritten = (await binding.writeBuffers(handle.fd\x2C buffers\x2C position\x2C\n                                                   kUsePromises)) || 0;\n  return { bytesWritten\x2C buffers };\n}\n\nasync function rename(oldPath\x2C newPath) {\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  return binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                        pathModule.toNamespacedPath(newPath)\x2C\n                        kUsePromises);\n}\n\nasync function truncate(path\x2C len = 0) {\n  const fd = await open(path\x2C 'r+');\n  return handleFdClose(ftruncate(fd\x2C len)\x2C fd.close);\n}\n\nasync function ftruncate(handle\x2C len = 0) {\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  return binding.ftruncate(handle.fd\x2C len\x2C kUsePromises);\n}\n\nasync function rm(path\x2C options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = await validateRmOptionsPromise(path\x2C options\x2C false);\n  return rimrafPromises(path\x2C options);\n}\n\nasync function rmdir(path\x2C options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = validateRmdirOptions(options);\n\n  if (options.recursive) {\n    emitRecursiveRmdirWarning();\n    const stats = await stat(path);\n    if (stats.isDirectory()) {\n      return rimrafPromises(path\x2C options);\n    }\n  }\n\n  return binding.rmdir(path\x2C kUsePromises);\n}\n\nasync function fdatasync(handle) {\n  return binding.fdatasync(handle.fd\x2C kUsePromises);\n}\n\nasync function fsync(handle) {\n  return binding.fsync(handle.fd\x2C kUsePromises);\n}\n\nasync function mkdir(path\x2C options) {\n  if (typeof options === 'number' || typeof options === 'string') {\n    options = { mode: options };\n  }\n  const {\n    recursive = false\x2C\n    mode = 0o777\x2C\n  } = options || kEmptyObject;\n  path = getValidatedPath(path);\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  return binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                       parseFileMode(mode\x2C 'mode'\x2C 0o777)\x2C recursive\x2C\n                       kUsePromises);\n}\n\nasync function readdirRecursive(originalPath\x2C options) {\n  const result = [];\n  const queue = [\n    [\n      originalPath\x2C\n      await binding.readdir(\n        pathModule.toNamespacedPath(originalPath)\x2C\n        options.encoding\x2C\n        !!options.withFileTypes\x2C\n        kUsePromises\x2C\n      )\x2C\n    ]\x2C\n  ];\n\n\n  if (options.withFileTypes) {\n    while (queue.length > 0) {\n      // If we want to implement BFS make this a `shift` call instead of `pop`\n      const { 0: path\x2C 1: readdir } = ArrayPrototypePop(queue);\n      for (const dirent of getDirents(path\x2C readdir)) {\n        ArrayPrototypePush(result\x2C dirent);\n        if (dirent.isDirectory()) {\n          const direntPath = pathModule.join(path\x2C dirent.name);\n          ArrayPrototypePush(queue\x2C [\n            direntPath\x2C\n            await binding.readdir(\n              direntPath\x2C\n              options.encoding\x2C\n              true\x2C\n              kUsePromises\x2C\n            )\x2C\n          ]);\n        }\n      }\n    }\n  } else {\n    while (queue.length > 0) {\n      const { 0: path\x2C 1: readdir } = ArrayPrototypePop(queue);\n      for (const ent of readdir) {\n        const direntPath = pathModule.join(path\x2C ent);\n        const stat = binding.internalModuleStat(direntPath);\n        ArrayPrototypePush(\n          result\x2C\n          pathModule.relative(originalPath\x2C direntPath)\x2C\n        );\n        if (stat === 1) {\n          ArrayPrototypePush(queue\x2C [\n            direntPath\x2C\n            await binding.readdir(\n              pathModule.toNamespacedPath(direntPath)\x2C\n              options.encoding\x2C\n              false\x2C\n              kUsePromises\x2C\n            )\x2C\n          ]);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nasync function readdir(path\x2C options) {\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  if (options.recursive) {\n    return readdirRecursive(path\x2C options);\n  }\n  const result = await binding.readdir(\n    pathModule.toNamespacedPath(path)\x2C\n    options.encoding\x2C\n    !!options.withFileTypes\x2C\n    kUsePromises\x2C\n  );\n  return options.withFileTypes ?\n    getDirectoryEntriesPromise(path\x2C result) :\n    result;\n}\n\nasync function readlink(path\x2C options) {\n  options = getOptions(options);\n  path = getValidatedPath(path\x2C 'oldPath');\n  return binding.readlink(pathModule.toNamespacedPath(path)\x2C\n                          options.encoding\x2C kUsePromises);\n}\n\nasync function symlink(target\x2C path\x2C type_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n  return binding.symlink(preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\n                         pathModule.toNamespacedPath(path)\x2C\n                         stringToSymlinkType(type)\x2C\n                         kUsePromises);\n}\n\nasync function fstat(handle\x2C options = { bigint: false }) {\n  const result = await binding.fstat(handle.fd\x2C options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function lstat(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.lstat(pathModule.toNamespacedPath(path)\x2C\n                                     options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function stat(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.stat(pathModule.toNamespacedPath(path)\x2C\n                                    options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function statfs(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.statfs(pathModule.toNamespacedPath(path)\x2C\n                                      options.bigint\x2C kUsePromises);\n  return getStatFsFromBinding(result);\n}\n\nasync function link(existingPath\x2C newPath) {\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  return binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n                      pathModule.toNamespacedPath(newPath)\x2C\n                      kUsePromises);\n}\n\nasync function unlink(path) {\n  path = getValidatedPath(path);\n  return binding.unlink(pathModule.toNamespacedPath(path)\x2C kUsePromises);\n}\n\nasync function fchmod(handle\x2C mode) {\n  mode = parseFileMode(mode\x2C 'mode');\n  return binding.fchmod(handle.fd\x2C mode\x2C kUsePromises);\n}\n\nasync function chmod(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n  return binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C kUsePromises);\n}\n\nasync function lchmod(path\x2C mode) {\n  if (O_SYMLINK === undefined)\n    throw new ERR_METHOD_NOT_IMPLEMENTED('lchmod()');\n\n  const fd = await open(path\x2C O_WRONLY | O_SYMLINK);\n  return handleFdClose(fchmod(fd\x2C mode)\x2C fd.close);\n}\n\nasync function lchown(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.lchown(pathModule.toNamespacedPath(path)\x2C\n                        uid\x2C gid\x2C kUsePromises);\n}\n\nasync function fchown(handle\x2C uid\x2C gid) {\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.fchown(handle.fd\x2C uid\x2C gid\x2C kUsePromises);\n}\n\nasync function chown(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.chown(pathModule.toNamespacedPath(path)\x2C\n                       uid\x2C gid\x2C kUsePromises);\n}\n\nasync function utimes(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  return binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                        toUnixTimestamp(atime)\x2C\n                        toUnixTimestamp(mtime)\x2C\n                        kUsePromises);\n}\n\nasync function futimes(handle\x2C atime\x2C mtime) {\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  return binding.futimes(handle.fd\x2C atime\x2C mtime\x2C kUsePromises);\n}\n\nasync function lutimes(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  return binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                         toUnixTimestamp(atime)\x2C\n                         toUnixTimestamp(mtime)\x2C\n                         kUsePromises);\n}\n\nasync function realpath(path\x2C options) {\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  return binding.realpath(path\x2C options.encoding\x2C kUsePromises);\n}\n\nasync function mkdtemp(prefix\x2C options) {\n  options = getOptions(options);\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix);\n  warnOnNonPortableTemplate(prefix);\n  return binding.mkdtemp(`${prefix}XXXXXX`\x2C options.encoding\x2C kUsePromises);\n}\n\nasync function writeFile(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (!isArrayBufferView(data) && !isCustomIterable(data)) {\n    validatePrimitiveStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(data\x2C options.encoding || 'utf8');\n  }\n\n  validateAbortSignal(options.signal);\n  if (path instanceof FileHandle)\n    return writeFileHandle(path\x2C data\x2C options.signal\x2C options.encoding);\n\n  checkAborted(options.signal);\n\n  const fd = await open(path\x2C flag\x2C options.mode);\n  return handleFdClose(\n    writeFileHandle(fd\x2C data\x2C options.signal\x2C options.encoding)\x2C fd.close);\n}\n\nfunction isCustomIterable(obj) {\n  return isIterable(obj) && !isArrayBufferView(obj) && typeof obj !== 'string';\n}\n\nasync function appendFile(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n  options = copyObject(options);\n  options.flag = options.flag || 'a';\n  return writeFile(path\x2C data\x2C options);\n}\n\nasync function readFile(path\x2C options) {\n  options = getOptions(options\x2C { flag: 'r' });\n  const flag = options.flag || 'r';\n\n  if (path instanceof FileHandle)\n    return readFileHandle(path\x2C options);\n\n  checkAborted(options.signal);\n\n  const fd = await open(path\x2C flag\x2C 0o666);\n  return handleFdClose(readFileHandle(fd\x2C options)\x2C fd.close);\n}\n\nmodule.exports = {\n  exports: {\n    access\x2C\n    copyFile\x2C\n    cp\x2C\n    open\x2C\n    opendir: promisify(opendir)\x2C\n    rename\x2C\n    truncate\x2C\n    rm\x2C\n    rmdir\x2C\n    mkdir\x2C\n    readdir\x2C\n    readlink\x2C\n    symlink\x2C\n    lstat\x2C\n    stat\x2C\n    statfs\x2C\n    link\x2C\n    unlink\x2C\n    chmod\x2C\n    lchmod\x2C\n    lchown\x2C\n    chown\x2C\n    utimes\x2C\n    lutimes\x2C\n    realpath\x2C\n    mkdtemp\x2C\n    writeFile\x2C\n    appendFile\x2C\n    readFile\x2C\n    watch\x2C\n    constants\x2C\n  }\x2C\n\n  FileHandle\x2C\n  kRef\x2C\n  kUnref\x2C\n};\n
code-source-info,0x1fa4d1d43aa8,481,0,28399,C0O0C4O28399,,
code-creation,Function,10,97334,0x1fa4d1d46458,1886, node:internal/fs/promises:1:1,0x1fa4d1d43a20,~
code-source-info,0x1fa4d1d46458,481,0,28399,C0O0C541O25C547O47C553O68C559O77C565O88C571O99C577O122C583O133C589O157C595O175C601O192C607O213C613O244C618O254C624O268C630O335C634O335C640O321C645O375C651O383C657O396C663O408C669O418C675O459C679O459C683O459C685O501C693O501C699O490C705O694C713O694C719O694C725O544C731O571C737O598C743O621C749O656C755O670C761O752C769O752C775O730C781O811C789O811C795O792C801O1477C809O1477C815O1477C821O869C827O887C833O903C839O930C845O964C851O995C857O1009C863O1038C869O1052C875O1066C881O1090C887O1113C893O1133C899O1149C905O1162C911O1194C917O1211C923O1234C929O1253C935O1276C941O1297C947O1325C953O1354C958O1375C964O1399C970O1446C976O1527C984O1527C990O1515C995O1701C1003O1701C1009O1565C1015O1582C1021O1605C1027O1624C1033O1642C1039O1662C1045O1681C1051O1752C1059O1752C1063O1752C1065O1830C1073O1830C1079O1779C1085O1795C1091O1815C1096O1886C1104O1886C1110O1864C1115O1946C1123O1946C1129O1928C1135O1991C1143O1991C1149O1981C1154O2047C1162O2047C1168O2032C1174O2097C1182O2097C1186O2097C1188O2142C1192O2142C1196O2142C1198O2173C1202O2173C1206O2173C1208O2202C1212O2202C1216O2202C1218O2241C1222O2241C1226O2241C1228O2288C1232O2288C1236O2288C1238O2334C1242O2334C1246O2334C1248O2371C1252O2371C1256O2371C1258O2402C1262O2402C1266O2402C1268O2436C1272O2436C1276O2436C1278O2481C1282O2464C1288O2512C1296O2512C1302O2498C1308O2622C1316O2622C1322O2562C1327O2578C1332O2592C1337O2603C1342O2702C1346O2702C1350O2702C1352O2758C1356O2758C1358O2793C1359O2793C1361O2948C1362O2948C1364O3069C1498O8329C1508O8733C1518O8790C1530O8881C1540O8918C1572O3044C1574O27929C1580O27959C1588O27965C1594O27977C1600O27991C1606O27999C1610O28018C1620O28042C1626O28054C1632O28068C1638O28076C1644O28087C1650O28098C1656O28111C1662O28125C1668O28138C1674O28149C1680O28159C1686O28171C1696O28181C1706O28193C1716O28204C1726O28216C1736O28228C1746O28239C1756O28251C1766O28264C1776O28278C1786O28291C1796O28306C1806O28322C1816O28336C1826O28347C1846O28366C1856O28380C1866O28388C1876O27944C1885O28398,,
code-creation,Function,10,97375,0x1fa4d1d46f20,19,<instance_members_initializer> node:internal/fs/promises:127:1,0x1fa4d1d45248,~
code-source-info,0x1fa4d1d46f20,481,3044,9136,C0O3044C9O4706C18O9136,,
tick,0x1011f1f8c,97584,1,0x100b1d1ec,6,0x0,0x41ccf059096,0x1100482ec,0x2b3d46ce8b1c,0x41ccf0590b7,0x1100482ec,0x2b3d46ce6af9,0x41ccf0590b7,0x1100482ec,0x2b3d46ce1b01,0x41ccf0590b7,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
tick,0x195a84b88,97584,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x1fa4d1d414bd,0x41ccf0590b7,0x1100482ec,0x2b3d46ce8b1c,0x41ccf0590b7,0x1100482ec,0x2b3d46ce6af9,0x41ccf0590b7,0x1100482ec,0x2b3d46ce1b01,0x41ccf0590b7,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
code-creation,Eval,10,97834,0x1fa4d1d4a168,5, node:internal/fs/rimraf:1:1,0x1fa4d1d49e00,~
script-source,482,node:internal/fs/rimraf,// This file is a modified version of the rimraf module on npm. It has been\n// modified in the following ways:\n// - Use of the assert module has been replaced with core's error system.\n// - All code related to the glob dependency has been removed.\n// - Bring your own custom fs module is not currently supported.\n// - Some basic code cleanup.\n'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  Promise\x2C\n  SafeSet\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst fs = require('fs');\nconst {\n  chmod\x2C\n  chmodSync\x2C\n  lstat\x2C\n  lstatSync\x2C\n  readdir\x2C\n  readdirSync\x2C\n  rmdir\x2C\n  rmdirSync\x2C\n  stat\x2C\n  statSync\x2C\n  unlink\x2C\n  unlinkSync\x2C\n} = fs;\nconst { sep } = require('path');\nconst { setTimeout } = require('timers');\nconst { sleep } = require('internal/util');\nconst notEmptyErrorCodes = new SafeSet(['ENOTEMPTY'\x2C 'EEXIST'\x2C 'EPERM']);\nconst retryErrorCodes = new SafeSet(\n  ['EBUSY'\x2C 'EMFILE'\x2C 'ENFILE'\x2C 'ENOTEMPTY'\x2C 'EPERM']);\nconst isWindows = process.platform === 'win32';\nconst epermHandler = isWindows ? fixWinEPERM : _rmdir;\nconst epermHandlerSync = isWindows ? fixWinEPERMSync : _rmdirSync;\nconst readdirEncoding = 'buffer';\nconst separator = Buffer.from(sep);\n\n\nfunction rimraf(path\x2C options\x2C callback) {\n  let retries = 0;\n\n  _rimraf(path\x2C options\x2C function CB(err) {\n    if (err) {\n      if (retryErrorCodes.has(err.code) && retries < options.maxRetries) {\n        retries++;\n        const delay = retries * options.retryDelay;\n        return setTimeout(_rimraf\x2C delay\x2C path\x2C options\x2C CB);\n      }\n\n      // The file is already gone.\n      if (err.code === 'ENOENT')\n        err = null;\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rimraf(path\x2C options\x2C callback) {\n  // SunOS lets the root user unlink directories. Use lstat here to make sure\n  // it's not a directory.\n  lstat(path\x2C (err\x2C stats) => {\n    if (err) {\n      if (err.code === 'ENOENT')\n        return callback(null);\n\n      // Windows can EPERM on stat.\n      if (isWindows && err.code === 'EPERM')\n        return fixWinEPERM(path\x2C options\x2C err\x2C callback);\n    } else if (stats.isDirectory()) {\n      return _rmdir(path\x2C options\x2C err\x2C callback);\n    }\n\n    unlink(path\x2C (err) => {\n      if (err) {\n        if (err.code === 'ENOENT')\n          return callback(null);\n        if (err.code === 'EISDIR')\n          return _rmdir(path\x2C options\x2C err\x2C callback);\n        if (err.code === 'EPERM') {\n          return epermHandler(path\x2C options\x2C err\x2C callback);\n        }\n      }\n\n      return callback(err);\n    });\n  });\n}\n\n\nfunction fixWinEPERM(path\x2C options\x2C originalErr\x2C callback) {\n  chmod(path\x2C 0o666\x2C (err) => {\n    if (err)\n      return callback(err.code === 'ENOENT' ? null : originalErr);\n\n    stat(path\x2C (err\x2C stats) => {\n      if (err)\n        return callback(err.code === 'ENOENT' ? null : originalErr);\n\n      if (stats.isDirectory())\n        _rmdir(path\x2C options\x2C originalErr\x2C callback);\n      else\n        unlink(path\x2C callback);\n    });\n  });\n}\n\n\nfunction _rmdir(path\x2C options\x2C originalErr\x2C callback) {\n  rmdir(path\x2C (err) => {\n    if (err) {\n      if (notEmptyErrorCodes.has(err.code))\n        return _rmchildren(path\x2C options\x2C callback);\n      if (err.code === 'ENOTDIR')\n        return callback(originalErr);\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rmchildren(path\x2C options\x2C callback) {\n  const pathBuf = Buffer.from(path);\n\n  readdir(pathBuf\x2C readdirEncoding\x2C (err\x2C files) => {\n    if (err)\n      return callback(err);\n\n    let numFiles = files.length;\n\n    if (numFiles === 0)\n      return rmdir(path\x2C callback);\n\n    let done = false;\n\n    ArrayPrototypeForEach(files\x2C (child) => {\n      const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\n\n      rimraf(childPath\x2C options\x2C (err) => {\n        if (done)\n          return;\n\n        if (err) {\n          done = true;\n          return callback(err);\n        }\n\n        numFiles--;\n        if (numFiles === 0)\n          rmdir(path\x2C callback);\n      });\n    });\n  });\n}\n\n\nfunction rimrafPromises(path\x2C options) {\n  return new Promise((resolve\x2C reject) => {\n    rimraf(path\x2C options\x2C (err) => {\n      if (err)\n        return reject(err);\n\n      resolve();\n    });\n  });\n}\n\n\nfunction rimrafSync(path\x2C options) {\n  let stats;\n\n  try {\n    stats = lstatSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    // Windows can EPERM on stat.\n    if (isWindows && err.code === 'EPERM')\n      fixWinEPERMSync(path\x2C options\x2C err);\n  }\n\n  try {\n    // SunOS lets the root user unlink directories.\n    if (stats?.isDirectory())\n      _rmdirSync(path\x2C options\x2C null);\n    else\n      _unlinkSync(path\x2C options);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'EPERM')\n      return epermHandlerSync(path\x2C options\x2C err);\n    if (err.code !== 'EISDIR')\n      throw err;\n\n    _rmdirSync(path\x2C options\x2C err);\n  }\n}\n\n\nfunction _unlinkSync(path\x2C options) {\n  const tries = options.maxRetries + 1;\n\n  for (let i = 1; i <= tries; i++) {\n    try {\n      return unlinkSync(path);\n    } catch (err) {\n      // Only sleep if this is not the last try\x2C and the delay is greater\n      // than zero\x2C and an error was encountered that warrants a retry.\n      if (retryErrorCodes.has(err.code) &&\n          i < tries &&\n          options.retryDelay > 0) {\n        sleep(i * options.retryDelay);\n      } else if (err.code === 'ENOENT') {\n        // The file is already gone.\n        return;\n      } else if (i === tries) {\n        throw err;\n      }\n    }\n  }\n}\n\n\nfunction _rmdirSync(path\x2C options\x2C originalErr) {\n  try {\n    rmdirSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'ENOTDIR') {\n      throw originalErr || err;\n    }\n\n    if (notEmptyErrorCodes.has(err.code)) {\n      // Removing failed. Try removing all children and then retrying the\n      // original removal. Windows has a habit of not closing handles promptly\n      // when files are deleted\x2C resulting in spurious ENOTEMPTY failures. Work\n      // around that issue by retrying on Windows.\n      const pathBuf = Buffer.from(path);\n\n      ArrayPrototypeForEach(readdirSync(pathBuf\x2C readdirEncoding)\x2C (child) => {\n        const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\n\n        rimrafSync(childPath\x2C options);\n      });\n\n      const tries = options.maxRetries + 1;\n\n      for (let i = 1; i <= tries; i++) {\n        try {\n          return fs.rmdirSync(path);\n        } catch (err) {\n          // Only sleep if this is not the last try\x2C and the delay is greater\n          // than zero\x2C and an error was encountered that warrants a retry.\n          if (retryErrorCodes.has(err.code) &&\n              i < tries &&\n              options.retryDelay > 0) {\n            sleep(i * options.retryDelay);\n          } else if (err.code === 'ENOENT') {\n            // The file is already gone.\n            return;\n          } else if (i === tries) {\n            throw err;\n          }\n        }\n      }\n    }\n\n    throw originalErr || err;\n  }\n}\n\n\nfunction fixWinEPERMSync(path\x2C options\x2C originalErr) {\n  try {\n    chmodSync(path\x2C 0o666);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    throw originalErr;\n  }\n\n  let stats;\n\n  try {\n    stats = statSync(path\x2C { throwIfNoEntry: false });\n  } catch {\n    throw originalErr;\n  }\n\n  if (stats === undefined) return;\n\n  if (stats.isDirectory())\n    _rmdirSync(path\x2C options\x2C originalErr);\n  else\n    _unlinkSync(path\x2C options);\n}\n\n\nmodule.exports = { rimraf\x2C rimrafPromises\x2C rimrafSync };\n
code-source-info,0x1fa4d1d4a168,482,0,7454,C0O0C4O7454,,
code-creation,Function,10,98167,0x1fa4d1d4a768,409, node:internal/fs/rimraf:1:1,0x1fa4d1d4a0e0,~
code-source-info,0x1fa4d1d4a768,482,0,7454,C0O0C139O368C145O393C151O404C156O450C159O450C164O439C170O480C173O480C177O480C179O643C182O505C188O514C194O527C200O536C206O549C212O560C218O575C224O584C230O597C236O605C242O617C248O627C254O663C257O663C262O655C267O703C270O703C275O688C281O740C284O740C289O730C295O793C302O793C307O793C309O864C316O864C321O864C323O959C330O968C333O951C335O1002C345O1002C347O1061C357O1061C359O1127C361O1127C363O1155C366O1162C371O1162C376O1155C378O7397C385O7416C391O7424C397O7440C403O7412C408O7453,,
code-creation,Eval,10,98750,0x1fa4d1d4e240,5, node:internal/readline/interface:1:1,0x1fa4d1d4cda0,~
script-source,483,node:internal/readline/interface,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePop\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeReverse\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeShift\x2C\n  ArrayPrototypeUnshift\x2C\n  DateNow\x2C\n  FunctionPrototypeCall\x2C\n  MathCeil\x2C\n  MathFloor\x2C\n  MathMax\x2C\n  MathMaxApply\x2C\n  NumberIsFinite\x2C\n  NumberIsNaN\x2C\n  ObjectSetPrototypeOf\x2C\n  RegExpPrototypeExec\x2C\n  StringPrototypeCodePointAt\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  StringPrototypeTrim\x2C\n  Symbol\x2C\n  SymbolAsyncIterator\x2C\n  SafeStringIterator\x2C\n} = primordials;\n\nconst { codes } = require('internal/errors');\n\nconst {\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_USE_AFTER_CLOSE\x2C\n} = codes;\nconst {\n  validateAbortSignal\x2C\n  validateArray\x2C\n  validateString\x2C\n  validateUint32\x2C\n} = require('internal/validators');\nconst { kEmptyObject } = require('internal/util');\nconst {\n  inspect\x2C\n  getStringWidth\x2C\n  stripVTControlCharacters\x2C\n} = require('internal/util/inspect');\nconst EventEmitter = require('events');\nconst {\n  charLengthAt\x2C\n  charLengthLeft\x2C\n  commonPrefix\x2C\n  kSubstringSearch\x2C\n} = require('internal/readline/utils');\nlet emitKeypressEvents;\nconst {\n  clearScreenDown\x2C\n  cursorTo\x2C\n  moveCursor\x2C\n} = require('internal/readline/callbacks');\n\nconst { StringDecoder } = require('string_decoder');\n\n// Lazy load Readable for startup performance.\nlet Readable;\n\nconst kHistorySize = 30;\nconst kMaxUndoRedoStackSize = 2048;\nconst kMincrlfDelay = 100;\n// \\r\\n\x2C \\n\x2C or \\r followed by something other than \\n\nconst lineEnding = /\\r?\\n|\\r(?!\\n)/g;\n\nconst kLineObjectStream = Symbol('line object stream');\nconst kQuestionCancel = Symbol('kQuestionCancel');\n\n// GNU readline library - keyseq-timeout is 500ms (default)\nconst ESCAPE_CODE_TIMEOUT = 500;\n\n// Max length of the kill ring\nconst kMaxLengthOfKillRing = 32;\n\nconst kAddHistory = Symbol('_addHistory');\nconst kBeforeEdit = Symbol('_beforeEdit');\nconst kDecoder = Symbol('_decoder');\nconst kDeleteLeft = Symbol('_deleteLeft');\nconst kDeleteLineLeft = Symbol('_deleteLineLeft');\nconst kDeleteLineRight = Symbol('_deleteLineRight');\nconst kDeleteRight = Symbol('_deleteRight');\nconst kDeleteWordLeft = Symbol('_deleteWordLeft');\nconst kDeleteWordRight = Symbol('_deleteWordRight');\nconst kGetDisplayPos = Symbol('_getDisplayPos');\nconst kHistoryNext = Symbol('_historyNext');\nconst kHistoryPrev = Symbol('_historyPrev');\nconst kInsertString = Symbol('_insertString');\nconst kLine = Symbol('_line');\nconst kLine_buffer = Symbol('_line_buffer');\nconst kKillRing = Symbol('_killRing');\nconst kKillRingCursor = Symbol('_killRingCursor');\nconst kMoveCursor = Symbol('_moveCursor');\nconst kNormalWrite = Symbol('_normalWrite');\nconst kOldPrompt = Symbol('_oldPrompt');\nconst kOnLine = Symbol('_onLine');\nconst kPreviousKey = Symbol('_previousKey');\nconst kPrompt = Symbol('_prompt');\nconst kPushToKillRing = Symbol('_pushToKillRing');\nconst kPushToUndoStack = Symbol('_pushToUndoStack');\nconst kQuestionCallback = Symbol('_questionCallback');\nconst kRedo = Symbol('_redo');\nconst kRedoStack = Symbol('_redoStack');\nconst kRefreshLine = Symbol('_refreshLine');\nconst kSawKeyPress = Symbol('_sawKeyPress');\nconst kSawReturnAt = Symbol('_sawReturnAt');\nconst kSetRawMode = Symbol('_setRawMode');\nconst kTabComplete = Symbol('_tabComplete');\nconst kTabCompleter = Symbol('_tabCompleter');\nconst kTtyWrite = Symbol('_ttyWrite');\nconst kUndo = Symbol('_undo');\nconst kUndoStack = Symbol('_undoStack');\nconst kWordLeft = Symbol('_wordLeft');\nconst kWordRight = Symbol('_wordRight');\nconst kWriteToOutput = Symbol('_writeToOutput');\nconst kYank = Symbol('_yank');\nconst kYanking = Symbol('_yanking');\nconst kYankPop = Symbol('_yankPop');\n\nfunction InterfaceConstructor(input\x2C output\x2C completer\x2C terminal) {\n  this[kSawReturnAt] = 0;\n  // TODO(BridgeAR): Document this property. The name is not ideal\x2C so we\n  // might want to expose an alias and document that instead.\n  this.isCompletionEnabled = true;\n  this[kSawKeyPress] = false;\n  this[kPreviousKey] = null;\n  this.escapeCodeTimeout = ESCAPE_CODE_TIMEOUT;\n  this.tabSize = 8;\n\n  FunctionPrototypeCall(EventEmitter\x2C this);\n\n  let history;\n  let historySize;\n  let removeHistoryDuplicates = false;\n  let crlfDelay;\n  let prompt = '> ';\n  let signal;\n\n  if (input?.input) {\n    // An options object was given\n    output = input.output;\n    completer = input.completer;\n    terminal = input.terminal;\n    history = input.history;\n    historySize = input.historySize;\n    signal = input.signal;\n    if (input.tabSize !== undefined) {\n      validateUint32(input.tabSize\x2C 'tabSize'\x2C true);\n      this.tabSize = input.tabSize;\n    }\n    removeHistoryDuplicates = input.removeHistoryDuplicates;\n    if (input.prompt !== undefined) {\n      prompt = input.prompt;\n    }\n    if (input.escapeCodeTimeout !== undefined) {\n      if (NumberIsFinite(input.escapeCodeTimeout)) {\n        this.escapeCodeTimeout = input.escapeCodeTimeout;\n      } else {\n        throw new ERR_INVALID_ARG_VALUE(\n          'input.escapeCodeTimeout'\x2C\n          this.escapeCodeTimeout\x2C\n        );\n      }\n    }\n\n    if (signal) {\n      validateAbortSignal(signal\x2C 'options.signal');\n    }\n\n    crlfDelay = input.crlfDelay;\n    input = input.input;\n  }\n\n  if (completer !== undefined && typeof completer !== 'function') {\n    throw new ERR_INVALID_ARG_VALUE('completer'\x2C completer);\n  }\n\n  if (history === undefined) {\n    history = [];\n  } else {\n    validateArray(history\x2C 'history');\n  }\n\n  if (historySize === undefined) {\n    historySize = kHistorySize;\n  }\n\n  if (\n    typeof historySize !== 'number' ||\n      NumberIsNaN(historySize) ||\n      historySize < 0\n  ) {\n    throw new ERR_INVALID_ARG_VALUE.RangeError('historySize'\x2C historySize);\n  }\n\n  // Backwards compat; check the isTTY prop of the output stream\n  //  when `terminal` was not specified\n  if (terminal === undefined && !(output === null || output === undefined)) {\n    terminal = !!output.isTTY;\n  }\n\n  const self = this;\n\n  this.line = '';\n  this[kSubstringSearch] = null;\n  this.output = output;\n  this.input = input;\n  this[kUndoStack] = [];\n  this[kRedoStack] = [];\n  this.history = history;\n  this.historySize = historySize;\n\n  // The kill ring is a global list of blocks of text that were previously\n  // killed (deleted). If its size exceeds kMaxLengthOfKillRing\x2C the oldest\n  // element will be removed to make room for the latest deletion. With kill\n  // ring\x2C users are able to recall (yank) or cycle (yank pop) among previously\n  // killed texts\x2C quite similar to the behavior of Emacs.\n  this[kKillRing] = [];\n  this[kKillRingCursor] = 0;\n\n  this.removeHistoryDuplicates = !!removeHistoryDuplicates;\n  this.crlfDelay = crlfDelay ?\n    MathMax(kMincrlfDelay\x2C crlfDelay) :\n    kMincrlfDelay;\n  this.completer = completer;\n\n  this.setPrompt(prompt);\n\n  this.terminal = !!terminal;\n\n\n  function onerror(err) {\n    self.emit('error'\x2C err);\n  }\n\n  function ondata(data) {\n    self[kNormalWrite](data);\n  }\n\n  function onend() {\n    if (\n      typeof self[kLine_buffer] === 'string' &&\n        self[kLine_buffer].length > 0\n    ) {\n      self.emit('line'\x2C self[kLine_buffer]);\n    }\n    self.close();\n  }\n\n  function ontermend() {\n    if (typeof self.line === 'string' && self.line.length > 0) {\n      self.emit('line'\x2C self.line);\n    }\n    self.close();\n  }\n\n  function onkeypress(s\x2C key) {\n    self[kTtyWrite](s\x2C key);\n    if (key && key.sequence) {\n      // If the key.sequence is half of a surrogate pair\n      // (>= 0xd800 and <= 0xdfff)\x2C refresh the line so\n      // the character is displayed appropriately.\n      const ch = StringPrototypeCodePointAt(key.sequence\x2C 0);\n      if (ch >= 0xd800 && ch <= 0xdfff) self[kRefreshLine]();\n    }\n  }\n\n  function onresize() {\n    self[kRefreshLine]();\n  }\n\n  this[kLineObjectStream] = undefined;\n\n  input.on('error'\x2C onerror);\n\n  if (!this.terminal) {\n    function onSelfCloseWithoutTerminal() {\n      input.removeListener('data'\x2C ondata);\n      input.removeListener('error'\x2C onerror);\n      input.removeListener('end'\x2C onend);\n    }\n\n    input.on('data'\x2C ondata);\n    input.on('end'\x2C onend);\n    self.once('close'\x2C onSelfCloseWithoutTerminal);\n    this[kDecoder] = new StringDecoder('utf8');\n  } else {\n    function onSelfCloseWithTerminal() {\n      input.removeListener('keypress'\x2C onkeypress);\n      input.removeListener('error'\x2C onerror);\n      input.removeListener('end'\x2C ontermend);\n      if (output !== null && output !== undefined) {\n        output.removeListener('resize'\x2C onresize);\n      }\n    }\n\n    emitKeypressEvents ??= require('internal/readline/emitKeypressEvents');\n    emitKeypressEvents(input\x2C this);\n\n    // `input` usually refers to stdin\n    input.on('keypress'\x2C onkeypress);\n    input.on('end'\x2C ontermend);\n\n    this[kSetRawMode](true);\n    this.terminal = true;\n\n    // Cursor position on the line.\n    this.cursor = 0;\n\n    this.historyIndex = -1;\n\n    if (output !== null && output !== undefined)\n      output.on('resize'\x2C onresize);\n\n    self.once('close'\x2C onSelfCloseWithTerminal);\n  }\n\n  if (signal) {\n    const onAborted = () => self.close();\n    if (signal.aborted) {\n      process.nextTick(onAborted);\n    } else {\n      signal.addEventListener('abort'\x2C onAborted\x2C { once: true });\n      self.once('close'\x2C () => signal.removeEventListener('abort'\x2C onAborted));\n    }\n  }\n\n  // Current line\n  this.line = '';\n\n  input.resume();\n}\n\nObjectSetPrototypeOf(InterfaceConstructor.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(InterfaceConstructor\x2C EventEmitter);\n\nclass Interface extends InterfaceConstructor {\n  // eslint-disable-next-line no-useless-constructor\n  constructor(input\x2C output\x2C completer\x2C terminal) {\n    super(input\x2C output\x2C completer\x2C terminal);\n  }\n  get columns() {\n    if (this.output && this.output.columns) return this.output.columns;\n    return Infinity;\n  }\n\n  /**\n   * Sets the prompt written to the output.\n   * @param {string} prompt\n   * @returns {void}\n   */\n  setPrompt(prompt) {\n    this[kPrompt] = prompt;\n  }\n\n  /**\n   * Returns the current prompt used by `rl.prompt()`.\n   * @returns {string}\n   */\n  getPrompt() {\n    return this[kPrompt];\n  }\n\n  [kSetRawMode](mode) {\n    const wasInRawMode = this.input.isRaw;\n\n    if (typeof this.input.setRawMode === 'function') {\n      this.input.setRawMode(mode);\n    }\n\n    return wasInRawMode;\n  }\n\n  /**\n   * Writes the configured `prompt` to a new line in `output`.\n   * @param {boolean} [preserveCursor]\n   * @returns {void}\n   */\n  prompt(preserveCursor) {\n    if (this.paused) this.resume();\n    if (this.terminal && process.env.TERM !== 'dumb') {\n      if (!preserveCursor) this.cursor = 0;\n      this[kRefreshLine]();\n    } else {\n      this[kWriteToOutput](this[kPrompt]);\n    }\n  }\n\n  question(query\x2C cb) {\n    if (this.closed) {\n      throw new ERR_USE_AFTER_CLOSE('readline');\n    }\n    if (this[kQuestionCallback]) {\n      this.prompt();\n    } else {\n      this[kOldPrompt] = this[kPrompt];\n      this.setPrompt(query);\n      this[kQuestionCallback] = cb;\n      this.prompt();\n    }\n  }\n\n  [kOnLine](line) {\n    if (this[kQuestionCallback]) {\n      const cb = this[kQuestionCallback];\n      this[kQuestionCallback] = null;\n      this.setPrompt(this[kOldPrompt]);\n      cb(line);\n    } else {\n      this.emit('line'\x2C line);\n    }\n  }\n\n  [kBeforeEdit](oldText\x2C oldCursor) {\n    this[kPushToUndoStack](oldText\x2C oldCursor);\n  }\n\n  [kQuestionCancel]() {\n    if (this[kQuestionCallback]) {\n      this[kQuestionCallback] = null;\n      this.setPrompt(this[kOldPrompt]);\n      this.clearLine();\n    }\n  }\n\n  [kWriteToOutput](stringToWrite) {\n    validateString(stringToWrite\x2C 'stringToWrite');\n\n    if (this.output !== null && this.output !== undefined) {\n      this.output.write(stringToWrite);\n    }\n  }\n\n  [kAddHistory]() {\n    if (this.line.length === 0) return '';\n\n    // If the history is disabled then return the line\n    if (this.historySize === 0) return this.line;\n\n    // If the trimmed line is empty then return the line\n    if (StringPrototypeTrim(this.line).length === 0) return this.line;\n\n    if (this.history.length === 0 || this.history[0] !== this.line) {\n      if (this.removeHistoryDuplicates) {\n        // Remove older history line if identical to new one\n        const dupIndex = ArrayPrototypeIndexOf(this.history\x2C this.line);\n        if (dupIndex !== -1) ArrayPrototypeSplice(this.history\x2C dupIndex\x2C 1);\n      }\n\n      ArrayPrototypeUnshift(this.history\x2C this.line);\n\n      // Only store so many\n      if (this.history.length > this.historySize)\n        ArrayPrototypePop(this.history);\n    }\n\n    this.historyIndex = -1;\n\n    // The listener could change the history object\x2C possibly\n    // to remove the last added entry if it is sensitive and should\n    // not be persisted in the history\x2C like a password\n    const line = this.history[0];\n\n    // Emit history event to notify listeners of update\n    this.emit('history'\x2C this.history);\n\n    return line;\n  }\n\n  [kRefreshLine]() {\n    // line length\n    const line = this[kPrompt] + this.line;\n    const dispPos = this[kGetDisplayPos](line);\n    const lineCols = dispPos.cols;\n    const lineRows = dispPos.rows;\n\n    // cursor position\n    const cursorPos = this.getCursorPos();\n\n    // First move to the bottom of the current line\x2C based on cursor pos\n    const prevRows = this.prevRows || 0;\n    if (prevRows > 0) {\n      moveCursor(this.output\x2C 0\x2C -prevRows);\n    }\n\n    // Cursor to left edge.\n    cursorTo(this.output\x2C 0);\n    // erase data\n    clearScreenDown(this.output);\n\n    // Write the prompt and the current buffer content.\n    this[kWriteToOutput](line);\n\n    // Force terminal to allocate a new line\n    if (lineCols === 0) {\n      this[kWriteToOutput](' ');\n    }\n\n    // Move cursor to original position.\n    cursorTo(this.output\x2C cursorPos.cols);\n\n    const diff = lineRows - cursorPos.rows;\n    if (diff > 0) {\n      moveCursor(this.output\x2C 0\x2C -diff);\n    }\n\n    this.prevRows = cursorPos.rows;\n  }\n\n  /**\n   * Closes the `readline.Interface` instance.\n   * @returns {void}\n   */\n  close() {\n    if (this.closed) return;\n    this.pause();\n    if (this.terminal) {\n      this[kSetRawMode](false);\n    }\n    this.closed = true;\n    this.emit('close');\n  }\n\n  /**\n   * Pauses the `input` stream.\n   * @returns {void | Interface}\n   */\n  pause() {\n    if (this.paused) return;\n    this.input.pause();\n    this.paused = true;\n    this.emit('pause');\n    return this;\n  }\n\n  /**\n   * Resumes the `input` stream if paused.\n   * @returns {void | Interface}\n   */\n  resume() {\n    if (!this.paused) return;\n    this.input.resume();\n    this.paused = false;\n    this.emit('resume');\n    return this;\n  }\n\n  /**\n   * Writes either `data` or a `key` sequence identified by\n   * `key` to the `output`.\n   * @param {string} d\n   * @param {{\n   *   ctrl?: boolean;\n   *   meta?: boolean;\n   *   shift?: boolean;\n   *   name?: string;\n   *   }} [key]\n   * @returns {void}\n   */\n  write(d\x2C key) {\n    if (this.paused) this.resume();\n    if (this.terminal) {\n      this[kTtyWrite](d\x2C key);\n    } else {\n      this[kNormalWrite](d);\n    }\n  }\n\n  [kNormalWrite](b) {\n    if (b === undefined) {\n      return;\n    }\n    let string = this[kDecoder].write(b);\n    if (\n      this[kSawReturnAt] &&\n      DateNow() - this[kSawReturnAt] <= this.crlfDelay\n    ) {\n      if (StringPrototypeCodePointAt(string) === 10) string = StringPrototypeSlice(string\x2C 1);\n      this[kSawReturnAt] = 0;\n    }\n\n    // Run test() on the new string chunk\x2C not on the entire line buffer.\n    let newPartContainsEnding = RegExpPrototypeExec(lineEnding\x2C string);\n    if (newPartContainsEnding !== null) {\n      if (this[kLine_buffer]) {\n        string = this[kLine_buffer] + string;\n        this[kLine_buffer] = null;\n        lineEnding.lastIndex = 0; // Start the search from the beginning of the string.\n        newPartContainsEnding = RegExpPrototypeExec(lineEnding\x2C string);\n      }\n      this[kSawReturnAt] = StringPrototypeEndsWith(string\x2C '\\r') ?\n        DateNow() :\n        0;\n\n      const indexes = [0\x2C newPartContainsEnding.index\x2C lineEnding.lastIndex];\n      let nextMatch;\n      while ((nextMatch = RegExpPrototypeExec(lineEnding\x2C string)) !== null) {\n        ArrayPrototypePush(indexes\x2C nextMatch.index\x2C lineEnding.lastIndex);\n      }\n      const lastIndex = indexes.length - 1;\n      // Either '' or (conceivably) the unfinished portion of the next line\n      this[kLine_buffer] = StringPrototypeSlice(string\x2C indexes[lastIndex]);\n      for (let i = 1; i < lastIndex; i += 2) {\n        this[kOnLine](StringPrototypeSlice(string\x2C indexes[i - 1]\x2C indexes[i]));\n      }\n    } else if (string) {\n      // No newlines this time\x2C save what we have for next time\n      if (this[kLine_buffer]) {\n        this[kLine_buffer] += string;\n      } else {\n        this[kLine_buffer] = string;\n      }\n    }\n  }\n\n  [kInsertString](c) {\n    this[kBeforeEdit](this.line\x2C this.cursor);\n    if (this.cursor < this.line.length) {\n      const beg = StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n      const end = StringPrototypeSlice(\n        this.line\x2C\n        this.cursor\x2C\n        this.line.length\x2C\n      );\n      this.line = beg + c + end;\n      this.cursor += c.length;\n      this[kRefreshLine]();\n    } else {\n      const oldPos = this.getCursorPos();\n      this.line += c;\n      this.cursor += c.length;\n      const newPos = this.getCursorPos();\n\n      if (oldPos.rows < newPos.rows) {\n        this[kRefreshLine]();\n      } else {\n        this[kWriteToOutput](c);\n      }\n    }\n  }\n\n  async [kTabComplete](lastKeypressWasTab) {\n    this.pause();\n    const string = StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n    let value;\n    try {\n      value = await this.completer(string);\n    } catch (err) {\n      this[kWriteToOutput](`Tab completion error: ${inspect(err)}`);\n      return;\n    } finally {\n      this.resume();\n    }\n    this[kTabCompleter](lastKeypressWasTab\x2C value);\n  }\n\n  [kTabCompleter](lastKeypressWasTab\x2C { 0: completions\x2C 1: completeOn }) {\n    // Result and the text that was completed.\n\n    if (!completions || completions.length === 0) {\n      return;\n    }\n\n    // If there is a common prefix to all matches\x2C then apply that portion.\n    const prefix = commonPrefix(\n      ArrayPrototypeFilter(completions\x2C (e) => e !== '')\x2C\n    );\n    if (StringPrototypeStartsWith(prefix\x2C completeOn) &&\n        prefix.length > completeOn.length) {\n      this[kInsertString](StringPrototypeSlice(prefix\x2C completeOn.length));\n      return;\n    } else if (!StringPrototypeStartsWith(completeOn\x2C prefix)) {\n      this.line = StringPrototypeSlice(this.line\x2C\n                                       0\x2C\n                                       this.cursor - completeOn.length) +\n                  prefix +\n                  StringPrototypeSlice(this.line\x2C\n                                       this.cursor\x2C\n                                       this.line.length);\n      this.cursor = this.cursor - completeOn.length + prefix.length;\n      this._refreshLine();\n      return;\n    }\n\n    if (!lastKeypressWasTab) {\n      return;\n    }\n\n    this[kBeforeEdit](this.line\x2C this.cursor);\n\n    // Apply/show completions.\n    const completionsWidth = ArrayPrototypeMap(completions\x2C (e) =>\n      getStringWidth(e)\x2C\n    );\n    const width = MathMaxApply(completionsWidth) + 2; // 2 space padding\n    let maxColumns = MathFloor(this.columns / width) || 1;\n    if (maxColumns === Infinity) {\n      maxColumns = 1;\n    }\n    let output = '\\r\\n';\n    let lineIndex = 0;\n    let whitespace = 0;\n    for (let i = 0; i < completions.length; i++) {\n      const completion = completions[i];\n      if (completion === '' || lineIndex === maxColumns) {\n        output += '\\r\\n';\n        lineIndex = 0;\n        whitespace = 0;\n      } else {\n        output += StringPrototypeRepeat(' '\x2C whitespace);\n      }\n      if (completion !== '') {\n        output += completion;\n        whitespace = width - completionsWidth[i];\n        lineIndex++;\n      } else {\n        output += '\\r\\n';\n      }\n    }\n    if (lineIndex !== 0) {\n      output += '\\r\\n\\r\\n';\n    }\n    this[kWriteToOutput](output);\n    this[kRefreshLine]();\n  }\n\n  [kWordLeft]() {\n    if (this.cursor > 0) {\n      // Reverse the string and match a word near beginning\n      // to avoid quadratic time complexity\n      const leading = StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n      const reversed = ArrayPrototypeJoin(\n        ArrayPrototypeReverse(ArrayFrom(leading))\x2C\n        ''\x2C\n      );\n      const match = RegExpPrototypeExec(/^\\s*(?:[^\\w\\s]+|\\w+)?/\x2C reversed);\n      this[kMoveCursor](-match[0].length);\n    }\n  }\n\n  [kWordRight]() {\n    if (this.cursor < this.line.length) {\n      const trailing = StringPrototypeSlice(this.line\x2C this.cursor);\n      const match = RegExpPrototypeExec(/^(?:\\s+|[^\\w\\s]+|\\w+)\\s*/\x2C trailing);\n      this[kMoveCursor](match[0].length);\n    }\n  }\n\n  [kDeleteLeft]() {\n    if (this.cursor > 0 && this.line.length > 0) {\n      this[kBeforeEdit](this.line\x2C this.cursor);\n      // The number of UTF-16 units comprising the character to the left\n      const charSize = charLengthLeft(this.line\x2C this.cursor);\n      this.line =\n        StringPrototypeSlice(this.line\x2C 0\x2C this.cursor - charSize) +\n        StringPrototypeSlice(this.line\x2C this.cursor\x2C this.line.length);\n\n      this.cursor -= charSize;\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line\x2C this.cursor);\n      // The number of UTF-16 units comprising the character to the left\n      const charSize = charLengthAt(this.line\x2C this.cursor);\n      this.line =\n        StringPrototypeSlice(this.line\x2C 0\x2C this.cursor) +\n        StringPrototypeSlice(\n          this.line\x2C\n          this.cursor + charSize\x2C\n          this.line.length\x2C\n        );\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteWordLeft]() {\n    if (this.cursor > 0) {\n      this[kBeforeEdit](this.line\x2C this.cursor);\n      // Reverse the string and match a word near beginning\n      // to avoid quadratic time complexity\n      let leading = StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n      const reversed = ArrayPrototypeJoin(\n        ArrayPrototypeReverse(ArrayFrom(leading))\x2C\n        ''\x2C\n      );\n      const match = RegExpPrototypeExec(/^\\s*(?:[^\\w\\s]+|\\w+)?/\x2C reversed);\n      leading = StringPrototypeSlice(\n        leading\x2C\n        0\x2C\n        leading.length - match[0].length\x2C\n      );\n      this.line =\n        leading +\n        StringPrototypeSlice(this.line\x2C this.cursor\x2C this.line.length);\n      this.cursor = leading.length;\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteWordRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line\x2C this.cursor);\n      const trailing = StringPrototypeSlice(this.line\x2C this.cursor);\n      const match = RegExpPrototypeExec(/^(?:\\s+|\\W+|\\w+)\\s*/\x2C trailing);\n      this.line =\n        StringPrototypeSlice(this.line\x2C 0\x2C this.cursor) +\n        StringPrototypeSlice(trailing\x2C match[0].length);\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteLineLeft]() {\n    this[kBeforeEdit](this.line\x2C this.cursor);\n    const del = StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n    this.line = StringPrototypeSlice(this.line\x2C this.cursor);\n    this.cursor = 0;\n    this[kPushToKillRing](del);\n    this[kRefreshLine]();\n  }\n\n  [kDeleteLineRight]() {\n    this[kBeforeEdit](this.line\x2C this.cursor);\n    const del = StringPrototypeSlice(this.line\x2C this.cursor);\n    this.line = StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n    this[kPushToKillRing](del);\n    this[kRefreshLine]();\n  }\n\n  [kPushToKillRing](del) {\n    if (!del || del === this[kKillRing][0]) return;\n    ArrayPrototypeUnshift(this[kKillRing]\x2C del);\n    this[kKillRingCursor] = 0;\n    while (this[kKillRing].length > kMaxLengthOfKillRing)\n      ArrayPrototypePop(this[kKillRing]);\n  }\n\n  [kYank]() {\n    if (this[kKillRing].length > 0) {\n      this[kYanking] = true;\n      this[kInsertString](this[kKillRing][this[kKillRingCursor]]);\n    }\n  }\n\n  [kYankPop]() {\n    if (!this[kYanking]) {\n      return;\n    }\n    if (this[kKillRing].length > 1) {\n      const lastYank = this[kKillRing][this[kKillRingCursor]];\n      this[kKillRingCursor]++;\n      if (this[kKillRingCursor] >= this[kKillRing].length) {\n        this[kKillRingCursor] = 0;\n      }\n      const currentYank = this[kKillRing][this[kKillRingCursor]];\n      const head =\n            StringPrototypeSlice(this.line\x2C 0\x2C this.cursor - lastYank.length);\n      const tail =\n            StringPrototypeSlice(this.line\x2C this.cursor);\n      this.line = head + currentYank + tail;\n      this.cursor = head.length + currentYank.length;\n      this[kRefreshLine]();\n    }\n  }\n\n  clearLine() {\n    this[kMoveCursor](+Infinity);\n    this[kWriteToOutput]('\\r\\n');\n    this.line = '';\n    this.cursor = 0;\n    this.prevRows = 0;\n  }\n\n  [kLine]() {\n    const line = this[kAddHistory]();\n    this[kUndoStack] = [];\n    this[kRedoStack] = [];\n    this.clearLine();\n    this[kOnLine](line);\n  }\n\n  [kPushToUndoStack](text\x2C cursor) {\n    if (ArrayPrototypePush(this[kUndoStack]\x2C { text\x2C cursor }) >\n        kMaxUndoRedoStackSize) {\n      ArrayPrototypeShift(this[kUndoStack]);\n    }\n  }\n\n  [kUndo]() {\n    if (this[kUndoStack].length <= 0) return;\n\n    ArrayPrototypePush(\n      this[kRedoStack]\x2C\n      { text: this.line\x2C cursor: this.cursor }\x2C\n    );\n\n    const entry = ArrayPrototypePop(this[kUndoStack]);\n    this.line = entry.text;\n    this.cursor = entry.cursor;\n\n    this[kRefreshLine]();\n  }\n\n  [kRedo]() {\n    if (this[kRedoStack].length <= 0) return;\n\n    ArrayPrototypePush(\n      this[kUndoStack]\x2C\n      { text: this.line\x2C cursor: this.cursor }\x2C\n    );\n\n    const entry = ArrayPrototypePop(this[kRedoStack]);\n    this.line = entry.text;\n    this.cursor = entry.cursor;\n\n    this[kRefreshLine]();\n  }\n\n  // TODO(BridgeAR): Add underscores to the search part and a red background in\n  // case no match is found. This should only be the visual part and not the\n  // actual line content!\n  // TODO(BridgeAR): In case the substring based search is active and the end is\n  // reached\x2C show a comment how to search the history as before. E.g.\x2C using\n  // <ctrl> + N. Only show this after two/three UPs or DOWNs\x2C not on the first\n  // one.\n  [kHistoryNext]() {\n    if (this.historyIndex >= 0) {\n      this[kBeforeEdit](this.line\x2C this.cursor);\n      const search = this[kSubstringSearch] || '';\n      let index = this.historyIndex - 1;\n      while (\n        index >= 0 &&\n        (!StringPrototypeStartsWith(this.history[index]\x2C search) ||\n          this.line === this.history[index])\n      ) {\n        index--;\n      }\n      if (index === -1) {\n        this.line = search;\n      } else {\n        this.line = this.history[index];\n      }\n      this.historyIndex = index;\n      this.cursor = this.line.length; // Set cursor to end of line.\n      this[kRefreshLine]();\n    }\n  }\n\n  [kHistoryPrev]() {\n    if (this.historyIndex < this.history.length && this.history.length) {\n      this[kBeforeEdit](this.line\x2C this.cursor);\n      const search = this[kSubstringSearch] || '';\n      let index = this.historyIndex + 1;\n      while (\n        index < this.history.length &&\n        (!StringPrototypeStartsWith(this.history[index]\x2C search) ||\n          this.line === this.history[index])\n      ) {\n        index++;\n      }\n      if (index === this.history.length) {\n        this.line = search;\n      } else {\n        this.line = this.history[index];\n      }\n      this.historyIndex = index;\n      this.cursor = this.line.length; // Set cursor to end of line.\n      this[kRefreshLine]();\n    }\n  }\n\n  // Returns the last character's display position of the given string\n  [kGetDisplayPos](str) {\n    let offset = 0;\n    const col = this.columns;\n    let rows = 0;\n    str = stripVTControlCharacters(str);\n    for (const char of new SafeStringIterator(str)) {\n      if (char === '\\n') {\n        // Rows must be incremented by 1 even if offset = 0 or col = +Infinity.\n        rows += MathCeil(offset / col) || 1;\n        offset = 0;\n        continue;\n      }\n      // Tabs must be aligned by an offset of the tab size.\n      if (char === '\\t') {\n        offset += this.tabSize - (offset % this.tabSize);\n        continue;\n      }\n      const width = getStringWidth(char\x2C false /* stripVTControlCharacters */);\n      if (width === 0 || width === 1) {\n        offset += width;\n      } else {\n        // width === 2\n        if ((offset + 1) % col === 0) {\n          offset++;\n        }\n        offset += 2;\n      }\n    }\n    const cols = offset % col;\n    rows += (offset - cols) / col;\n    return { cols\x2C rows };\n  }\n\n  /**\n   * Returns the real position of the cursor in relation\n   * to the input prompt + string.\n   * @returns {{\n   *   rows: number;\n   *   cols: number;\n   *   }}\n   */\n  getCursorPos() {\n    const strBeforeCursor =\n      this[kPrompt] + StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n    return this[kGetDisplayPos](strBeforeCursor);\n  }\n\n  // This function moves cursor dx places to the right\n  // (-dx for left) and refreshes the line if it is needed.\n  [kMoveCursor](dx) {\n    if (dx === 0) {\n      return;\n    }\n    const oldPos = this.getCursorPos();\n    this.cursor += dx;\n\n    // Bounds check\n    if (this.cursor < 0) {\n      this.cursor = 0;\n    } else if (this.cursor > this.line.length) {\n      this.cursor = this.line.length;\n    }\n\n    const newPos = this.getCursorPos();\n\n    // Check if cursor stayed on the line.\n    if (oldPos.rows === newPos.rows) {\n      const diffWidth = newPos.cols - oldPos.cols;\n      moveCursor(this.output\x2C diffWidth\x2C 0);\n    } else {\n      this[kRefreshLine]();\n    }\n  }\n\n  // Handle a write from the tty\n  [kTtyWrite](s\x2C key) {\n    const previousKey = this[kPreviousKey];\n    key = key || kEmptyObject;\n    this[kPreviousKey] = key;\n\n    if (!key.meta || key.name !== 'y') {\n      // Reset yanking state unless we are doing yank pop.\n      this[kYanking] = false;\n    }\n\n    // Activate or deactivate substring search.\n    if (\n      (key.name === 'up' || key.name === 'down') &&\n      !key.ctrl &&\n      !key.meta &&\n      !key.shift\n    ) {\n      if (this[kSubstringSearch] === null) {\n        this[kSubstringSearch] = StringPrototypeSlice(\n          this.line\x2C\n          0\x2C\n          this.cursor\x2C\n        );\n      }\n    } else if (this[kSubstringSearch] !== null) {\n      this[kSubstringSearch] = null;\n      // Reset the index in case there's no match.\n      if (this.history.length === this.historyIndex) {\n        this.historyIndex = -1;\n      }\n    }\n\n    // Undo & Redo\n    if (typeof key.sequence === 'string') {\n      switch (StringPrototypeCodePointAt(key.sequence\x2C 0)) {\n        case 0x1f:\n          this[kUndo]();\n          return;\n        case 0x1e:\n          this[kRedo]();\n          return;\n        default:\n          break;\n      }\n    }\n\n    // Ignore escape key\x2C fixes\n    // https://github.com/nodejs/node-v0.x-archive/issues/2876.\n    if (key.name === 'escape') return;\n\n    if (key.ctrl && key.shift) {\n      /* Control and shift pressed */\n      switch (key.name) {\n        // TODO(BridgeAR): The transmitted escape sequence is `\\b` and that is\n        // identical to <ctrl>-h. It should have a unique escape sequence.\n        case 'backspace':\n          this[kDeleteLineLeft]();\n          break;\n\n        case 'delete':\n          this[kDeleteLineRight]();\n          break;\n      }\n    } else if (key.ctrl) {\n      /* Control key pressed */\n\n      switch (key.name) {\n        case 'c':\n          if (this.listenerCount('SIGINT') > 0) {\n            this.emit('SIGINT');\n          } else {\n            // This readline instance is finished\n            this.close();\n          }\n          break;\n\n        case 'h': // delete left\n          this[kDeleteLeft]();\n          break;\n\n        case 'd': // delete right or EOF\n          if (this.cursor === 0 && this.line.length === 0) {\n            // This readline instance is finished\n            this.close();\n          } else if (this.cursor < this.line.length) {\n            this[kDeleteRight]();\n          }\n          break;\n\n        case 'u': // Delete from current to start of line\n          this[kDeleteLineLeft]();\n          break;\n\n        case 'k': // Delete from current to end of line\n          this[kDeleteLineRight]();\n          break;\n\n        case 'a': // Go to the start of the line\n          this[kMoveCursor](-Infinity);\n          break;\n\n        case 'e': // Go to the end of the line\n          this[kMoveCursor](+Infinity);\n          break;\n\n        case 'b': // back one character\n          this[kMoveCursor](-charLengthLeft(this.line\x2C this.cursor));\n          break;\n\n        case 'f': // Forward one character\n          this[kMoveCursor](+charLengthAt(this.line\x2C this.cursor));\n          break;\n\n        case 'l': // Clear the whole screen\n          cursorTo(this.output\x2C 0\x2C 0);\n          clearScreenDown(this.output);\n          this[kRefreshLine]();\n          break;\n\n        case 'n': // next history item\n          this[kHistoryNext]();\n          break;\n\n        case 'p': // Previous history item\n          this[kHistoryPrev]();\n          break;\n\n        case 'y': // Yank killed string\n          this[kYank]();\n          break;\n\n        case 'z':\n          if (process.platform === 'win32') break;\n          if (this.listenerCount('SIGTSTP') > 0) {\n            this.emit('SIGTSTP');\n          } else {\n            process.once('SIGCONT'\x2C () => {\n              // Don't raise events if stream has already been abandoned.\n              if (!this.paused) {\n                // Stream must be paused and resumed after SIGCONT to catch\n                // SIGINT\x2C SIGTSTP\x2C and EOF.\n                this.pause();\n                this.emit('SIGCONT');\n              }\n              // Explicitly re-enable "raw mode" and move the cursor to\n              // the correct position.\n              // See https://github.com/joyent/node/issues/3295.\n              this[kSetRawMode](true);\n              this[kRefreshLine]();\n            });\n            this[kSetRawMode](false);\n            process.kill(process.pid\x2C 'SIGTSTP');\n          }\n          break;\n\n        case 'w': // Delete backwards to a word boundary\n        // TODO(BridgeAR): The transmitted escape sequence is `\\b` and that is\n        // identical to <ctrl>-h. It should have a unique escape sequence.\n        // Falls through\n        case 'backspace':\n          this[kDeleteWordLeft]();\n          break;\n\n        case 'delete': // Delete forward to a word boundary\n          this[kDeleteWordRight]();\n          break;\n\n        case 'left':\n          this[kWordLeft]();\n          break;\n\n        case 'right':\n          this[kWordRight]();\n          break;\n      }\n    } else if (key.meta) {\n      /* Meta key pressed */\n\n      switch (key.name) {\n        case 'b': // backward word\n          this[kWordLeft]();\n          break;\n\n        case 'f': // forward word\n          this[kWordRight]();\n          break;\n\n        case 'd': // delete forward word\n        case 'delete':\n          this[kDeleteWordRight]();\n          break;\n\n        case 'backspace': // Delete backwards to a word boundary\n          this[kDeleteWordLeft]();\n          break;\n\n        case 'y': // Doing yank pop\n          this[kYankPop]();\n          break;\n      }\n    } else {\n      /* No modifier keys used */\n\n      // \\r bookkeeping is only relevant if a \\n comes right after.\n      if (this[kSawReturnAt] && key.name !== 'enter') this[kSawReturnAt] = 0;\n\n      switch (key.name) {\n        case 'return': // Carriage return\x2C i.e. \\r\n          this[kSawReturnAt] = DateNow();\n          this[kLine]();\n          break;\n\n        case 'enter':\n          // When key interval > crlfDelay\n          if (\n            this[kSawReturnAt] === 0 ||\n            DateNow() - this[kSawReturnAt] > this.crlfDelay\n          ) {\n            this[kLine]();\n          }\n          this[kSawReturnAt] = 0;\n          break;\n\n        case 'backspace':\n          this[kDeleteLeft]();\n          break;\n\n        case 'delete':\n          this[kDeleteRight]();\n          break;\n\n        case 'left':\n          // Obtain the code point to the left\n          this[kMoveCursor](-charLengthLeft(this.line\x2C this.cursor));\n          break;\n\n        case 'right':\n          this[kMoveCursor](+charLengthAt(this.line\x2C this.cursor));\n          break;\n\n        case 'home':\n          this[kMoveCursor](-Infinity);\n          break;\n\n        case 'end':\n          this[kMoveCursor](+Infinity);\n          break;\n\n        case 'up':\n          this[kHistoryPrev]();\n          break;\n\n        case 'down':\n          this[kHistoryNext]();\n          break;\n\n        case 'tab':\n          // If tab completion enabled\x2C do that...\n          if (\n            typeof this.completer === 'function' &&\n            this.isCompletionEnabled\n          ) {\n            const lastKeypressWasTab =\n              previousKey && previousKey.name === 'tab';\n            this[kTabComplete](lastKeypressWasTab);\n            break;\n          }\n        // falls through\n        default:\n          if (typeof s === 'string' && s) {\n            // Erase state of previous searches.\n            lineEnding.lastIndex = 0;\n            let nextMatch;\n            // Keep track of the end of the last match.\n            let lastIndex = 0;\n            while ((nextMatch = RegExpPrototypeExec(lineEnding\x2C s)) !== null) {\n              this[kInsertString](StringPrototypeSlice(s\x2C lastIndex\x2C nextMatch.index));\n              ({ lastIndex } = lineEnding);\n              this[kLine]();\n              // Restore lastIndex as the call to kLine could have mutated it.\n              lineEnding.lastIndex = lastIndex;\n            }\n            // This ensures that the last line is written if it doesn't end in a newline.\n            // Note that the last line may be the first line\x2C in which case this still works.\n            this[kInsertString](StringPrototypeSlice(s\x2C lastIndex));\n          }\n      }\n    }\n  }\n\n  /**\n   * Creates an `AsyncIterator` object that iterates through\n   * each line in the input stream as a string.\n   * @typedef {{\n   *   [Symbol.asyncIterator]: () => InterfaceAsyncIterator\x2C\n   *   next: () => Promise<string>\n   * }} InterfaceAsyncIterator\n   * @returns {InterfaceAsyncIterator}\n   */\n  [SymbolAsyncIterator]() {\n    if (this[kLineObjectStream] === undefined) {\n      if (Readable === undefined) {\n        Readable = require('stream').Readable;\n      }\n      const readable = new Readable({\n        objectMode: true\x2C\n        read: () => {\n          this.resume();\n        }\x2C\n        destroy: (err\x2C cb) => {\n          this.off('line'\x2C lineListener);\n          this.off('close'\x2C closeListener);\n          this.close();\n          cb(err);\n        }\x2C\n      });\n      const lineListener = (input) => {\n        if (!readable.push(input)) {\n          // TODO(rexagod): drain to resume flow\n          this.pause();\n        }\n      };\n      const closeListener = () => {\n        readable.push(null);\n      };\n      const errorListener = (err) => {\n        readable.destroy(err);\n      };\n      this.on('error'\x2C errorListener);\n      this.on('line'\x2C lineListener);\n      this.on('close'\x2C closeListener);\n      this[kLineObjectStream] = readable;\n    }\n\n    return this[kLineObjectStream][SymbolAsyncIterator]();\n  }\n}\n\nmodule.exports = {\n  Interface\x2C\n  InterfaceConstructor\x2C\n  kAddHistory\x2C\n  kDecoder\x2C\n  kDeleteLeft\x2C\n  kDeleteLineLeft\x2C\n  kDeleteLineRight\x2C\n  kDeleteRight\x2C\n  kDeleteWordLeft\x2C\n  kDeleteWordRight\x2C\n  kGetDisplayPos\x2C\n  kHistoryNext\x2C\n  kHistoryPrev\x2C\n  kInsertString\x2C\n  kLine\x2C\n  kLine_buffer\x2C\n  kMoveCursor\x2C\n  kNormalWrite\x2C\n  kOldPrompt\x2C\n  kOnLine\x2C\n  kPreviousKey\x2C\n  kPrompt\x2C\n  kQuestionCallback\x2C\n  kQuestionCancel\x2C\n  kRefreshLine\x2C\n  kSawKeyPress\x2C\n  kSawReturnAt\x2C\n  kSetRawMode\x2C\n  kTabComplete\x2C\n  kTabCompleter\x2C\n  kTtyWrite\x2C\n  kWordLeft\x2C\n  kWordRight\x2C\n  kWriteToOutput\x2C\n};\n
code-source-info,0x1fa4d1d4e240,483,0,39790,C0O0C4O39790,,
code-creation,Function,10,101542,0x1fa4d1d50de8,1839, node:internal/readline/interface:1:1,0x1fa4d1d4e1b8,~
code-source-info,0x1fa4d1d50de8,483,0,39790,C0O0C315O25C321O38C327O62C333O87C339O109C345O130C351O151C357O173C363O198C369O222C375O245C381O270C387O281C393O306C399O318C405O331C411O342C417O358C423O376C429O391C434O415C440O438C446O468C452O495C458O520C464O544C470O573C476O596C481O606C487O629C493O685C499O685C504O675C509O724C515O749C521O869C527O869C532O791C538O814C544O831C550O849C556O926C562O926C567O909C573O1021C579O1021C584O962C590O973C596O991C602O1076C608O1076C612O1076C614O1177C620O1177C625O1105C631O1121C637O1139C643O1155C649O1217C650O1217C652O1294C658O1294C663O1247C669O1266C675O1278C681O1361C687O1361C692O1343C698O1440C699O1440C701O1472C703O1472C705O1506C709O1506C711O1534C713O1534C715O1613C719O1613C721O1659C724O1659C728O1659C730O1713C733O1713C738O1829C742O1829C744O1895C746O1895C748O1920C751O1920C755O1920C757O1963C760O1963C764O1963C766O2003C769O2003C773O2003C775O2043C778O2043C782O2043C784O2090C787O2090C791O2090C793O2142C796O2142C800O2142C802O2191C805O2191C809O2191C811O2239C814O2239C818O2239C820O2291C823O2291C827O2291C829O2342C832O2342C836O2342C838O2389C841O2389C845O2389C847O2434C850O2434C854O2434C856O2480C859O2480C863O2480C865O2519C868O2519C872O2519C874O2557C877O2557C881O2557C883O2599C886O2599C890O2599C892O2644C895O2644C899O2644C901O2691C904O2691C908O2691C910O2735C913O2735C917O2735C919O2778C922O2778C926O2778C928O2816C931O2816C935O2816C937O2856C940O2856C944O2856C946O2896C949O2896C953O2896C955O2939C958O2939C962O2939C964O2991C967O2991C971O2991C973O3045C976O3045C980O3045C982O3088C985O3088C989O3088C991O3124C994O3124C998O3124C1000O3167C1003O3167C1007O3167C1009O3212C1012O3212C1016O3212C1018O3257C1021O3257C1025O3257C1027O3301C1030O3301C1034O3301C1036O3345C1039O3345C1043O3345C1045O3391C1048O3391C1052O3391C1054O3434C1057O3434C1061O3434C1063O3469C1066O3469C1070O3469C1072O3505C1075O3505C1079O3505C1081O3545C1084O3545C1088O3545C1090O3585C1093O3585C1097O3585C1099O3630C1102O3630C1106O3630C1108O3670C1111O3670C1115O3670C1117O3704C1120O3704C1124O3704C1126O3741C1129O3741C1133O3741C1135O9469C1143O9493C1148O9427C1153O9505C1156O9505C1161O9588C1184O10183C1205O11079C1215O11325C1223O11416C1235O11588C1245O11789C1255O12971C1289O15105C1299O16843C1309O17522C1319O17919C1329O20131C1339O20596C1349O20858C1359O21344C1369O21829C1379O22593C1389O23024C1399O23306C1409O23568C1419O23832C1429O23991C1445O24823C1455O24981C1465O25172C1475O25484C1485O26227C1495O26865C1505O27648C1521O29053C1531O29647C1541O38205C1566O39226C1573O39247C1579O39260C1585O39284C1591O39299C1597O39311C1603O39326C1609O39345C1615O39365C1621O39381C1627O39400C1633O39420C1639O39438C1645O39454C1651O39470C1657O39487C1663O39496C1669O39512C1675O39527C1681O39543C1687O39557C1693O39568C1699O39584C1709O39595C1719O39616C1729O39635C1739O39651C1749O39667C1759O39683C1769O39698C1779O39714C1789O39731C1799O39744C1809O39757C1819O39771C1829O39241C1838O39789,,
code-creation,Eval,10,101875,0x1fa4d1d550b0,5, node:internal/readline/utils:1:1,0x1fa4d1d54eb8,~
script-source,484,node:internal/readline/utils,'use strict';\n\nconst {\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  RegExpPrototypeExec\x2C\n  StringFromCharCode\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeCodePointAt\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n  Symbol\x2C\n} = primordials;\n\nconst kUTF16SurrogateThreshold = 0x10000; // 2 ** 16\nconst kEscape = '\\x1b';\nconst kSubstringSearch = Symbol('kSubstringSearch');\n\nfunction CSI(strings\x2C ...args) {\n  let ret = `${kEscape}[`;\n  for (let n = 0; n < strings.length; n++) {\n    ret += strings[n];\n    if (n < args.length)\n      ret += args[n];\n  }\n  return ret;\n}\n\nCSI.kEscape = kEscape;\nCSI.kClearToLineBeginning = CSI`1K`;\nCSI.kClearToLineEnd = CSI`0K`;\nCSI.kClearLine = CSI`2K`;\nCSI.kClearScreenDown = CSI`0J`;\n\n// TODO(BridgeAR): Treat combined characters as single character\x2C i.e\x2C\n// 'a\\u0301' and '\\u0301a' (both have the same visual output).\n// Check Canonical_Combining_Class in\n// http://userguide.icu-project.org/strings/properties\nfunction charLengthLeft(str\x2C i) {\n  if (i <= 0)\n    return 0;\n  if ((i > 1 &&\n      StringPrototypeCodePointAt(str\x2C i - 2) >= kUTF16SurrogateThreshold) ||\n      StringPrototypeCodePointAt(str\x2C i - 1) >= kUTF16SurrogateThreshold) {\n    return 2;\n  }\n  return 1;\n}\n\nfunction charLengthAt(str\x2C i) {\n  if (str.length <= i) {\n    // Pretend to move to the right. This is necessary to autocomplete while\n    // moving to the right.\n    return 1;\n  }\n  return StringPrototypeCodePointAt(str\x2C i) >= kUTF16SurrogateThreshold ? 2 : 1;\n}\n\n/*\n  Some patterns seen in terminal key escape codes\x2C derived from combos seen\n  at http://www.midnight-commander.org/browser/lib/tty/key.c\n\n  ESC letter\n  ESC [ letter\n  ESC [ modifier letter\n  ESC [ 1 ; modifier letter\n  ESC [ num char\n  ESC [ num ; modifier char\n  ESC O letter\n  ESC O modifier letter\n  ESC O 1 ; modifier letter\n  ESC N letter\n  ESC [ [ num ; modifier char\n  ESC [ [ 1 ; modifier letter\n  ESC ESC [ num char\n  ESC ESC O letter\n\n  - char is usually ~ but $ and ^ also happen with rxvt\n  - modifier is 1 +\n                (shift     * 1) +\n                (left_alt  * 2) +\n                (ctrl      * 4) +\n                (right_alt * 8)\n  - two leading ESCs apparently mean the same as one leading ESC\n*/\nfunction* emitKeys(stream) {\n  while (true) {\n    let ch = yield;\n    let s = ch;\n    let escaped = false;\n    const key = {\n      sequence: null\x2C\n      name: undefined\x2C\n      ctrl: false\x2C\n      meta: false\x2C\n      shift: false\x2C\n    };\n\n    if (ch === kEscape) {\n      escaped = true;\n      s += (ch = yield);\n\n      if (ch === kEscape) {\n        s += (ch = yield);\n      }\n    }\n\n    if (escaped && (ch === 'O' || ch === '[')) {\n      // ANSI escape sequence\n      let code = ch;\n      let modifier = 0;\n\n      if (ch === 'O') {\n        // ESC O letter\n        // ESC O modifier letter\n        s += (ch = yield);\n\n        if (ch >= '0' && ch <= '9') {\n          modifier = (ch >> 0) - 1;\n          s += (ch = yield);\n        }\n\n        code += ch;\n      } else if (ch === '[') {\n        // ESC [ letter\n        // ESC [ modifier letter\n        // ESC [ [ modifier letter\n        // ESC [ [ num char\n        s += (ch = yield);\n\n        if (ch === '[') {\n          // \\x1b[[A\n          //      ^--- escape codes might have a second bracket\n          code += ch;\n          s += (ch = yield);\n        }\n\n        /*\n         * Here and later we try to buffer just enough data to get\n         * a complete ascii sequence.\n         *\n         * We have basically two classes of ascii characters to process:\n         *\n         *\n         * 1. `\\x1b[24;5~` should be parsed as { code: '[24~'\x2C modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+F12 in xterm.\n         *\n         *  - `;5` part is optional\x2C e.g. it could be `\\x1b[24~`\n         *  - first part can contain one or two digits\n         *\n         * So the generic regexp is like /^\\d\\d?(;\\d)?[~^$]$/\n         *\n         *\n         * 2. `\\x1b[1;5H` should be parsed as { code: '[H'\x2C modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+Home in xterm.\n         *\n         *  - `1;5` part is optional\x2C e.g. it could be `\\x1b[H`\n         *  - `1;` part is optional\x2C e.g. it could be `\\x1b[5H`\n         *\n         * So the generic regexp is like /^((\\d;)?\\d)?[A-Za-z]$/\n         *\n         */\n        const cmdStart = s.length - 1;\n\n        // Skip one or two leading digits\n        if (ch >= '0' && ch <= '9') {\n          s += (ch = yield);\n\n          if (ch >= '0' && ch <= '9') {\n            s += (ch = yield);\n          }\n        }\n\n        // skip modifier\n        if (ch === ';') {\n          s += (ch = yield);\n\n          if (ch >= '0' && ch <= '9') {\n            s += yield;\n          }\n        }\n\n        /*\n         * We buffered enough data\x2C now trying to extract code\n         * and modifier from it\n         */\n        const cmd = StringPrototypeSlice(s\x2C cmdStart);\n        let match;\n\n        if ((match = RegExpPrototypeExec(/^(\\d\\d?)(;(\\d))?([~^$])$/\x2C cmd))) {\n          code += match[1] + match[4];\n          modifier = (match[3] || 1) - 1;\n        } else if (\n          (match = RegExpPrototypeExec(/^((\\d;)?(\\d))?([A-Za-z])$/\x2C cmd))\n        ) {\n          code += match[4];\n          modifier = (match[3] || 1) - 1;\n        } else {\n          code += cmd;\n        }\n      }\n\n      // Parse the key modifier\n      key.ctrl = !!(modifier & 4);\n      key.meta = !!(modifier & 10);\n      key.shift = !!(modifier & 1);\n      key.code = code;\n\n      // Parse the key itself\n      switch (code) {\n        /* xterm/gnome ESC [ letter (with modifier) */\n        case '[P': key.name = 'f1'; break;\n        case '[Q': key.name = 'f2'; break;\n        case '[R': key.name = 'f3'; break;\n        case '[S': key.name = 'f4'; break;\n\n        /* xterm/gnome ESC O letter (without modifier) */\n        case 'OP': key.name = 'f1'; break;\n        case 'OQ': key.name = 'f2'; break;\n        case 'OR': key.name = 'f3'; break;\n        case 'OS': key.name = 'f4'; break;\n\n        /* xterm/rxvt ESC [ number ~ */\n        case '[11~': key.name = 'f1'; break;\n        case '[12~': key.name = 'f2'; break;\n        case '[13~': key.name = 'f3'; break;\n        case '[14~': key.name = 'f4'; break;\n\n        /* from Cygwin and used in libuv */\n        case '[[A': key.name = 'f1'; break;\n        case '[[B': key.name = 'f2'; break;\n        case '[[C': key.name = 'f3'; break;\n        case '[[D': key.name = 'f4'; break;\n        case '[[E': key.name = 'f5'; break;\n\n        /* common */\n        case '[15~': key.name = 'f5'; break;\n        case '[17~': key.name = 'f6'; break;\n        case '[18~': key.name = 'f7'; break;\n        case '[19~': key.name = 'f8'; break;\n        case '[20~': key.name = 'f9'; break;\n        case '[21~': key.name = 'f10'; break;\n        case '[23~': key.name = 'f11'; break;\n        case '[24~': key.name = 'f12'; break;\n\n        /* xterm ESC [ letter */\n        case '[A': key.name = 'up'; break;\n        case '[B': key.name = 'down'; break;\n        case '[C': key.name = 'right'; break;\n        case '[D': key.name = 'left'; break;\n        case '[E': key.name = 'clear'; break;\n        case '[F': key.name = 'end'; break;\n        case '[H': key.name = 'home'; break;\n\n        /* xterm/gnome ESC O letter */\n        case 'OA': key.name = 'up'; break;\n        case 'OB': key.name = 'down'; break;\n        case 'OC': key.name = 'right'; break;\n        case 'OD': key.name = 'left'; break;\n        case 'OE': key.name = 'clear'; break;\n        case 'OF': key.name = 'end'; break;\n        case 'OH': key.name = 'home'; break;\n\n        /* xterm/rxvt ESC [ number ~ */\n        case '[1~': key.name = 'home'; break;\n        case '[2~': key.name = 'insert'; break;\n        case '[3~': key.name = 'delete'; break;\n        case '[4~': key.name = 'end'; break;\n        case '[5~': key.name = 'pageup'; break;\n        case '[6~': key.name = 'pagedown'; break;\n\n        /* putty */\n        case '[[5~': key.name = 'pageup'; break;\n        case '[[6~': key.name = 'pagedown'; break;\n\n        /* rxvt */\n        case '[7~': key.name = 'home'; break;\n        case '[8~': key.name = 'end'; break;\n\n        /* rxvt keys with modifiers */\n        case '[a': key.name = 'up'; key.shift = true; break;\n        case '[b': key.name = 'down'; key.shift = true; break;\n        case '[c': key.name = 'right'; key.shift = true; break;\n        case '[d': key.name = 'left'; key.shift = true; break;\n        case '[e': key.name = 'clear'; key.shift = true; break;\n\n        case '[2$': key.name = 'insert'; key.shift = true; break;\n        case '[3$': key.name = 'delete'; key.shift = true; break;\n        case '[5$': key.name = 'pageup'; key.shift = true; break;\n        case '[6$': key.name = 'pagedown'; key.shift = true; break;\n        case '[7$': key.name = 'home'; key.shift = true; break;\n        case '[8$': key.name = 'end'; key.shift = true; break;\n\n        case 'Oa': key.name = 'up'; key.ctrl = true; break;\n        case 'Ob': key.name = 'down'; key.ctrl = true; break;\n        case 'Oc': key.name = 'right'; key.ctrl = true; break;\n        case 'Od': key.name = 'left'; key.ctrl = true; break;\n        case 'Oe': key.name = 'clear'; key.ctrl = true; break;\n\n        case '[2^': key.name = 'insert'; key.ctrl = true; break;\n        case '[3^': key.name = 'delete'; key.ctrl = true; break;\n        case '[5^': key.name = 'pageup'; key.ctrl = true; break;\n        case '[6^': key.name = 'pagedown'; key.ctrl = true; break;\n        case '[7^': key.name = 'home'; key.ctrl = true; break;\n        case '[8^': key.name = 'end'; key.ctrl = true; break;\n\n        /* misc. */\n        case '[Z': key.name = 'tab'; key.shift = true; break;\n        default: key.name = 'undefined'; break;\n      }\n    } else if (ch === '\\r') {\n      // carriage return\n      key.name = 'return';\n      key.meta = escaped;\n    } else if (ch === '\\n') {\n      // Enter\x2C should have been called linefeed\n      key.name = 'enter';\n      key.meta = escaped;\n    } else if (ch === '\\t') {\n      // tab\n      key.name = 'tab';\n      key.meta = escaped;\n    } else if (ch === '\\b' || ch === '\\x7f') {\n      // backspace or ctrl+h\n      key.name = 'backspace';\n      key.meta = escaped;\n    } else if (ch === kEscape) {\n      // escape key\n      key.name = 'escape';\n      key.meta = escaped;\n    } else if (ch === ' ') {\n      key.name = 'space';\n      key.meta = escaped;\n    } else if (!escaped && ch <= '\\x1a') {\n      // ctrl+letter\n      key.name = StringFromCharCode(\n        StringPrototypeCharCodeAt(ch) + StringPrototypeCharCodeAt('a') - 1\x2C\n      );\n      key.ctrl = true;\n    } else if (RegExpPrototypeExec(/^[0-9A-Za-z]$/\x2C ch) !== null) {\n      // Letter\x2C number\x2C shift+letter\n      key.name = StringPrototypeToLowerCase(ch);\n      key.shift = RegExpPrototypeExec(/^[A-Z]$/\x2C ch) !== null;\n      key.meta = escaped;\n    } else if (escaped) {\n      // Escape sequence timeout\n      key.name = ch.length ? undefined : 'escape';\n      key.meta = true;\n    }\n\n    key.sequence = s;\n\n    if (s.length !== 0 && (key.name !== undefined || escaped)) {\n      /* Named character or sequence */\n      stream.emit('keypress'\x2C escaped ? undefined : s\x2C key);\n    } else if (charLengthAt(s\x2C 0) === s.length) {\n      /* Single unnamed character\x2C e.g. "." */\n      stream.emit('keypress'\x2C s\x2C key);\n    }\n    /* Unrecognized or broken escape sequence\x2C don't emit anything */\n  }\n}\n\n// This runs in O(n log n).\nfunction commonPrefix(strings) {\n  if (strings.length === 0) {\n    return '';\n  }\n  if (strings.length === 1) {\n    return strings[0];\n  }\n  const sorted = ArrayPrototypeSort(ArrayPrototypeSlice(strings));\n  const min = sorted[0];\n  const max = sorted[sorted.length - 1];\n  for (let i = 0; i < min.length; i++) {\n    if (min[i] !== max[i]) {\n      return StringPrototypeSlice(min\x2C 0\x2C i);\n    }\n  }\n  return min;\n}\n\nmodule.exports = {\n  charLengthAt\x2C\n  charLengthLeft\x2C\n  commonPrefix\x2C\n  emitKeys\x2C\n  kSubstringSearch\x2C\n  CSI\x2C\n};\n
code-source-info,0x1fa4d1d550b0,484,0,11903,C0O0C4O11903,,
code-creation,Function,10,102834,0x1fa4d1d554f8,237, node:internal/readline/utils:1:1,0x1fa4d1d55028,~
code-source-info,0x1fa4d1d554f8,484,0,11903,C0O0C61O25C67O48C73O70C79O93C85O115C91O144C97O174C103O198C109O228C114O287C120O287C122O323C124O323C126O356C129O356C134O581C136O593C140O635C144O635C148O630C152O666C156O666C160O661C164O692C168O692C172O687C176O724C180O724C184O719C188O11792C195O11813C201O11829C207O11847C213O11863C219O11875C225O11895C231O11807C236O11902,,
tick,0x100e12cd0,102917,1,0x100b1d1ec,5,0x0,0x41ccf059096,0x1100482ec,0x1fa4d1d46968,0x41ccf0590b7,0x1100482ec,0x1fa4d1d414bd,0x41ccf0590b7,0x1100482ec,0x2b3d46ce8b1c,0x41ccf0590b7,0x1100482ec,0x2b3d46ce6af9,0x41ccf0590b7,0x1100482ec,0x2b3d46ce1b01,0x41ccf0590b7,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
tick,0x19596ce44,102917,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x1fa4d1d46968,0x41ccf0590b7,0x1100482ec,0x1fa4d1d414bd,0x41ccf0590b7,0x1100482ec,0x2b3d46ce8b1c,0x41ccf0590b7,0x1100482ec,0x2b3d46ce6af9,0x41ccf0590b7,0x1100482ec,0x2b3d46ce1b01,0x41ccf0590b7,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
tick,0x100ab9120,102917,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x1fa4d1d46968,0x41ccf0590b7,0x1100482ec,0x1fa4d1d414bd,0x41ccf0590b7,0x1100482ec,0x2b3d46ce8b1c,0x41ccf0590b7,0x1100482ec,0x2b3d46ce6af9,0x41ccf0590b7,0x1100482ec,0x2b3d46ce1b01,0x41ccf0590b7,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
tick,0x195959bc4,102959,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x1fa4d1d51054,0x41ccf0590b7,0x1100482ec,0x1fa4d1d46968,0x41ccf0590b7,0x1100482ec,0x1fa4d1d414bd,0x41ccf0590b7,0x1100482ec,0x2b3d46ce8b1c,0x41ccf0590b7,0x1100482ec,0x2b3d46ce6af9,0x41ccf0590b7,0x1100482ec,0x2b3d46ce1b01,0x41ccf0590b7,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
code-creation,LazyCompile,10,102959,0x1fa4d1d56670,75,CSI node:internal/readline/utils:19:13,0x1fa4d1d550e0,~
code-source-info,0x1fa4d1d56670,484,397,579,C0O397C8O430C20O460C22O475C26O465C31O494C33O508C43O530C47O523C52O544C54O555C64O484C69O447C72O566C74O577,,
code-creation,Eval,10,103042,0x1fa4d1d57778,5, node:internal/readline/callbacks:1:1,0x1fa4d1d57590,~
script-source,485,node:internal/readline/callbacks,'use strict';\n\nconst {\n  NumberIsNaN\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_CURSOR_POS\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  validateFunction\x2C\n} = require('internal/validators');\nconst {\n  CSI\x2C\n} = require('internal/readline/utils');\n\nconst {\n  kClearLine\x2C\n  kClearScreenDown\x2C\n  kClearToLineBeginning\x2C\n  kClearToLineEnd\x2C\n} = CSI;\n\n\n/**\n * moves the cursor to the x and y coordinate on the given stream\n */\n\nfunction cursorTo(stream\x2C x\x2C y\x2C callback) {\n  if (callback !== undefined) {\n    validateFunction(callback\x2C 'callback');\n  }\n\n  if (typeof y === 'function') {\n    callback = y;\n    y = undefined;\n  }\n\n  if (NumberIsNaN(x)) throw new ERR_INVALID_ARG_VALUE('x'\x2C x);\n  if (NumberIsNaN(y)) throw new ERR_INVALID_ARG_VALUE('y'\x2C y);\n\n  if (stream == null || (typeof x !== 'number' && typeof y !== 'number')) {\n    if (typeof callback === 'function') process.nextTick(callback\x2C null);\n    return true;\n  }\n\n  if (typeof x !== 'number') throw new ERR_INVALID_CURSOR_POS();\n\n  const data = typeof y !== 'number' ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n  return stream.write(data\x2C callback);\n}\n\n/**\n * moves the cursor relative to its current location\n */\n\nfunction moveCursor(stream\x2C dx\x2C dy\x2C callback) {\n  if (callback !== undefined) {\n    validateFunction(callback\x2C 'callback');\n  }\n\n  if (stream == null || !(dx || dy)) {\n    if (typeof callback === 'function') process.nextTick(callback\x2C null);\n    return true;\n  }\n\n  let data = '';\n\n  if (dx < 0) {\n    data += CSI`${-dx}D`;\n  } else if (dx > 0) {\n    data += CSI`${dx}C`;\n  }\n\n  if (dy < 0) {\n    data += CSI`${-dy}A`;\n  } else if (dy > 0) {\n    data += CSI`${dy}B`;\n  }\n\n  return stream.write(data\x2C callback);\n}\n\n/**\n * clears the current line the cursor is on:\n *   -1 for left of the cursor\n *   +1 for right of the cursor\n *    0 for the entire line\n */\n\nfunction clearLine(stream\x2C dir\x2C callback) {\n  if (callback !== undefined) {\n    validateFunction(callback\x2C 'callback');\n  }\n\n  if (stream === null || stream === undefined) {\n    if (typeof callback === 'function') process.nextTick(callback\x2C null);\n    return true;\n  }\n\n  const type =\n    dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;\n  return stream.write(type\x2C callback);\n}\n\n/**\n * clears the screen from the current position of the cursor down\n */\n\nfunction clearScreenDown(stream\x2C callback) {\n  if (callback !== undefined) {\n    validateFunction(callback\x2C 'callback');\n  }\n\n  if (stream === null || stream === undefined) {\n    if (typeof callback === 'function') process.nextTick(callback\x2C null);\n    return true;\n  }\n\n  return stream.write(kClearScreenDown\x2C callback);\n}\n\nmodule.exports = {\n  clearLine\x2C\n  clearScreenDown\x2C\n  cursorTo\x2C\n  moveCursor\x2C\n};\n
code-source-info,0x1fa4d1d57778,485,0,2754,C0O0C4O2754,,
code-creation,Function,10,103209,0x1fa4d1d57a48,179, node:internal/readline/callbacks:1:1,0x1fa4d1d576f0,~
code-source-info,0x1fa4d1d57a48,485,0,2754,C0O0C56O25C62O139C65O139C70O139C75O79C81O106C87O200C90O200C95O178C101O251C104O251C109O242C115O378C118O298C124O312C130O332C136O357C142O2674C149O2695C155O2708C161O2727C167O2739C173O2689C178O2753,,
code-creation,LazyCompile,10,103375,0x1fa4d1d58850,112,EventEmitterMixin node:internal/event_target:1067:27,0x35d2971bb4c0,~
script-source,47,node:internal/event_target,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  Boolean\x2C\n  Error\x2C\n  FunctionPrototypeCall\x2C\n  NumberIsInteger\x2C\n  ObjectAssign\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ObjectSetPrototypeOf\x2C\n  ObjectValues\x2C\n  ReflectApply\x2C\n  SafeArrayIterator\x2C\n  SafeFinalizationRegistry\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  SafeWeakRef\x2C\n  SafeWeakSet\x2C\n  String\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_EVENT_RECURSION\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_INVALID_THIS\x2C\n  }\x2C\n} = require('internal/errors');\nconst { validateObject\x2C validateString } = require('internal/validators');\n\nconst {\n  customInspectSymbol\x2C\n  kEmptyObject\x2C\n  kEnumerableProperty\x2C\n} = require('internal/util');\nconst { inspect } = require('util');\nconst webidl = require('internal/webidl');\n\nconst kIsEventTarget = SymbolFor('nodejs.event_target');\nconst kIsNodeEventTarget = Symbol('kIsNodeEventTarget');\n\nconst EventEmitter = require('events');\nconst {\n  kMaxEventTargetListeners\x2C\n  kMaxEventTargetListenersWarned\x2C\n} = EventEmitter;\n\nconst kEvents = Symbol('kEvents');\nconst kIsBeingDispatched = Symbol('kIsBeingDispatched');\nconst kStop = Symbol('kStop');\nconst kTarget = Symbol('kTarget');\nconst kHandlers = Symbol('kHandlers');\nconst kWeakHandler = Symbol('kWeak');\n\nconst kHybridDispatch = SymbolFor('nodejs.internal.kHybridDispatch');\nconst kCreateEvent = Symbol('kCreateEvent');\nconst kNewListener = Symbol('kNewListener');\nconst kRemoveListener = Symbol('kRemoveListener');\nconst kIsNodeStyleListener = Symbol('kIsNodeStyleListener');\nconst kTrustEvent = Symbol('kTrustEvent');\n\nconst { now } = require('internal/perf/utils');\n\nconst kType = Symbol('type');\nconst kDetail = Symbol('detail');\n\nconst isTrustedSet = new SafeWeakSet();\nconst isTrusted = ObjectGetOwnPropertyDescriptor({\n  get isTrusted() {\n    return isTrustedSet.has(this);\n  }\x2C\n}\x2C 'isTrusted').get;\n\nconst isTrustedDescriptor = {\n  __proto__: null\x2C\n  configurable: false\x2C\n  enumerable: true\x2C\n  get: isTrusted\x2C\n};\n\nfunction isEvent(value) {\n  return typeof value?.[kType] === 'string';\n}\n\nclass Event {\n  #cancelable = false;\n  #bubbles = false;\n  #composed = false;\n  #defaultPrevented = false;\n  #timestamp = now();\n  #propagationStopped = false;\n\n  /**\n   * @param {string} type\n   * @param {{\n   *   bubbles?: boolean\x2C\n   *   cancelable?: boolean\x2C\n   *   composed?: boolean\x2C\n   * }} [options]\n   */\n  constructor(type\x2C options = kEmptyObject) {\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS('type');\n    validateObject(options\x2C 'options');\n    const { bubbles\x2C cancelable\x2C composed } = options;\n    this.#cancelable = !!cancelable;\n    this.#bubbles = !!bubbles;\n    this.#composed = !!composed;\n\n    this[kType] = `${type}`;\n    if (options?.[kTrustEvent]) {\n      isTrustedSet.add(this);\n    }\n\n    this[kTarget] = null;\n    this[kIsBeingDispatched] = false;\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\x2C\n    });\n\n    return `${name} ${inspect({\n      type: this[kType]\x2C\n      defaultPrevented: this.#defaultPrevented\x2C\n      cancelable: this.#cancelable\x2C\n      timeStamp: this.#timestamp\x2C\n    }\x2C opts)}`;\n  }\n\n  stopImmediatePropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this[kStop] = true;\n  }\n\n  preventDefault() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this.#defaultPrevented = true;\n  }\n\n  /**\n   * @type {EventTarget}\n   */\n  get target() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  /**\n   * @type {EventTarget}\n   */\n  get currentTarget() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  /**\n   * @type {EventTarget}\n   */\n  get srcElement() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  /**\n   * @type {string}\n   */\n  get type() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kType];\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get cancelable() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#cancelable;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get defaultPrevented() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#cancelable && this.#defaultPrevented;\n  }\n\n  /**\n   * @type {number}\n   */\n  get timeStamp() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#timestamp;\n  }\n\n\n  // The following are non-op and unused properties/methods from Web API Event.\n  // These are not supported in Node.js and are provided purely for\n  // API completeness.\n  /**\n   * @returns {EventTarget[]}\n   */\n  composedPath() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kIsBeingDispatched] ? [this[kTarget]] : [];\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get returnValue() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return !this.#cancelable || !this.#defaultPrevented;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get bubbles() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#bubbles;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get composed() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#composed;\n  }\n\n  /**\n   * @type {number}\n   */\n  get eventPhase() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kIsBeingDispatched] ? Event.AT_TARGET : Event.NONE;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get cancelBubble() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#propagationStopped;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  set cancelBubble(value) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    if (value) {\n      this.stopPropagation();\n    }\n  }\n\n  stopPropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this.#propagationStopped = true;\n  }\n\n  static NONE = 0;\n  static CAPTURING_PHASE = 1;\n  static AT_TARGET = 2;\n  static BUBBLING_PHASE = 3;\n}\n\nObjectDefineProperties(\n  Event.prototype\x2C {\n    [SymbolToStringTag]: {\n      __proto__: null\x2C\n      writable: false\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: 'Event'\x2C\n    }\x2C\n    stopImmediatePropagation: kEnumerableProperty\x2C\n    preventDefault: kEnumerableProperty\x2C\n    target: kEnumerableProperty\x2C\n    currentTarget: kEnumerableProperty\x2C\n    srcElement: kEnumerableProperty\x2C\n    type: kEnumerableProperty\x2C\n    cancelable: kEnumerableProperty\x2C\n    defaultPrevented: kEnumerableProperty\x2C\n    timeStamp: kEnumerableProperty\x2C\n    composedPath: kEnumerableProperty\x2C\n    returnValue: kEnumerableProperty\x2C\n    bubbles: kEnumerableProperty\x2C\n    composed: kEnumerableProperty\x2C\n    eventPhase: kEnumerableProperty\x2C\n    cancelBubble: kEnumerableProperty\x2C\n    stopPropagation: kEnumerableProperty\x2C\n    // Don't conform to the spec with isTrusted. The spec defines it as\n    // LegacyUnforgeable but defining it in the constructor has a big\n    // performance impact and the property doesn't seem to be useful outside of\n    // browsers.\n    isTrusted: isTrustedDescriptor\x2C\n  });\n\nfunction isCustomEvent(value) {\n  return isEvent(value) && (value?.[kDetail] !== undefined);\n}\n\nclass CustomEvent extends Event {\n  /**\n   * @constructor\n   * @param {string} type\n   * @param {{\n   *   bubbles?: boolean\x2C\n   *   cancelable?: boolean\x2C\n   *   composed?: boolean\x2C\n   *   detail?: any\x2C\n   * }} [options]\n   */\n  constructor(type\x2C options = kEmptyObject) {\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS('type');\n    super(type\x2C options);\n    this[kDetail] = options?.detail ?? null;\n  }\n\n  /**\n   * @type {any}\n   */\n  get detail() {\n    if (!isCustomEvent(this))\n      throw new ERR_INVALID_THIS('CustomEvent');\n    return this[kDetail];\n  }\n}\n\nObjectDefineProperties(CustomEvent.prototype\x2C {\n  [SymbolToStringTag]: {\n    __proto__: null\x2C\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: 'CustomEvent'\x2C\n  }\x2C\n  detail: kEnumerableProperty\x2C\n});\n\nclass NodeCustomEvent extends Event {\n  constructor(type\x2C options) {\n    super(type\x2C options);\n    if (options?.detail) {\n      this.detail = options.detail;\n    }\n  }\n}\n\n// Weak listener cleanup\n// This has to be lazy for snapshots to work\nlet weakListenersState = null;\n// The resource needs to retain the callback so that it doesn't\n// get garbage collected now that it's weak.\nlet objectToWeakListenerMap = null;\nfunction weakListeners() {\n  weakListenersState ??= new SafeFinalizationRegistry(\n    (listener) => listener.remove()\x2C\n  );\n  objectToWeakListenerMap ??= new SafeWeakMap();\n  return { registry: weakListenersState\x2C map: objectToWeakListenerMap };\n}\n\nconst kFlagOnce = 1 << 0;\nconst kFlagCapture = 1 << 1;\nconst kFlagPassive = 1 << 2;\nconst kFlagNodeStyle = 1 << 3;\nconst kFlagWeak = 1 << 4;\nconst kFlagRemoved = 1 << 5;\n\n// The listeners for an EventTarget are maintained as a linked list.\n// Unfortunately\x2C the way EventTarget is defined\x2C listeners are accounted\n// using the tuple [handler\x2Ccapture]\x2C and even if we don't actually make\n// use of capture or bubbling\x2C in order to be spec compliant we have to\n// take on the additional complexity of supporting it. Fortunately\x2C using\n// the linked list makes dispatching faster\x2C even if adding/removing is\n// slower.\nclass Listener {\n  constructor(previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n              isNodeStyleListener\x2C weak) {\n    this.next = undefined;\n    if (previous !== undefined)\n      previous.next = this;\n    this.previous = previous;\n    this.listener = listener;\n\n    let flags = 0b0;\n    if (once)\n      flags |= kFlagOnce;\n    if (capture)\n      flags |= kFlagCapture;\n    if (passive)\n      flags |= kFlagPassive;\n    if (isNodeStyleListener)\n      flags |= kFlagNodeStyle;\n    if (weak)\n      flags |= kFlagWeak;\n    this.flags = flags;\n\n    this.removed = false;\n\n    if (this.weak) {\n      this.callback = new SafeWeakRef(listener);\n      weakListeners().registry.register(listener\x2C this\x2C this);\n      // Make the retainer retain the listener in a WeakMap\n      weakListeners().map.set(weak\x2C listener);\n      this.listener = this.callback;\n    } else if (typeof listener === 'function') {\n      this.callback = listener;\n      this.listener = listener;\n    } else {\n      this.callback = async (...args) => {\n        if (listener.handleEvent)\n          await ReflectApply(listener.handleEvent\x2C listener\x2C args);\n      };\n      this.listener = listener;\n    }\n  }\n\n  get once() {\n    return Boolean(this.flags & kFlagOnce);\n  }\n  get capture() {\n    return Boolean(this.flags & kFlagCapture);\n  }\n  get passive() {\n    return Boolean(this.flags & kFlagPassive);\n  }\n  get isNodeStyleListener() {\n    return Boolean(this.flags & kFlagNodeStyle);\n  }\n  get weak() {\n    return Boolean(this.flags & kFlagWeak);\n  }\n  get removed() {\n    return Boolean(this.flags & kFlagRemoved);\n  }\n  set removed(value) {\n    if (value)\n      this.flags |= kFlagRemoved;\n    else\n      this.flags &= ~kFlagRemoved;\n  }\n\n  same(listener\x2C capture) {\n    const myListener = this.weak ? this.listener.deref() : this.listener;\n    return myListener === listener && this.capture === capture;\n  }\n\n  remove() {\n    if (this.previous !== undefined)\n      this.previous.next = this.next;\n    if (this.next !== undefined)\n      this.next.previous = this.previous;\n    this.removed = true;\n    if (this.weak)\n      weakListeners().registry.unregister(this);\n  }\n}\n\nfunction initEventTarget(self) {\n  self[kEvents] = new SafeMap();\n  self[kMaxEventTargetListeners] = EventEmitter.defaultMaxListeners;\n  self[kMaxEventTargetListenersWarned] = false;\n}\n\nclass EventTarget {\n  // Used in checking whether an object is an EventTarget. This is a well-known\n  // symbol as EventTarget may be used cross-realm.\n  // Ref: https://github.com/nodejs/node/pull/33661\n  static [kIsEventTarget] = true;\n\n  constructor() {\n    initEventTarget(this);\n  }\n\n  [kNewListener](size\x2C type\x2C listener\x2C once\x2C capture\x2C passive\x2C weak) {\n    if (this[kMaxEventTargetListeners] > 0 &&\n        size > this[kMaxEventTargetListeners] &&\n        !this[kMaxEventTargetListenersWarned]) {\n      this[kMaxEventTargetListenersWarned] = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error('Possible EventTarget memory leak detected. ' +\n                          `${size} ${type} listeners ` +\n                          `added to ${inspect(this\x2C { depth: -1 })}. Use ` +\n                          'events.setMaxListeners() to increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.target = this;\n      w.type = type;\n      w.count = size;\n      process.emitWarning(w);\n    }\n  }\n  [kRemoveListener](size\x2C type\x2C listener\x2C capture) {}\n\n  /**\n   * @callback EventTargetCallback\n   * @param {Event} event\n   */\n\n  /**\n   * @typedef {{ handleEvent: EventTargetCallback }} EventListener\n   */\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   *   once?: boolean\x2C\n   *   passive?: boolean\x2C\n   *   signal?: AbortSignal\n   * }} [options]\n   */\n  addEventListener(type\x2C listener\x2C options = kEmptyObject) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (arguments.length < 2)\n      throw new ERR_MISSING_ARGS('type'\x2C 'listener');\n\n    // We validateOptions before the validateListener check because the spec\n    // requires us to hit getters.\n    const {\n      once\x2C\n      capture\x2C\n      passive\x2C\n      signal\x2C\n      isNodeStyleListener\x2C\n      weak\x2C\n    } = validateEventListenerOptions(options);\n\n    if (!validateEventListener(listener)) {\n      // The DOM silently allows passing undefined as a second argument\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error(`addEventListener called with ${listener}` +\n                          ' which has no effect.');\n      w.name = 'AddEventListenerArgumentTypeWarning';\n      w.target = this;\n      w.type = type;\n      process.emitWarning(w);\n      return;\n    }\n    type = webidl.converters.DOMString(type);\n\n    if (signal) {\n      if (signal.aborted) {\n        return;\n      }\n      // TODO(benjamingr) make this weak somehow? ideally the signal would\n      // not prevent the event target from GC.\n      signal.addEventListener('abort'\x2C () => {\n        this.removeEventListener(type\x2C listener\x2C options);\n      }\x2C { once: true\x2C [kWeakHandler]: this });\n    }\n\n    let root = this[kEvents].get(type);\n\n    if (root === undefined) {\n      root = { size: 1\x2C next: undefined };\n      // This is the first handler in our linked list.\n      new Listener(root\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                   isNodeStyleListener\x2C weak);\n      this[kNewListener](\n        root.size\x2C\n        type\x2C\n        listener\x2C\n        once\x2C\n        capture\x2C\n        passive\x2C\n        weak);\n      this[kEvents].set(type\x2C root);\n      return;\n    }\n\n    let handler = root.next;\n    let previous = root;\n\n    // We have to walk the linked list to see if we have a match\n    while (handler !== undefined && !handler.same(listener\x2C capture)) {\n      previous = handler;\n      handler = handler.next;\n    }\n\n    if (handler !== undefined) { // Duplicate! Ignore\n      return;\n    }\n\n    new Listener(previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                 isNodeStyleListener\x2C weak);\n    root.size++;\n    this[kNewListener](root.size\x2C type\x2C listener\x2C once\x2C capture\x2C passive\x2C weak);\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   * }} [options]\n   */\n  removeEventListener(type\x2C listener\x2C options = kEmptyObject) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (arguments.length < 2)\n      throw new ERR_MISSING_ARGS('type'\x2C 'listener');\n    if (!validateEventListener(listener))\n      return;\n\n    type = webidl.converters.DOMString(type);\n    const capture = options?.capture === true;\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined)\n      return;\n\n    let handler = root.next;\n    while (handler !== undefined) {\n      if (handler.same(listener\x2C capture)) {\n        handler.remove();\n        root.size--;\n        if (root.size === 0)\n          this[kEvents].delete(type);\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n        break;\n      }\n      handler = handler.next;\n    }\n  }\n\n  /**\n   * @param {Event} event\n   */\n  dispatchEvent(event) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (arguments.length < 1)\n      throw new ERR_MISSING_ARGS('event');\n\n    if (!(event instanceof Event))\n      throw new ERR_INVALID_ARG_TYPE('event'\x2C 'Event'\x2C event);\n\n    if (event[kIsBeingDispatched])\n      throw new ERR_EVENT_RECURSION(event.type);\n\n    this[kHybridDispatch](event\x2C event.type\x2C event);\n\n    return event.defaultPrevented !== true;\n  }\n\n  [kHybridDispatch](nodeValue\x2C type\x2C event) {\n    const createEvent = () => {\n      if (event === undefined) {\n        event = this[kCreateEvent](nodeValue\x2C type);\n        event[kTarget] = this;\n        event[kIsBeingDispatched] = true;\n      }\n      return event;\n    };\n    if (event !== undefined) {\n      event[kTarget] = this;\n      event[kIsBeingDispatched] = true;\n    }\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined) {\n      if (event !== undefined)\n        event[kIsBeingDispatched] = false;\n      return true;\n    }\n\n    let handler = root.next;\n    let next;\n\n    while (handler !== undefined &&\n           (handler.passive || event?.[kStop] !== true)) {\n      // Cache the next item in case this iteration removes the current one\n      next = handler.next;\n\n      if (handler.removed) {\n        // Deal with the case an event is removed while event handlers are\n        // Being processed (removeEventListener called from a listener)\n        handler = next;\n        continue;\n      }\n      if (handler.once) {\n        handler.remove();\n        root.size--;\n        const { listener\x2C capture } = handler;\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n      }\n\n      try {\n        let arg;\n        if (handler.isNodeStyleListener) {\n          arg = nodeValue;\n        } else {\n          arg = createEvent();\n        }\n        const callback = handler.weak ?\n          handler.callback.deref() : handler.callback;\n        let result;\n        if (callback) {\n          result = FunctionPrototypeCall(callback\x2C this\x2C arg);\n          if (!handler.isNodeStyleListener) {\n            arg[kIsBeingDispatched] = false;\n          }\n        }\n        if (result !== undefined && result !== null)\n          addCatch(result);\n      } catch (err) {\n        emitUncaughtException(err);\n      }\n\n      handler = next;\n    }\n\n    if (event !== undefined)\n      event[kIsBeingDispatched] = false;\n  }\n\n  [kCreateEvent](nodeValue\x2C type) {\n    return new NodeCustomEvent(type\x2C { detail: nodeValue });\n  }\n  [customInspectSymbol](depth\x2C options) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\x2C\n    });\n\n    return `${name} ${inspect({}\x2C opts)}`;\n  }\n}\n\nObjectDefineProperties(EventTarget.prototype\x2C {\n  addEventListener: kEnumerableProperty\x2C\n  removeEventListener: kEnumerableProperty\x2C\n  dispatchEvent: kEnumerableProperty\x2C\n  [SymbolToStringTag]: {\n    __proto__: null\x2C\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: 'EventTarget'\x2C\n  }\x2C\n});\n\nfunction initNodeEventTarget(self) {\n  initEventTarget(self);\n}\n\nclass NodeEventTarget extends EventTarget {\n  static [kIsNodeEventTarget] = true;\n  static defaultMaxListeners = 10;\n\n  constructor() {\n    super();\n    initNodeEventTarget(this);\n  }\n\n  /**\n   * @param {number} n\n   */\n  setMaxListeners(n) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    EventEmitter.setMaxListeners(n\x2C this);\n  }\n\n  /**\n   * @returns {number}\n   */\n  getMaxListeners() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    return this[kMaxEventTargetListeners];\n  }\n\n  /**\n   * @returns {string[]}\n   */\n  eventNames() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    return ArrayFrom(this[kEvents].keys());\n  }\n\n  /**\n   * @param {string} type\n   * @returns {number}\n   */\n  listenerCount(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    const root = this[kEvents].get(String(type));\n    return root !== undefined ? root.size : 0;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   * }} [options]\n   * @returns {NodeEventTarget}\n   */\n  off(type\x2C listener\x2C options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   * }} [options]\n   * @returns {NodeEventTarget}\n   */\n  removeListener(type\x2C listener\x2C options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @returns {NodeEventTarget}\n   */\n  on(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @returns {NodeEventTarget}\n   */\n  addListener(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {any} arg\n   * @returns {boolean}\n   */\n  emit(type\x2C arg) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    validateString(type\x2C 'type');\n    const hadListeners = this.listenerCount(type) > 0;\n    this[kHybridDispatch](arg\x2C type);\n    return hadListeners;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @returns {NodeEventTarget}\n   */\n  once(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C\n                          { once: true\x2C [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  /**\n   * @param {string} [type]\n   * @returns {NodeEventTarget}\n   */\n  removeAllListeners(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    if (type !== undefined) {\n      this[kEvents].delete(String(type));\n    } else {\n      this[kEvents].clear();\n    }\n\n    return this;\n  }\n}\n\nObjectDefineProperties(NodeEventTarget.prototype\x2C {\n  setMaxListeners: kEnumerableProperty\x2C\n  getMaxListeners: kEnumerableProperty\x2C\n  eventNames: kEnumerableProperty\x2C\n  listenerCount: kEnumerableProperty\x2C\n  off: kEnumerableProperty\x2C\n  removeListener: kEnumerableProperty\x2C\n  on: kEnumerableProperty\x2C\n  addListener: kEnumerableProperty\x2C\n  once: kEnumerableProperty\x2C\n  emit: kEnumerableProperty\x2C\n  removeAllListeners: kEnumerableProperty\x2C\n});\n\n// EventTarget API\n\nfunction validateEventListener(listener) {\n  if (typeof listener === 'function' ||\n      typeof listener?.handleEvent === 'function') {\n    return true;\n  }\n\n  if (listener == null)\n    return false;\n\n  if (typeof listener === 'object') {\n    // Require `handleEvent` lazily.\n    return true;\n  }\n\n  throw new ERR_INVALID_ARG_TYPE('listener'\x2C 'EventListener'\x2C listener);\n}\n\nfunction validateEventListenerOptions(options) {\n  if (typeof options === 'boolean')\n    return { capture: options };\n\n  if (options === null)\n    return kEmptyObject;\n  validateObject(options\x2C 'options'\x2C {\n    allowArray: true\x2C allowFunction: true\x2C\n  });\n  return {\n    once: Boolean(options.once)\x2C\n    capture: Boolean(options.capture)\x2C\n    passive: Boolean(options.passive)\x2C\n    signal: options.signal\x2C\n    weak: options[kWeakHandler]\x2C\n    isNodeStyleListener: Boolean(options[kIsNodeStyleListener])\x2C\n  };\n}\n\n// Test whether the argument is an event object. This is far from a fool-proof\n// test\x2C for example this input will result in a false positive:\n// > isEventTarget({ constructor: EventTarget })\n// It stands in its current implementation as a compromise.\n// Ref: https://github.com/nodejs/node/pull/33661\nfunction isEventTarget(obj) {\n  return obj?.constructor?.[kIsEventTarget];\n}\n\nfunction isNodeEventTarget(obj) {\n  return obj?.constructor?.[kIsNodeEventTarget];\n}\n\nfunction addCatch(promise) {\n  const then = promise.then;\n  if (typeof then === 'function') {\n    FunctionPrototypeCall(then\x2C promise\x2C undefined\x2C function(err) {\n      // The callback is called with nextTick to avoid a follow-up\n      // rejection from this promise.\n      emitUncaughtException(err);\n    });\n  }\n}\n\nfunction emitUncaughtException(err) {\n  process.nextTick(() => { throw err; });\n}\n\nfunction makeEventHandler(handler) {\n  // Event handlers are dispatched in the order they were first set\n  // See https://github.com/nodejs/node/pull/35949#issuecomment-722496598\n  function eventHandler(...args) {\n    if (typeof eventHandler.handler !== 'function') {\n      return;\n    }\n    return ReflectApply(eventHandler.handler\x2C this\x2C args);\n  }\n  eventHandler.handler = handler;\n  return eventHandler;\n}\n\nfunction defineEventHandler(emitter\x2C name) {\n  // 8.1.5.1 Event handlers - basically `on[eventName]` attributes\n  ObjectDefineProperty(emitter\x2C `on${name}`\x2C {\n    __proto__: null\x2C\n    get() {\n      return this[kHandlers]?.get(name)?.handler ?? null;\n    }\x2C\n    set(value) {\n      if (!this[kHandlers]) {\n        this[kHandlers] = new SafeMap();\n      }\n      let wrappedHandler = this[kHandlers]?.get(name);\n      if (wrappedHandler) {\n        if (typeof wrappedHandler.handler === 'function') {\n          this[kEvents].get(name).size--;\n          const size = this[kEvents].get(name).size;\n          this[kRemoveListener](size\x2C name\x2C wrappedHandler.handler\x2C false);\n        }\n        wrappedHandler.handler = value;\n        if (typeof wrappedHandler.handler === 'function') {\n          this[kEvents].get(name).size++;\n          const size = this[kEvents].get(name).size;\n          this[kNewListener](size\x2C name\x2C value\x2C false\x2C false\x2C false\x2C false);\n        }\n      } else {\n        wrappedHandler = makeEventHandler(value);\n        this.addEventListener(name\x2C wrappedHandler);\n      }\n      this[kHandlers].set(name\x2C wrappedHandler);\n    }\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n  });\n}\n\nconst EventEmitterMixin = (Superclass) => {\n  class MixedEventEmitter extends Superclass {\n    constructor(...args) {\n      args = new SafeArrayIterator(args);\n      super(...args);\n      FunctionPrototypeCall(EventEmitter\x2C this);\n    }\n  }\n  const protoProps = ObjectGetOwnPropertyDescriptors(EventEmitter.prototype);\n  delete protoProps.constructor;\n  const propertiesValues = ObjectValues(protoProps);\n  for (let i = 0; i < propertiesValues.length; i++) {\n    // We want to use null-prototype objects to not rely on globally mutable\n    // %Object.prototype%.\n    ObjectSetPrototypeOf(propertiesValues[i]\x2C null);\n  }\n  ObjectDefineProperties(MixedEventEmitter.prototype\x2C protoProps);\n  return MixedEventEmitter;\n};\n\nmodule.exports = {\n  Event\x2C\n  CustomEvent\x2C\n  EventEmitterMixin\x2C\n  EventTarget\x2C\n  NodeEventTarget\x2C\n  defineEventHandler\x2C\n  initEventTarget\x2C\n  initNodeEventTarget\x2C\n  kCreateEvent\x2C\n  kNewListener\x2C\n  kTrustEvent\x2C\n  kRemoveListener\x2C\n  kEvents\x2C\n  kWeakHandler\x2C\n  isEventTarget\x2C\n};\n
code-source-info,0x1fa4d1d58850,47,27735,28425,C0O27787C23O27971C30O28003C33O28016C38O27971C43O28030C47O28088C52O28088C57O28129C59O28153C63O28134C68O28276C75O28313C81O28276C86O28162C91O28116C94O28331C99O28372C104O28331C109O28398C111O28423,,
tick,0x100f46080,105000,0,0x0,3,0x0,0x1fa4d1d469ac,0x41ccf0590b7,0x1100482ec,0x1fa4d1d414bd,0x41ccf0590b7,0x1100482ec,0x2b3d46ce8b1c,0x41ccf0590b7,0x1100482ec,0x2b3d46ce6af9,0x41ccf0590b7,0x1100482ec,0x2b3d46ce1b01,0x41ccf0590b7,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
code-creation,Eval,10,105000,0x1fa4d1d5b5c0,5, node:internal/modules/esm/translators:1:1,0x1fa4d1d5b168,~
script-source,486,node:internal/modules/esm/translators,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  Boolean\x2C\n  JSONParse\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectKeys\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeReplaceAll\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  SyntaxErrorPrototype\x2C\n  globalThis: { WebAssembly }\x2C\n} = primordials;\n\nlet _TYPES = null;\nfunction lazyTypes() {\n  if (_TYPES !== null) return _TYPES;\n  return _TYPES = require('internal/util/types');\n}\n\nconst { readFileSync } = require('fs');\nconst { extname\x2C isAbsolute } = require('path');\nconst {\n  hasEsmSyntax\x2C\n  loadBuiltinModule\x2C\n  stripBOM\x2C\n} = require('internal/modules/cjs/helpers');\nconst {\n  Module: CJSModule\x2C\n  cjsParseCache\x2C\n} = require('internal/modules/cjs/loader');\nconst internalURLModule = require('internal/url');\nconst createDynamicModule = require(\n  'internal/modules/esm/create_dynamic_module');\nconst { fileURLToPath\x2C URL } = require('url');\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { emitExperimentalWarning } = require('internal/util');\nconst {\n  ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  ERR_INVALID_RETURN_PROPERTY_VALUE\x2C\n} = require('internal/errors').codes;\nconst { maybeCacheSourceMap } = require('internal/source_map/source_map_cache');\nconst moduleWrap = internalBinding('module_wrap');\nconst { ModuleWrap } = moduleWrap;\nconst asyncESM = require('internal/process/esm_loader');\nconst { emitWarningSync } = require('internal/process/warning');\nconst { TextDecoder } = require('internal/encoding');\n\nlet cjsParse;\nasync function initCJSParse() {\n  if (typeof WebAssembly === 'undefined') {\n    cjsParse = require('internal/deps/cjs-module-lexer/lexer').parse;\n  } else {\n    const { parse\x2C init } =\n        require('internal/deps/cjs-module-lexer/dist/lexer');\n    try {\n      await init();\n      cjsParse = parse;\n    } catch {\n      cjsParse = require('internal/deps/cjs-module-lexer/lexer').parse;\n    }\n  }\n}\n\nconst translators = new SafeMap();\nexports.translators = translators;\nexports.enrichCJSError = enrichCJSError;\n\nlet DECODER = null;\nfunction assertBufferSource(body\x2C allowString\x2C hookName) {\n  if (allowString && typeof body === 'string') {\n    return;\n  }\n  const { isArrayBufferView\x2C isAnyArrayBuffer } = lazyTypes();\n  if (isArrayBufferView(body) || isAnyArrayBuffer(body)) {\n    return;\n  }\n  throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n    `${allowString ? 'string\x2C ' : ''}array buffer\x2C or typed array`\x2C\n    hookName\x2C\n    'source'\x2C\n    body\x2C\n  );\n}\n\nfunction stringify(body) {\n  if (typeof body === 'string') return body;\n  assertBufferSource(body\x2C false\x2C 'transformSource');\n  DECODER = DECODER === null ? new TextDecoder() : DECODER;\n  return DECODER.decode(body);\n}\n\nfunction errPath(url) {\n  const parsed = new URL(url);\n  if (parsed.protocol === 'file:') {\n    return fileURLToPath(parsed);\n  }\n  return url;\n}\n\nasync function importModuleDynamically(specifier\x2C { url }\x2C assertions) {\n  return asyncESM.esmLoader.import(specifier\x2C url\x2C assertions);\n}\n\n// Strategy for loading a standard JavaScript module.\ntranslators.set('module'\x2C async function moduleStrategy(url\x2C source\x2C isMain) {\n  assertBufferSource(source\x2C true\x2C 'load');\n  source = stringify(source);\n  maybeCacheSourceMap(url\x2C source);\n  debug(`Translating StandardModule ${url}`);\n  const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n  moduleWrap.callbackMap.set(module\x2C {\n    initializeImportMeta: (meta\x2C wrap) => this.importMetaInitialize(meta\x2C { url })\x2C\n    importModuleDynamically\x2C\n  });\n  return module;\n});\n\n/**\n * @param {Error | any} err\n * @param {string} [content] Content of the file\x2C if known.\n * @param {string} [filename] Useful only if `content` is unknown.\n */\nfunction enrichCJSError(err\x2C content\x2C filename) {\n  if (err != null && ObjectGetPrototypeOf(err) === SyntaxErrorPrototype &&\n      hasEsmSyntax(content || readFileSync(filename\x2C 'utf-8'))) {\n    // Emit the warning synchronously because we are in the middle of handling\n    // a SyntaxError that will throw and likely terminate the process before an\n    // asynchronous warning would be emitted.\n    emitWarningSync(\n      'To load an ES module\x2C set "type": "module" in the package.json or use ' +\n      'the .mjs extension.'\x2C\n    );\n  }\n}\n\n// Strategy for loading a node-style CommonJS module\nconst isWindows = process.platform === 'win32';\ntranslators.set('commonjs'\x2C async function commonjsStrategy(url\x2C source\x2C\n                                                            isMain) {\n  debug(`Translating CJSModule ${url}`);\n\n  let filename = internalURLModule.fileURLToPath(new URL(url));\n  if (isWindows)\n    filename = StringPrototypeReplaceAll(filename\x2C '/'\x2C '\\\\');\n\n  if (!cjsParse) await initCJSParse();\n  const { module\x2C exportNames } = cjsPreparseModuleExports(filename);\n  const namesWithDefault = exportNames.has('default') ?\n    [...exportNames] : ['default'\x2C ...exportNames];\n\n  return new ModuleWrap(url\x2C undefined\x2C namesWithDefault\x2C function() {\n    debug(`Loading CJSModule ${url}`);\n\n    let exports;\n    if (asyncESM.esmLoader.cjsCache.has(module)) {\n      exports = asyncESM.esmLoader.cjsCache.get(module);\n      asyncESM.esmLoader.cjsCache.delete(module);\n    } else {\n      try {\n        exports = CJSModule._load(filename\x2C undefined\x2C isMain);\n      } catch (err) {\n        enrichCJSError(err\x2C undefined\x2C filename);\n        throw err;\n      }\n    }\n\n    for (const exportName of exportNames) {\n      if (!ObjectPrototypeHasOwnProperty(exports\x2C exportName) ||\n          exportName === 'default')\n        continue;\n      // We might trigger a getter -> dont fail.\n      let value;\n      try {\n        value = exports[exportName];\n      } catch {\n        // Continue regardless of error.\n      }\n      this.setExport(exportName\x2C value);\n    }\n    this.setExport('default'\x2C exports);\n  });\n});\n\nfunction cjsPreparseModuleExports(filename) {\n  let module = CJSModule._cache[filename];\n  if (module) {\n    const cached = cjsParseCache.get(module);\n    if (cached)\n      return { module\x2C exportNames: cached.exportNames };\n  }\n  const loaded = Boolean(module);\n  if (!loaded) {\n    module = new CJSModule(filename);\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n    CJSModule._cache[filename] = module;\n  }\n\n  let source;\n  try {\n    source = readFileSync(filename\x2C 'utf8');\n  } catch {\n    // Continue regardless of error.\n  }\n\n  let exports\x2C reexports;\n  try {\n    ({ exports\x2C reexports } = cjsParse(source || ''));\n  } catch {\n    exports = [];\n    reexports = [];\n  }\n\n  const exportNames = new SafeSet(new SafeArrayIterator(exports));\n\n  // Set first for cycles.\n  cjsParseCache.set(module\x2C { source\x2C exportNames\x2C loaded });\n\n  if (reexports.length) {\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n  }\n  ArrayPrototypeForEach(reexports\x2C (reexport) => {\n    let resolved;\n    try {\n      resolved = CJSModule._resolveFilename(reexport\x2C module);\n    } catch {\n      return;\n    }\n    const ext = extname(resolved);\n    if ((ext === '.js' || ext === '.cjs' || !CJSModule._extensions[ext]) &&\n        isAbsolute(resolved)) {\n      const { exportNames: reexportNames } = cjsPreparseModuleExports(resolved);\n      for (const name of reexportNames)\n        exportNames.add(name);\n    }\n  });\n\n  return { module\x2C exportNames };\n}\n\n// Strategy for loading a node builtin CommonJS module that isn't\n// through normal resolution\ntranslators.set('builtin'\x2C async function builtinStrategy(url) {\n  debug(`Translating BuiltinModule ${url}`);\n  // Slice 'node:' scheme\n  const id = StringPrototypeSlice(url\x2C 5);\n  const module = loadBuiltinModule(id\x2C url);\n  if (!StringPrototypeStartsWith(url\x2C 'node:') || !module) {\n    throw new ERR_UNKNOWN_BUILTIN_MODULE(url);\n  }\n  debug(`Loading BuiltinModule ${url}`);\n  return module.getESMFacade();\n});\n\n// Strategy for loading a JSON file\ntranslators.set('json'\x2C async function jsonStrategy(url\x2C source) {\n  emitExperimentalWarning('Importing JSON modules');\n  assertBufferSource(source\x2C true\x2C 'load');\n  debug(`Loading JSONModule ${url}`);\n  const pathname = StringPrototypeStartsWith(url\x2C 'file:') ?\n    fileURLToPath(url) : null;\n  let modulePath;\n  let module;\n  if (pathname) {\n    modulePath = isWindows ?\n      StringPrototypeReplaceAll(pathname\x2C '/'\x2C '\\\\') : pathname;\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  source = stringify(source);\n  if (pathname) {\n    // A require call could have been called on the same file during loading and\n    // that resolves synchronously. To make sure we always return the identical\n    // export\x2C we have to check again if the module already exists or not.\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  try {\n    const exports = JSONParse(stripBOM(source));\n    module = {\n      exports\x2C\n      loaded: true\x2C\n    };\n  } catch (err) {\n    // TODO (BridgeAR): We could add a NodeCore error that wraps the JSON\n    // parse error instead of just manipulating the original error message.\n    // That would allow to add further properties and maybe additional\n    // debugging information.\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n  if (pathname) {\n    CJSModule._cache[modulePath] = module;\n  }\n  return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n    debug(`Parsing JSONModule ${url}`);\n    this.setExport('default'\x2C module.exports);\n  });\n});\n\n// Strategy for loading a wasm module\ntranslators.set('wasm'\x2C async function(url\x2C source) {\n  emitExperimentalWarning('Importing WebAssembly modules');\n\n  assertBufferSource(source\x2C false\x2C 'load');\n\n  debug(`Translating WASMModule ${url}`);\n\n  let compiled;\n  try {\n    compiled = await WebAssembly.compile(source);\n  } catch (err) {\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n\n  const imports =\n      ArrayPrototypeMap(WebAssembly.Module.imports(compiled)\x2C\n                        ({ module }) => module);\n  const exports =\n    ArrayPrototypeMap(WebAssembly.Module.exports(compiled)\x2C\n                      ({ name }) => name);\n\n  return createDynamicModule(imports\x2C exports\x2C url\x2C (reflect) => {\n    const { exports } = new WebAssembly.Instance(compiled\x2C reflect.imports);\n    for (const expt of ObjectKeys(exports))\n      reflect.exports[expt].set(exports[expt]);\n  }).module;\n});\n
code-source-info,0x1fa4d1d5b5c0,486,0,10736,C0O0C4O10736,,
code-creation,Function,10,105709,0x1fa4d1d5bd60,706, node:internal/modules/esm/translators:1:1,0x1fa4d1d5b538,~
code-source-info,0x1fa4d1d5bd60,486,0,10736,C0O0C177O25C183O50C189O71C195O82C201O95C207O119C213O152C219O166C225O187C230O198C236O209C242O238C248O262C254O291C265O329C271O375C272O375C274O520C280O520C285O503C291O567C297O567C302O543C308O552C314O645C320O645C325O594C331O610C337O631C343O736C349O736C354O704C360O717C366O802C372O802C376O802C378O855C384O855C388O855C390O944C396O944C401O921C407O936C413O972C419O972C424O1005C437O1006C443O972C445O1086C451O1086C456O1058C462O1191C468O1191C473O1217C478O1122C484O1152C490O1257C496O1257C501O1233C507O1325C510O1325C514O1325C516O1380C519O1365C525O1409C531O1409C535O1409C537O1477C543O1477C548O1457C554O1538C560O1538C565O1522C571O1573C572O1573C574O2003C576O2003C582O2018C584O2038C588O2053C590O2076C594O2109C595O2109C597O3111C610O3111C616O4360C623O4369C626O4352C628O4394C641O4394C647O7481C660O7481C666O7931C679O7931C685O9875C698O9875C705O10735,,
code-creation,Eval,10,105875,0x1fa4d1d5d258,5, node:internal/modules/esm/create_dynamic_module:1:1,0x1fa4d1d5d080,~
script-source,487,node:internal/modules/esm/create_dynamic_module,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  JSONStringify\x2C\n  ObjectCreate\x2C\n  SafeSet\x2C\n} = primordials;\n\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\n\nfunction createImport(impt\x2C index) {\n  const imptPath = JSONStringify(impt);\n  return `import * as $import_${index} from ${imptPath};\nimport.meta.imports[${imptPath}] = $import_${index};`;\n}\n\nfunction createExport(expt) {\n  const name = `${expt}`;\n  return `let $${name};\nexport { $${name} as ${name} };\nimport.meta.exports.${name} = {\n  get: () => $${name}\x2C\n  set: (v) => $${name} = v\x2C\n};`;\n}\n\nconst createDynamicModule = (imports\x2C exports\x2C url = ''\x2C evaluate) => {\n  debug('creating ESM facade for %s with exports: %j'\x2C url\x2C exports);\n  const source = `\n${ArrayPrototypeJoin(ArrayPrototypeMap(imports\x2C createImport)\x2C '\\n')}\n${ArrayPrototypeJoin(ArrayPrototypeMap(exports\x2C createExport)\x2C '\\n')}\nimport.meta.done();\n`;\n  const { ModuleWrap\x2C callbackMap } = internalBinding('module_wrap');\n  const m = new ModuleWrap(`${url}`\x2C undefined\x2C source\x2C 0\x2C 0);\n\n  const readyfns = new SafeSet();\n  const reflect = {\n    exports: ObjectCreate(null)\x2C\n    onReady: (cb) => { readyfns.add(cb); }\x2C\n  };\n\n  if (imports.length)\n    reflect.imports = ObjectCreate(null);\n\n  callbackMap.set(m\x2C {\n    initializeImportMeta: (meta\x2C wrap) => {\n      meta.exports = reflect.exports;\n      if (reflect.imports)\n        meta.imports = reflect.imports;\n      meta.done = () => {\n        evaluate(reflect);\n        reflect.onReady = (cb) => cb(reflect);\n        for (const fn of readyfns) {\n          readyfns.delete(fn);\n          fn(reflect);\n        }\n      };\n    }\x2C\n  });\n\n  return {\n    module: m\x2C\n    reflect\x2C\n  };\n};\n\nmodule.exports = createDynamicModule;\n
code-source-info,0x1fa4d1d5d258,487,0,1756,C0O0C4O1756,,
code-creation,Function,10,105959,0x1fa4d1d5d480,111, node:internal/modules/esm/create_dynamic_module:1:1,0x1fa4d1d5d1d0,~
code-source-info,0x1fa4d1d5d480,487,0,1756,C0O0C39O25C45O47C51O68C57O85C63O101C69O140C72O140C77O173C90O174C96O140C98O642C103O1718C105O1733C110O1755,,
code-creation,Eval,10,106209,0x1fa4d1d5e388,5, node:internal/vm/module:1:1,0x1fa4d1d5de10,~
script-source,488,node:internal/vm/module,'use strict';\n\nconst assert = require('internal/assert');\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeSome\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  SafePromiseAllReturnVoid\x2C\n  SafeWeakMap\x2C\n  Symbol\x2C\n  SymbolToStringTag\x2C\n  TypeError\x2C\n} = primordials;\n\nconst { isContext } = internalBinding('contextify');\nconst {\n  isModuleNamespaceObject\x2C\n} = require('internal/util/types');\nconst {\n  customInspectSymbol\x2C\n  emitExperimentalWarning\x2C\n  getConstructorOf\x2C\n  kEmptyObject\x2C\n} = require('internal/util');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_VM_MODULE_ALREADY_LINKED\x2C\n  ERR_VM_MODULE_DIFFERENT_CONTEXT\x2C\n  ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA\x2C\n  ERR_VM_MODULE_LINK_FAILURE\x2C\n  ERR_VM_MODULE_NOT_MODULE\x2C\n  ERR_VM_MODULE_STATUS\x2C\n} = require('internal/errors').codes;\nconst {\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateObject\x2C\n  validateUint32\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst binding = internalBinding('module_wrap');\nconst {\n  ModuleWrap\x2C\n  kUninstantiated\x2C\n  kInstantiating\x2C\n  kInstantiated\x2C\n  kEvaluating\x2C\n  kEvaluated\x2C\n  kErrored\x2C\n} = binding;\n\nconst STATUS_MAP = {\n  [kUninstantiated]: 'unlinked'\x2C\n  [kInstantiating]: 'linking'\x2C\n  [kInstantiated]: 'linked'\x2C\n  [kEvaluating]: 'evaluating'\x2C\n  [kEvaluated]: 'evaluated'\x2C\n  [kErrored]: 'errored'\x2C\n};\n\nlet globalModuleId = 0;\nconst defaultModuleName = 'vm:module';\nconst wrapToModuleMap = new SafeWeakMap();\n\nconst kWrap = Symbol('kWrap');\nconst kContext = Symbol('kContext');\nconst kPerContextModuleId = Symbol('kPerContextModuleId');\nconst kLink = Symbol('kLink');\n\nclass Module {\n  constructor(options) {\n    emitExperimentalWarning('VM Modules');\n\n    if (new.target === Module) {\n      // eslint-disable-next-line no-restricted-syntax\n      throw new TypeError('Module is not a constructor');\n    }\n\n    const {\n      context\x2C\n      sourceText\x2C\n      syntheticExportNames\x2C\n      syntheticEvaluationSteps\x2C\n    } = options;\n\n    if (context !== undefined) {\n      validateObject(context\x2C 'context');\n      if (!isContext(context)) {\n        throw new ERR_INVALID_ARG_TYPE('options.context'\x2C 'vm.Context'\x2C\n                                       context);\n      }\n    }\n\n    let { identifier } = options;\n    if (identifier !== undefined) {\n      validateString(identifier\x2C 'options.identifier');\n    } else if (context === undefined) {\n      identifier = `${defaultModuleName}(${globalModuleId++})`;\n    } else if (context[kPerContextModuleId] !== undefined) {\n      const curId = context[kPerContextModuleId];\n      identifier = `${defaultModuleName}(${curId})`;\n      context[kPerContextModuleId] += 1;\n    } else {\n      identifier = `${defaultModuleName}(0)`;\n      ObjectDefineProperty(context\x2C kPerContextModuleId\x2C {\n        __proto__: null\x2C\n        value: 1\x2C\n        writable: true\x2C\n        enumerable: false\x2C\n        configurable: true\x2C\n      });\n    }\n\n    if (sourceText !== undefined) {\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C sourceText\x2C\n                                   options.lineOffset\x2C options.columnOffset\x2C\n                                   options.cachedData);\n\n      binding.callbackMap.set(this[kWrap]\x2C {\n        initializeImportMeta: options.initializeImportMeta\x2C\n        importModuleDynamically: options.importModuleDynamically ?\n          importModuleDynamicallyWrap(options.importModuleDynamically) :\n          undefined\x2C\n      });\n    } else {\n      assert(syntheticEvaluationSteps);\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C\n                                   syntheticExportNames\x2C\n                                   syntheticEvaluationSteps);\n    }\n\n    wrapToModuleMap.set(this[kWrap]\x2C this);\n\n    this[kContext] = context;\n  }\n\n  get identifier() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kWrap].url;\n  }\n\n  get context() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kContext];\n  }\n\n  get namespace() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must not be unlinked or linking');\n    }\n    return this[kWrap].getNamespace();\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return STATUS_MAP[this[kWrap].getStatus()];\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS('must be errored');\n    }\n    return this[kWrap].getError();\n  }\n\n  async link(linker) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateFunction(linker\x2C 'linker');\n    if (this.status === 'linked') {\n      throw new ERR_VM_MODULE_ALREADY_LINKED();\n    }\n    if (this.status !== 'unlinked') {\n      throw new ERR_VM_MODULE_STATUS('must be unlinked');\n    }\n    await this[kLink](linker);\n    this[kWrap].instantiate();\n  }\n\n  async evaluate(options = kEmptyObject) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n\n    validateObject(options\x2C 'options');\n\n    let timeout = options.timeout;\n    if (timeout === undefined) {\n      timeout = -1;\n    } else {\n      validateUint32(timeout\x2C 'options.timeout'\x2C true);\n    }\n    const { breakOnSigint = false } = options;\n    validateBoolean(breakOnSigint\x2C 'options.breakOnSigint');\n    const status = this[kWrap].getStatus();\n    if (status !== kInstantiated &&\n        status !== kEvaluated &&\n        status !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS(\n        'must be one of linked\x2C evaluated\x2C or errored'\x2C\n      );\n    }\n    await this[kWrap].evaluate(timeout\x2C breakOnSigint);\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || Module;\n    const o = ObjectCreate({ constructor });\n    o.status = this.status;\n    o.identifier = this.identifier;\n    o.context = this.context;\n\n    ObjectSetPrototypeOf(o\x2C ObjectGetPrototypeOf(this));\n    ObjectDefineProperty(o\x2C SymbolToStringTag\x2C {\n      __proto__: null\x2C\n      value: constructor.name\x2C\n      configurable: true\x2C\n    });\n\n    // Lazy to avoid circular dependency\n    const { inspect } = require('internal/util/inspect');\n    return inspect(o\x2C { ...options\x2C customInspect: false });\n  }\n}\n\nconst kDependencySpecifiers = Symbol('kDependencySpecifiers');\nconst kNoError = Symbol('kNoError');\n\nclass SourceTextModule extends Module {\n  #error = kNoError;\n  #statusOverride;\n\n  constructor(sourceText\x2C options = kEmptyObject) {\n    validateString(sourceText\x2C 'sourceText');\n    validateObject(options\x2C 'options');\n\n    const {\n      lineOffset = 0\x2C\n      columnOffset = 0\x2C\n      initializeImportMeta\x2C\n      importModuleDynamically\x2C\n      context\x2C\n      identifier\x2C\n      cachedData\x2C\n    } = options;\n\n    validateInt32(lineOffset\x2C 'options.lineOffset');\n    validateInt32(columnOffset\x2C 'options.columnOffset');\n\n    if (initializeImportMeta !== undefined) {\n      validateFunction(initializeImportMeta\x2C 'options.initializeImportMeta');\n    }\n\n    if (importModuleDynamically !== undefined) {\n      validateFunction(importModuleDynamically\x2C 'options.importModuleDynamically');\n    }\n\n    if (cachedData !== undefined) {\n      validateBuffer(cachedData\x2C 'options.cachedData');\n    }\n\n    super({\n      sourceText\x2C\n      context\x2C\n      identifier\x2C\n      lineOffset\x2C\n      columnOffset\x2C\n      cachedData\x2C\n      initializeImportMeta\x2C\n      importModuleDynamically\x2C\n    });\n\n    this[kLink] = async (linker) => {\n      this.#statusOverride = 'linking';\n\n      const promises = this[kWrap].link(async (identifier\x2C assert) => {\n        const module = await linker(identifier\x2C this\x2C { assert });\n        if (module[kWrap] === undefined) {\n          throw new ERR_VM_MODULE_NOT_MODULE();\n        }\n        if (module.context !== this.context) {\n          throw new ERR_VM_MODULE_DIFFERENT_CONTEXT();\n        }\n        if (module.status === 'errored') {\n          throw new ERR_VM_MODULE_LINK_FAILURE(`request for '${identifier}' resolved to an errored module`\x2C module.error);\n        }\n        if (module.status === 'unlinked') {\n          await module[kLink](linker);\n        }\n        return module[kWrap];\n      });\n\n      try {\n        if (promises !== undefined) {\n          await SafePromiseAllReturnVoid(promises);\n        }\n      } catch (e) {\n        this.#error = e;\n        throw e;\n      } finally {\n        this.#statusOverride = undefined;\n      }\n    };\n\n    this[kDependencySpecifiers] = undefined;\n  }\n\n  get dependencySpecifiers() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kDependencySpecifiers] === undefined) {\n      this[kDependencySpecifiers] = this[kWrap].getStaticDependencySpecifiers();\n    }\n    return this[kDependencySpecifiers];\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return 'errored';\n    }\n    if (this.#statusOverride) {\n      return this.#statusOverride;\n    }\n    return super.status;\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return this.#error;\n    }\n    return super.error;\n  }\n\n  createCachedData() {\n    const { status } = this;\n    if (status === 'evaluating' ||\n        status === 'evaluated' ||\n        status === 'errored') {\n      throw new ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA();\n    }\n    return this[kWrap].createCachedData();\n  }\n}\n\nclass SyntheticModule extends Module {\n  constructor(exportNames\x2C evaluateCallback\x2C options = kEmptyObject) {\n    if (!ArrayIsArray(exportNames) ||\n      ArrayPrototypeSome(exportNames\x2C (e) => typeof e !== 'string')) {\n      throw new ERR_INVALID_ARG_TYPE('exportNames'\x2C\n                                     'Array of unique strings'\x2C\n                                     exportNames);\n    } else {\n      ArrayPrototypeForEach(exportNames\x2C (name\x2C i) => {\n        if (ArrayPrototypeIndexOf(exportNames\x2C name\x2C i + 1) !== -1) {\n          throw new ERR_INVALID_ARG_VALUE(`exportNames.${name}`\x2C\n                                          name\x2C\n                                          'is duplicated');\n        }\n      });\n    }\n    validateFunction(evaluateCallback\x2C 'evaluateCallback');\n\n    validateObject(options\x2C 'options');\n\n    const { context\x2C identifier } = options;\n\n    super({\n      syntheticExportNames: exportNames\x2C\n      syntheticEvaluationSteps: evaluateCallback\x2C\n      context\x2C\n      identifier\x2C\n    });\n\n    this[kLink] = () => this[kWrap].link(() => {\n      assert.fail('link callback should not be called');\n    });\n  }\n\n  setExport(name\x2C value) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateString(name\x2C 'name');\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must be linked');\n    }\n    this[kWrap].setExport(name\x2C value);\n  }\n}\n\nfunction importModuleDynamicallyWrap(importModuleDynamically) {\n  const importModuleDynamicallyWrapper = async (...args) => {\n    const m = await ReflectApply(importModuleDynamically\x2C this\x2C args);\n    if (isModuleNamespaceObject(m)) {\n      return m;\n    }\n    if (!m || m[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (m.status === 'errored') {\n      throw m.error;\n    }\n    return m.namespace;\n  };\n  return importModuleDynamicallyWrapper;\n}\n\nmodule.exports = {\n  Module\x2C\n  SourceTextModule\x2C\n  SyntheticModule\x2C\n  importModuleDynamicallyWrap\x2C\n  getModuleFromWrap: (wrap) => wrapToModuleMap.get(wrap)\x2C\n};\n
code-source-info,0x1fa4d1d5e388,488,0,12082,C0O0C4O12082,,
code-creation,Function,10,108000,0x1fa4d1d5f5f0,881, node:internal/vm/module:1:1,0x1fa4d1d5e300,~
code-source-info,0x1fa4d1d5f5f0,488,0,12082,C0O0C159O30C165O30C169O30C171O68C177O84C183O109C189O134C195O156C201O172C207O196C213O220C219O244C225O260C231O288C236O303C241O313C247O334C253O385C256O385C261O371C267O455C273O455C278O426C284O585C290O585C295O497C300O520C306O547C312O567C318O864C324O864C329O890C334O621C340O645C346O670C352O702C358O737C364O780C370O810C376O838C382O1038C388O1038C393O908C399O927C405O945C411O965C417O982C423O1000C429O1018C435O1087C438O1087C442O1087C444O1240C447O1129C453O1143C458O1162C463O1180C469O1197C474O1212C480O1226C486O1269C493O1274C497O1292C504O1307C508O1324C515O1338C519O1354C526O1367C530O1381C537O1398C541O1411C548O1427C552O1438C559O1269C561O1474C562O1474C564O1503C566O1503C568O1540C570O1540C575O1540C577O1574C580O1574C584O1574C586O1608C589O1608C593O1608C595O1656C598O1656C602O1656C604O1701C607O1701C611O1701C669O5983C697O6767C700O6767C704O6767C706O6817C709O6817C713O6817C745O6869C808O10027C836O11922C843O11943C849O11953C855O11973C861O11992C865O12042C875O11937C880O12081,,
code-creation,Function,10,108042,0x1fa4d1d5fb40,23,<instance_members_initializer> node:internal/vm/module:258:1,0x1fa4d1d5e970,~
code-source-info,0x1fa4d1d5fb40,488,6838,9995,C3O6889C17O6901C22O9995,,
code-creation,LazyCompile,10,108250,0x1fa4d1d61190,161,ESMLoader node:internal/modules/esm/loader:237:14,0x2b3d46ce8148,~
code-source-info,0x1fa4d1d61190,468,7043,7650,C5O7043C23O7052C33O7056C38O7095C44O7103C49O7116C59O7116C63O7173C73O7177C79O7235C89O7235C93O7289C105O7344C111O7344C118O7398C123O7423C128O7431C139O7431C145O7599C151O7633C160O7649,,
code-creation,LazyCompile,10,108334,0x1fa4d1d62f88,27,ModuleMap node:internal/modules/esm/module_map:17:14,0x2b3d46ceb1d8,~
code-source-info,0x1fa4d1d62f88,469,518,535,C3O524C7O530C11O524C26O534,,
code-creation,LazyCompile,10,108375,0x1fa4d1d63240,13,desc.value node:internal/per_context/primordials:381:32,0x41ccf052880,~
script-source,12,node:internal/per_context/primordials,'use strict';\n\n/* eslint-disable node-core/prefer-primordials */\n\n// This file subclasses and stores the JS builtins that come from the VM\n// so that Node.js's builtin modules do not need to later look these up from\n// the global proxy\x2C which can be mutated by users.\n\n// Use of primordials have sometimes a dramatic impact on performance\x2C please\n// benchmark all changes made in performance-sensitive areas of the codebase.\n// See: https://github.com/nodejs/node/pull/38248\n\nconst {\n  defineProperty: ReflectDefineProperty\x2C\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor\x2C\n  ownKeys: ReflectOwnKeys\x2C\n} = Reflect;\n\n// `uncurryThis` is equivalent to `func => Function.prototype.call.bind(func)`.\n// It is using `bind.bind(call)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.call` after it may have been mutated by users.\nconst { apply\x2C bind\x2C call } = Function.prototype;\nconst uncurryThis = bind.bind(call);\nprimordials.uncurryThis = uncurryThis;\n\n// `applyBind` is equivalent to `func => Function.prototype.apply.bind(func)`.\n// It is using `bind.bind(apply)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.apply` after it may have been mutated by users.\nconst applyBind = bind.bind(apply);\nprimordials.applyBind = applyBind;\n\n// Methods that accept a variable number of arguments\x2C and thus it's useful to\n// also create `${prefix}${key}Apply`\x2C which uses `Function.prototype.apply`\x2C\n// instead of `Function.prototype.call`\x2C and thus doesn't require iterator\n// destructuring.\nconst varargsMethods = [\n  // 'ArrayPrototypeConcat' is omitted\x2C because it performs the spread\n  // on its own for arrays and array-likes with a truthy\n  // @@isConcatSpreadable symbol property.\n  'ArrayOf'\x2C\n  'ArrayPrototypePush'\x2C\n  'ArrayPrototypeUnshift'\x2C\n  // 'FunctionPrototypeCall' is omitted\x2C since there's 'ReflectApply'\n  // and 'FunctionPrototypeApply'.\n  'MathHypot'\x2C\n  'MathMax'\x2C\n  'MathMin'\x2C\n  'StringFromCharCode'\x2C\n  'StringFromCodePoint'\x2C\n  'StringPrototypeConcat'\x2C\n  'TypedArrayOf'\x2C\n];\n\nfunction getNewKey(key) {\n  return typeof key === 'symbol' ?\n    `Symbol${key.description[7].toUpperCase()}${key.description.slice(8)}` :\n    `${key[0].toUpperCase()}${key.slice(1)}`;\n}\n\nfunction copyAccessor(dest\x2C prefix\x2C key\x2C { enumerable\x2C get\x2C set }) {\n  ReflectDefineProperty(dest\x2C `${prefix}Get${key}`\x2C {\n    __proto__: null\x2C\n    value: uncurryThis(get)\x2C\n    enumerable\x2C\n  });\n  if (set !== undefined) {\n    ReflectDefineProperty(dest\x2C `${prefix}Set${key}`\x2C {\n      __proto__: null\x2C\n      value: uncurryThis(set)\x2C\n      enumerable\x2C\n    });\n  }\n}\n\nfunction copyPropsRenamed(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C { __proto__: null\x2C ...desc });\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          __proto__: null\x2C\n          // `src` is bound as the `this` so that the static `this` points\n          // to the object it was defined on\x2C\n          // e.g.: `ArrayOfApply` gets a `this` of `Array`:\n          value: applyBind(desc.value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPropsRenamedBound(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = value.bind(src);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C { __proto__: null\x2C ...desc });\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          __proto__: null\x2C\n          value: applyBind(value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPrototype(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = uncurryThis(value);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C { __proto__: null\x2C ...desc });\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          __proto__: null\x2C\n          value: applyBind(value)\x2C\n        });\n      }\n    }\n  }\n}\n\n// Create copies of configurable value properties of the global object\n[\n  'Proxy'\x2C\n  'globalThis'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  primordials[name] = globalThis[name];\n});\n\n// Create copies of URI handling functions\n[\n  decodeURI\x2C\n  decodeURIComponent\x2C\n  encodeURI\x2C\n  encodeURIComponent\x2C\n].forEach((fn) => {\n  primordials[fn.name] = fn;\n});\n\n// Create copies of legacy functions\n[\n  escape\x2C\n  eval\x2C\n  unescape\x2C\n].forEach((fn) => {\n  primordials[fn.name] = fn;\n});\n\n// Create copies of the namespace objects\n[\n  'JSON'\x2C\n  'Math'\x2C\n  'Proxy'\x2C\n  'Reflect'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  copyPropsRenamed(globalThis[name]\x2C primordials\x2C name);\n});\n\n// Create copies of intrinsic objects\n[\n  'AggregateError'\x2C\n  'Array'\x2C\n  'ArrayBuffer'\x2C\n  'BigInt'\x2C\n  'BigInt64Array'\x2C\n  'BigUint64Array'\x2C\n  'Boolean'\x2C\n  'DataView'\x2C\n  'Date'\x2C\n  'Error'\x2C\n  'EvalError'\x2C\n  'FinalizationRegistry'\x2C\n  'Float32Array'\x2C\n  'Float64Array'\x2C\n  'Function'\x2C\n  'Int16Array'\x2C\n  'Int32Array'\x2C\n  'Int8Array'\x2C\n  'Map'\x2C\n  'Number'\x2C\n  'Object'\x2C\n  'RangeError'\x2C\n  'ReferenceError'\x2C\n  'RegExp'\x2C\n  'Set'\x2C\n  'String'\x2C\n  'Symbol'\x2C\n  'SyntaxError'\x2C\n  'TypeError'\x2C\n  'URIError'\x2C\n  'Uint16Array'\x2C\n  'Uint32Array'\x2C\n  'Uint8Array'\x2C\n  'Uint8ClampedArray'\x2C\n  'WeakMap'\x2C\n  'WeakRef'\x2C\n  'WeakSet'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = globalThis[name];\n  primordials[name] = original;\n  copyPropsRenamed(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Create copies of intrinsic objects that require a valid `this` to call\n// static methods.\n// Refs: https://www.ecma-international.org/ecma-262/#sec-promise.all\n[\n  'Promise'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = globalThis[name];\n  primordials[name] = original;\n  copyPropsRenamedBound(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Create copies of abstract intrinsic objects that are not directly exposed\n// on the global object.\n// Refs: https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object\n[\n  { name: 'TypedArray'\x2C original: Reflect.getPrototypeOf(Uint8Array) }\x2C\n  { name: 'ArrayIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(Array.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n  { name: 'StringIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(String.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n].forEach(({ name\x2C original }) => {\n  primordials[name] = original;\n  // The static %TypedArray% methods require a valid `this`\x2C but can't be bound\x2C\n  // as they need a subclass constructor as the receiver:\n  copyPrototype(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\nprimordials.IteratorPrototype = Reflect.getPrototypeOf(primordials.ArrayIteratorPrototype);\n\n/* eslint-enable node-core/prefer-primordials */\n\nconst {\n  Array: ArrayConstructor\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  FinalizationRegistry\x2C\n  FunctionPrototypeCall\x2C\n  Map\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectFreeze\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  ReflectSet\x2C\n  ReflectGet\x2C\n  RegExp\x2C\n  RegExpPrototype\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeGetDotAll\x2C\n  RegExpPrototypeGetFlags\x2C\n  RegExpPrototypeGetGlobal\x2C\n  RegExpPrototypeGetHasIndices\x2C\n  RegExpPrototypeGetIgnoreCase\x2C\n  RegExpPrototypeGetMultiline\x2C\n  RegExpPrototypeGetSource\x2C\n  RegExpPrototypeGetSticky\x2C\n  RegExpPrototypeGetUnicode\x2C\n  Set\x2C\n  SymbolIterator\x2C\n  SymbolMatch\x2C\n  SymbolMatchAll\x2C\n  SymbolReplace\x2C\n  SymbolSearch\x2C\n  SymbolSpecies\x2C\n  SymbolSplit\x2C\n  WeakMap\x2C\n  WeakRef\x2C\n  WeakSet\x2C\n} = primordials;\n\n\n/**\n * Creates a class that can be safely iterated over.\n *\n * Because these functions are used by `makeSafe`\x2C which is exposed on the\n * `primordials` object\x2C it's important to use const references to the\n * primordials that they use.\n * @template {Iterable} T\n * @template {*} TReturn\n * @template {*} TNext\n * @param {(self: T) => IterableIterator<T>} factory\n * @param {(...args: [] | [TNext]) => IteratorResult<T\x2C TReturn>} next\n * @returns {Iterator<T\x2C TReturn\x2C TNext>}\n */\nconst createSafeIterator = (factory\x2C next) => {\n  class SafeIterator {\n    constructor(iterable) {\n      this._iterator = factory(iterable);\n    }\n    next() {\n      return next(this._iterator);\n    }\n    [SymbolIterator]() {\n      return this;\n    }\n  }\n  ObjectSetPrototypeOf(SafeIterator.prototype\x2C null);\n  ObjectFreeze(SafeIterator.prototype);\n  ObjectFreeze(SafeIterator);\n  return SafeIterator;\n};\n\nprimordials.SafeArrayIterator = createSafeIterator(\n  primordials.ArrayPrototypeSymbolIterator\x2C\n  primordials.ArrayIteratorPrototypeNext\x2C\n);\nprimordials.SafeStringIterator = createSafeIterator(\n  primordials.StringPrototypeSymbolIterator\x2C\n  primordials.StringIteratorPrototypeNext\x2C\n);\n\nconst copyProps = (src\x2C dest) => {\n  ArrayPrototypeForEach(ReflectOwnKeys(src)\x2C (key) => {\n    if (!ReflectGetOwnPropertyDescriptor(dest\x2C key)) {\n      ReflectDefineProperty(\n        dest\x2C\n        key\x2C\n        { __proto__: null\x2C ...ReflectGetOwnPropertyDescriptor(src\x2C key) });\n    }\n  });\n};\n\n/**\n * @type {typeof primordials.makeSafe}\n */\nconst makeSafe = (unsafe\x2C safe) => {\n  if (SymbolIterator in unsafe.prototype) {\n    const dummy = new unsafe();\n    let next; // We can reuse the same `next` method.\n\n    ArrayPrototypeForEach(ReflectOwnKeys(unsafe.prototype)\x2C (key) => {\n      if (!ReflectGetOwnPropertyDescriptor(safe.prototype\x2C key)) {\n        const desc = ReflectGetOwnPropertyDescriptor(unsafe.prototype\x2C key);\n        if (\n          typeof desc.value === 'function' &&\n          desc.value.length === 0 &&\n          SymbolIterator in (FunctionPrototypeCall(desc.value\x2C dummy) ?? {})\n        ) {\n          const createIterator = uncurryThis(desc.value);\n          next ??= uncurryThis(createIterator(dummy).next);\n          const SafeIterator = createSafeIterator(createIterator\x2C next);\n          desc.value = function() {\n            return new SafeIterator(this);\n          };\n        }\n        ReflectDefineProperty(safe.prototype\x2C key\x2C { __proto__: null\x2C ...desc });\n      }\n    });\n  } else {\n    copyProps(unsafe.prototype\x2C safe.prototype);\n  }\n  copyProps(unsafe\x2C safe);\n\n  ObjectSetPrototypeOf(safe.prototype\x2C null);\n  ObjectFreeze(safe.prototype);\n  ObjectFreeze(safe);\n  return safe;\n};\nprimordials.makeSafe = makeSafe;\n\n// Subclass the constructors because we need to use their prototype\n// methods later.\n// Defining the `constructor` is necessary here to avoid the default\n// constructor which uses the user-mutable `%ArrayIteratorPrototype%.next`.\nprimordials.SafeMap = makeSafe(\n  Map\x2C\n  class SafeMap extends Map {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\x2C\n);\nprimordials.SafeWeakMap = makeSafe(\n  WeakMap\x2C\n  class SafeWeakMap extends WeakMap {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\x2C\n);\n\nprimordials.SafeSet = makeSafe(\n  Set\x2C\n  class SafeSet extends Set {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\x2C\n);\nprimordials.SafeWeakSet = makeSafe(\n  WeakSet\x2C\n  class SafeWeakSet extends WeakSet {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\x2C\n);\n\nprimordials.SafeFinalizationRegistry = makeSafe(\n  FinalizationRegistry\x2C\n  class SafeFinalizationRegistry extends FinalizationRegistry {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(cleanupCallback) { super(cleanupCallback); }\n  }\x2C\n);\nprimordials.SafeWeakRef = makeSafe(\n  WeakRef\x2C\n  class SafeWeakRef extends WeakRef {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(target) { super(target); }\n  }\x2C\n);\n\nconst SafePromise = makeSafe(\n  Promise\x2C\n  class SafePromise extends Promise {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(executor) { super(executor); }\n  }\x2C\n);\n\n/**\n * Attaches a callback that is invoked when the Promise is settled (fulfilled or\n * rejected). The resolved value cannot be modified from the callback.\n * Prefer using async functions when possible.\n * @param {Promise<any>} thisPromise\n * @param {() => void) | undefined | null} onFinally The callback to execute\n *        when the Promise is settled (fulfilled or rejected).\n * @returns {Promise} A Promise for the completion of the callback.\n */\nprimordials.SafePromisePrototypeFinally = (thisPromise\x2C onFinally) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    new SafePromise((a\x2C b) => PromisePrototypeThen(thisPromise\x2C a\x2C b))\n      .finally(onFinally)\n      .then(a\x2C b)\x2C\n  );\n\nprimordials.AsyncIteratorPrototype =\n  primordials.ReflectGetPrototypeOf(\n    primordials.ReflectGetPrototypeOf(\n      async function* () {}).prototype);\n\nconst arrayToSafePromiseIterable = (promises\x2C mapFn) =>\n  new primordials.SafeArrayIterator(\n    ArrayPrototypeMap(\n      promises\x2C\n      (promise\x2C i) =>\n        new SafePromise((a\x2C b) => PromisePrototypeThen(mapFn == null ? promise : mapFn(promise\x2C i)\x2C a\x2C b))\x2C\n    )\x2C\n  );\n\n/**\n * @template T\x2CU\n * @param {Array<T | PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<Awaited<U>[]>}\n */\nprimordials.SafePromiseAll = (promises\x2C mapFn) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    SafePromise.all(arrayToSafePromiseIterable(promises\x2C mapFn)).then(a\x2C b)\x2C\n  );\n\n/**\n * Should only be used for internal functions\x2C this would produce similar\n * results as `Promise.all` but without prototype pollution\x2C and the return\n * value is not a genuine Array but an array-like object.\n * @template T\x2CU\n * @param {ArrayLike<T | PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<ArrayLike<Awaited<U>>>}\n */\nprimordials.SafePromiseAllReturnArrayLike = (promises\x2C mapFn) =>\n  new Promise((resolve\x2C reject) => {\n    const { length } = promises;\n\n    const returnVal = ArrayConstructor(length);\n    ObjectSetPrototypeOf(returnVal\x2C null);\n    if (length === 0) resolve(returnVal);\n\n    let pendingPromises = length;\n    for (let i = 0; i < length; i++) {\n      const promise = mapFn != null ? mapFn(promises[i]\x2C i) : promises[i];\n      PromisePrototypeThen(PromiseResolve(promise)\x2C (result) => {\n        returnVal[i] = result;\n        if (--pendingPromises === 0) resolve(returnVal);\n      }\x2C reject);\n    }\n  });\n\n/**\n * Should only be used when we only care about waiting for all the promises to\n * resolve\x2C not what value they resolve to.\n * @template T\x2CU\n * @param {ArrayLike<T | PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<void>}\n */\nprimordials.SafePromiseAllReturnVoid = (promises\x2C mapFn) =>\n  new Promise((resolve\x2C reject) => {\n    let pendingPromises = promises.length;\n    if (pendingPromises === 0) resolve();\n    for (let i = 0; i < promises.length; i++) {\n      const promise = mapFn != null ? mapFn(promises[i]\x2C i) : promises[i];\n      PromisePrototypeThen(PromiseResolve(promise)\x2C () => {\n        if (--pendingPromises === 0) resolve();\n      }\x2C reject);\n    }\n  });\n\n/**\n * @template T\x2CU\n * @param {Array<T|PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<PromiseSettledResult<any>[]>}\n */\nprimordials.SafePromiseAllSettled = (promises\x2C mapFn) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    SafePromise.allSettled(arrayToSafePromiseIterable(promises\x2C mapFn)).then(a\x2C b)\x2C\n  );\n\n/**\n * Should only be used when we only care about waiting for all the promises to\n * settle\x2C not what value they resolve or reject to.\n * @template T\x2CU\n * @param {ArrayLike<T|PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<void>}\n */\nprimordials.SafePromiseAllSettledReturnVoid = async (promises\x2C mapFn) => {\n  await primordials.SafePromiseAllSettled(promises\x2C mapFn);\n};\n\n/**\n * @template T\x2CU\n * @param {Array<T|PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<Awaited<U>>}\n */\nprimordials.SafePromiseAny = (promises\x2C mapFn) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    SafePromise.any(arrayToSafePromiseIterable(promises\x2C mapFn)).then(a\x2C b)\x2C\n  );\n\n/**\n * @template T\x2CU\n * @param {Array<T|PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<Awaited<U>>}\n */\nprimordials.SafePromiseRace = (promises\x2C mapFn) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    SafePromise.race(arrayToSafePromiseIterable(promises\x2C mapFn)).then(a\x2C b)\x2C\n  );\n\n\nconst {\n  exec: OriginalRegExpPrototypeExec\x2C\n  [SymbolMatch]: OriginalRegExpPrototypeSymbolMatch\x2C\n  [SymbolMatchAll]: OriginalRegExpPrototypeSymbolMatchAll\x2C\n  [SymbolReplace]: OriginalRegExpPrototypeSymbolReplace\x2C\n  [SymbolSearch]: OriginalRegExpPrototypeSymbolSearch\x2C\n  [SymbolSplit]: OriginalRegExpPrototypeSymbolSplit\x2C\n} = RegExpPrototype;\n\nclass RegExpLikeForStringSplitting {\n  #regex;\n  constructor() {\n    this.#regex = ReflectConstruct(RegExp\x2C arguments);\n  }\n\n  get lastIndex() {\n    return ReflectGet(this.#regex\x2C 'lastIndex');\n  }\n  set lastIndex(value) {\n    ReflectSet(this.#regex\x2C 'lastIndex'\x2C value);\n  }\n\n  exec() {\n    return ReflectApply(OriginalRegExpPrototypeExec\x2C this.#regex\x2C arguments);\n  }\n}\nObjectSetPrototypeOf(RegExpLikeForStringSplitting.prototype\x2C null);\n\n/**\n * @param {RegExp} pattern\n * @returns {RegExp}\n */\nprimordials.hardenRegExp = function hardenRegExp(pattern) {\n  ObjectDefineProperties(pattern\x2C {\n    [SymbolMatch]: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: OriginalRegExpPrototypeSymbolMatch\x2C\n    }\x2C\n    [SymbolMatchAll]: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: OriginalRegExpPrototypeSymbolMatchAll\x2C\n    }\x2C\n    [SymbolReplace]: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: OriginalRegExpPrototypeSymbolReplace\x2C\n    }\x2C\n    [SymbolSearch]: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: OriginalRegExpPrototypeSymbolSearch\x2C\n    }\x2C\n    [SymbolSplit]: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: OriginalRegExpPrototypeSymbolSplit\x2C\n    }\x2C\n    constructor: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: {\n        [SymbolSpecies]: RegExpLikeForStringSplitting\x2C\n      }\x2C\n    }\x2C\n    dotAll: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetDotAll(pattern)\x2C\n    }\x2C\n    exec: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: OriginalRegExpPrototypeExec\x2C\n    }\x2C\n    global: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetGlobal(pattern)\x2C\n    }\x2C\n    hasIndices: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetHasIndices(pattern)\x2C\n    }\x2C\n    ignoreCase: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetIgnoreCase(pattern)\x2C\n    }\x2C\n    multiline: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetMultiline(pattern)\x2C\n    }\x2C\n    source: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetSource(pattern)\x2C\n    }\x2C\n    sticky: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetSticky(pattern)\x2C\n    }\x2C\n    unicode: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetUnicode(pattern)\x2C\n    }\x2C\n  });\n  ObjectDefineProperty(pattern\x2C 'flags'\x2C {\n    __proto__: null\x2C\n    configurable: true\x2C\n    value: RegExpPrototypeGetFlags(pattern)\x2C\n  });\n  return pattern;\n};\n\n\n/**\n * @param {string} str\n * @param {RegExp} regexp\n * @returns {number}\n */\nprimordials.SafeStringPrototypeSearch = (str\x2C regexp) => {\n  regexp.lastIndex = 0;\n  const match = RegExpPrototypeExec(regexp\x2C str);\n  return match ? match.index : -1;\n};\n\nObjectSetPrototypeOf(primordials\x2C null);\nObjectFreeze(primordials);\n
code-source-info,0x1fa4d1d63240,12,10896,10955,C0O10913C7O10920C12O10943,,
code-creation,LazyCompile,10,110459,0x1fa4d1d64a60,19,canBeRequiredWithoutScheme node:internal/bootstrap/loaders:256:36,0x41ccf058e28,~
code-source-info,0x1fa4d1d64a60,15,7825,7876,C0O7836C7O7864C12O7864C18O7872,,
tick,0x195a84cd8,110750,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x2b3d46ce6b2c,0x41ccf0590b7,0x1100482ec,0x2b3d46ce1b01,0x41ccf0590b7,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
tick,0x195a4df24,110792,1,0x100b1d1ec,3,0x0,0x41ccf059096,0x1100482ec,0x2b3d46ce6b2c,0x41ccf0590b7,0x1100482ec,0x2b3d46ce1b01,0x41ccf0590b7,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
tick,0x1959e93e8,110792,0,0x0,3,0x0,0x2b3d46ce1bb1,0x41ccf0590b7,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
tick,0x100b1e3ec,110792,0,0x0,0,0x0,0x2b3d46ce1c49,0x41ccf0590b7,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
code-creation,Function,11,110917,0x110049640,28680, node:internal/modules/cjs/loader:1:1,0x2b3d46cdf2f8,^
code-source-info,0x110049640,465,0,45391,,,
code-creation,Function,11,111167,0x1100506c0,512,getCLIOptionsFromBinding node:internal/options:18:34,0x25dc1a859a78,^
code-source-info,0x1100506c0,88,497,598,,,
code-creation,Function,11,111167,0x110050920,1456,compileForInternalLoader node:internal/bootstrap/loaders:320:27,0x41ccf058fe0,^
code-source-info,0x110050920,15,10162,10960,,,
code-creation,Function,11,111209,0x110050f40,656,internalBinding node:internal/bootstrap/loaders:173:45,0x41ccf058910,^
code-source-info,0x110050f40,15,5306,5544,,,
code-creation,Function,11,111209,0x110051240,320,protoGetter node:net:845:21,0x30e76772f448,^
code-source-info,0x110051240,458,22355,22517,,,
code-creation,Function,11,111375,0x1100513e0,1480,deprecate node:internal/util:112:19,0x1012a39464e8,^
script-source,21,node:internal/util,'use strict';\n\nconst {\n  ArrayBufferPrototypeGetByteLength\x2C\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  Error\x2C\n  FunctionPrototypeCall\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectFreeze\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ObjectValues\x2C\n  Promise\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeGetDotAll\x2C\n  RegExpPrototypeGetGlobal\x2C\n  RegExpPrototypeGetHasIndices\x2C\n  RegExpPrototypeGetIgnoreCase\x2C\n  RegExpPrototypeGetMultiline\x2C\n  RegExpPrototypeGetSticky\x2C\n  RegExpPrototypeGetUnicode\x2C\n  RegExpPrototypeGetSource\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  SafeWeakMap\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolReplace\x2C\n  SymbolSplit\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_NO_CRYPTO\x2C\n    ERR_UNKNOWN_SIGNAL\x2C\n  }\x2C\n  uvErrmapGet\x2C\n  overrideStackTrace\x2C\n} = require('internal/errors');\nconst { signals } = internalBinding('constants').os;\nconst {\n  isArrayBufferDetached: _isArrayBufferDetached\x2C\n  privateSymbols: {\n    arrow_message_private_symbol\x2C\n    decorated_private_symbol\x2C\n  }\x2C\n  sleep: _sleep\x2C\n  toUSVString: _toUSVString\x2C\n} = internalBinding('util');\nconst { isNativeError } = internalBinding('types');\n\nconst noCrypto = !process.versions.openssl;\n\nconst experimentalWarnings = new SafeSet();\n\nconst colorRegExp = /\\u001b\\[\\d\\d?m/g; // eslint-disable-line no-control-regex\n\nconst unpairedSurrogateRe =\n  /(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])/;\nfunction toUSVString(val) {\n  const str = `${val}`;\n  // As of V8 5.5\x2C `str.search()` (and `unpairedSurrogateRe[@@search]()`) are\n  // slower than `unpairedSurrogateRe.exec()`.\n  const match = RegExpPrototypeExec(unpairedSurrogateRe\x2C str);\n  if (!match)\n    return str;\n  return _toUSVString(str\x2C match.index);\n}\n\nlet uvBinding;\n\nfunction lazyUv() {\n  uvBinding ??= internalBinding('uv');\n  return uvBinding;\n}\n\nfunction removeColors(str) {\n  return StringPrototypeReplace(str\x2C colorRegExp\x2C '');\n}\n\nfunction isError(e) {\n  // An error could be an instance of Error while not being a native error\n  // or could be from a different realm and not be instance of Error but still\n  // be a native error.\n  return isNativeError(e) || e instanceof Error;\n}\n\n// Keep a list of deprecation codes that have been warned on so we only warn on\n// each one once.\nconst codesWarned = new SafeSet();\n\nlet validateString;\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set\x2C then it is a no-op.\nfunction deprecate(fn\x2C msg\x2C code) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Lazy-load to avoid a circular dependency.\n  if (validateString === undefined)\n    ({ validateString } = require('internal/validators'));\n\n  if (code !== undefined)\n    validateString(code\x2C 'code');\n\n  let warned = false;\n  function deprecated(...args) {\n    if (!warned) {\n      warned = true;\n      if (code !== undefined) {\n        if (!codesWarned.has(code)) {\n          process.emitWarning(msg\x2C 'DeprecationWarning'\x2C code\x2C deprecated);\n          codesWarned.add(code);\n        }\n      } else {\n        process.emitWarning(msg\x2C 'DeprecationWarning'\x2C deprecated);\n      }\n    }\n    if (new.target) {\n      return ReflectConstruct(fn\x2C args\x2C new.target);\n    }\n    return ReflectApply(fn\x2C this\x2C args);\n  }\n\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  ObjectSetPrototypeOf(deprecated\x2C fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype\x2C as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nfunction decorateErrorStack(err) {\n  if (!(isError(err) && err.stack) || err[decorated_private_symbol])\n    return;\n\n  const arrow = err[arrow_message_private_symbol];\n\n  if (arrow) {\n    err.stack = arrow + err.stack;\n    err[decorated_private_symbol] = true;\n  }\n}\n\nfunction assertCrypto() {\n  if (noCrypto)\n    throw new ERR_NO_CRYPTO();\n}\n\n// Return undefined if there is no match.\n// Move the "slow cases" to a separate function to make sure this function gets\n// inlined properly. That prioritizes the common case.\nfunction normalizeEncoding(enc) {\n  if (enc == null || enc === 'utf8' || enc === 'utf-8') return 'utf8';\n  return slowCases(enc);\n}\n\nfunction slowCases(enc) {\n  switch (enc.length) {\n    case 4:\n      if (enc === 'UTF8') return 'utf8';\n      if (enc === 'ucs2' || enc === 'UCS2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf8') return 'utf8';\n      if (enc === 'ucs2') return 'utf16le';\n      break;\n    case 3:\n      if (enc === 'hex' || enc === 'HEX' ||\n          `${enc}`.toLowerCase() === 'hex')\n        return 'hex';\n      break;\n    case 5:\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      if (enc === 'UTF-8') return 'utf8';\n      if (enc === 'ASCII') return 'ascii';\n      if (enc === 'UCS-2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf-8') return 'utf8';\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      break;\n    case 6:\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      if (enc === 'BASE64') return 'base64';\n      if (enc === 'LATIN1' || enc === 'BINARY') return 'latin1';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      break;\n    case 7:\n      if (enc === 'utf16le' || enc === 'UTF16LE' ||\n          `${enc}`.toLowerCase() === 'utf16le')\n        return 'utf16le';\n      break;\n    case 8:\n      if (enc === 'utf-16le' || enc === 'UTF-16LE' ||\n        `${enc}`.toLowerCase() === 'utf-16le')\n        return 'utf16le';\n      break;\n    case 9:\n      if (enc === 'base64url' || enc === 'BASE64URL' ||\n          `${enc}`.toLowerCase() === 'base64url')\n        return 'base64url';\n      break;\n    default:\n      if (enc === '') return 'utf8';\n  }\n}\n\nfunction emitExperimentalWarning(feature) {\n  if (experimentalWarnings.has(feature)) return;\n  const msg = `${feature} is an experimental feature and might change at any time`;\n  experimentalWarnings.add(feature);\n  process.emitWarning(msg\x2C 'ExperimentalWarning');\n}\n\nfunction filterDuplicateStrings(items\x2C low) {\n  const map = new SafeMap();\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const key = StringPrototypeToLowerCase(item);\n    if (low) {\n      map.set(key\x2C key);\n    } else {\n      map.set(key\x2C item);\n    }\n  }\n  return ArrayPrototypeSort(ArrayFrom(map.values()));\n}\n\nfunction cachedResult(fn) {\n  let result;\n  return () => {\n    if (result === undefined)\n      result = fn();\n    return ArrayPrototypeSlice(result);\n  };\n}\n\n// Useful for Wrapping an ES6 Class with a constructor Function that\n// does not require the new keyword. For instance:\n//   class A { constructor(x) {this.x = x;}}\n//   const B = createClassWrapper(A);\n//   B() instanceof A // true\n//   B() instanceof B // true\nfunction createClassWrapper(type) {\n  function fn(...args) {\n    return ReflectConstruct(type\x2C args\x2C new.target || type);\n  }\n  // Mask the wrapper function name and length values\n  ObjectDefineProperties(fn\x2C {\n    name: { __proto__: null\x2C value: type.name }\x2C\n    length: { __proto__: null\x2C value: type.length }\x2C\n  });\n  ObjectSetPrototypeOf(fn\x2C type);\n  fn.prototype = type.prototype;\n  return fn;\n}\n\nlet signalsToNamesMapping;\nfunction getSignalsToNamesMapping() {\n  if (signalsToNamesMapping !== undefined)\n    return signalsToNamesMapping;\n\n  signalsToNamesMapping = ObjectCreate(null);\n  for (const key in signals) {\n    signalsToNamesMapping[signals[key]] = key;\n  }\n\n  return signalsToNamesMapping;\n}\n\nfunction convertToValidSignal(signal) {\n  if (typeof signal === 'number' && getSignalsToNamesMapping()[signal])\n    return signal;\n\n  if (typeof signal === 'string') {\n    const signalName = signals[StringPrototypeToUpperCase(signal)];\n    if (signalName) return signalName;\n  }\n\n  throw new ERR_UNKNOWN_SIGNAL(signal);\n}\n\nfunction getConstructorOf(obj) {\n  while (obj) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '') {\n      return descriptor.value;\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n  }\n\n  return null;\n}\n\nfunction getSystemErrorName(err) {\n  const entry = uvErrmapGet(err);\n  return entry ? entry[0] : `Unknown system error ${err}`;\n}\n\nfunction getSystemErrorMap() {\n  return lazyUv().getErrorMap();\n}\n\nconst kCustomPromisifiedSymbol = SymbolFor('nodejs.util.promisify.custom');\nconst kCustomPromisifyArgsSymbol = Symbol('customPromisifyArgs');\n\nlet validateFunction;\n\nfunction promisify(original) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateFunction === undefined)\n    ({ validateFunction } = require('internal/validators'));\n\n  validateFunction(original\x2C 'original');\n\n  if (original[kCustomPromisifiedSymbol]) {\n    const fn = original[kCustomPromisifiedSymbol];\n\n    validateFunction(fn\x2C 'util.promisify.custom');\n\n    return ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n      __proto__: null\x2C\n      value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\x2C\n    });\n  }\n\n  // Names to create an object from in case the callback receives multiple\n  // arguments\x2C e.g. ['bytesRead'\x2C 'buffer'] for fs.read.\n  const argumentNames = original[kCustomPromisifyArgsSymbol];\n\n  function fn(...args) {\n    return new Promise((resolve\x2C reject) => {\n      ArrayPrototypePush(args\x2C (err\x2C ...values) => {\n        if (err) {\n          return reject(err);\n        }\n        if (argumentNames !== undefined && values.length > 1) {\n          const obj = {};\n          for (let i = 0; i < argumentNames.length; i++)\n            obj[argumentNames[i]] = values[i];\n          resolve(obj);\n        } else {\n          resolve(values[0]);\n        }\n      });\n      ReflectApply(original\x2C this\x2C args);\n    });\n  }\n\n  ObjectSetPrototypeOf(fn\x2C ObjectGetPrototypeOf(original));\n\n  ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n    __proto__: null\x2C\n    value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\x2C\n  });\n\n  const descriptors = ObjectGetOwnPropertyDescriptors(original);\n  const propertiesValues = ObjectValues(descriptors);\n  for (let i = 0; i < propertiesValues.length; i++) {\n    // We want to use null-prototype objects to not rely on globally mutable\n    // %Object.prototype%.\n    ObjectSetPrototypeOf(propertiesValues[i]\x2C null);\n  }\n  return ObjectDefineProperties(fn\x2C descriptors);\n}\n\npromisify.custom = kCustomPromisifiedSymbol;\n\n// The built-in Array#join is slower in v8 6.0\nfunction join(output\x2C separator) {\n  let str = '';\n  if (output.length !== 0) {\n    const lastIndex = output.length - 1;\n    for (let i = 0; i < lastIndex; i++) {\n      // It is faster not to use a template string here\n      str += output[i];\n      str += separator;\n    }\n    str += output[lastIndex];\n  }\n  return str;\n}\n\n// As of V8 6.6\x2C depending on the size of the array\x2C this is anywhere\n// between 1.5-10x faster than the two-arg version of Array#splice()\nfunction spliceOne(list\x2C index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nconst kNodeModulesRE = /^(.*)[\\\\/]node_modules[\\\\/]/;\n\nlet getStructuredStack;\n\nfunction isInsideNodeModules() {\n  if (getStructuredStack === undefined) {\n    // Lazy-load to avoid a circular dependency.\n    const { runInNewContext } = require('vm');\n    // Use `runInNewContext()` to get something tamper-proof and\n    // side-effect-free. Since this is currently only used for a deprecated API\x2C\n    // the perf implications should be okay.\n    getStructuredStack = runInNewContext(`(function() {\n      try { Error.stackTraceLimit = Infinity; } catch {}\n      return function structuredStack() {\n        const e = new Error();\n        overrideStackTrace.set(e\x2C (err\x2C trace) => trace);\n        return e.stack;\n      };\n    })()`\x2C { overrideStackTrace }\x2C { filename: 'structured-stack' });\n  }\n\n  const stack = getStructuredStack();\n\n  // Iterate over all stack frames and look for the first one not coming\n  // from inside Node.js itself:\n  if (ArrayIsArray(stack)) {\n    for (const frame of stack) {\n      const filename = frame.getFileName();\n      // If a filename does not start with / or contain \\\x2C\n      // it's likely from Node.js core.\n      if (RegExpPrototypeExec(/^\\/|\\\\/\x2C filename) === null)\n        continue;\n      return RegExpPrototypeExec(kNodeModulesRE\x2C filename) !== null;\n    }\n  }\n  return false;\n}\n\nfunction once(callback) {\n  let called = false;\n  return function(...args) {\n    if (called) return;\n    called = true;\n    return ReflectApply(callback\x2C this\x2C args);\n  };\n}\n\nlet validateUint32;\n\nfunction sleep(msec) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateUint32 === undefined)\n    ({ validateUint32 } = require('internal/validators'));\n\n  validateUint32(msec\x2C 'msec');\n  _sleep(msec);\n}\n\nfunction createDeferredPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res\x2C rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise\x2C resolve\x2C reject };\n}\n\n// https://heycam.github.io/webidl/#define-the-operations\nfunction defineOperation(target\x2C name\x2C method) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    __proto__: null\x2C\n    writable: true\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    value: method\x2C\n  });\n}\n\n// https://heycam.github.io/webidl/#es-interfaces\nfunction exposeInterface(target\x2C name\x2C interfaceObject) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    __proto__: null\x2C\n    writable: true\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: interfaceObject\x2C\n  });\n}\n\nlet _DOMException;\nconst lazyDOMExceptionClass = () => {\n  _DOMException ??= internalBinding('messaging').DOMException;\n  return _DOMException;\n};\n\nconst lazyDOMException = hideStackFrames((message\x2C name) => {\n  _DOMException ??= internalBinding('messaging').DOMException;\n  return new _DOMException(message\x2C name);\n});\n\nconst kEnumerableProperty = ObjectCreate(null);\nkEnumerableProperty.enumerable = true;\nObjectFreeze(kEnumerableProperty);\n\nconst kEmptyObject = ObjectFreeze(ObjectCreate(null));\n\nfunction filterOwnProperties(source\x2C keys) {\n  const filtered = ObjectCreate(null);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (ObjectPrototypeHasOwnProperty(source\x2C key)) {\n      filtered[key] = source[key];\n    }\n  }\n\n  return filtered;\n}\n\n/**\n * Mimics `obj[key] = value` but ignoring potential prototype inheritance.\n * @param {any} obj\n * @param {string} key\n * @param {any} value\n * @returns {any}\n */\nfunction setOwnProperty(obj\x2C key\x2C value) {\n  return ObjectDefineProperty(obj\x2C key\x2C {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    value\x2C\n    writable: true\x2C\n  });\n}\n\nlet internalGlobal;\nfunction getInternalGlobal() {\n  if (internalGlobal == null) {\n    // Lazy-load to avoid a circular dependency.\n    const { runInNewContext } = require('vm');\n    internalGlobal = runInNewContext('this'\x2C undefined\x2C { contextName: 'internal' });\n  }\n  return internalGlobal;\n}\n\nfunction SideEffectFreeRegExpPrototypeExec(regex\x2C string) {\n  const { RegExp: RegExpFromAnotherRealm } = getInternalGlobal();\n  return FunctionPrototypeCall(RegExpFromAnotherRealm.prototype.exec\x2C regex\x2C string);\n}\n\nconst crossRelmRegexes = new SafeWeakMap();\nfunction getCrossRelmRegex(regex) {\n  const cached = crossRelmRegexes.get(regex);\n  if (cached) return cached;\n\n  let flagString = '';\n  if (RegExpPrototypeGetHasIndices(regex)) flagString += 'd';\n  if (RegExpPrototypeGetGlobal(regex)) flagString += 'g';\n  if (RegExpPrototypeGetIgnoreCase(regex)) flagString += 'i';\n  if (RegExpPrototypeGetMultiline(regex)) flagString += 'm';\n  if (RegExpPrototypeGetDotAll(regex)) flagString += 's';\n  if (RegExpPrototypeGetUnicode(regex)) flagString += 'u';\n  if (RegExpPrototypeGetSticky(regex)) flagString += 'y';\n\n  const { RegExp: RegExpFromAnotherRealm } = getInternalGlobal();\n  const crossRelmRegex = new RegExpFromAnotherRealm(RegExpPrototypeGetSource(regex)\x2C flagString);\n  crossRelmRegexes.set(regex\x2C crossRelmRegex);\n  return crossRelmRegex;\n}\n\nfunction SideEffectFreeRegExpPrototypeSymbolReplace(regex\x2C string\x2C replacement) {\n  return getCrossRelmRegex(regex)[SymbolReplace](string\x2C replacement);\n}\n\nfunction SideEffectFreeRegExpPrototypeSymbolSplit(regex\x2C string\x2C limit = undefined) {\n  return getCrossRelmRegex(regex)[SymbolSplit](string\x2C limit);\n}\n\n\nfunction isArrayBufferDetached(value) {\n  if (ArrayBufferPrototypeGetByteLength(value) === 0) {\n    return _isArrayBufferDetached(value);\n  }\n\n  return false;\n}\n\n// Setup user-facing NODE_V8_COVERAGE environment variable that writes\n// ScriptCoverage objects to a specified directory.\nfunction setupCoverageHooks(dir) {\n  const cwd = require('internal/process/execution').tryGetCwd();\n  const { resolve } = require('path');\n  const coverageDirectory = resolve(cwd\x2C dir);\n  const { sourceMapCacheToObject } =\n    require('internal/source_map/source_map_cache');\n\n  if (process.features.inspector) {\n    internalBinding('profiler').setCoverageDirectory(coverageDirectory);\n    internalBinding('profiler').setSourceMapCacheGetter(sourceMapCacheToObject);\n  } else {\n    process.emitWarning('The inspector is disabled\x2C ' +\n                        'coverage could not be collected'\x2C\n                        'Warning');\n    return '';\n  }\n  return coverageDirectory;\n}\n\nmodule.exports = {\n  assertCrypto\x2C\n  cachedResult\x2C\n  convertToValidSignal\x2C\n  createClassWrapper\x2C\n  createDeferredPromise\x2C\n  decorateErrorStack\x2C\n  defineOperation\x2C\n  deprecate\x2C\n  emitExperimentalWarning\x2C\n  exposeInterface\x2C\n  filterDuplicateStrings\x2C\n  filterOwnProperties\x2C\n  getConstructorOf\x2C\n  getInternalGlobal\x2C\n  getSystemErrorMap\x2C\n  getSystemErrorName\x2C\n  isArrayBufferDetached\x2C\n  isError\x2C\n  isInsideNodeModules\x2C\n  join\x2C\n  lazyDOMException\x2C\n  lazyDOMExceptionClass\x2C\n  normalizeEncoding\x2C\n  once\x2C\n  promisify\x2C\n  SideEffectFreeRegExpPrototypeExec\x2C\n  SideEffectFreeRegExpPrototypeSymbolReplace\x2C\n  SideEffectFreeRegExpPrototypeSymbolSplit\x2C\n  sleep\x2C\n  spliceOne\x2C\n  setupCoverageHooks\x2C\n  toUSVString\x2C\n  removeColors\x2C\n\n  // Symbol used to customize promisify conversion\n  customPromisifyArgs: kCustomPromisifyArgsSymbol\x2C\n\n  // Symbol used to provide a custom inspect function for an object as an\n  // alternative to using 'inspect'\n  customInspectSymbol: SymbolFor('nodejs.util.inspect.custom')\x2C\n\n  // Used by the buffer module to capture an internal reference to the\n  // default isEncoding implementation\x2C just in case userland overrides it.\n  kIsEncodingSymbol: Symbol('kIsEncodingSymbol')\x2C\n  kVmBreakFirstLineSymbol: Symbol('kVmBreakFirstLineSymbol')\x2C\n\n  kEmptyObject\x2C\n  kEnumerableProperty\x2C\n  setOwnProperty\x2C\n};\n
code-source-info,0x1100513e0,21,2775,3951,,,
code-creation,Function,11,112709,0x110051a20,312,SafeMap node:internal/per_context/primordials:407:16,0x41ccf052a58,^
code-source-info,0x110051a20,12,11624,11641,,,
code-creation,Function,11,112750,0x110051bc0,136,next node:internal/per_context/primordials:329:9,0x41ccf051eb0,^
code-source-info,0x110051bc0,12,9228,9273,,,
code-creation,Function,11,112750,0x110051cc0,232,canBeRequiredWithoutScheme node:internal/bootstrap/loaders:256:36,0x41ccf058e28,^
code-source-info,0x110051cc0,15,7825,7876,,,
code-creation,LazyCompile,10,112792,0x1fa4d1d6a190,32, node:internal/modules/cjs/loader:255:41,0x2b3d46cdfcd0,~
code-source-info,0x1fa4d1d6a190,465,7589,7615,C0O7597C9O7598C21O7610C31O7615,,
code-creation,LazyCompile,10,112875,0x1fa4d1d6a330,19,getSchemeOnlyModuleNames node:internal/bootstrap/loaders:260:34,0x41ccf058e78,~
code-source-info,0x1fa4d1d6a330,15,7911,7962,C0O7920C11O7937C14O7927C18O7958,,
code-creation,LazyCompile,10,112917,0x1fa4d1d6a4a8,26, node:internal/modules/cjs/loader:257:50,0x2b3d46cdfd20,~
code-source-info,0x1fa4d1d6a4a8,465,7670,7717,C0O7695C5O7695C15O7707C20O7695C25O7717,,
code-creation,LazyCompile,10,113000,0x1fa4d1d6ac28,28,getEmbedderOptions node:internal/options:32:28,0x25dc1a859bf0,~
code-source-info,0x1fa4d1d6ac28,88,760,877,C0O767C6O795C11O813C17O811C23O852C27O875,,
code-creation,LazyCompile,10,113084,0x1fa4d1d6aed0,315,Module._initPaths node:internal/modules/cjs/loader:1384:29,0x2b3d46ce08d0,~
code-source-info,0x1fa4d1d6aed0,465,43416,44373,C0O43439C9O43459C14O43463C22O43477C28O43477C33O43516C42O43536C47O43540C55O43552C61O43552C66O43747C74O43763C77O43768C85O43784C93O43768C103O43806C106O43811C114O43827C125O43811C131O43867C140O43868C143O43873C157O43873C169O43912C173O43931C180O43960C183O43965C191O43965C198O43931C203O44007C210O44036C213O44041C221O44041C228O44007C233O44084C237O44104C244O44138C249O44166C254O44197C257O44202C262O44166C270O44220C273O44138C279O44104C284O44244C286O44256C292O44317C297O44338C302O44358C305O44338C309O44336C314O44372,,
code-creation,Eval,10,113167,0x1fa4d1d6b5a0,5, node:internal/modules/run_main:1:1,0x1fa4d1d6b378,~
script-source,489,node:internal/modules/run_main,'use strict';\n\nconst {\n  ObjectCreate\x2C\n  StringPrototypeEndsWith\x2C\n} = primordials;\nconst CJSLoader = require('internal/modules/cjs/loader');\nconst { Module\x2C toRealPath\x2C readPackageScope } = CJSLoader;\nconst { getOptionValue } = require('internal/options');\nconst path = require('path');\nconst {\n  handleProcessExit\x2C\n} = require('internal/modules/esm/handle_process_exit');\n\nfunction resolveMainPath(main) {\n  // Note extension resolution for the main entry point can be deprecated in a\n  // future major.\n  // Module._findPath is monkey-patchable here.\n  let mainPath = Module._findPath(path.resolve(main)\x2C null\x2C true);\n  if (!mainPath)\n    return;\n\n  const preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\n  if (!preserveSymlinksMain)\n    mainPath = toRealPath(mainPath);\n\n  return mainPath;\n}\n\nfunction shouldUseESMLoader(mainPath) {\n  /**\n   * @type {string[]} userLoaders A list of custom loaders registered by the user\n   * (or an empty list when none have been registered).\n   */\n  const userLoaders = getOptionValue('--experimental-loader');\n  if (userLoaders.length > 0)\n    return true;\n  const esModuleSpecifierResolution =\n    getOptionValue('--experimental-specifier-resolution');\n  if (esModuleSpecifierResolution === 'node')\n    return true;\n  // Determine the module format of the main\n  if (mainPath && StringPrototypeEndsWith(mainPath\x2C '.mjs'))\n    return true;\n  if (!mainPath || StringPrototypeEndsWith(mainPath\x2C '.cjs'))\n    return false;\n  const pkg = readPackageScope(mainPath);\n  return pkg && pkg.data.type === 'module';\n}\n\nfunction runMainESM(mainPath) {\n  const { loadESM } = require('internal/process/esm_loader');\n  const { pathToFileURL } = require('internal/url');\n\n  handleMainPromise(loadESM((esmLoader) => {\n    const main = path.isAbsolute(mainPath) ?\n      pathToFileURL(mainPath).href : mainPath;\n    return esmLoader.import(main\x2C undefined\x2C ObjectCreate(null));\n  }));\n}\n\nasync function handleMainPromise(promise) {\n  process.on('exit'\x2C handleProcessExit);\n  try {\n    return await promise;\n  } finally {\n    process.off('exit'\x2C handleProcessExit);\n  }\n}\n\n// For backwards compatibility\x2C we have to run a bunch of\n// monkey-patchable code that belongs to the CJS loader (exposed by\n// `require('module')`) even when the entry point is ESM.\nfunction executeUserEntryPoint(main = process.argv[1]) {\n  const resolvedMain = resolveMainPath(main);\n  const useESMLoader = shouldUseESMLoader(resolvedMain);\n  if (useESMLoader) {\n    runMainESM(resolvedMain || main);\n  } else {\n    // Module._load is the monkey-patchable CJS module loader.\n    Module._load(main\x2C null\x2C true);\n  }\n}\n\nmodule.exports = {\n  executeUserEntryPoint\x2C\n  handleMainPromise\x2C\n};\n
code-source-info,0x1fa4d1d6b5a0,489,0,2700,C0O0C4O2700,,
code-creation,Function,10,113334,0x1fa4d1d6b888,178, node:internal/modules/run_main:1:1,0x1fa4d1d6b518,~
code-source-info,0x1fa4d1d6b888,489,0,2700,C0O0C66O25C72O41C78O101C84O101C89O149C95O157C101O169C107O228C113O228C118O209C124O270C130O270C134O270C136O320C142O320C147O297C153O2632C160O2653C166O2678C172O2647C177O2699,,
code-creation,LazyCompile,10,113375,0x1fa4d1d6bea0,163,initializeESMLoader node:internal/process/pre_execution:544:29,0x202f02877c30,~
code-source-info,0x1fa4d1d6bea0,447,17124,18213,C0O17206C6O17206C13O17255C16O17251C21O17249C25O17273C30O17277C34O17297C40O17326C41O17333C42O17434C48O17434C53O17349C58O17389C63O17480C69O17480C74O17681C79O17639C83O17751C88O17712C92O17917C100O17921C106O18037C112O18037C117O17986C122O17994C127O18012C132O18083C138O18083C143O18102C145O18112C149O18126C151O18146C155O18170C157O18189C162O18212,,
code-creation,LazyCompile,10,113417,0x1fa4d1d6c0b8,5,get hasLoadedAnyUserCJSModule node:internal/modules/cjs/loader:75:32,0x2b3d46cdfbe0,~
code-source-info,0x1fa4d1d6c0b8,465,2319,2359,C0O2324C4O2357,,
code-creation,LazyCompile,10,113459,0x1fa4d1d6c1a0,53,loadPreloadModules node:internal/process/pre_execution:589:28,0x202f02877d20,~
code-source-info,0x1fa4d1d6c1a0,447,18790,19111,C0O18877C8O18877C13O18908C15O18945C21O18952C26O19029C32O19029C37O19029C42O18995C47O19073C52O19110,,
code-creation,LazyCompile,10,113500,0x1fa4d1d6c388,50,initializeFrozenIntrinsics node:internal/process/pre_execution:581:36,0x202f02877cd0,~
code-source-info,0x1fa4d1d6c388,447,18539,18761,C0O18546C8O18550C14O18595C17O18603C28O18603C34O18715C40O18715C45O18752C49O18760,,
code-creation,LazyCompile,10,113500,0x1fa4d1d6c4b0,22,markBootstrapComplete node:internal/process/pre_execution:602:31,0x202f02877d70,~
code-source-info,0x1fa4d1d6c4b0,447,19143,19207,C0O19150C6O19150C11O19180C16O19181C21O19206,,
tick,0x195a84ae8,113542,0,0x0,0,0x0,0x2b3d46ce1c49,0x41ccf0590b7,0x1100482ec,0x2b3d46cdc4be,0x2b3d46cdc2b3,0x202f0287b5d8,0x202f02879dd8,0x202f028761e9
code-creation,LazyCompile,10,113542,0x1fa4d1d6c5b0,80,executeUserEntryPoint node:internal/modules/run_main:74:31,0x1fa4d1d6b710,~
code-source-info,0x1fa4d1d6c5b0,489,2325,2630,C7O2341C14O2345C22O2375C25O2375C30O2421C33O2421C38O2457C40O2481C45O2492C50O2481C56O2593C61O2600C73O2600C79O2629,,
code-creation,LazyCompile,10,113584,0x1fa4d1d6ca00,68,resolveMainPath node:internal/modules/run_main:15:25,0x1fa4d1d6b5d0,~
code-source-info,0x1fa4d1d6ca00,489,398,812,C0O570C5O577C12O587C15O592C20O592C30O577C36O622C38O641C39O648C40O681C48O681C53O727C55O758C60O769C65O794C67O810,,
code-creation,LazyCompile,10,113709,0x1fa4d1d6cd70,825,Module._findPath node:internal/modules/cjs/loader:584:28,0x2b3d46ce00e0,~
code-source-info,0x1fa4d1d6cd70,465,16872,20768,C0O16925C6O16930C11O16930C17O16953C19O16980C27O17003C31O17023C37O17030C42O17043C43O17056C44O17081C46O17089C52O17100C60O17100C65O17098C69O17151C72O17158C79O17168C83O17182C85O17197C87O17210C88O17218C90O17256C96O17263C103O17275C106O17318C110O17325C115O17275C123O17334C125O17330C132O17364C135O17407C139O17414C144O17364C152O17423C154O17419C159O17459C166O17466C173O17483C176O17526C180O17533C185O17483C193O17542C195O17538C202O17573C205O17616C209O17623C214O17573C222O17632C224O17628C229O17664C236O17671C243O17690C246O17733C250O17740C255O17690C263O17749C265O17745C269O17817C277O17817C285O17859C287O17855C292O17891C299O17898C306O17913C313O17913C321O17955C323O17951C330O17984C336O17997C343O17997C351O18039C353O18035C360O18070C367O18070C375O18112C377O18108C382O18143C389O18150C396O18167C403O18167C411O18209C413O18205C420O18241C426O18254C433O18254C441O18296C443O18292C447O18345C449O18353C453O18401C459O18406C464O18406C470O18430C479O18434C486O18494C488O18559C490O18572C494O18564C499O18688C501O18693C505O18702C511O18720C515O18731C518O18731C525O18746C530O18751C532O18766C536O18820C539O18820C545O18860C547O18889C549O18912C550O18941C556O18946C561O18946C568O18981C570O19007C575O19007C580O19028C584O19056C585O19063C590O19090C594O19115C600O19151C606O19167C611O19167C619O19217C622O19228C629O19277C635O19891C641O19907C646O19907C654O19953C657O19964C662O20011C666O20082C670O20116C679O20141C685O20123C690O20163C702O20174C708O20232C714O20252C719O20337C723O20369C732O20394C738O20376C743O20414C758O20425C764O20481C768O20503C771O20510C778O20531C782O20549C784O20565C785O20596C790O20606C794O20638C799O20638C804O20691C807O20691C812O18581C817O18546C823O20753C824O20766,,
code-creation,LazyCompile,10,113750,0x1fa4d1d6d370,45,isAbsolute node:path:1155:13,0x28e4ce8cd170,~
code-source-info,0x1fa4d1d6d370,74,35491,35637,C0O35504C8O35504C13O35550C19O35557C26O35575C31O35575C39O35614C41O35610C44O35633,,
code-creation,LazyCompile,10,113834,0x1fa4d1d6d520,85,stat node:internal/modules/cjs/loader:180:14,0x2b3d46cdf400,~
code-source-info,0x1fa4d1d6d520,465,5297,5694,C0O5312C5O5328C10O5328C17O5358C23O5403C28O5413C33O5413C39O5432C41O5458C43O5472C44O5494C49O5494C54O5526C61O5559C66O5639C71O5649C76O5649C82O5678C84O5692,,
code-creation,LazyCompile,10,113834,0x1fa4d1d6d660,3,toNamespacedPath node:path:1265:19,0x28e4ce8cd260,~
code-source-info,0x1fa4d1d6d660,74,38652,38712,C0O38696C2O38708,,
code-creation,LazyCompile,10,113875,0x1fa4d1d6d750,42,toRealPath node:internal/modules/cjs/loader:478:20,0x2b3d46cdf770,~
code-source-info,0x1fa4d1d6d750,465,13642,13755,C0O13660C5O13670C10O13683C17O13703C20O13714C28O13733C35O13670C41O13753,,
code-creation,LazyCompile,10,114084,0x1fa4d1d6dfc0,1079,realpathSync node:fs:2577:22,0x28e4ce8e7878,~
script-source,76,node:fs,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Maintainers\x2C keep in mind that ES1-style octal literals (`0666`) are not\n// allowed in strict mode. Use ES6-style octal literals instead (`0o666`).\n\n'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  BigIntPrototypeToString\x2C\n  Boolean\x2C\n  MathMax\x2C\n  Number\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  Promise\x2C\n  ReflectApply\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeSlice\x2C\n} = primordials;\n\nconst { fs: constants } = internalBinding('constants');\nconst {\n  S_IFIFO\x2C\n  S_IFLNK\x2C\n  S_IFMT\x2C\n  S_IFREG\x2C\n  S_IFSOCK\x2C\n  F_OK\x2C\n  R_OK\x2C\n  W_OK\x2C\n  X_OK\x2C\n  O_WRONLY\x2C\n  O_SYMLINK\x2C\n} = constants;\n\nconst pathModule = require('path');\nconst { isArrayBufferView } = require('internal/util/types');\n\n// We need to get the statValues from the binding at the callsite since\n// it's re-initialized after deserialization.\n\nconst binding = internalBinding('fs');\nconst { Buffer } = require('buffer');\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_FS_FILE_TOO_LARGE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_FEATURE_UNAVAILABLE_ON_PLATFORM\x2C\n  }\x2C\n  AbortError\x2C\n  uvErrmapGet\x2C\n  uvException\x2C\n} = require('internal/errors');\n\nconst { FSReqCallback } = binding;\nconst { toPathIfFileURL } = require('internal/url');\nconst {\n  customPromisifyArgs: kCustomPromisifyArgsSymbol\x2C\n  deprecate\x2C\n  kEmptyObject\x2C\n  promisify: {\n    custom: kCustomPromisifiedSymbol\x2C\n  }\x2C\n  SideEffectFreeRegExpPrototypeExec\x2C\n} = require('internal/util');\nconst {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n  }\x2C\n  copyObject\x2C\n  Dirent\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirent\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getValidatedFd\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  handleErrorFromBinding\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  Stats\x2C\n  getStatFsFromBinding\x2C\n  getStatsFromBinding\x2C\n  realpathCacheKey\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validatePath\x2C\n  validatePosition\x2C\n  validateRmOptions\x2C\n  validateRmOptionsSync\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  validatePrimitiveStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\x2C\n} = require('internal/fs/utils');\nconst {\n  Dir\x2C\n  opendir\x2C\n  opendirSync\x2C\n} = require('internal/fs/dir');\nconst {\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n} = require('internal/constants');\nconst {\n  isUint32\x2C\n  parseFileMode\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateFunction\x2C\n  validateInteger\x2C\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst watchers = require('internal/fs/watchers');\nconst ReadFileContext = require('internal/fs/read_file_context');\n\nlet truncateWarn = true;\nlet fs;\n\n// Lazy loaded\nlet cpFn;\nlet cpSyncFn;\nlet promises = null;\nlet ReadStream;\nlet WriteStream;\nlet rimraf;\nlet rimrafSync;\n\n// These have to be separate because of how graceful-fs happens to do it's\n// monkeypatching.\nlet FileReadStream;\nlet FileWriteStream;\n\nconst isWindows = process.platform === 'win32';\nconst isOSX = process.platform === 'darwin';\n\n\nconst showStringCoercionDeprecation = deprecate(\n  () => {}\x2C\n  'Implicit coercion of objects with own toString property is deprecated.'\x2C\n  'DEP0162'\x2C\n);\nfunction showTruncateDeprecation() {\n  if (truncateWarn) {\n    process.emitWarning(\n      'Using fs.truncate with a file descriptor is deprecated. Please use ' +\n      'fs.ftruncate with a file descriptor instead.'\x2C\n      'DeprecationWarning'\x2C 'DEP0081');\n    truncateWarn = false;\n  }\n}\n\nfunction maybeCallback(cb) {\n  validateFunction(cb\x2C 'cb');\n\n  return cb;\n}\n\n// Ensure that callbacks run in the global context. Only use this function\n// for callbacks that are passed to the binding layer\x2C callbacks that are\n// invoked from JS already run in the proper scope.\nfunction makeCallback(cb) {\n  validateFunction(cb\x2C 'cb');\n\n  return (...args) => ReflectApply(cb\x2C this\x2C args);\n}\n\n// Special case of `makeCallback()` that is specific to async `*stat()` calls as\n// an optimization\x2C since the data passed back to the callback needs to be\n// transformed anyway.\nfunction makeStatsCallback(cb) {\n  validateFunction(cb\x2C 'cb');\n\n  return (err\x2C stats) => {\n    if (err) return cb(err);\n    cb(err\x2C getStatsFromBinding(stats));\n  };\n}\n\nconst isFd = isUint32;\n\nfunction isFileType(stats\x2C fileType) {\n  // Use stats array directly to avoid creating an fs.Stats instance just for\n  // our internal use.\n  let mode = stats[1];\n  if (typeof mode === 'bigint')\n    mode = Number(mode);\n  return (mode & S_IFMT) === fileType;\n}\n\n/**\n * Tests a user's permissions for the file or directory\n * specified by `path`.\n * @param {string | Buffer | URL} path\n * @param {number} [mode]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction access(path\x2C mode\x2C callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = F_OK;\n  }\n\n  path = getValidatedPath(path);\n  mode = getValidMode(mode\x2C 'access');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\n}\n\n/**\n * Synchronously tests a user's permissions for the file or\n * directory specified by `path`.\n * @param {string | Buffer | URL} path\n * @param {number} [mode]\n * @returns {void}\n */\nfunction accessSync(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = getValidMode(mode\x2C 'access');\n\n  const ctx = { path };\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Tests whether or not the given path exists.\n * @param {string | Buffer | URL} path\n * @param {(exists?: boolean) => any} callback\n * @returns {void}\n */\nfunction exists(path\x2C callback) {\n  maybeCallback(callback);\n\n  function suppressedCallback(err) {\n    callback(err ? false : true);\n  }\n\n  try {\n    fs.access(path\x2C F_OK\x2C suppressedCallback);\n  } catch {\n    return callback(false);\n  }\n}\n\nObjectDefineProperty(exists\x2C kCustomPromisifiedSymbol\x2C {\n  __proto__: null\x2C\n  value: function exists(path) { // eslint-disable-line func-name-matching\n    return new Promise((resolve) => fs.exists(path\x2C resolve));\n  }\x2C\n});\n\n// fs.existsSync never throws\x2C it only returns true or false.\n// Since fs.existsSync never throws\x2C users have established\n// the expectation that passing invalid arguments to it\x2C even like\n// fs.existsSync()\x2C would only get a false in return\x2C so we cannot signal\n// validation errors to users properly out of compatibility concerns.\n// TODO(joyeecheung): deprecate the never-throw-on-invalid-arguments behavior\n/**\n * Synchronously tests whether or not the given path exists.\n * @param {string | Buffer | URL} path\n * @returns {boolean}\n */\nfunction existsSync(path) {\n  try {\n    path = getValidatedPath(path);\n  } catch {\n    return false;\n  }\n  const ctx = { path };\n  const nPath = pathModule.toNamespacedPath(path);\n  binding.access(nPath\x2C F_OK\x2C undefined\x2C ctx);\n\n  // In case of an invalid symlink\x2C `binding.access()` on win32\n  // will **not** return an error and is therefore not enough.\n  // Double check with `binding.stat()`.\n  if (isWindows && ctx.errno === undefined) {\n    binding.stat(nPath\x2C false\x2C undefined\x2C ctx);\n  }\n\n  return ctx.errno === undefined;\n}\n\nfunction readFileAfterOpen(err\x2C fd) {\n  const context = this.context;\n\n  if (err) {\n    context.callback(err);\n    return;\n  }\n\n  context.fd = fd;\n\n  const req = new FSReqCallback();\n  req.oncomplete = readFileAfterStat;\n  req.context = context;\n  binding.fstat(fd\x2C false\x2C req);\n}\n\nfunction readFileAfterStat(err\x2C stats) {\n  const context = this.context;\n\n  if (err)\n    return context.close(err);\n\n  // TODO(BridgeAR): Check if allocating a smaller chunk is better performance\n  // wise\x2C similar to the promise based version (less peak memory and chunked\n  // stringify operations vs multiple C++/JS boundary crossings).\n  const size = context.size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\n\n  if (size > kIoMaxLength) {\n    err = new ERR_FS_FILE_TOO_LARGE(size);\n    return context.close(err);\n  }\n\n  try {\n    if (size === 0) {\n      // TODO(BridgeAR): If an encoding is set\x2C use the StringDecoder to concat\n      // the result and reuse the buffer instead of allocating a new one.\n      context.buffers = [];\n    } else {\n      context.buffer = Buffer.allocUnsafeSlow(size);\n    }\n  } catch (err) {\n    return context.close(err);\n  }\n  context.read();\n}\n\nfunction checkAborted(signal\x2C callback) {\n  if (signal?.aborted) {\n    callback(new AbortError(undefined\x2C { cause: signal?.reason }));\n    return true;\n  }\n  return false;\n}\n\n/**\n * Asynchronously reads the entire contents of a file.\n * @param {string | Buffer | URL | number} path\n * @param {{\n *   encoding?: string | null;\n *   flag?: string;\n *   signal?: AbortSignal;\n *   } | string} [options]\n * @param {(\n *   err?: Error\x2C\n *   data?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction readFile(path\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { flag: 'r' });\n  const context = new ReadFileContext(callback\x2C options.encoding);\n  context.isUserFd = isFd(path); // File descriptor ownership\n\n  if (options.signal) {\n    context.signal = options.signal;\n  }\n  if (context.isUserFd) {\n    process.nextTick(function tick(context) {\n      ReflectApply(readFileAfterOpen\x2C { context }\x2C [null\x2C path]);\n    }\x2C context);\n    return;\n  }\n\n  if (checkAborted(options.signal\x2C callback))\n    return;\n\n  const flagsNumber = stringToFlags(options.flag\x2C 'options.flag');\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.context = context;\n  req.oncomplete = readFileAfterOpen;\n  binding.open(pathModule.toNamespacedPath(path)\x2C\n               flagsNumber\x2C\n               0o666\x2C\n               req);\n}\n\nfunction tryStatSync(fd\x2C isUserFd) {\n  const ctx = {};\n  const stats = binding.fstat(fd\x2C false\x2C undefined\x2C ctx);\n  if (ctx.errno !== undefined && !isUserFd) {\n    fs.closeSync(fd);\n    throw uvException(ctx);\n  }\n  return stats;\n}\n\nfunction tryCreateBuffer(size\x2C fd\x2C isUserFd) {\n  let threw = true;\n  let buffer;\n  try {\n    if (size > kIoMaxLength) {\n      throw new ERR_FS_FILE_TOO_LARGE(size);\n    }\n    buffer = Buffer.allocUnsafe(size);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return buffer;\n}\n\nfunction tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C len) {\n  let threw = true;\n  let bytesRead;\n  try {\n    bytesRead = fs.readSync(fd\x2C buffer\x2C pos\x2C len);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return bytesRead;\n}\n\n/**\n * Synchronously reads the entire contents of a file.\n * @param {string | Buffer | URL | number} path\n * @param {{\n *   encoding?: string | null;\n *   flag?: string;\n *   }} [options]\n * @returns {string | Buffer}\n */\nfunction readFileSync(path\x2C options) {\n  options = getOptions(options\x2C { flag: 'r' });\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path\x2C options.flag\x2C 0o666);\n\n  const stats = tryStatSync(fd\x2C isUserFd);\n  const size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\n  let pos = 0;\n  let buffer; // Single buffer with file data\n  let buffers; // List for when size is unknown\n\n  if (size === 0) {\n    buffers = [];\n  } else {\n    buffer = tryCreateBuffer(size\x2C fd\x2C isUserFd);\n  }\n\n  let bytesRead;\n\n  if (size !== 0) {\n    do {\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C size - pos);\n      pos += bytesRead;\n    } while (bytesRead !== 0 && pos < size);\n  } else {\n    do {\n      // The kernel lies about many files.\n      // Go ahead and try to read some bytes.\n      buffer = Buffer.allocUnsafe(8192);\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C 0\x2C 8192);\n      if (bytesRead !== 0) {\n        ArrayPrototypePush(buffers\x2C buffer.slice(0\x2C bytesRead));\n      }\n      pos += bytesRead;\n    } while (bytesRead !== 0);\n  }\n\n  if (!isUserFd)\n    fs.closeSync(fd);\n\n  if (size === 0) {\n    // Data was collected into the buffers list.\n    buffer = Buffer.concat(buffers\x2C pos);\n  } else if (pos < size) {\n    buffer = buffer.slice(0\x2C pos);\n  }\n\n  if (options.encoding) buffer = buffer.toString(options.encoding);\n  return buffer;\n}\n\nfunction defaultCloseCallback(err) {\n  if (err != null) throw err;\n}\n\n/**\n * Closes the file descriptor.\n * @param {number} fd\n * @param {(err?: Error) => any} [callback]\n * @returns {void}\n */\nfunction close(fd\x2C callback = defaultCloseCallback) {\n  fd = getValidatedFd(fd);\n  if (callback !== defaultCloseCallback)\n    callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.close(fd\x2C req);\n}\n\n/**\n * Synchronously closes the file descriptor.\n * @param {number} fd\n * @returns {void}\n */\nfunction closeSync(fd) {\n  fd = getValidatedFd(fd);\n\n  const ctx = {};\n  binding.close(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously opens a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} [flags]\n * @param {string | number} [mode]\n * @param {(\n *   err?: Error\x2C\n *   fd?: number\n *   ) => any} callback\n * @returns {void}\n */\nfunction open(path\x2C flags\x2C mode\x2C callback) {\n  path = getValidatedPath(path);\n  if (arguments.length < 3) {\n    callback = flags;\n    flags = 'r';\n    mode = 0o666;\n  } else if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0o666;\n  } else {\n    mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n  }\n  const flagsNumber = stringToFlags(flags);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.open(pathModule.toNamespacedPath(path)\x2C\n               flagsNumber\x2C\n               mode\x2C\n               req);\n}\n\n/**\n * Synchronously opens a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} [flags]\n * @param {string | number} [mode]\n * @returns {number}\n */\nfunction openSync(path\x2C flags\x2C mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n\n  const ctx = { path };\n  const result = binding.open(pathModule.toNamespacedPath(path)\x2C\n                              flagsNumber\x2C mode\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Reads file from the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView} buffer\n * @param {number} offsetOrOptions\n * @param {number} length\n * @param {number | bigint | null} position\n * @param {(\n *   err?: Error\x2C\n *   bytesRead?: number\x2C\n *   buffer?: Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction read(fd\x2C buffer\x2C offsetOrOptions\x2C length\x2C position\x2C callback) {\n  fd = getValidatedFd(fd);\n\n  let offset = offsetOrOptions;\n  let params = null;\n  if (arguments.length <= 4) {\n    if (arguments.length === 4) {\n      // This is fs.read(fd\x2C buffer\x2C options\x2C callback)\n      validateObject(offsetOrOptions\x2C 'options'\x2C { nullable: true });\n      callback = length;\n      params = offsetOrOptions;\n    } else if (arguments.length === 3) {\n      // This is fs.read(fd\x2C bufferOrParams\x2C callback)\n      if (!isArrayBufferView(buffer)) {\n        // This is fs.read(fd\x2C params\x2C callback)\n        params = buffer;\n        ({ buffer = Buffer.alloc(16384) } = params ?? kEmptyObject);\n      }\n      callback = offsetOrOptions;\n    } else {\n      // This is fs.read(fd\x2C callback)\n      callback = buffer;\n      buffer = Buffer.alloc(16384);\n    }\n\n    ({\n      offset = 0\x2C\n      length = buffer.byteLength - offset\x2C\n      position = null\x2C\n    } = params ?? kEmptyObject);\n  }\n\n  validateBuffer(buffer);\n  callback = maybeCallback(callback);\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return process.nextTick(function tick() {\n      callback(null\x2C 0\x2C buffer);\n    });\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (position == null)\n    position = -1;\n\n  validatePosition(position\x2C 'position');\n\n  function wrapper(err\x2C bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err\x2C bytesRead || 0\x2C buffer);\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\n}\n\nObjectDefineProperty(read\x2C kCustomPromisifyArgsSymbol\x2C\n                     { __proto__: null\x2C value: ['bytesRead'\x2C 'buffer']\x2C enumerable: false });\n\n/**\n * Synchronously reads the file from the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView} buffer\n * @param {{\n *   offset?: number;\n *   length?: number;\n *   position?: number | bigint | null;\n *   }} [offset]\n * @returns {number}\n */\nfunction readSync(fd\x2C buffer\x2C offset\x2C length\x2C position) {\n  fd = getValidatedFd(fd);\n\n  validateBuffer(buffer);\n\n  if (arguments.length <= 3) {\n    // Assume fs.readSync(fd\x2C buffer\x2C options)\n    const options = offset || kEmptyObject;\n\n    ({\n      offset = 0\x2C\n      length = buffer.byteLength - offset\x2C\n      position = null\x2C\n    } = options);\n  }\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return 0;\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (position == null)\n    position = -1;\n\n  validatePosition(position\x2C 'position');\n\n  const ctx = {};\n  const result = binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Reads file from the specified `fd` (file descriptor)\n * and writes to an array of `ArrayBufferView`s.\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number | null} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesRead?: number\x2C\n *   buffers?: ArrayBufferView[];\n *   ) => any} callback\n * @returns {void}\n */\nfunction readv(fd\x2C buffers\x2C position\x2C callback) {\n  function wrapper(err\x2C read) {\n    callback(err\x2C read || 0\x2C buffers);\n  }\n\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  return binding.readBuffers(fd\x2C buffers\x2C position\x2C req);\n}\n\nObjectDefineProperty(readv\x2C kCustomPromisifyArgsSymbol\x2C\n                     { __proto__: null\x2C value: ['bytesRead'\x2C 'buffers']\x2C enumerable: false });\n\n/**\n * Synchronously reads file from the\n * specified `fd` (file descriptor) and writes to an array\n * of `ArrayBufferView`s.\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number | null} [position]\n * @returns {number}\n */\nfunction readvSync(fd\x2C buffers\x2C position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n\n  const ctx = {};\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const result = binding.readBuffers(fd\x2C buffers\x2C position\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Writes `buffer` to the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView | string | object} buffer\n * @param {number | object} [offsetOrOptions]\n * @param {number} [length]\n * @param {number | null} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesWritten?: number;\n *   buffer?: Buffer | TypedArray | DataView\n *   ) => any} callback\n * @returns {void}\n */\nfunction write(fd\x2C buffer\x2C offsetOrOptions\x2C length\x2C position\x2C callback) {\n  function wrapper(err\x2C written) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err\x2C written || 0\x2C buffer);\n  }\n\n  fd = getValidatedFd(fd);\n\n  let offset = offsetOrOptions;\n  if (isArrayBufferView(buffer)) {\n    callback = maybeCallback(callback || position || length || offset);\n\n    if (typeof offset === 'object') {\n      ({\n        offset = 0\x2C\n        length = buffer.byteLength - offset\x2C\n        position = null\x2C\n      } = offsetOrOptions ?? kEmptyObject);\n    }\n\n    if (offset == null || typeof offset === 'function') {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n\n    const req = new FSReqCallback();\n    req.oncomplete = wrapper;\n    return binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\n  }\n\n  validateStringAfterArrayBufferView(buffer\x2C 'buffer');\n  if (typeof buffer !== 'string') {\n    showStringCoercionDeprecation();\n  }\n\n  if (typeof position !== 'function') {\n    if (typeof offset === 'function') {\n      position = offset;\n      offset = null;\n    } else {\n      position = length;\n    }\n    length = 'utf8';\n  }\n\n  const str = String(buffer);\n  validateEncoding(str\x2C length);\n  callback = maybeCallback(position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n  return binding.writeString(fd\x2C str\x2C offset\x2C length\x2C req);\n}\n\nObjectDefineProperty(write\x2C kCustomPromisifyArgsSymbol\x2C\n                     { __proto__: null\x2C value: ['bytesWritten'\x2C 'buffer']\x2C enumerable: false });\n\n/**\n * Synchronously writes `buffer` to the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView | string} buffer\n * @param {{\n *   offset?: number;\n *   length?: number;\n *   position?: number | null;\n *   }} [offsetOrOptions]\n * @returns {number}\n */\nfunction writeSync(fd\x2C buffer\x2C offsetOrOptions\x2C length\x2C position) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  let result;\n\n  let offset = offsetOrOptions;\n  if (isArrayBufferView(buffer)) {\n    if (typeof offset === 'object') {\n      ({\n        offset = 0\x2C\n        length = buffer.byteLength - offset\x2C\n        position = null\x2C\n      } = offsetOrOptions ?? kEmptyObject);\n    }\n    if (position === undefined)\n      position = null;\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n    result = binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C\n                                 undefined\x2C ctx);\n  } else {\n    validatePrimitiveStringAfterArrayBufferView(buffer\x2C 'buffer');\n    validateEncoding(buffer\x2C length);\n\n    if (offset === undefined)\n      offset = null;\n    result = binding.writeString(fd\x2C buffer\x2C offset\x2C length\x2C\n                                 undefined\x2C ctx);\n  }\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Writes an array of `ArrayBufferView`s to the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number | null} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesWritten?: number\x2C\n *   buffers?: ArrayBufferView[]\n *   ) => any} callback\n * @returns {void}\n */\nfunction writev(fd\x2C buffers\x2C position\x2C callback) {\n  function wrapper(err\x2C written) {\n    callback(err\x2C written || 0\x2C buffers);\n  }\n\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  if (buffers.length === 0) {\n    process.nextTick(callback\x2C null\x2C 0\x2C buffers);\n    return;\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  return binding.writeBuffers(fd\x2C buffers\x2C position\x2C req);\n}\n\nObjectDefineProperty(writev\x2C kCustomPromisifyArgsSymbol\x2C {\n  __proto__: null\x2C\n  value: ['bytesWritten'\x2C 'buffer']\x2C\n  enumerable: false\x2C\n});\n\n/**\n * Synchronously writes an array of `ArrayBufferView`s\n * to the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number | null} [position]\n * @returns {number}\n */\nfunction writevSync(fd\x2C buffers\x2C position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n\n  if (buffers.length === 0) {\n    return 0;\n  }\n\n  const ctx = {};\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const result = binding.writeBuffers(fd\x2C buffers\x2C position\x2C undefined\x2C ctx);\n\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously renames file at `oldPath` to\n * the pathname provided as `newPath`.\n * @param {string | Buffer | URL} oldPath\n * @param {string | Buffer | URL} newPath\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rename(oldPath\x2C newPath\x2C callback) {\n  callback = makeCallback(callback);\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                 pathModule.toNamespacedPath(newPath)\x2C\n                 req);\n}\n\n\n/**\n * Synchronously renames file at `oldPath` to\n * the pathname provided as `newPath`.\n * @param {string | Buffer | URL} oldPath\n * @param {string | Buffer | URL} newPath\n * @returns {void}\n */\nfunction renameSync(oldPath\x2C newPath) {\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  const ctx = { path: oldPath\x2C dest: newPath };\n  binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                 pathModule.toNamespacedPath(newPath)\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Truncates the file.\n * @param {string | Buffer | URL} path\n * @param {number} [len]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction truncate(path\x2C len\x2C callback) {\n  if (typeof path === 'number') {\n    showTruncateDeprecation();\n    return fs.ftruncate(path\x2C len\x2C callback);\n  }\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (len === undefined) {\n    len = 0;\n  }\n\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  callback = maybeCallback(callback);\n  fs.open(path\x2C 'r+'\x2C (er\x2C fd) => {\n    if (er) return callback(er);\n    const req = new FSReqCallback();\n    req.oncomplete = function oncomplete(er) {\n      fs.close(fd\x2C (er2) => {\n        callback(aggregateTwoErrors(er2\x2C er));\n      });\n    };\n    binding.ftruncate(fd\x2C len\x2C req);\n  });\n}\n\n/**\n * Synchronously truncates the file.\n * @param {string | Buffer | URL} path\n * @param {number} [len]\n * @returns {void}\n */\nfunction truncateSync(path\x2C len) {\n  if (typeof path === 'number') {\n    // legacy\n    showTruncateDeprecation();\n    return fs.ftruncateSync(path\x2C len);\n  }\n  if (len === undefined) {\n    len = 0;\n  }\n  // Allow error to be thrown\x2C but still close fd.\n  const fd = fs.openSync(path\x2C 'r+');\n  let ret;\n\n  try {\n    ret = fs.ftruncateSync(fd\x2C len);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\n/**\n * Truncates the file descriptor.\n * @param {number} fd\n * @param {number} [len]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction ftruncate(fd\x2C len = 0\x2C callback) {\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  }\n  fd = getValidatedFd(fd);\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.ftruncate(fd\x2C len\x2C req);\n}\n\n/**\n * Synchronously truncates the file descriptor.\n * @param {number} fd\n * @param {number} [len]\n * @returns {void}\n */\nfunction ftruncateSync(fd\x2C len = 0) {\n  fd = getValidatedFd(fd);\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  const ctx = {};\n  binding.ftruncate(fd\x2C len\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction lazyLoadCp() {\n  if (cpFn === undefined) {\n    ({ cpFn } = require('internal/fs/cp/cp'));\n    cpFn = require('util').callbackify(cpFn);\n    ({ cpSyncFn } = require('internal/fs/cp/cp-sync'));\n  }\n}\n\nfunction lazyLoadRimraf() {\n  if (rimraf === undefined)\n    ({ rimraf\x2C rimrafSync } = require('internal/fs/rimraf'));\n}\n\n/**\n * Asynchronously removes a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rmdir(path\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  callback = makeCallback(callback);\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    validateRmOptions(\n      path\x2C\n      { ...options\x2C force: false }\x2C\n      true\x2C\n      (err\x2C options) => {\n        if (err === false) {\n          const req = new FSReqCallback();\n          req.oncomplete = callback;\n          return binding.rmdir(path\x2C req);\n        }\n        if (err) {\n          return callback(err);\n        }\n\n        lazyLoadRimraf();\n        rimraf(path\x2C options\x2C callback);\n      });\n  } else {\n    validateRmdirOptions(options);\n    const req = new FSReqCallback();\n    req.oncomplete = callback;\n    return binding.rmdir(path\x2C req);\n  }\n}\n\n/**\n * Synchronously removes a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @returns {void}\n */\nfunction rmdirSync(path\x2C options) {\n  path = getValidatedPath(path);\n\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    options = validateRmOptionsSync(path\x2C { ...options\x2C force: false }\x2C true);\n    if (options !== false) {\n      lazyLoadRimraf();\n      return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\n    }\n  } else {\n    validateRmdirOptions(options);\n  }\n\n  const ctx = { path };\n  binding.rmdir(pathModule.toNamespacedPath(path)\x2C undefined\x2C ctx);\n  return handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously removes files and\n * directories (modeled on the standard POSIX `rm` utility).\n * @param {string | Buffer | URL} path\n * @param {{\n *   force?: boolean;\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rm(path\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  path = getValidatedPath(path);\n\n  validateRmOptions(path\x2C options\x2C false\x2C (err\x2C options) => {\n    if (err) {\n      return callback(err);\n    }\n    lazyLoadRimraf();\n    return rimraf(pathModule.toNamespacedPath(path)\x2C options\x2C callback);\n  });\n}\n\n/**\n * Synchronously removes files and\n * directories (modeled on the standard POSIX `rm` utility).\n * @param {string | Buffer | URL} path\n * @param {{\n *   force?: boolean;\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @returns {void}\n */\nfunction rmSync(path\x2C options) {\n  path = getValidatedPath(path);\n  options = validateRmOptionsSync(path\x2C options\x2C false);\n\n  lazyLoadRimraf();\n  return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\n}\n\n/**\n * Forces all currently queued I/O operations associated\n * with the file to the operating system's synchronized\n * I/O completion state.\n * @param {number} fd\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fdatasync(fd\x2C callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fdatasync(fd\x2C req);\n}\n\n/**\n * Synchronously forces all currently queued I/O operations\n * associated with the file to the operating\n * system's synchronized I/O completion state.\n * @param {number} fd\n * @returns {void}\n */\nfunction fdatasyncSync(fd) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  binding.fdatasync(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Requests for all data for the open file descriptor\n * to be flushed to the storage device.\n * @param {number} fd\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fsync(fd\x2C callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fsync(fd\x2C req);\n}\n\n/**\n * Synchronously requests for all data for the open\n * file descriptor to be flushed to the storage device.\n * @param {number} fd\n * @returns {void}\n */\nfunction fsyncSync(fd) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  binding.fsync(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously creates a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   recursive?: boolean;\n *   mode?: string | number;\n *   } | number} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction mkdir(path\x2C options\x2C callback) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'function') {\n    callback = options;\n  } else if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                parseFileMode(mode\x2C 'mode')\x2C recursive\x2C req);\n}\n\n/**\n * Synchronously creates a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   recursive?: boolean;\n *   mode?: string | number;\n *   } | number} [options]\n * @returns {string | void}\n */\nfunction mkdirSync(path\x2C options) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  path = getValidatedPath(path);\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  const ctx = { path };\n  const result = binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                               parseFileMode(mode\x2C 'mode')\x2C recursive\x2C\n                               undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  if (recursive) {\n    return result;\n  }\n}\n\n/**\n * An iterative algorithm for reading the entire contents of the `basePath` directory.\n * This function does not validate `basePath` as a directory. It is passed directly to\n * `binding.readdir` after a `nullCheck`.\n * @param {string} basePath\n * @param {{ encoding: string\x2C withFileTypes: boolean }} options\n * @returns {string[] | Dirent[]}\n */\nfunction readdirSyncRecursive(basePath\x2C options) {\n  nullCheck(basePath\x2C 'path'\x2C true);\n\n  const withFileTypes = Boolean(options.withFileTypes);\n  const encoding = options.encoding;\n\n  const readdirResults = [];\n  const pathsQueue = [basePath];\n\n  const ctx = { path: basePath };\n  function read(path) {\n    ctx.path = path;\n    const readdirResult = binding.readdir(\n      pathModule.toNamespacedPath(path)\x2C\n      encoding\x2C\n      withFileTypes\x2C\n      undefined\x2C\n      ctx\x2C\n    );\n    handleErrorFromBinding(ctx);\n\n    for (let i = 0; i < readdirResult.length; i++) {\n      if (withFileTypes) {\n        const dirent = getDirent(path\x2C readdirResult[0][i]\x2C readdirResult[1][i]);\n        ArrayPrototypePush(readdirResults\x2C dirent);\n        if (dirent.isDirectory()) {\n          ArrayPrototypePush(pathsQueue\x2C pathModule.join(dirent.path\x2C dirent.name));\n        }\n      } else {\n        const resultPath = pathModule.join(path\x2C readdirResult[i]);\n        const relativeResultPath = pathModule.relative(basePath\x2C resultPath);\n        const stat = binding.internalModuleStat(resultPath);\n        ArrayPrototypePush(readdirResults\x2C relativeResultPath);\n        // 1 indicates directory\n        if (stat === 1) {\n          ArrayPrototypePush(pathsQueue\x2C resultPath);\n        }\n      }\n    }\n  }\n\n  for (let i = 0; i < pathsQueue.length; i++) {\n    read(pathsQueue[i]);\n  }\n\n  return readdirResults;\n}\n\n/**\n * Reads the contents of a directory.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   encoding?: string;\n *   withFileTypes?: boolean;\n *   }} [options]\n * @param {(\n *   err?: Error\x2C\n *   files?: string[] | Buffer[] | Direct[];\n *   ) => any} callback\n * @returns {void}\n */\nfunction readdir(path\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  if (options.recursive != null) {\n    validateBoolean(options.recursive\x2C 'options.recursive');\n  }\n\n  if (options.recursive) {\n    callback(null\x2C readdirSyncRecursive(path\x2C options));\n    return;\n  }\n\n  const req = new FSReqCallback();\n  if (!options.withFileTypes) {\n    req.oncomplete = callback;\n  } else {\n    req.oncomplete = (err\x2C result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      getDirents(path\x2C result\x2C callback);\n    };\n  }\n  binding.readdir(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C\n                  !!options.withFileTypes\x2C req);\n}\n\n/**\n * Synchronously reads the contents of a directory.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   encoding?: string;\n *   withFileTypes?: boolean;\n *   recursive?: boolean;\n *   }} [options]\n * @returns {string | Buffer[] | Dirent[]}\n */\nfunction readdirSync(path\x2C options) {\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  if (options.recursive != null) {\n    validateBoolean(options.recursive\x2C 'options.recursive');\n  }\n\n  if (options.recursive) {\n    return readdirSyncRecursive(path\x2C options);\n  }\n\n  const ctx = { path };\n  const result = binding.readdir(pathModule.toNamespacedPath(path)\x2C\n                                 options.encoding\x2C !!options.withFileTypes\x2C\n                                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return options.withFileTypes ? getDirents(path\x2C result) : result;\n}\n\n/**\n * Invokes the callback with the `fs.Stats`\n * for the file descriptor.\n * @param {number} fd\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction fstat(fd\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = kEmptyObject;\n  }\n  fd = getValidatedFd(fd);\n  callback = makeStatsCallback(callback);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.fstat(fd\x2C options.bigint\x2C req);\n}\n\n/**\n * Retrieves the `fs.Stats` for the symbolic link\n * referred to by the `path`.\n * @param {string | Buffer | URL} path\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction lstat(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = kEmptyObject;\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.lstat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\n/**\n * Asynchronously gets the stats of a file.\n * @param {string | Buffer | URL} path\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction stat(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = kEmptyObject;\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.stat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\nfunction statfs(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = kEmptyObject;\n  }\n  callback = maybeCallback(callback);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = (err\x2C stats) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(err\x2C getStatFsFromBinding(stats));\n  };\n  binding.statfs(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\nfunction hasNoEntryError(ctx) {\n  if (ctx.errno) {\n    const uvErr = uvErrmapGet(ctx.errno);\n    return uvErr?.[0] === 'ENOENT';\n  }\n\n  if (ctx.error) {\n    return ctx.error.code === 'ENOENT';\n  }\n\n  return false;\n}\n\n/**\n * Synchronously retrieves the `fs.Stats` for\n * the file descriptor.\n * @param {number} fd\n * @param {{\n *   bigint?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction fstatSync(fd\x2C options = { bigint: false }) {\n  fd = getValidatedFd(fd);\n  const ctx = { fd };\n  const stats = binding.fstat(fd\x2C options.bigint\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Synchronously retrieves the `fs.Stats` for\n * the symbolic link referred to by the `path`.\n * @param {string | Buffer | URL} path\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction lstatSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.lstat(pathModule.toNamespacedPath(path)\x2C\n                              options.bigint\x2C undefined\x2C ctx);\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\n    return undefined;\n  }\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Synchronously retrieves the `fs.Stats`\n * for the `path`.\n * @param {string | Buffer | URL} path\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction statSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.stat(pathModule.toNamespacedPath(path)\x2C\n                             options.bigint\x2C undefined\x2C ctx);\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\n    return undefined;\n  }\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\nfunction statfsSync(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.statfs(pathModule.toNamespacedPath(path)\x2C\n                               options.bigint\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return getStatFsFromBinding(stats);\n}\n\n/**\n * Reads the contents of a symbolic link\n * referred to by `path`.\n * @param {string | Buffer | URL} path\n * @param {{ encoding?: string; } | string} [options]\n * @param {(\n *   err?: Error\x2C\n *   linkString?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction readlink(path\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options);\n  path = getValidatedPath(path\x2C 'oldPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.readlink(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C req);\n}\n\n/**\n * Synchronously reads the contents of a symbolic link\n * referred to by `path`.\n * @param {string | Buffer | URL} path\n * @param {{ encoding?: string; } | string} [options]\n * @returns {string | Buffer}\n */\nfunction readlinkSync(path\x2C options) {\n  options = getOptions(options);\n  path = getValidatedPath(path\x2C 'oldPath');\n  const ctx = { path };\n  const result = binding.readlink(pathModule.toNamespacedPath(path)\x2C\n                                  options.encoding\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Creates the link called `path` pointing to `target`.\n * @param {string | Buffer | URL} target\n * @param {string | Buffer | URL} path\n * @param {string | null} [type_]\n * @param {(err?: Error) => any} callback_\n * @returns {void}\n */\nfunction symlink(target\x2C path\x2C type_\x2C callback_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  const callback = makeCallback(arguments[arguments.length - 1]);\n\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n\n  if (isWindows && type === null) {\n    let absoluteTarget;\n    try {\n      // Symlinks targets can be relative to the newly created path.\n      // Calculate absolute file name of the symlink target\x2C and check\n      // if it is a directory. Ignore resolve error to keep symlink\n      // errors consistent between platforms if invalid path is\n      // provided.\n      absoluteTarget = pathModule.resolve(path\x2C '..'\x2C target);\n    } catch {\n      // Continue regardless of error.\n    }\n    if (absoluteTarget !== undefined) {\n      stat(absoluteTarget\x2C (err\x2C stat) => {\n        const resolvedType = !err && stat.isDirectory() ? 'dir' : 'file';\n        const resolvedFlags = stringToSymlinkType(resolvedType);\n        const destination = preprocessSymlinkDestination(target\x2C\n                                                         resolvedType\x2C\n                                                         path);\n\n        const req = new FSReqCallback();\n        req.oncomplete = callback;\n        binding.symlink(destination\x2C\n                        pathModule.toNamespacedPath(path)\x2C resolvedFlags\x2C req);\n      });\n      return;\n    }\n  }\n\n  const destination = preprocessSymlinkDestination(target\x2C type\x2C path);\n\n  const flags = stringToSymlinkType(type);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.symlink(destination\x2C pathModule.toNamespacedPath(path)\x2C flags\x2C req);\n}\n\n/**\n * Synchronously creates the link called `path`\n * pointing to `target`.\n * @param {string | Buffer | URL} target\n * @param {string | Buffer | URL} path\n * @param {string | null} [type]\n * @returns {void}\n */\nfunction symlinkSync(target\x2C path\x2C type) {\n  type = (typeof type === 'string' ? type : null);\n  if (isWindows && type === null) {\n    const absoluteTarget = pathModule.resolve(`${path}`\x2C '..'\x2C `${target}`);\n    if (statSync(absoluteTarget\x2C { throwIfNoEntry: false })?.isDirectory()) {\n      type = 'dir';\n    }\n  }\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n  const flags = stringToSymlinkType(type);\n\n  const ctx = { path: target\x2C dest: path };\n  binding.symlink(preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\n                  pathModule.toNamespacedPath(path)\x2C flags\x2C undefined\x2C ctx);\n\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Creates a new link from the `existingPath`\n * to the `newPath`.\n * @param {string | Buffer | URL} existingPath\n * @param {string | Buffer | URL} newPath\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction link(existingPath\x2C newPath\x2C callback) {\n  callback = makeCallback(callback);\n\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n               pathModule.toNamespacedPath(newPath)\x2C\n               req);\n}\n\n/**\n * Synchronously creates a new link from the `existingPath`\n * to the `newPath`.\n * @param {string | Buffer | URL} existingPath\n * @param {string | Buffer | URL} newPath\n * @returns {void}\n */\nfunction linkSync(existingPath\x2C newPath) {\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n\n  const ctx = { path: existingPath\x2C dest: newPath };\n  const result = binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n                              pathModule.toNamespacedPath(newPath)\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously removes a file or symbolic link.\n * @param {string | Buffer | URL} path\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction unlink(path\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.unlink(pathModule.toNamespacedPath(path)\x2C req);\n}\n\n/**\n * Synchronously removes a file or symbolic link.\n * @param {string | Buffer | URL} path\n * @returns {void}\n */\nfunction unlinkSync(path) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.unlink(pathModule.toNamespacedPath(path)\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the permissions on the file.\n * @param {number} fd\n * @param {string | number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fchmod(fd\x2C mode\x2C callback) {\n  fd = getValidatedFd(fd);\n  mode = parseFileMode(mode\x2C 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchmod(fd\x2C mode\x2C req);\n}\n\n/**\n * Synchronously sets the permissions on the file.\n * @param {number} fd\n * @param {string | number} mode\n * @returns {void}\n */\nfunction fchmodSync(fd\x2C mode) {\n  fd = getValidatedFd(fd);\n  mode = parseFileMode(mode\x2C 'mode');\n  const ctx = {};\n  binding.fchmod(fd\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the permissions on a symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lchmod(path\x2C mode\x2C callback) {\n  callback = maybeCallback(callback);\n  mode = parseFileMode(mode\x2C 'mode');\n  fs.open(path\x2C O_WRONLY | O_SYMLINK\x2C (err\x2C fd) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    // Prefer to return the chmod error\x2C if one occurs\x2C\n    // but still try to close\x2C and report closing errors if they occur.\n    fs.fchmod(fd\x2C mode\x2C (err) => {\n      fs.close(fd\x2C (err2) => {\n        callback(aggregateTwoErrors(err2\x2C err));\n      });\n    });\n  });\n}\n\n/**\n * Synchronously changes the permissions on a symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} mode\n * @returns {void}\n */\nfunction lchmodSync(path\x2C mode) {\n  const fd = fs.openSync(path\x2C O_WRONLY | O_SYMLINK);\n\n  // Prefer to return the chmod error\x2C if one occurs\x2C\n  // but still try to close\x2C and report closing errors if they occur.\n  let ret;\n  try {\n    ret = fs.fchmodSync(fd\x2C mode);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\n/**\n * Asynchronously changes the permissions of a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction chmod(path\x2C mode\x2C callback) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\n}\n\n/**\n * Synchronously changes the permissions of a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} mode\n * @returns {void}\n */\nfunction chmodSync(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n\n  const ctx = { path };\n  binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the owner of the symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lchown(path\x2C uid\x2C gid\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lchown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously sets the owner of the symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction lchownSync(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const ctx = { path };\n  binding.lchown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the owner of the file.\n * @param {number} fd\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fchown(fd\x2C uid\x2C gid\x2C callback) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchown(fd\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously sets the owner of the file.\n * @param {number} fd\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction fchownSync(fd\x2C uid\x2C gid) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n\n  const ctx = {};\n  binding.fchown(fd\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously changes the owner and group\n * of a file.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction chown(path\x2C uid\x2C gid\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously changes the owner and group\n * of a file.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction chownSync(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const ctx = { path };\n  binding.chown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the file system timestamps of the object\n * referenced by `path`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction utimes(path\x2C atime\x2C mtime\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                 toUnixTimestamp(atime)\x2C\n                 toUnixTimestamp(mtime)\x2C\n                 req);\n}\n\n/**\n * Synchronously changes the file system timestamps\n * of the object referenced by `path`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction utimesSync(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                 toUnixTimestamp(atime)\x2C toUnixTimestamp(mtime)\x2C\n                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the file system timestamps of the object\n * referenced by the supplied `fd` (file descriptor).\n * @param {number} fd\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction futimes(fd\x2C atime\x2C mtime\x2C callback) {\n  fd = getValidatedFd(fd);\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.futimes(fd\x2C atime\x2C mtime\x2C req);\n}\n\n/**\n * Synchronously changes the file system timestamps\n * of the object referenced by the\n * supplied `fd` (file descriptor).\n * @param {number} fd\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction futimesSync(fd\x2C atime\x2C mtime) {\n  fd = getValidatedFd(fd);\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  const ctx = {};\n  binding.futimes(fd\x2C atime\x2C mtime\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the access and modification times of\n * a file in the same way as `fs.utimes()`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lutimes(path\x2C atime\x2C mtime\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                  toUnixTimestamp(atime)\x2C\n                  toUnixTimestamp(mtime)\x2C\n                  req);\n}\n\n/**\n * Synchronously changes the access and modification\n * times of a file in the same way as `fs.utimesSync()`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction lutimesSync(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                  toUnixTimestamp(atime)\x2C\n                  toUnixTimestamp(mtime)\x2C\n                  undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C callback) {\n  if (signal?.aborted) {\n    const abortError = new AbortError(undefined\x2C { cause: signal?.reason });\n    if (isUserFd) {\n      callback(abortError);\n    } else {\n      fs.close(fd\x2C (err) => {\n        callback(aggregateTwoErrors(err\x2C abortError));\n      });\n    }\n    return;\n  }\n  // write(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback)\n  fs.write(fd\x2C buffer\x2C offset\x2C length\x2C null\x2C (writeErr\x2C written) => {\n    if (writeErr) {\n      if (isUserFd) {\n        callback(writeErr);\n      } else {\n        fs.close(fd\x2C (err) => {\n          callback(aggregateTwoErrors(err\x2C writeErr));\n        });\n      }\n    } else if (written === length) {\n      if (isUserFd) {\n        callback(null);\n      } else {\n        fs.close(fd\x2C callback);\n      }\n    } else {\n      offset += written;\n      length -= written;\n      writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C callback);\n    }\n  });\n}\n\n/**\n * Asynchronously writes data to the file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer | TypedArray | DataView | object} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   signal?: AbortSignal;\n *   } | string} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction writeFile(path\x2C data\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    if (typeof data !== 'string') {\n      showStringCoercionDeprecation();\n    }\n    data = Buffer.from(String(data)\x2C options.encoding || 'utf8');\n  }\n\n  if (isFd(path)) {\n    const isUserFd = true;\n    const signal = options.signal;\n    writeAll(path\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C callback);\n    return;\n  }\n\n  if (checkAborted(options.signal\x2C callback))\n    return;\n\n  fs.open(path\x2C flag\x2C options.mode\x2C (openErr\x2C fd) => {\n    if (openErr) {\n      callback(openErr);\n    } else {\n      const isUserFd = false;\n      const signal = options.signal;\n      writeAll(fd\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C callback);\n    }\n  });\n}\n\n/**\n * Synchronously writes data to the file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer | TypedArray | DataView | object} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @returns {void}\n */\nfunction writeFileSync(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    if (typeof data !== 'string') {\n      showStringCoercionDeprecation();\n    }\n    data = Buffer.from(String(data)\x2C options.encoding || 'utf8');\n  }\n\n  const flag = options.flag || 'w';\n\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path\x2C flag\x2C options.mode);\n\n  let offset = 0;\n  let length = data.byteLength;\n  try {\n    while (length > 0) {\n      const written = fs.writeSync(fd\x2C data\x2C offset\x2C length);\n      offset += written;\n      length -= written;\n    }\n  } finally {\n    if (!isUserFd) fs.closeSync(fd);\n  }\n}\n\n/**\n * Asynchronously appends data to a file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction appendFile(path\x2C data\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFile(path\x2C data\x2C options\x2C callback);\n}\n\n/**\n * Synchronously appends data to a file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @returns {void}\n */\nfunction appendFileSync(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFileSync(path\x2C data\x2C options);\n}\n\n/**\n * Watches for the changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {string | {\n *   persistent?: boolean;\n *   recursive?: boolean;\n *   encoding?: string;\n *   signal?: AbortSignal;\n *   }} [options]\n * @param {(\n *   eventType?: string\x2C\n *   filename?: string | Buffer\n *   ) => any} [listener]\n * @returns {watchers.FSWatcher}\n */\nfunction watch(filename\x2C options\x2C listener) {\n  if (typeof options === 'function') {\n    listener = options;\n  }\n  options = getOptions(options);\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  if (options.persistent === undefined) options.persistent = true;\n  if (options.recursive === undefined) options.recursive = false;\n  if (options.recursive && !(isOSX || isWindows))\n    throw new ERR_FEATURE_UNAVAILABLE_ON_PLATFORM('watch recursively');\n  const watcher = new watchers.FSWatcher();\n  watcher[watchers.kFSWatchStart](filename\x2C\n                                  options.persistent\x2C\n                                  options.recursive\x2C\n                                  options.encoding);\n\n  if (listener) {\n    watcher.addListener('change'\x2C listener);\n  }\n  if (options.signal) {\n    if (options.signal.aborted) {\n      process.nextTick(() => watcher.close());\n    } else {\n      const listener = () => watcher.close();\n      options.signal.addEventListener('abort'\x2C listener);\n      watcher.once('close'\x2C () => {\n        options.signal.removeEventListener('abort'\x2C listener);\n      });\n    }\n  }\n\n  return watcher;\n}\n\n\nconst statWatchers = new SafeMap();\n\n/**\n * Watches for changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {{\n *   bigint?: boolean;\n *   persistent?: boolean;\n *   interval?: number;\n *   }} [options]\n * @param {(\n *   current?: Stats\x2C\n *   previous?: Stats\n *   ) => any} listener\n * @returns {watchers.StatWatcher}\n */\nfunction watchFile(filename\x2C options\x2C listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  let stat;\n\n  if (options === null || typeof options !== 'object') {\n    listener = options;\n    options = null;\n  }\n\n  options = {\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\n    // a little on the slow side but let's stick with it for now to keep\n    // behavioral changes to a minimum.\n    interval: 5007\x2C\n    persistent: true\x2C\n    ...options\x2C\n  };\n\n  validateFunction(listener\x2C 'listener');\n\n  stat = statWatchers.get(filename);\n\n  if (stat === undefined) {\n    stat = new watchers.StatWatcher(options.bigint);\n    stat[watchers.kFSStatWatcherStart](filename\x2C\n                                       options.persistent\x2C options.interval);\n    statWatchers.set(filename\x2C stat);\n  } else {\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('add');\n  }\n\n  stat.addListener('change'\x2C listener);\n  return stat;\n}\n\n/**\n * Stops watching for changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {() => any} [listener]\n * @returns {void}\n */\nfunction unwatchFile(filename\x2C listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  const stat = statWatchers.get(filename);\n\n  if (stat === undefined) return;\n\n  if (typeof listener === 'function') {\n    const beforeListenerCount = stat.listenerCount('change');\n    stat.removeListener('change'\x2C listener);\n    if (stat.listenerCount('change') < beforeListenerCount)\n      stat[watchers.kFSStatWatcherAddOrCleanRef]('clean');\n  } else {\n    stat.removeAllListeners('change');\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('cleanAll');\n  }\n\n  if (stat.listenerCount('change') === 0) {\n    stat.stop();\n    statWatchers.delete(filename);\n  }\n}\n\n\nlet splitRoot;\nif (isWindows) {\n  // Regex to find the device root on Windows (e.g. 'c:\\\\')\x2C including trailing\n  // slash.\n  const splitRootRe = /^(?:[a-zA-Z]:|[\\\\/]{2}[^\\\\/]+[\\\\/][^\\\\/]+)?[\\\\/]*/;\n  splitRoot = function splitRoot(str) {\n    return SideEffectFreeRegExpPrototypeExec(splitRootRe\x2C str)[0];\n  };\n} else {\n  splitRoot = function splitRoot(str) {\n    for (let i = 0; i < str.length; ++i) {\n      if (StringPrototypeCharCodeAt(str\x2C i) !== CHAR_FORWARD_SLASH)\n        return StringPrototypeSlice(str\x2C 0\x2C i);\n    }\n    return str;\n  };\n}\n\nfunction encodeRealpathResult(result\x2C options) {\n  if (!options || !options.encoding || options.encoding === 'utf8')\n    return result;\n  const asBuffer = Buffer.from(result);\n  if (options.encoding === 'buffer') {\n    return asBuffer;\n  }\n  return asBuffer.toString(options.encoding);\n}\n\n// Finds the next portion of a (partial) path\x2C up to the next path delimiter\nlet nextPart;\nif (isWindows) {\n  nextPart = function nextPart(p\x2C i) {\n    for (; i < p.length; ++i) {\n      const ch = StringPrototypeCharCodeAt(p\x2C i);\n\n      // Check for a separator character\n      if (ch === CHAR_BACKWARD_SLASH || ch === CHAR_FORWARD_SLASH)\n        return i;\n    }\n    return -1;\n  };\n} else {\n  nextPart = function nextPart(p\x2C i) {\n    return StringPrototypeIndexOf(p\x2C '/'\x2C i);\n  };\n}\n\n/**\n * Returns the resolved pathname.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string | null; }} [options]\n * @returns {string | Buffer}\n */\nfunction realpathSync(p\x2C options) {\n  options = getOptions(options);\n  p = toPathIfFileURL(p);\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const cache = options[realpathCacheKey];\n  const maybeCachedResult = cache?.get(p);\n  if (maybeCachedResult) {\n    return maybeCachedResult;\n  }\n\n  const seenLinks = new SafeMap();\n  const knownHard = new SafeSet();\n  const original = p;\n\n  // Current character position in p\n  let pos;\n  // The partial path so far\x2C including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round\x2C with slash\n  let previous;\n\n  // Skip over roots\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows\x2C check that the root exists. On unix there is no need.\n  if (isWindows) {\n    const ctx = { path: base };\n    binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C ctx);\n    handleErrorFromBinding(ctx);\n    knownHard.add(base);\n  }\n\n  // Walk down the path\x2C swapping out linked path parts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    const result = nextPart(p\x2C pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p\x2C pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink\x2C break if a pipe/socket\n    if (knownHard.has(base) || cache?.get(base) === base) {\n      if (isFileType(binding.statValues\x2C S_IFIFO) ||\n          isFileType(binding.statValues\x2C S_IFSOCK)) {\n        break;\n      }\n      continue;\n    }\n\n    let resolvedLink;\n    const maybeCachedResolved = cache?.get(base);\n    if (maybeCachedResolved) {\n      resolvedLink = maybeCachedResolved;\n    } else {\n      // Use stats array directly to avoid creating an fs.Stats instance just\n      // for our internal use.\n\n      const baseLong = pathModule.toNamespacedPath(base);\n      const ctx = { path: base };\n      const stats = binding.lstat(baseLong\x2C true\x2C undefined\x2C ctx);\n      handleErrorFromBinding(ctx);\n\n      if (!isFileType(stats\x2C S_IFLNK)) {\n        knownHard.add(base);\n        cache?.set(base\x2C base);\n        continue;\n      }\n\n      // Read the link if it wasn't read before\n      // dev/ino always return 0 on windows\x2C so skip the check.\n      let linkTarget = null;\n      let id;\n      if (!isWindows) {\n        const dev = BigIntPrototypeToString(stats[0]\x2C 32);\n        const ino = BigIntPrototypeToString(stats[7]\x2C 32);\n        id = `${dev}:${ino}`;\n        if (seenLinks.has(id)) {\n          linkTarget = seenLinks.get(id);\n        }\n      }\n      if (linkTarget === null) {\n        const ctx = { path: base };\n        binding.stat(baseLong\x2C false\x2C undefined\x2C ctx);\n        handleErrorFromBinding(ctx);\n        linkTarget = binding.readlink(baseLong\x2C undefined\x2C undefined\x2C ctx);\n        handleErrorFromBinding(ctx);\n      }\n      resolvedLink = pathModule.resolve(previous\x2C linkTarget);\n\n      cache?.set(base\x2C resolvedLink);\n      if (!isWindows) seenLinks.set(id\x2C linkTarget);\n    }\n\n    // Resolve the link\x2C then start over\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\n\n    // Skip over roots\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows\x2C check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard.has(base)) {\n      const ctx = { path: base };\n      binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C ctx);\n      handleErrorFromBinding(ctx);\n      knownHard.add(base);\n    }\n  }\n\n  cache?.set(original\x2C p);\n  return encodeRealpathResult(p\x2C options);\n}\n\n/**\n * Returns the resolved pathname.\n * @param {string | Buffer | URL} path\n * @param {string | { encoding?: string; }} [options]\n * @returns {string | Buffer}\n */\nrealpathSync.native = (path\x2C options) => {\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const result = binding.realpath(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n};\n\n/**\n * Asynchronously computes the canonical pathname by\n * resolving `.`\x2C `..` and symbolic links.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   resolvedPath?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction realpath(p\x2C options\x2C callback) {\n  callback = typeof options === 'function' ? options : maybeCallback(callback);\n  options = getOptions(options);\n  p = toPathIfFileURL(p);\n\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const seenLinks = new SafeMap();\n  const knownHard = new SafeSet();\n\n  // Current character position in p\n  let pos;\n  // The partial path so far\x2C including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round\x2C with slash\n  let previous;\n\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows\x2C check that the root exists. On unix there is no need.\n  if (isWindows && !knownHard.has(base)) {\n    fs.lstat(base\x2C (err\x2C stats) => {\n      if (err) return callback(err);\n      knownHard.add(base);\n      LOOP();\n    });\n  } else {\n    process.nextTick(LOOP);\n  }\n\n  // Walk down the path\x2C swapping out linked path parts for their real\n  // values\n  function LOOP() {\n    // Stop if scanned past end of path\n    if (pos >= p.length) {\n      return callback(null\x2C encodeRealpathResult(p\x2C options));\n    }\n\n    // find the next part\n    const result = nextPart(p\x2C pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p\x2C pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink\x2C break if a pipe/socket\n    if (knownHard.has(base)) {\n      if (isFileType(binding.statValues\x2C S_IFIFO) ||\n          isFileType(binding.statValues\x2C S_IFSOCK)) {\n        return callback(null\x2C encodeRealpathResult(p\x2C options));\n      }\n      return process.nextTick(LOOP);\n    }\n\n    return fs.lstat(base\x2C { bigint: true }\x2C gotStat);\n  }\n\n  function gotStat(err\x2C stats) {\n    if (err) return callback(err);\n\n    // If not a symlink\x2C skip to the next path part\n    if (!stats.isSymbolicLink()) {\n      knownHard.add(base);\n      return process.nextTick(LOOP);\n    }\n\n    // Stat & read the link if not read before.\n    // Call `gotTarget()` as soon as the link target is known.\n    // `dev`/`ino` always return 0 on windows\x2C so skip the check.\n    let id;\n    if (!isWindows) {\n      const dev = BigIntPrototypeToString(stats.dev\x2C 32);\n      const ino = BigIntPrototypeToString(stats.ino\x2C 32);\n      id = `${dev}:${ino}`;\n      if (seenLinks.has(id)) {\n        return gotTarget(null\x2C seenLinks.get(id));\n      }\n    }\n    fs.stat(base\x2C (err) => {\n      if (err) return callback(err);\n\n      fs.readlink(base\x2C (err\x2C target) => {\n        if (!isWindows) seenLinks.set(id\x2C target);\n        gotTarget(err\x2C target);\n      });\n    });\n  }\n\n  function gotTarget(err\x2C target) {\n    if (err) return callback(err);\n\n    gotResolvedLink(pathModule.resolve(previous\x2C target));\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // Resolve the link\x2C then start over\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows\x2C check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard.has(base)) {\n      fs.lstat(base\x2C (err) => {\n        if (err) return callback(err);\n        knownHard.add(base);\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n}\n\n/**\n * Asynchronously computes the canonical pathname by\n * resolving `.`\x2C `..` and symbolic links.\n * @param {string | Buffer | URL} path\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   resolvedPath?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nrealpath.native = (path\x2C options\x2C callback) => {\n  callback = makeCallback(callback || options);\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  return binding.realpath(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C req);\n};\n\n/**\n * Creates a unique temporary directory.\n * @param {string} prefix\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   directory?: string\n *   ) => any} callback\n * @returns {void}\n */\nfunction mkdtemp(prefix\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options);\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix\x2C 'prefix');\n  warnOnNonPortableTemplate(prefix);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdtemp(`${prefix}XXXXXX`\x2C options.encoding\x2C req);\n}\n\n/**\n * Synchronously creates a unique temporary directory.\n * @param {string} prefix\n * @param {string | { encoding?: string; }} [options]\n * @returns {string}\n */\nfunction mkdtempSync(prefix\x2C options) {\n  options = getOptions(options);\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix\x2C 'prefix');\n  warnOnNonPortableTemplate(prefix);\n  const path = `${prefix}XXXXXX`;\n  const ctx = { path };\n  const result = binding.mkdtemp(path\x2C options.encoding\x2C\n                                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously copies `src` to `dest`. By\n * default\x2C `dest` is overwritten if it already exists.\n * @param {string | Buffer | URL} src\n * @param {string | Buffer | URL} dest\n * @param {number} [mode]\n * @param {() => any} callback\n * @returns {void}\n */\nfunction copyFile(src\x2C dest\x2C mode\x2C callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0;\n  }\n\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode\x2C 'copyFile');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.copyFile(src\x2C dest\x2C mode\x2C req);\n}\n\n/**\n * Synchronously copies `src` to `dest`. By\n * default\x2C `dest` is overwritten if it already exists.\n * @param {string | Buffer | URL} src\n * @param {string | Buffer | URL} dest\n * @param {number} [mode]\n * @returns {void}\n */\nfunction copyFileSync(src\x2C dest\x2C mode) {\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n\n  const ctx = { path: src\x2C dest };  // non-prefixed\n\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode\x2C 'copyFile');\n  binding.copyFile(src\x2C dest\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously copies `src` to `dest`. `src` can be a file\x2C directory\x2C or\n * symlink. The contents of directories will be copied recursively.\n * @param {string | URL} src\n * @param {string | URL} dest\n * @param {object} [options]\n * @param {() => any} callback\n * @returns {void}\n */\nfunction cp(src\x2C dest\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  callback = makeCallback(callback);\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  lazyLoadCp();\n  cpFn(src\x2C dest\x2C options\x2C callback);\n}\n\n/**\n * Synchronously copies `src` to `dest`. `src` can be a file\x2C directory\x2C or\n * symlink. The contents of directories will be copied recursively.\n * @param {string | URL} src\n * @param {string | URL} dest\n * @param {object} [options]\n * @returns {void}\n */\nfunction cpSync(src\x2C dest\x2C options) {\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  lazyLoadCp();\n  cpSyncFn(src\x2C dest\x2C options);\n}\n\nfunction lazyLoadStreams() {\n  if (!ReadStream) {\n    ({ ReadStream\x2C WriteStream } = require('internal/fs/streams'));\n    FileReadStream = ReadStream;\n    FileWriteStream = WriteStream;\n  }\n}\n\n/**\n * Creates a readable stream with a default `highWaterMark`\n * of 64 KiB.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   flags?: string;\n *   encoding?: string;\n *   fd?: number | FileHandle;\n *   mode?: number;\n *   autoClose?: boolean;\n *   emitClose?: boolean;\n *   start: number;\n *   end?: number;\n *   highWaterMark?: number;\n *   fs?: object | null;\n *   }} [options]\n * @returns {ReadStream}\n */\nfunction createReadStream(path\x2C options) {\n  lazyLoadStreams();\n  return new ReadStream(path\x2C options);\n}\n\n/**\n * Creates a write stream.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   flags?: string;\n *   encoding?: string;\n *   fd?: number | FileHandle;\n *   mode?: number;\n *   autoClose?: boolean;\n *   emitClose?: boolean;\n *   start: number;\n *   fs?: object | null;\n *   }} [options]\n * @returns {WriteStream}\n */\nfunction createWriteStream(path\x2C options) {\n  lazyLoadStreams();\n  return new WriteStream(path\x2C options);\n}\n\nmodule.exports = fs = {\n  appendFile\x2C\n  appendFileSync\x2C\n  access\x2C\n  accessSync\x2C\n  chown\x2C\n  chownSync\x2C\n  chmod\x2C\n  chmodSync\x2C\n  close\x2C\n  closeSync\x2C\n  copyFile\x2C\n  copyFileSync\x2C\n  cp\x2C\n  cpSync\x2C\n  createReadStream\x2C\n  createWriteStream\x2C\n  exists\x2C\n  existsSync\x2C\n  fchown\x2C\n  fchownSync\x2C\n  fchmod\x2C\n  fchmodSync\x2C\n  fdatasync\x2C\n  fdatasyncSync\x2C\n  fstat\x2C\n  fstatSync\x2C\n  fsync\x2C\n  fsyncSync\x2C\n  ftruncate\x2C\n  ftruncateSync\x2C\n  futimes\x2C\n  futimesSync\x2C\n  lchown\x2C\n  lchownSync\x2C\n  lchmod: constants.O_SYMLINK !== undefined ? lchmod : undefined\x2C\n  lchmodSync: constants.O_SYMLINK !== undefined ? lchmodSync : undefined\x2C\n  link\x2C\n  linkSync\x2C\n  lstat\x2C\n  lstatSync\x2C\n  lutimes\x2C\n  lutimesSync\x2C\n  mkdir\x2C\n  mkdirSync\x2C\n  mkdtemp\x2C\n  mkdtempSync\x2C\n  open\x2C\n  openSync\x2C\n  opendir\x2C\n  opendirSync\x2C\n  readdir\x2C\n  readdirSync\x2C\n  read\x2C\n  readSync\x2C\n  readv\x2C\n  readvSync\x2C\n  readFile\x2C\n  readFileSync\x2C\n  readlink\x2C\n  readlinkSync\x2C\n  realpath\x2C\n  realpathSync\x2C\n  rename\x2C\n  renameSync\x2C\n  rm\x2C\n  rmSync\x2C\n  rmdir\x2C\n  rmdirSync\x2C\n  stat\x2C\n  statfs\x2C\n  statSync\x2C\n  statfsSync\x2C\n  symlink\x2C\n  symlinkSync\x2C\n  truncate\x2C\n  truncateSync\x2C\n  unwatchFile\x2C\n  unlink\x2C\n  unlinkSync\x2C\n  utimes\x2C\n  utimesSync\x2C\n  watch\x2C\n  watchFile\x2C\n  writeFile\x2C\n  writeFileSync\x2C\n  write\x2C\n  writeSync\x2C\n  writev\x2C\n  writevSync\x2C\n  Dir\x2C\n  Dirent\x2C\n  Stats\x2C\n\n  get ReadStream() {\n    lazyLoadStreams();\n    return ReadStream;\n  }\x2C\n\n  set ReadStream(val) {\n    ReadStream = val;\n  }\x2C\n\n  get WriteStream() {\n    lazyLoadStreams();\n    return WriteStream;\n  }\x2C\n\n  set WriteStream(val) {\n    WriteStream = val;\n  }\x2C\n\n  // Legacy names... these have to be separate because of how graceful-fs\n  // (and possibly other) modules monkey patch the values.\n  get FileReadStream() {\n    lazyLoadStreams();\n    return FileReadStream;\n  }\x2C\n\n  set FileReadStream(val) {\n    FileReadStream = val;\n  }\x2C\n\n  get FileWriteStream() {\n    lazyLoadStreams();\n    return FileWriteStream;\n  }\x2C\n\n  set FileWriteStream(val) {\n    FileWriteStream = val;\n  }\x2C\n\n  // For tests\n  _toUnixTimestamp: toUnixTimestamp\x2C\n};\n\nObjectDefineProperties(fs\x2C {\n  F_OK: { __proto__: null\x2C enumerable: true\x2C value: F_OK || 0 }\x2C\n  R_OK: { __proto__: null\x2C enumerable: true\x2C value: R_OK || 0 }\x2C\n  W_OK: { __proto__: null\x2C enumerable: true\x2C value: W_OK || 0 }\x2C\n  X_OK: { __proto__: null\x2C enumerable: true\x2C value: X_OK || 0 }\x2C\n  constants: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\x2C\n  }\x2C\n  promises: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      promises ??= require('internal/fs/promises').exports;\n      return promises;\n    }\x2C\n  }\x2C\n});\n
code-source-info,0x1fa4d1d6dfc0,76,69085,72976,C0O69102C6O69112C12O69135C18O69139C24O69161C28O69194C38O69209C44O69209C48O69228C54O69243C60O69243C67O69272C69O69280C71O69279C75O69327C79O69332C85O69334C94O69344C96O69373C98O69398C99O69424C105O69424C111O69459C117O69459C123O69493C126O69540C128O69615C130O69710C132O69786C134O69820C140O69837C146O69867C151O69949C157O69982C165O69990C172O70002C178O70010C186O70016C190O70027C196O70027C212O70010C217O70079C223O70079C227O70122C233O70122C238O70265C242O70261C247O70320C253O70320C259O70342C262O70366C264O70377C269O70406C275O70406C282O70442C284O70453C291O70465C293O70481C297O70503C304O70530C306O70541C312O70577C323O70541C335O70589C337O70607C350O70607C355O70605C359O70651C361O70664C365O70751C371O70751C385O70769C391O70771C403O70781C408O70799C414O70814C418O70822C426O70834C430O70803C443O70867C447O70875C455O70887C459O70856C466O70908C468O70929C470O70954C472O71000C479O71005C485O71007C494O71022C496O71055C503O71237C509O71248C515O71248C521O71290C529O71298C536O71326C542O71334C560O71334C566O71379C572O71379C576O71415C582O71438C586O71420C593O71468C599O71468C604O71487C611O71492C617O71494C626O71519C628O71673C631O71689C634O71699C640O71737C647O71766C656O71737C663O71796C671O71825C680O71796C687O71843C701O71858C707O71887C713O71887C720O71931C726O71931C733O71964C737O72011C745O72019C752O72035C758O72043C776O72043C781O72090C787O72090C791O72127C797O72148C815O72148C822O72203C828O72203C832O72246C838O72272C844O72272C851O72310C858O72315C864O72317C873O72348C879O72374C885O72374C891O72447C897O72462C905O72484C909O72484C916O72462C924O72543C930O72560C936O72592C941O72678C947O72706C953O72706C960O72737C968O72745C975O72759C981O72767C989O72773C993O72784C999O72784C1015O72767C1020O72838C1026O72838C1030O72883C1036O72883C1041O70250C1047O72907C1054O72912C1060O72914C1069O72934C1073O72941C1078O72974,,
tick,0x19594db80,119000,0,0x0,3,0x0,0x1fa4d1d6cd7b,0x1fa4d1d6ca1e,0x1fa4d1d6c5c9,0x202f0287621a
tick,0x19594de58,119000,0,0x0,3,0x0,0x1fa4d1d6d773,0x1fa4d1d6d001,0x1fa4d1d6ca1e,0x1fa4d1d6c5c9,0x202f0287621a
tick,0x1959599fc,119000,0,0x0,3,0x0,0x1fa4d1d6d773,0x1fa4d1d6d001,0x1fa4d1d6ca1e,0x1fa4d1d6c5c9,0x202f0287621a
tick,0x1959e9414,119042,0,0x0,3,0x0,0x1fa4d1d6d773,0x1fa4d1d6d001,0x1fa4d1d6ca1e,0x1fa4d1d6c5c9,0x202f0287621a
code-creation,LazyCompile,10,119084,0x1fa4d1d74bf8,135,getOptions node:internal/fs/utils:320:20,0x25dc1a8494f0,~
script-source,80,node:internal/fs/utils,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  BigInt\x2C\n  Date\x2C\n  DateNow\x2C\n  DatePrototypeGetTime\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeCall\x2C\n  Number\x2C\n  NumberIsFinite\x2C\n  MathMin\x2C\n  MathRound\x2C\n  ObjectIs\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  ReflectOwnKeys\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  Symbol\x2C\n  TypedArrayPrototypeIncludes\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst {\n  codes: {\n    ERR_FS_EISDIR\x2C\n    ERR_FS_INVALID_SYMLINK_TYPE\x2C\n    ERR_INCOMPATIBLE_OPTION_PAIR\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n  }\x2C\n  hideStackFrames\x2C\n  uvException\x2C\n} = require('internal/errors');\nconst {\n  isArrayBufferView\x2C\n  isBigInt64Array\x2C\n  isDate\x2C\n  isUint8Array\x2C\n} = require('internal/util/types');\nconst {\n  kEmptyObject\x2C\n  once\x2C\n} = require('internal/util');\nconst { toPathIfFileURL } = require('internal/url');\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateInteger\x2C\n  validateObject\x2C\n  validateUint32\x2C\n} = require('internal/validators');\nconst pathModule = require('path');\nconst kType = Symbol('type');\nconst kStats = Symbol('stats');\nconst assert = require('internal/assert');\n\nconst {\n  fs: {\n    F_OK = 0\x2C\n    W_OK = 0\x2C\n    R_OK = 0\x2C\n    X_OK = 0\x2C\n    COPYFILE_EXCL\x2C\n    COPYFILE_FICLONE\x2C\n    COPYFILE_FICLONE_FORCE\x2C\n    O_APPEND\x2C\n    O_CREAT\x2C\n    O_EXCL\x2C\n    O_RDONLY\x2C\n    O_RDWR\x2C\n    O_SYNC\x2C\n    O_TRUNC\x2C\n    O_WRONLY\x2C\n    S_IFBLK\x2C\n    S_IFCHR\x2C\n    S_IFDIR\x2C\n    S_IFIFO\x2C\n    S_IFLNK\x2C\n    S_IFMT\x2C\n    S_IFREG\x2C\n    S_IFSOCK\x2C\n    UV_FS_SYMLINK_DIR\x2C\n    UV_FS_SYMLINK_JUNCTION\x2C\n    UV_DIRENT_UNKNOWN\x2C\n    UV_DIRENT_FILE\x2C\n    UV_DIRENT_DIR\x2C\n    UV_DIRENT_LINK\x2C\n    UV_DIRENT_FIFO\x2C\n    UV_DIRENT_SOCKET\x2C\n    UV_DIRENT_CHAR\x2C\n    UV_DIRENT_BLOCK\x2C\n  }\x2C\n  os: {\n    errno: {\n      EISDIR\x2C\n    }\x2C\n  }\x2C\n} = internalBinding('constants');\n\n// The access modes can be any of F_OK\x2C R_OK\x2C W_OK or X_OK. Some might not be\n// available on specific systems. They can be used in combination as well\n// (F_OK | R_OK | W_OK | X_OK).\nconst kMinimumAccessMode = MathMin(F_OK\x2C W_OK\x2C R_OK\x2C X_OK);\nconst kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;\n\nconst kDefaultCopyMode = 0;\n// The copy modes can be any of COPYFILE_EXCL\x2C COPYFILE_FICLONE or\n// COPYFILE_FICLONE_FORCE. They can be used in combination as well\n// (COPYFILE_EXCL | COPYFILE_FICLONE | COPYFILE_FICLONE_FORCE).\nconst kMinimumCopyMode = MathMin(\n  kDefaultCopyMode\x2C\n  COPYFILE_EXCL\x2C\n  COPYFILE_FICLONE\x2C\n  COPYFILE_FICLONE_FORCE\x2C\n);\nconst kMaximumCopyMode = COPYFILE_EXCL |\n                         COPYFILE_FICLONE |\n                         COPYFILE_FICLONE_FORCE;\n\n// Most platforms don't allow reads or writes >= 2 GiB.\n// See https://github.com/libuv/libuv/pull/1501.\nconst kIoMaxLength = 2 ** 31 - 1;\n\n// Use 64kb in case the file type is not a regular file and thus do not know the\n// actual file size. Increasing the value further results in more frequent over\n// allocation for small files and consumes CPU time and memory that should be\n// used else wise.\n// Use up to 512kb per read otherwise to partition reading big files to prevent\n// blocking other threads in case the available threads are all in use.\nconst kReadFileUnknownBufferLength = 64 * 1024;\nconst kReadFileBufferLength = 512 * 1024;\n\nconst kWriteFileMaxChunkSize = 512 * 1024;\n\nconst kMaxUserId = 2 ** 32 - 1;\n\nconst isWindows = process.platform === 'win32';\n\nlet fs;\nfunction lazyLoadFs() {\n  if (!fs) {\n    fs = require('fs');\n  }\n  return fs;\n}\n\nfunction assertEncoding(encoding) {\n  if (encoding && !Buffer.isEncoding(encoding)) {\n    const reason = 'is invalid encoding';\n    throw new ERR_INVALID_ARG_VALUE(encoding\x2C 'encoding'\x2C reason);\n  }\n}\n\nclass Dirent {\n  constructor(name\x2C type\x2C path) {\n    this.name = name;\n    this.path = path;\n    this[kType] = type;\n  }\n\n  isDirectory() {\n    return this[kType] === UV_DIRENT_DIR;\n  }\n\n  isFile() {\n    return this[kType] === UV_DIRENT_FILE;\n  }\n\n  isBlockDevice() {\n    return this[kType] === UV_DIRENT_BLOCK;\n  }\n\n  isCharacterDevice() {\n    return this[kType] === UV_DIRENT_CHAR;\n  }\n\n  isSymbolicLink() {\n    return this[kType] === UV_DIRENT_LINK;\n  }\n\n  isFIFO() {\n    return this[kType] === UV_DIRENT_FIFO;\n  }\n\n  isSocket() {\n    return this[kType] === UV_DIRENT_SOCKET;\n  }\n}\n\nclass DirentFromStats extends Dirent {\n  constructor(name\x2C stats\x2C path) {\n    super(name\x2C null\x2C path);\n    this[kStats] = stats;\n  }\n}\n\nfor (const name of ReflectOwnKeys(Dirent.prototype)) {\n  if (name === 'constructor') {\n    continue;\n  }\n  DirentFromStats.prototype[name] = function() {\n    return this[kStats][name]();\n  };\n}\n\nfunction copyObject(source) {\n  const target = {};\n  for (const key in source)\n    target[key] = source[key];\n  return target;\n}\n\nconst bufferSep = Buffer.from(pathModule.sep);\n\nfunction join(path\x2C name) {\n  if ((typeof path === 'string' || isUint8Array(path)) &&\n      name === undefined) {\n    return path;\n  }\n\n  if (typeof path === 'string' && isUint8Array(name)) {\n    const pathBuffer = Buffer.from(pathModule.join(path\x2C pathModule.sep));\n    return Buffer.concat([pathBuffer\x2C name]);\n  }\n\n  if (typeof path === 'string' && typeof name === 'string') {\n    return pathModule.basename(path) === name ? path : pathModule.join(path\x2C name);\n  }\n\n  if (isUint8Array(path) && isUint8Array(name)) {\n    return Buffer.concat([path\x2C bufferSep\x2C name]);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'path'\x2C ['string'\x2C 'Buffer']\x2C path);\n}\n\nfunction getDirents(path\x2C { 0: names\x2C 1: types }\x2C callback) {\n  let i;\n  if (typeof callback === 'function') {\n    const len = names.length;\n    let toFinish = 0;\n    callback = once(callback);\n    for (i = 0; i < len; i++) {\n      const type = types[i];\n      if (type === UV_DIRENT_UNKNOWN) {\n        const name = names[i];\n        const idx = i;\n        toFinish++;\n        let filepath;\n        try {\n          filepath = join(path\x2C name);\n        } catch (err) {\n          callback(err);\n          return;\n        }\n        lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\n          if (err) {\n            callback(err);\n            return;\n          }\n          names[idx] = new DirentFromStats(name\x2C stats\x2C path);\n          if (--toFinish === 0) {\n            callback(null\x2C names);\n          }\n        });\n      } else {\n        names[i] = new Dirent(names[i]\x2C types[i]\x2C path);\n      }\n    }\n    if (toFinish === 0) {\n      callback(null\x2C names);\n    }\n  } else {\n    const len = names.length;\n    for (i = 0; i < len; i++) {\n      names[i] = getDirent(path\x2C names[i]\x2C types[i]);\n    }\n    return names;\n  }\n}\n\nfunction getDirent(path\x2C name\x2C type\x2C callback) {\n  if (typeof callback === 'function') {\n    if (type === UV_DIRENT_UNKNOWN) {\n      let filepath;\n      try {\n        filepath = join(path\x2C name);\n      } catch (err) {\n        callback(err);\n        return;\n      }\n      lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\n        if (err) {\n          callback(err);\n          return;\n        }\n        callback(null\x2C new DirentFromStats(name\x2C stats\x2C filepath));\n      });\n    } else {\n      callback(null\x2C new Dirent(name\x2C type\x2C path));\n    }\n  } else if (type === UV_DIRENT_UNKNOWN) {\n    const filepath = join(path\x2C name);\n    const stats = lazyLoadFs().lstatSync(filepath);\n    return new DirentFromStats(name\x2C stats\x2C path);\n  } else {\n    return new Dirent(name\x2C type\x2C path);\n  }\n}\n\nfunction getOptions(options\x2C defaultOptions = kEmptyObject) {\n  if (options == null || typeof options === 'function') {\n    return defaultOptions;\n  }\n\n  if (typeof options === 'string') {\n    defaultOptions = { ...defaultOptions };\n    defaultOptions.encoding = options;\n    options = defaultOptions;\n  } else if (typeof options !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C ['string'\x2C 'Object']\x2C options);\n  }\n\n  if (options.encoding !== 'buffer')\n    assertEncoding(options.encoding);\n\n  if (options.signal !== undefined) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n\n  return options;\n}\n\n/**\n * @param {InternalFSBinding.FSSyncContext} ctx\n */\nfunction handleErrorFromBinding(ctx) {\n  if (ctx.errno !== undefined) {  // libuv error numbers\n    const err = uvException(ctx);\n    ErrorCaptureStackTrace(err\x2C handleErrorFromBinding);\n    throw err;\n  }\n  if (ctx.error !== undefined) {  // Errors created in C++ land.\n    // TODO(joyeecheung): currently\x2C ctx.error are encoding errors\n    // usually caused by memory problems. We need to figure out proper error\n    // code(s) for this.\n    ErrorCaptureStackTrace(ctx.error\x2C handleErrorFromBinding);\n    throw ctx.error;\n  }\n}\n\n// Check if the path contains null types if it is a string nor Uint8Array\x2C\n// otherwise return silently.\nconst nullCheck = hideStackFrames((path\x2C propName\x2C throwError = true) => {\n  const pathIsString = typeof path === 'string';\n  const pathIsUint8Array = isUint8Array(path);\n\n  // We can only perform meaningful checks on strings and Uint8Arrays.\n  if ((!pathIsString && !pathIsUint8Array) ||\n      (pathIsString && !StringPrototypeIncludes(path\x2C '\\u0000')) ||\n      (pathIsUint8Array && !TypedArrayPrototypeIncludes(path\x2C 0))) {\n    return;\n  }\n\n  const err = new ERR_INVALID_ARG_VALUE(\n    propName\x2C\n    path\x2C\n    'must be a string or Uint8Array without null bytes'\x2C\n  );\n  if (throwError) {\n    throw err;\n  }\n  return err;\n});\n\nfunction preprocessSymlinkDestination(path\x2C type\x2C linkPath) {\n  if (!isWindows) {\n    // No preprocessing is needed on Unix.\n    return path;\n  }\n  path = '' + path;\n  if (type === 'junction') {\n    // Junctions paths need to be absolute and \\\\?\\-prefixed.\n    // A relative target is relative to the link's parent directory.\n    path = pathModule.resolve(linkPath\x2C '..'\x2C path);\n    return pathModule.toNamespacedPath(path);\n  }\n  if (pathModule.isAbsolute(path)) {\n    // If the path is absolute\x2C use the \\\\?\\-prefix to enable long filenames\n    return pathModule.toNamespacedPath(path);\n  }\n  // Windows symlinks don't tolerate forward slashes.\n  return RegExpPrototypeSymbolReplace(/\\//g\x2C path\x2C '\\\\');\n}\n\n// Constructor for file stats.\nfunction StatsBase(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                   ino\x2C size\x2C blocks) {\n  this.dev = dev;\n  this.mode = mode;\n  this.nlink = nlink;\n  this.uid = uid;\n  this.gid = gid;\n  this.rdev = rdev;\n  this.blksize = blksize;\n  this.ino = ino;\n  this.size = size;\n  this.blocks = blocks;\n}\n\nStatsBase.prototype.isDirectory = function() {\n  return this._checkModeProperty(S_IFDIR);\n};\n\nStatsBase.prototype.isFile = function() {\n  return this._checkModeProperty(S_IFREG);\n};\n\nStatsBase.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(S_IFBLK);\n};\n\nStatsBase.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(S_IFCHR);\n};\n\nStatsBase.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(S_IFLNK);\n};\n\nStatsBase.prototype.isFIFO = function() {\n  return this._checkModeProperty(S_IFIFO);\n};\n\nStatsBase.prototype.isSocket = function() {\n  return this._checkModeProperty(S_IFSOCK);\n};\n\nconst kNsPerMsBigInt = 10n ** 6n;\nconst kNsPerSecBigInt = 10n ** 9n;\nconst kMsPerSec = 10 ** 3;\nconst kNsPerMs = 10 ** 6;\nfunction msFromTimeSpec(sec\x2C nsec) {\n  return sec * kMsPerSec + nsec / kNsPerMs;\n}\n\nfunction nsFromTimeSpecBigInt(sec\x2C nsec) {\n  return sec * kNsPerSecBigInt + nsec;\n}\n\n// The Date constructor performs Math.floor() on the absolute value\n// of the timestamp: https://tc39.es/ecma262/#sec-timeclip\n// Since there may be a precision loss when the timestamp is\n// converted to a floating point number\x2C we manually round\n// the timestamp here before passing it to Date().\n// Refs: https://github.com/nodejs/node/pull/12607\n// Refs: https://github.com/nodejs/node/pull/43714\nfunction dateFromMs(ms) {\n  // Coercing to number\x2C ms can be bigint\n  return new Date(MathRound(Number(ms)));\n}\n\nfunction BigIntStats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                     ino\x2C size\x2C blocks\x2C\n                     atimeNs\x2C mtimeNs\x2C ctimeNs\x2C birthtimeNs) {\n  ReflectApply(StatsBase\x2C this\x2C [dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                                 ino\x2C size\x2C blocks]);\n\n  this.atimeMs = atimeNs / kNsPerMsBigInt;\n  this.mtimeMs = mtimeNs / kNsPerMsBigInt;\n  this.ctimeMs = ctimeNs / kNsPerMsBigInt;\n  this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;\n  this.atimeNs = atimeNs;\n  this.mtimeNs = mtimeNs;\n  this.ctimeNs = ctimeNs;\n  this.birthtimeNs = birthtimeNs;\n  this.atime = dateFromMs(this.atimeMs);\n  this.mtime = dateFromMs(this.mtimeMs);\n  this.ctime = dateFromMs(this.ctimeMs);\n  this.birthtime = dateFromMs(this.birthtimeMs);\n}\n\nObjectSetPrototypeOf(BigIntStats.prototype\x2C StatsBase.prototype);\nObjectSetPrototypeOf(BigIntStats\x2C StatsBase);\n\nBigIntStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & BigInt(S_IFMT)) === BigInt(property);\n};\n\nfunction Stats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n               ino\x2C size\x2C blocks\x2C\n               atimeMs\x2C mtimeMs\x2C ctimeMs\x2C birthtimeMs) {\n  FunctionPrototypeCall(StatsBase\x2C this\x2C dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C\n                        blksize\x2C ino\x2C size\x2C blocks);\n  this.atimeMs = atimeMs;\n  this.mtimeMs = mtimeMs;\n  this.ctimeMs = ctimeMs;\n  this.birthtimeMs = birthtimeMs;\n  this.atime = dateFromMs(atimeMs);\n  this.mtime = dateFromMs(mtimeMs);\n  this.ctime = dateFromMs(ctimeMs);\n  this.birthtime = dateFromMs(birthtimeMs);\n}\n\nObjectSetPrototypeOf(Stats.prototype\x2C StatsBase.prototype);\nObjectSetPrototypeOf(Stats\x2C StatsBase);\n\n// HACK: Workaround for https://github.com/standard-things/esm/issues/821.\n// TODO(ronag): Remove this as soon as `esm` publishes a fixed version.\nStats.prototype.isFile = StatsBase.prototype.isFile;\n\nStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & S_IFMT) === property;\n};\n\n/**\n * @param {Float64Array | BigInt64Array} stats\n * @param {number} offset\n * @returns {BigIntStats | Stats}\n */\nfunction getStatsFromBinding(stats\x2C offset = 0) {\n  if (isBigInt64Array(stats)) {\n    return new BigIntStats(\n      stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\n      stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\n      stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\n      stats[9 + offset]\x2C\n      nsFromTimeSpecBigInt(stats[10 + offset]\x2C stats[11 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[12 + offset]\x2C stats[13 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[14 + offset]\x2C stats[15 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[16 + offset]\x2C stats[17 + offset])\x2C\n    );\n  }\n  return new Stats(\n    stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\n    stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\n    stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\n    stats[9 + offset]\x2C\n    msFromTimeSpec(stats[10 + offset]\x2C stats[11 + offset])\x2C\n    msFromTimeSpec(stats[12 + offset]\x2C stats[13 + offset])\x2C\n    msFromTimeSpec(stats[14 + offset]\x2C stats[15 + offset])\x2C\n    msFromTimeSpec(stats[16 + offset]\x2C stats[17 + offset])\x2C\n  );\n}\n\nclass StatFs {\n  constructor(type\x2C bsize\x2C blocks\x2C bfree\x2C bavail\x2C files\x2C ffree) {\n    this.type = type;\n    this.bsize = bsize;\n    this.blocks = blocks;\n    this.bfree = bfree;\n    this.bavail = bavail;\n    this.files = files;\n    this.ffree = ffree;\n  }\n}\n\nfunction getStatFsFromBinding(stats) {\n  return new StatFs(\n    stats[0]\x2C stats[1]\x2C stats[2]\x2C stats[3]\x2C stats[4]\x2C stats[5]\x2C stats[6]\x2C\n  );\n}\n\nfunction stringToFlags(flags\x2C name = 'flags') {\n  if (typeof flags === 'number') {\n    validateInt32(flags\x2C name);\n    return flags;\n  }\n\n  if (flags == null) {\n    return O_RDONLY;\n  }\n\n  switch (flags) {\n    case 'r' : return O_RDONLY;\n    case 'rs' : // Fall through.\n    case 'sr' : return O_RDONLY | O_SYNC;\n    case 'r+' : return O_RDWR;\n    case 'rs+' : // Fall through.\n    case 'sr+' : return O_RDWR | O_SYNC;\n\n    case 'w' : return O_TRUNC | O_CREAT | O_WRONLY;\n    case 'wx' : // Fall through.\n    case 'xw' : return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;\n\n    case 'w+' : return O_TRUNC | O_CREAT | O_RDWR;\n    case 'wx+': // Fall through.\n    case 'xw+': return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;\n\n    case 'a' : return O_APPEND | O_CREAT | O_WRONLY;\n    case 'ax' : // Fall through.\n    case 'xa' : return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;\n    case 'as' : // Fall through.\n    case 'sa' : return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;\n\n    case 'a+' : return O_APPEND | O_CREAT | O_RDWR;\n    case 'ax+': // Fall through.\n    case 'xa+': return O_APPEND | O_CREAT | O_RDWR | O_EXCL;\n    case 'as+': // Fall through.\n    case 'sa+': return O_APPEND | O_CREAT | O_RDWR | O_SYNC;\n  }\n\n  throw new ERR_INVALID_ARG_VALUE('flags'\x2C flags);\n}\n\nconst stringToSymlinkType = hideStackFrames((type) => {\n  let flags = 0;\n  if (typeof type === 'string') {\n    switch (type) {\n      case 'dir':\n        flags |= UV_FS_SYMLINK_DIR;\n        break;\n      case 'junction':\n        flags |= UV_FS_SYMLINK_JUNCTION;\n        break;\n      case 'file':\n        break;\n      default:\n        throw new ERR_FS_INVALID_SYMLINK_TYPE(type);\n    }\n  }\n  return flags;\n});\n\n// converts Date or number to a fractional UNIX timestamp\nfunction toUnixTimestamp(time\x2C name = 'time') {\n  // eslint-disable-next-line eqeqeq\n  if (typeof time === 'string' && +time == time) {\n    return +time;\n  }\n  if (NumberIsFinite(time)) {\n    if (time < 0) {\n      return DateNow() / 1000;\n    }\n    return time;\n  }\n  if (isDate(time)) {\n    // Convert to 123.456 UNIX timestamp\n    return DatePrototypeGetTime(time) / 1000;\n  }\n  throw new ERR_INVALID_ARG_TYPE(name\x2C ['Date'\x2C 'Time in seconds']\x2C time);\n}\n\nconst validateOffsetLengthRead = hideStackFrames(\n  (offset\x2C length\x2C bufferLength) => {\n    if (offset < 0) {\n      throw new ERR_OUT_OF_RANGE('offset'\x2C '>= 0'\x2C offset);\n    }\n    if (length < 0) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\n    }\n    if (offset + length > bufferLength) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C\n                                 `<= ${bufferLength - offset}`\x2C length);\n    }\n  }\x2C\n);\n\nconst validateOffsetLengthWrite = hideStackFrames(\n  (offset\x2C length\x2C byteLength) => {\n    if (offset > byteLength) {\n      throw new ERR_OUT_OF_RANGE('offset'\x2C `<= ${byteLength}`\x2C offset);\n    }\n\n    if (length > byteLength - offset) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C `<= ${byteLength - offset}`\x2C length);\n    }\n\n    if (length < 0) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\n    }\n\n    validateInt32(length\x2C 'length'\x2C 0);\n  }\x2C\n);\n\nconst validatePath = hideStackFrames((path\x2C propName = 'path') => {\n  if (typeof path !== 'string' && !isUint8Array(path)) {\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C ['string'\x2C 'Buffer'\x2C 'URL']\x2C path);\n  }\n\n  const err = nullCheck(path\x2C propName\x2C false);\n\n  if (err !== undefined) {\n    throw err;\n  }\n});\n\nconst getValidatedPath = hideStackFrames((fileURLOrPath\x2C propName = 'path') => {\n  const path = toPathIfFileURL(fileURLOrPath);\n  validatePath(path\x2C propName);\n  return path;\n});\n\nconst getValidatedFd = hideStackFrames((fd\x2C propName = 'fd') => {\n  if (ObjectIs(fd\x2C -0)) {\n    return 0;\n  }\n\n  validateInt32(fd\x2C propName\x2C 0);\n\n  return fd;\n});\n\nconst validateBufferArray = hideStackFrames((buffers\x2C propName = 'buffers') => {\n  if (!ArrayIsArray(buffers))\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\n\n  for (let i = 0; i < buffers.length; i++) {\n    if (!isArrayBufferView(buffers[i]))\n      throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\n  }\n\n  return buffers;\n});\n\nlet nonPortableTemplateWarn = true;\n\nfunction warnOnNonPortableTemplate(template) {\n  // Template strings passed to the mkdtemp() family of functions should not\n  // end with 'X' because they are handled inconsistently across platforms.\n  if (nonPortableTemplateWarn && StringPrototypeEndsWith(template\x2C 'X')) {\n    process.emitWarning('mkdtemp() templates ending with X are not portable. ' +\n                        'For details see: https://nodejs.org/api/fs.html');\n    nonPortableTemplateWarn = false;\n  }\n}\n\nconst defaultCpOptions = {\n  dereference: false\x2C\n  errorOnExist: false\x2C\n  filter: undefined\x2C\n  force: true\x2C\n  preserveTimestamps: false\x2C\n  recursive: false\x2C\n  verbatimSymlinks: false\x2C\n};\n\nconst defaultRmOptions = {\n  recursive: false\x2C\n  force: false\x2C\n  retryDelay: 100\x2C\n  maxRetries: 0\x2C\n};\n\nconst defaultRmdirOptions = {\n  retryDelay: 100\x2C\n  maxRetries: 0\x2C\n  recursive: false\x2C\n};\n\nconst validateCpOptions = hideStackFrames((options) => {\n  if (options === undefined)\n    return { ...defaultCpOptions };\n  validateObject(options\x2C 'options');\n  options = { ...defaultCpOptions\x2C ...options };\n  validateBoolean(options.dereference\x2C 'options.dereference');\n  validateBoolean(options.errorOnExist\x2C 'options.errorOnExist');\n  validateBoolean(options.force\x2C 'options.force');\n  validateBoolean(options.preserveTimestamps\x2C 'options.preserveTimestamps');\n  validateBoolean(options.recursive\x2C 'options.recursive');\n  validateBoolean(options.verbatimSymlinks\x2C 'options.verbatimSymlinks');\n  options.mode = getValidMode(options.mode\x2C 'copyFile');\n  if (options.dereference === true && options.verbatimSymlinks === true) {\n    throw new ERR_INCOMPATIBLE_OPTION_PAIR('dereference'\x2C 'verbatimSymlinks');\n  }\n  if (options.filter !== undefined) {\n    validateFunction(options.filter\x2C 'options.filter');\n  }\n  return options;\n});\n\nconst validateRmOptions = hideStackFrames((path\x2C options\x2C expectDir\x2C cb) => {\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\n  validateBoolean(options.force\x2C 'options.force');\n\n  lazyLoadFs().lstat(path\x2C (err\x2C stats) => {\n    if (err) {\n      if (options.force && err.code === 'ENOENT') {\n        return cb(null\x2C options);\n      }\n      return cb(err\x2C options);\n    }\n\n    if (expectDir && !stats.isDirectory()) {\n      return cb(false);\n    }\n\n    if (stats.isDirectory() && !options.recursive) {\n      return cb(new ERR_FS_EISDIR({\n        code: 'EISDIR'\x2C\n        message: 'is a directory'\x2C\n        path\x2C\n        syscall: 'rm'\x2C\n        errno: EISDIR\x2C\n      }));\n    }\n    return cb(null\x2C options);\n  });\n});\n\nconst validateRmOptionsSync = hideStackFrames((path\x2C options\x2C expectDir) => {\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\n  validateBoolean(options.force\x2C 'options.force');\n\n  if (!options.force || expectDir || !options.recursive) {\n    const isDirectory = lazyLoadFs()\n      .lstatSync(path\x2C { throwIfNoEntry: !options.force })?.isDirectory();\n\n    if (expectDir && !isDirectory) {\n      return false;\n    }\n\n    if (isDirectory && !options.recursive) {\n      throw new ERR_FS_EISDIR({\n        code: 'EISDIR'\x2C\n        message: 'is a directory'\x2C\n        path\x2C\n        syscall: 'rm'\x2C\n        errno: EISDIR\x2C\n      });\n    }\n  }\n\n  return options;\n});\n\nlet recursiveRmdirWarned = process.noDeprecation;\nfunction emitRecursiveRmdirWarning() {\n  if (!recursiveRmdirWarned) {\n    process.emitWarning(\n      'In future versions of Node.js\x2C fs.rmdir(path\x2C { recursive: true }) ' +\n      'will be removed. Use fs.rm(path\x2C { recursive: true }) instead'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0147'\x2C\n    );\n    recursiveRmdirWarned = true;\n  }\n}\n\nconst validateRmdirOptions = hideStackFrames(\n  (options\x2C defaults = defaultRmdirOptions) => {\n    if (options === undefined)\n      return defaults;\n    validateObject(options\x2C 'options');\n\n    options = { ...defaults\x2C ...options };\n\n    validateBoolean(options.recursive\x2C 'options.recursive');\n    validateInt32(options.retryDelay\x2C 'options.retryDelay'\x2C 0);\n    validateUint32(options.maxRetries\x2C 'options.maxRetries');\n\n    return options;\n  });\n\nconst getValidMode = hideStackFrames((mode\x2C type) => {\n  let min = kMinimumAccessMode;\n  let max = kMaximumAccessMode;\n  let def = F_OK;\n  if (type === 'copyFile') {\n    min = kMinimumCopyMode;\n    max = kMaximumCopyMode;\n    def = mode || kDefaultCopyMode;\n  } else {\n    assert(type === 'access');\n  }\n  if (mode == null) {\n    return def;\n  }\n  validateInteger(mode\x2C 'mode'\x2C min\x2C max);\n  return mode;\n});\n\nconst validateStringAfterArrayBufferView = hideStackFrames((buffer\x2C name) => {\n  if (typeof buffer === 'string') {\n    return;\n  }\n\n  if (\n    typeof buffer === 'object' &&\n    buffer !== null &&\n    typeof buffer.toString === 'function' &&\n    ObjectPrototypeHasOwnProperty(buffer\x2C 'toString')\n  ) {\n    return;\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    name\x2C\n    ['string'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n    buffer\x2C\n  );\n});\n\nconst validatePrimitiveStringAfterArrayBufferView = hideStackFrames((buffer\x2C name) => {\n  if (typeof buffer !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE(\n      name\x2C\n      ['string'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n      buffer\x2C\n    );\n  }\n});\n\nconst validatePosition = hideStackFrames((position\x2C name) => {\n  if (typeof position === 'number') {\n    validateInteger(position\x2C name);\n  } else if (typeof position === 'bigint') {\n    if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {\n      throw new ERR_OUT_OF_RANGE(name\x2C\n                                 `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`\x2C\n                                 position);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C ['integer'\x2C 'bigint']\x2C position);\n  }\n});\n\nmodule.exports = {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n    kReadFileBufferLength\x2C\n    kReadFileUnknownBufferLength\x2C\n    kWriteFileMaxChunkSize\x2C\n  }\x2C\n  assertEncoding\x2C\n  BigIntStats\x2C  // for testing\n  copyObject\x2C\n  Dirent\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirent\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getValidatedFd\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  handleErrorFromBinding\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  realpathCacheKey: Symbol('realpathCacheKey')\x2C\n  getStatFsFromBinding\x2C\n  getStatsFromBinding\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  Stats\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validatePath\x2C\n  validatePosition\x2C\n  validateRmOptions\x2C\n  validateRmOptionsSync\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  validatePrimitiveStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\x2C\n};\n
code-source-info,0x1fa4d1d74bf8,80,7434,8041,C9O7461C16O7479C27O7539C29O7561C30O7569C36O7608C41O7652C43O7676C47O7691C54O7726C60O7765C78O7771C83O7765C84O7858C91O7867C96O7885C99O7908C104O7885C108O7934C114O7962C119O7990C127O7962C132O8024C134O8039,,
code-creation,LazyCompile,10,120250,0x1fa4d1d76c78,48,assertEncoding node:internal/fs/utils:155:24,0x25dc1a848fc8,~
code-source-info,0x1fa4d1d76c78,80,3588,3765,C0O3603C6O3620C9O3627C14O3627C21O3670C24O3697C40O3703C45O3697C47O3764,,
code-creation,LazyCompile,10,120334,0x1fa4d1d76d90,20,toPathIfFileURL node:internal/url:1476:25,0x28e4ce8f5728,~
script-source,77,node:internal/url,'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeReduce\x2C\n  ArrayPrototypeSlice\x2C\n  Int8Array\x2C\n  IteratorPrototype\x2C\n  Number\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertySymbols\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ReflectGetOwnPropertyDescriptor\x2C\n  ReflectOwnKeys\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  SafeMap\x2C\n  StringPrototypeCharAt\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeCodePointAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolIterator\x2C\n  SymbolToStringTag\x2C\n  decodeURIComponent\x2C\n} = primordials;\n\nconst { inspect } = require('internal/util/inspect');\nconst {\n  encodeStr\x2C\n  hexTable\x2C\n  isHexTable\x2C\n} = require('internal/querystring');\n\nconst {\n  getConstructorOf\x2C\n  removeColors\x2C\n  toUSVString\x2C\n  kEnumerableProperty\x2C\n  SideEffectFreeRegExpPrototypeSymbolReplace\x2C\n} = require('internal/util');\n\nconst {\n  codes: {\n    ERR_ARG_NOT_ITERABLE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_FILE_URL_HOST\x2C\n    ERR_INVALID_FILE_URL_PATH\x2C\n    ERR_INVALID_THIS\x2C\n    ERR_INVALID_TUPLE\x2C\n    ERR_INVALID_URL\x2C\n    ERR_INVALID_URL_SCHEME\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_NO_CRYPTO\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  CHAR_AMPERSAND\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_EQUAL\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_PERCENT\x2C\n  CHAR_PLUS\x2C\n} = require('internal/constants');\nconst path = require('path');\n\nconst {\n  validateFunction\x2C\n} = require('internal/validators');\n\nconst querystring = require('querystring');\n\nconst { platform } = process;\nconst isWindows = platform === 'win32';\n\nconst bindingUrl = internalBinding('url');\n\nconst {\n  storeDataObject\x2C\n  revokeDataObject\x2C\n} = internalBinding('blob');\n\nconst FORWARD_SLASH = /\\//g;\n\nconst context = Symbol('context');\nconst searchParams = Symbol('query');\n\nconst updateActions = {\n  kProtocol: 0\x2C\n  kHost: 1\x2C\n  kHostname: 2\x2C\n  kPort: 3\x2C\n  kUsername: 4\x2C\n  kPassword: 5\x2C\n  kPathname: 6\x2C\n  kSearch: 7\x2C\n  kHash: 8\x2C\n  kHref: 9\x2C\n};\nlet blob;\nlet cryptoRandom;\n\nfunction lazyBlob() {\n  blob ??= require('internal/blob');\n  return blob;\n}\n\nfunction lazyCryptoRandom() {\n  try {\n    cryptoRandom ??= require('internal/crypto/random');\n  } catch {\n    // If Node.js built without crypto support\x2C we'll fall\n    // through here and handle it later.\n  }\n  return cryptoRandom;\n}\n\n// This class provides the internal state of a URL object. An instance of this\n// class is stored in every URL object and is accessed internally by setters\n// and getters. It roughly corresponds to the concept of a URL record in the\n// URL Standard\x2C with a few differences. It is also the object transported to\n// the C++ binding.\n// Refs: https://url.spec.whatwg.org/#concept-url\nclass URLContext {\n  // This is the maximum value uint32_t can get.\n  // Ada uses uint32_t(-1) for declaring omitted values.\n  static #omitted = 4294967295;\n\n  href = '';\n  protocol_end = 0;\n  username_end = 0;\n  host_start = 0;\n  host_end = 0;\n  pathname_start = 0;\n  search_start = 0;\n  hash_start = 0;\n  port = 0;\n  /**\n   * Refers to `ada::scheme::type`\n   *\n   * enum type : uint8_t {\n   *   HTTP = 0\x2C\n   *   NOT_SPECIAL = 1\x2C\n   *   HTTPS = 2\x2C\n   *   WS = 3\x2C\n   *   FTP = 4\x2C\n   *   WSS = 5\x2C\n   *   FILE = 6\n   * };\n   * @type {number}\n   */\n  scheme_type = 1;\n\n  get hasPort() {\n    return this.port !== URLContext.#omitted;\n  }\n\n  get hasSearch() {\n    return this.search_start !== URLContext.#omitted;\n  }\n\n  get hasHash() {\n    return this.hash_start !== URLContext.#omitted;\n  }\n}\n\nfunction isURLSearchParams(self) {\n  return self && self[searchParams] && !self[searchParams][searchParams];\n}\n\nclass URLSearchParams {\n  [searchParams] = [];\n\n  // "associated url object"\n  [context] = null;\n\n  // URL Standard says the default value is ''\x2C but as undefined and '' have\n  // the same result\x2C undefined is used to prevent unnecessary parsing.\n  // Default parameter is necessary to keep URLSearchParams.length === 0 in\n  // accordance with Web IDL spec.\n  constructor(init = undefined) {\n    if (init == null) {\n      // Do nothing\n    } else if (typeof init === 'object' || typeof init === 'function') {\n      const method = init[SymbolIterator];\n      if (method === this[SymbolIterator]) {\n        // While the spec does not have this branch\x2C we can use it as a\n        // shortcut to avoid having to go through the costly generic iterator.\n        const childParams = init[searchParams];\n        this[searchParams] = childParams.slice();\n      } else if (method != null) {\n        // Sequence<sequence<USVString>>\n        if (typeof method !== 'function') {\n          throw new ERR_ARG_NOT_ITERABLE('Query pairs');\n        }\n\n        // The following implementationd differs from the URL specification:\n        // Sequences must first be converted from ECMAScript objects before\n        // and operations are done on them\x2C and the operation of converting\n        // the sequences would first exhaust the iterators. If the iterator\n        // returns something invalid in the middle\x2C whether it would be called\n        // after that would be an observable change to the users.\n        // Exhausting the iterator and later converting them to USVString comes\n        // with a significant cost (~40-80%). In order optimize URLSearchParams\n        // creation duration\x2C Node.js merges the iteration and converting\n        // iterations into a single iteration.\n        for (const pair of init) {\n          if (pair == null) {\n            throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n          } else if (ArrayIsArray(pair)) {\n            // If innerSequence's size is not 2\x2C then throw a TypeError.\n            if (pair.length !== 2) {\n              throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n            }\n            // Append (innerSequence[0]\x2C innerSequence[1]) to querys list.\n            ArrayPrototypePush(this[searchParams]\x2C toUSVString(pair[0])\x2C toUSVString(pair[1]));\n          } else {\n            if (((typeof pair !== 'object' && typeof pair !== 'function') ||\n                typeof pair[SymbolIterator] !== 'function')) {\n              throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n            }\n\n            let length = 0;\n\n            for (const element of pair) {\n              length++;\n              ArrayPrototypePush(this[searchParams]\x2C toUSVString(element));\n            }\n\n            // If innerSequence's size is not 2\x2C then throw a TypeError.\n            if (length !== 2) {\n              throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n            }\n          }\n        }\n      } else {\n        // Record<USVString\x2C USVString>\n        // Need to use reflection APIs for full spec compliance.\n        const visited = new SafeMap();\n        const keys = ReflectOwnKeys(init);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const desc = ReflectGetOwnPropertyDescriptor(init\x2C key);\n          if (desc !== undefined && desc.enumerable) {\n            const typedKey = toUSVString(key);\n            const typedValue = toUSVString(init[key]);\n\n            // Two different keys may become the same USVString after normalization.\n            // In that case\x2C we retain the later one. Refer to WPT.\n            const keyIdx = visited.get(typedKey);\n            if (keyIdx !== undefined) {\n              this[searchParams][keyIdx] = typedValue;\n            } else {\n              visited.set(typedKey\x2C ArrayPrototypePush(this[searchParams]\x2C\n                                                       typedKey\x2C\n                                                       typedValue) - 1);\n            }\n          }\n        }\n      }\n    } else {\n      // https://url.spec.whatwg.org/#dom-urlsearchparams-urlsearchparams\n      init = toUSVString(init);\n      this[searchParams] = init ? parseParams(init) : [];\n    }\n  }\n\n  [inspect.custom](recurseTimes\x2C ctx) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]'\x2C 'special');\n\n    const separator = '\x2C ';\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const innerInspect = (v) => inspect(v\x2C innerOpts);\n\n    const list = this[searchParams];\n    const output = [];\n    for (let i = 0; i < list.length; i += 2)\n      ArrayPrototypePush(\n        output\x2C\n        `${innerInspect(list[i])} => ${innerInspect(list[i + 1])}`);\n\n    const length = ArrayPrototypeReduce(\n      output\x2C\n      (prev\x2C cur) => prev + removeColors(cur).length + separator.length\x2C\n      -separator.length\x2C\n    );\n    if (length > ctx.breakLength) {\n      return `${this.constructor.name} {\\n` +\n      `  ${ArrayPrototypeJoin(output\x2C '\x2C\\n  ')} }`;\n    } else if (output.length) {\n      return `${this.constructor.name} { ` +\n      `${ArrayPrototypeJoin(output\x2C separator)} }`;\n    }\n    return `${this.constructor.name} {}`;\n  }\n\n  get size() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    return this[searchParams].length / 2;\n  }\n\n  append(name\x2C value) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\n    }\n\n    name = toUSVString(name);\n    value = toUSVString(value);\n    ArrayPrototypePush(this[searchParams]\x2C name\x2C value);\n    if (this[context]) {\n      this[context].search = this.toString();\n    }\n  }\n\n  delete(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        list.splice(i\x2C 2);\n      } else {\n        i += 2;\n      }\n    }\n    if (this[context]) {\n      this[context].search = this.toString();\n    }\n  }\n\n  get(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return list[i + 1];\n      }\n    }\n    return null;\n  }\n\n  getAll(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    const values = [];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        values.push(list[i + 1]);\n      }\n    }\n    return values;\n  }\n\n  has(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  set(name\x2C value) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    value = toUSVString(value);\n\n    // If there are any name-value pairs whose name is `name`\x2C in `list`\x2C set\n    // the value of the first such name-value pair to `value` and remove the\n    // others.\n    let found = false;\n    for (let i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        if (!found) {\n          list[i + 1] = value;\n          found = true;\n          i += 2;\n        } else {\n          list.splice(i\x2C 2);\n        }\n      } else {\n        i += 2;\n      }\n    }\n\n    // Otherwise\x2C append a new name-value pair whose name is `name` and value\n    // is `value`\x2C to `list`.\n    if (!found) {\n      ArrayPrototypePush(list\x2C name\x2C value);\n    }\n\n    if (this[context]) {\n      this[context].search = this.toString();\n    }\n  }\n\n  sort() {\n    const a = this[searchParams];\n    const len = a.length;\n\n    if (len <= 2) {\n      // Nothing needs to be done.\n    } else if (len < 100) {\n      // 100 is found through testing.\n      // Simple stable in-place insertion sort\n      // Derived from v8/src/js/array.js\n      for (let i = 2; i < len; i += 2) {\n        const curKey = a[i];\n        const curVal = a[i + 1];\n        let j;\n        for (j = i - 2; j >= 0; j -= 2) {\n          if (a[j] > curKey) {\n            a[j + 2] = a[j];\n            a[j + 3] = a[j + 1];\n          } else {\n            break;\n          }\n        }\n        a[j + 2] = curKey;\n        a[j + 3] = curVal;\n      }\n    } else {\n      // Bottom-up iterative stable merge sort\n      const lBuffer = new Array(len);\n      const rBuffer = new Array(len);\n      for (let step = 2; step < len; step *= 2) {\n        for (let start = 0; start < len - 2; start += 2 * step) {\n          const mid = start + step;\n          let end = mid + step;\n          end = end < len ? end : len;\n          if (mid > end)\n            continue;\n          merge(a\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer);\n        }\n      }\n    }\n\n    if (this[context]) {\n      this[context].search = this.toString();\n    }\n  }\n\n  // https://heycam.github.io/webidl/#es-iterators\n  // Define entries here rather than [Symbol.iterator] as the function name\n  // must be set to `entries`.\n  entries() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'key+value');\n  }\n\n  forEach(callback\x2C thisArg = undefined) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    validateFunction(callback\x2C 'callback');\n\n    let list = this[searchParams];\n\n    let i = 0;\n    while (i < list.length) {\n      const key = list[i];\n      const value = list[i + 1];\n      callback.call(thisArg\x2C value\x2C key\x2C this);\n      // In case the URL object's `search` is updated\n      list = this[searchParams];\n      i += 2;\n    }\n  }\n\n  // https://heycam.github.io/webidl/#es-iterable\n  keys() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'key');\n  }\n\n  values() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'value');\n  }\n\n  // https://heycam.github.io/webidl/#es-stringifier\n  // https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior\n  toString() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return serializeParams(this[searchParams]);\n  }\n}\n\nObjectDefineProperties(URLSearchParams.prototype\x2C {\n  append: kEnumerableProperty\x2C\n  delete: kEnumerableProperty\x2C\n  get: kEnumerableProperty\x2C\n  getAll: kEnumerableProperty\x2C\n  has: kEnumerableProperty\x2C\n  set: kEnumerableProperty\x2C\n  size: kEnumerableProperty\x2C\n  sort: kEnumerableProperty\x2C\n  entries: kEnumerableProperty\x2C\n  forEach: kEnumerableProperty\x2C\n  keys: kEnumerableProperty\x2C\n  values: kEnumerableProperty\x2C\n  toString: kEnumerableProperty\x2C\n  [SymbolToStringTag]: { __proto__: null\x2C configurable: true\x2C value: 'URLSearchParams' }\x2C\n\n  // https://heycam.github.io/webidl/#es-iterable-entries\n  [SymbolIterator]: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    writable: true\x2C\n    value: URLSearchParams.prototype.entries\x2C\n  }\x2C\n});\n\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron)\x2C so instead we are\n * checking some well known properties for a lack of a better test.\n * @param {*} self\n * @returns {self is URL}\n */\nfunction isURL(self) {\n  return self != null && ObjectPrototypeHasOwnProperty(self\x2C context);\n}\n\nclass URL {\n  constructor(input\x2C base = undefined) {\n    // toUSVString is not needed.\n    input = `${input}`;\n    this[context] = new URLContext();\n\n    if (base !== undefined) {\n      base = `${base}`;\n    }\n\n    const href = bindingUrl.parse(input\x2C base);\n\n    if (!href) {\n      throw new ERR_INVALID_URL(input);\n    }\n\n    this.#updateContext(href);\n  }\n\n  [inspect.custom](depth\x2C opts) {\n    if (this == null ||\n        ObjectGetPrototypeOf(this[context]) !== URLContext.prototype) {\n      throw new ERR_INVALID_THIS('URL');\n    }\n\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || URL;\n    const obj = ObjectCreate({ constructor });\n\n    obj.href = this.href;\n    obj.origin = this.origin;\n    obj.protocol = this.protocol;\n    obj.username = this.username;\n    obj.password = this.password;\n    obj.host = this.host;\n    obj.hostname = this.hostname;\n    obj.port = this.port;\n    obj.pathname = this.pathname;\n    obj.search = this.search;\n    obj.searchParams = this.searchParams;\n    obj.hash = this.hash;\n\n    if (opts.showHidden) {\n      obj[context] = this[context];\n    }\n\n    return `${constructor.name} ${inspect(obj\x2C opts)}`;\n  }\n\n  #updateContext(href) {\n    const ctx = this[context];\n    ctx.href = href;\n\n    const {\n      0: protocol_end\x2C\n      1: username_end\x2C\n      2: host_start\x2C\n      3: host_end\x2C\n      4: port\x2C\n      5: pathname_start\x2C\n      6: search_start\x2C\n      7: hash_start\x2C\n      8: scheme_type\x2C\n    } = bindingUrl.urlComponents;\n\n    ctx.protocol_end = protocol_end;\n    ctx.username_end = username_end;\n    ctx.host_start = host_start;\n    ctx.host_end = host_end;\n    ctx.port = port;\n    ctx.pathname_start = pathname_start;\n    ctx.search_start = search_start;\n    ctx.hash_start = hash_start;\n    ctx.scheme_type = scheme_type;\n\n    if (this[searchParams]) {\n      if (ctx.hasSearch) {\n        this[searchParams][searchParams] = parseParams(this.search);\n      } else {\n        this[searchParams][searchParams] = [];\n      }\n    }\n  }\n\n  toString() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[context].href;\n  }\n\n  get href() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[context].href;\n  }\n\n  set href(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    value = `${value}`;\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kHref\x2C value);\n    if (!href) { throw ERR_INVALID_URL(value); }\n    this.#updateContext(href);\n  }\n\n  // readonly\n  get origin() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    const protocol = StringPrototypeSlice(ctx.href\x2C 0\x2C ctx.protocol_end);\n\n    // Check if scheme_type is not `NOT_SPECIAL`\n    if (ctx.scheme_type !== 1) {\n      // Check if scheme_type is `FILE`\n      if (ctx.scheme_type === 6) {\n        return 'null';\n      }\n      return `${protocol}//${this.host}`;\n    }\n\n    if (protocol === 'blob:') {\n      const path = this.pathname;\n      if (path.length > 0) {\n        try {\n          const out = new URL(path);\n          if (out[context].scheme_type !== 1) {\n            return `${out.protocol}//${out.host}`;\n          }\n        } catch {\n          // Do nothing.\n        }\n      }\n    }\n\n    return 'null';\n  }\n\n  get protocol() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    return StringPrototypeSlice(this[context].href\x2C 0\x2C this[context].protocol_end);\n  }\n\n  set protocol(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kProtocol\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get username() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    if (ctx.protocol_end + 2 < ctx.username_end) {\n      return StringPrototypeSlice(ctx.href\x2C ctx.protocol_end + 2\x2C ctx.username_end);\n    }\n    return '';\n  }\n\n  set username(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kUsername\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get password() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    if (ctx.host_start - ctx.username_end > 0) {\n      return StringPrototypeSlice(ctx.href\x2C ctx.username_end + 1\x2C ctx.host_start);\n    }\n    return '';\n  }\n\n  set password(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kPassword\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get host() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    let startsAt = ctx.host_start;\n    if (ctx.href[startsAt] === '@') {\n      startsAt++;\n    }\n    // If we have an empty host\x2C then the space between components.host_end and\n    // components.pathname_start may be occupied by /.\n    if (startsAt === ctx.host_end) {\n      return '';\n    }\n    return StringPrototypeSlice(ctx.href\x2C startsAt\x2C ctx.pathname_start);\n  }\n\n  set host(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kHost\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get hostname() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    let startsAt = ctx.host_start;\n    // host_start might be "@" if the URL has credentials\n    if (ctx.href[startsAt] === '@') {\n      startsAt++;\n    }\n    return StringPrototypeSlice(ctx.href\x2C startsAt\x2C ctx.host_end);\n  }\n\n  set hostname(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kHostname\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get port() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    if (this[context].hasPort) {\n      return `${this[context].port}`;\n    }\n    return '';\n  }\n\n  set port(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kPort\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get pathname() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    let endsAt;\n    if (ctx.hasSearch) {\n      endsAt = ctx.search_start;\n    } else if (ctx.hasHash) {\n      endsAt = ctx.hash_start;\n    }\n    return StringPrototypeSlice(ctx.href\x2C ctx.pathname_start\x2C endsAt);\n  }\n\n  set pathname(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kPathname\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get search() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    if (!ctx.hasSearch) { return ''; }\n    let endsAt = ctx.href.length;\n    if (ctx.hasHash) { endsAt = ctx.hash_start; }\n    if (endsAt - ctx.search_start <= 1) { return ''; }\n    return StringPrototypeSlice(ctx.href\x2C ctx.search_start\x2C endsAt);\n  }\n\n  set search(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kSearch\x2C toUSVString(value));\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  // readonly\n  get searchParams() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    if (this[searchParams] == null) {\n      this[searchParams] = new URLSearchParams(this.search);\n      this[searchParams][context] = this;\n    }\n    return this[searchParams];\n  }\n\n  get hash() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    if (!ctx.hasHash || (ctx.href.length - ctx.hash_start <= 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(ctx.href\x2C ctx.hash_start);\n  }\n\n  set hash(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kHash\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  toJSON() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[context].href;\n  }\n\n  static canParse(url\x2C base = undefined) {\n    url = `${url}`;\n\n    if (base !== undefined) {\n      base = `${base}`;\n    }\n\n    return bindingUrl.canParse(url\x2C base);\n  }\n\n  static createObjectURL(obj) {\n    const cryptoRandom = lazyCryptoRandom();\n    if (cryptoRandom === undefined)\n      throw new ERR_NO_CRYPTO();\n\n    const blob = lazyBlob();\n    if (!blob.isBlob(obj))\n      throw new ERR_INVALID_ARG_TYPE('obj'\x2C 'Blob'\x2C obj);\n\n    const id = cryptoRandom.randomUUID();\n\n    storeDataObject(id\x2C obj[blob.kHandle]\x2C obj.size\x2C obj.type);\n\n    return `blob:nodedata:${id}`;\n  }\n\n  static revokeObjectURL(url) {\n    url = `${url}`;\n    try {\n      // TODO(@anonrig): Remove this try/catch by calling `parse` directly.\n      const parsed = new URL(url);\n      const split = StringPrototypeSplit(parsed.pathname\x2C ':');\n      if (split.length === 2)\n        revokeDataObject(split[1]);\n    } catch {\n      // If there's an error\x2C it's ignored.\n    }\n  }\n}\n\nObjectDefineProperties(URL.prototype\x2C {\n  [SymbolToStringTag]: { __proto__: null\x2C configurable: true\x2C value: 'URL' }\x2C\n  toString: kEnumerableProperty\x2C\n  href: kEnumerableProperty\x2C\n  origin: kEnumerableProperty\x2C\n  protocol: kEnumerableProperty\x2C\n  username: kEnumerableProperty\x2C\n  password: kEnumerableProperty\x2C\n  host: kEnumerableProperty\x2C\n  hostname: kEnumerableProperty\x2C\n  port: kEnumerableProperty\x2C\n  pathname: kEnumerableProperty\x2C\n  search: kEnumerableProperty\x2C\n  searchParams: kEnumerableProperty\x2C\n  hash: kEnumerableProperty\x2C\n  toJSON: kEnumerableProperty\x2C\n});\n\nObjectDefineProperties(URL\x2C {\n  canParse: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    writable: true\x2C\n    enumerable: true\x2C\n  }\x2C\n  createObjectURL: kEnumerableProperty\x2C\n  revokeObjectURL: kEnumerableProperty\x2C\n});\n\n// application/x-www-form-urlencoded parser\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-parser\nfunction parseParams(qs) {\n  const out = [];\n  let seenSep = false;\n  let buf = '';\n  let encoded = false;\n  let encodeCheck = 0;\n  let i = qs[0] === '?' ? 1 : 0;\n  let pairStart = i;\n  let lastPos = i;\n  for (; i < qs.length; ++i) {\n    const code = StringPrototypeCharCodeAt(qs\x2C i);\n\n    // Try matching key/value pair separator\n    if (code === CHAR_AMPERSAND) {\n      if (pairStart === i) {\n        // We saw an empty substring between pair separators\n        lastPos = pairStart = i + 1;\n        continue;\n      }\n\n      if (lastPos < i)\n        buf += qs.slice(lastPos\x2C i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      // If `buf` is the key\x2C add an empty value.\n      if (!seenSep)\n        out.push('');\n\n      seenSep = false;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = pairStart = i + 1;\n      continue;\n    }\n\n    // Try matching key/value separator (e.g. '=') if we haven't already\n    if (!seenSep && code === CHAR_EQUAL) {\n      // Key/value separator match!\n      if (lastPos < i)\n        buf += qs.slice(lastPos\x2C i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      seenSep = true;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = i + 1;\n      continue;\n    }\n\n    // Handle + and percent decoding.\n    if (code === CHAR_PLUS) {\n      if (lastPos < i)\n        buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n      buf += ' ';\n      lastPos = i + 1;\n    } else if (!encoded) {\n      // Try to match an (valid) encoded byte (once) to minimize unnecessary\n      // calls to string decoding functions\n      if (code === CHAR_PERCENT) {\n        encodeCheck = 1;\n      } else if (encodeCheck > 0) {\n        if (isHexTable[code] === 1) {\n          if (++encodeCheck === 3) {\n            encoded = true;\n          }\n        } else {\n          encodeCheck = 0;\n        }\n      }\n    }\n  }\n\n  // Deal with any leftover key or value data\n\n  // There is a trailing &. No more processing is needed.\n  if (pairStart === i)\n    return out;\n\n  if (lastPos < i)\n    buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n  if (encoded)\n    buf = querystring.unescape(buf);\n  ArrayPrototypePush(out\x2C buf);\n\n  // If `buf` is the key\x2C add an empty value.\n  if (!seenSep)\n    ArrayPrototypePush(out\x2C '');\n\n  return out;\n}\n\n// Adapted from querystring's implementation.\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-byte-serializer\nconst noEscape = new Int8Array([\n/*\n  0\x2C 1\x2C 2\x2C 3\x2C 4\x2C 5\x2C 6\x2C 7\x2C 8\x2C 9\x2C A\x2C B\x2C C\x2C D\x2C E\x2C F\n*/\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x00 - 0x0F\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x10 - 0x1F\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C 0\x2C 0\x2C 1\x2C 1\x2C 0\x2C // 0x20 - 0x2F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x30 - 0x3F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x40 - 0x4F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C // 0x50 - 0x5F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x60 - 0x6F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C  // 0x70 - 0x7F\n]);\n\n// Special version of hexTable that uses `+` for U+0020 SPACE.\nconst paramHexTable = hexTable.slice();\nparamHexTable[0x20] = '+';\n\n// application/x-www-form-urlencoded serializer\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-serializer\nfunction serializeParams(array) {\n  const len = array.length;\n  if (len === 0)\n    return '';\n\n  const firstEncodedParam = encodeStr(array[0]\x2C noEscape\x2C paramHexTable);\n  const firstEncodedValue = encodeStr(array[1]\x2C noEscape\x2C paramHexTable);\n  let output = `${firstEncodedParam}=${firstEncodedValue}`;\n\n  for (let i = 2; i < len; i += 2) {\n    const encodedParam = encodeStr(array[i]\x2C noEscape\x2C paramHexTable);\n    const encodedValue = encodeStr(array[i + 1]\x2C noEscape\x2C paramHexTable);\n    output += `&${encodedParam}=${encodedValue}`;\n  }\n\n  return output;\n}\n\n// Mainly to mitigate func-name-matching ESLint rule\nfunction defineIDLClass(proto\x2C classStr\x2C obj) {\n  // https://heycam.github.io/webidl/#dfn-class-string\n  ObjectDefineProperty(proto\x2C SymbolToStringTag\x2C {\n    __proto__: null\x2C\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: classStr\x2C\n  });\n\n  // https://heycam.github.io/webidl/#es-operations\n  for (const key of ObjectKeys(obj)) {\n    ObjectDefineProperty(proto\x2C key\x2C {\n      __proto__: null\x2C\n      writable: true\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      value: obj[key]\x2C\n    });\n  }\n  for (const key of ObjectGetOwnPropertySymbols(obj)) {\n    ObjectDefineProperty(proto\x2C key\x2C {\n      __proto__: null\x2C\n      writable: true\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: obj[key]\x2C\n    });\n  }\n}\n\n// for merge sort\nfunction merge(out\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer) {\n  const sizeLeft = mid - start;\n  const sizeRight = end - mid;\n  let l\x2C r\x2C o;\n\n  for (l = 0; l < sizeLeft; l++)\n    lBuffer[l] = out[start + l];\n  for (r = 0; r < sizeRight; r++)\n    rBuffer[r] = out[mid + r];\n\n  l = 0;\n  r = 0;\n  o = start;\n  while (l < sizeLeft && r < sizeRight) {\n    if (lBuffer[l] <= rBuffer[r]) {\n      out[o++] = lBuffer[l++];\n      out[o++] = lBuffer[l++];\n    } else {\n      out[o++] = rBuffer[r++];\n      out[o++] = rBuffer[r++];\n    }\n  }\n  while (l < sizeLeft)\n    out[o++] = lBuffer[l++];\n  while (r < sizeRight)\n    out[o++] = rBuffer[r++];\n}\n\n// https://heycam.github.io/webidl/#dfn-default-iterator-object\nfunction createSearchParamsIterator(target\x2C kind) {\n  const iterator = ObjectCreate(URLSearchParamsIteratorPrototype);\n  iterator[context] = {\n    target\x2C\n    kind\x2C\n    index: 0\x2C\n  };\n  return iterator;\n}\n\n// https://heycam.github.io/webidl/#dfn-iterator-prototype-object\nconst URLSearchParamsIteratorPrototype = ObjectCreate(IteratorPrototype);\n\ndefineIDLClass(URLSearchParamsIteratorPrototype\x2C 'URLSearchParams Iterator'\x2C {\n  next() {\n    if (!this ||\n        ObjectGetPrototypeOf(this) !== URLSearchParamsIteratorPrototype) {\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n    }\n\n    const {\n      target\x2C\n      kind\x2C\n      index\x2C\n    } = this[context];\n    const values = target[searchParams];\n    const len = values.length;\n    if (index >= len) {\n      return {\n        value: undefined\x2C\n        done: true\x2C\n      };\n    }\n\n    const name = values[index];\n    const value = values[index + 1];\n    this[context].index = index + 2;\n\n    let result;\n    if (kind === 'key') {\n      result = name;\n    } else if (kind === 'value') {\n      result = value;\n    } else {\n      result = [name\x2C value];\n    }\n\n    return {\n      value: result\x2C\n      done: false\x2C\n    };\n  }\x2C\n  [inspect.custom](recurseTimes\x2C ctx) {\n    if (this == null || this[context] == null || this[context].target == null)\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]'\x2C 'special');\n\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const {\n      target\x2C\n      kind\x2C\n      index\x2C\n    } = this[context];\n    const output = ArrayPrototypeReduce(\n      ArrayPrototypeSlice(target[searchParams]\x2C index)\x2C\n      (prev\x2C cur\x2C i) => {\n        const key = i % 2 === 0;\n        if (kind === 'key' && key) {\n          ArrayPrototypePush(prev\x2C cur);\n        } else if (kind === 'value' && !key) {\n          ArrayPrototypePush(prev\x2C cur);\n        } else if (kind === 'key+value' && !key) {\n          ArrayPrototypePush(prev\x2C [target[searchParams][index + i - 1]\x2C cur]);\n        }\n        return prev;\n      }\x2C\n      []\x2C\n    );\n    const breakLn = StringPrototypeIncludes(inspect(output\x2C innerOpts)\x2C '\\n');\n    const outputStrs = ArrayPrototypeMap(output\x2C (p) => inspect(p\x2C innerOpts));\n    let outputStr;\n    if (breakLn) {\n      outputStr = `\\n  ${ArrayPrototypeJoin(outputStrs\x2C '\x2C\\n  ')}`;\n    } else {\n      outputStr = ` ${ArrayPrototypeJoin(outputStrs\x2C '\x2C ')}`;\n    }\n    return `${this[SymbolToStringTag]} {${outputStr} }`;\n  }\x2C\n});\n\nfunction domainToASCII(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return bindingUrl.domainToASCII(`${domain}`);\n}\n\nfunction domainToUnicode(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return bindingUrl.domainToUnicode(`${domain}`);\n}\n\n/**\n * Utility function that converts a URL object into an ordinary options object\n * as expected by the `http.request` and `https.request` APIs.\n * @param {URL} url\n * @returns {Record<string\x2C unknown>}\n */\nfunction urlToHttpOptions(url) {\n  const { hostname\x2C pathname\x2C port\x2C username\x2C password\x2C search } = url;\n  const options = {\n    __proto__: null\x2C\n    ...url\x2C // In case the url object was extended by the user.\n    protocol: url.protocol\x2C\n    hostname: hostname && StringPrototypeStartsWith(hostname\x2C '[') ?\n      StringPrototypeSlice(hostname\x2C 1\x2C -1) :\n      hostname\x2C\n    hash: url.hash\x2C\n    search: search\x2C\n    pathname: pathname\x2C\n    path: `${pathname || ''}${search || ''}`\x2C\n    href: url.href\x2C\n  };\n  if (port !== '') {\n    options.port = Number(port);\n  }\n  if (username || password) {\n    options.auth = `${decodeURIComponent(username)}:${decodeURIComponent(password)}`;\n  }\n  return options;\n}\n\nfunction getPathFromURLWin32(url) {\n  const hostname = url.hostname;\n  let pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = StringPrototypeCodePointAt(pathname\x2C n + 2) | 0x20;\n      if ((pathname[n + 1] === '2' && third === 102) || // 2f 2F /\n          (pathname[n + 1] === '5' && third === 99)) {  // 5c 5C \\\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded \\\\ or / characters'\x2C\n        );\n      }\n    }\n  }\n  pathname = SideEffectFreeRegExpPrototypeSymbolReplace(FORWARD_SLASH\x2C pathname\x2C '\\\\');\n  pathname = decodeURIComponent(pathname);\n  if (hostname !== '') {\n    // If hostname is set\x2C then we have a UNC path\n    // Pass the hostname through domainToUnicode just in case\n    // it is an IDN using punycode encoding. We do not need to worry\n    // about percent encoding because the URL parser will have\n    // already taken care of that for us. Note that this only\n    // causes IDNs with an appropriate `xn--` prefix to be decoded.\n    return `\\\\\\\\${domainToUnicode(hostname)}${pathname}`;\n  }\n  // Otherwise\x2C it's a local path that requires a drive letter\n  const letter = StringPrototypeCodePointAt(pathname\x2C 1) | 0x20;\n  const sep = StringPrototypeCharAt(pathname\x2C 2);\n  if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z ||   // a..z A..Z\n      (sep !== ':')) {\n    throw new ERR_INVALID_FILE_URL_PATH('must be absolute');\n  }\n  return StringPrototypeSlice(pathname\x2C 1);\n}\n\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    throw new ERR_INVALID_FILE_URL_HOST(platform);\n  }\n  const pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = StringPrototypeCodePointAt(pathname\x2C n + 2) | 0x20;\n      if (pathname[n + 1] === '2' && third === 102) {\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded / characters'\x2C\n        );\n      }\n    }\n  }\n  return decodeURIComponent(pathname);\n}\n\nfunction fileURLToPath(path) {\n  if (typeof path === 'string')\n    path = new URL(path);\n  else if (!isURL(path))\n    throw new ERR_INVALID_ARG_TYPE('path'\x2C ['string'\x2C 'URL']\x2C path);\n  if (path.protocol !== 'file:')\n    throw new ERR_INVALID_URL_SCHEME('file');\n  return isWindows ? getPathFromURLWin32(path) : getPathFromURLPosix(path);\n}\n\n// The following characters are percent-encoded when converting from file path\n// to URL:\n// - %: The percent character is the only character not encoded by the\n//        `pathname` setter.\n// - \\: Backslash is encoded on non-windows platforms since it's a valid\n//      character but the `pathname` setters replaces it by a forward slash.\n// - LF: The newline character is stripped out by the `pathname` setter.\n//       (See whatwg/url#419)\n// - CR: The carriage return character is also stripped out by the `pathname`\n//       setter.\n// - TAB: The tab character is also stripped out by the `pathname` setter.\nconst percentRegEx = /%/g;\nconst backslashRegEx = /\\\\/g;\nconst newlineRegEx = /\\n/g;\nconst carriageReturnRegEx = /\\r/g;\nconst tabRegEx = /\\t/g;\n\nfunction encodePathChars(filepath) {\n  if (StringPrototypeIncludes(filepath\x2C '%'))\n    filepath = RegExpPrototypeSymbolReplace(percentRegEx\x2C filepath\x2C '%25');\n  // In posix\x2C backslash is a valid character in paths:\n  if (!isWindows && StringPrototypeIncludes(filepath\x2C '\\\\'))\n    filepath = RegExpPrototypeSymbolReplace(backslashRegEx\x2C filepath\x2C '%5C');\n  if (StringPrototypeIncludes(filepath\x2C '\\n'))\n    filepath = RegExpPrototypeSymbolReplace(newlineRegEx\x2C filepath\x2C '%0A');\n  if (StringPrototypeIncludes(filepath\x2C '\\r'))\n    filepath = RegExpPrototypeSymbolReplace(carriageReturnRegEx\x2C filepath\x2C '%0D');\n  if (StringPrototypeIncludes(filepath\x2C '\\t'))\n    filepath = RegExpPrototypeSymbolReplace(tabRegEx\x2C filepath\x2C '%09');\n  return filepath;\n}\n\nfunction pathToFileURL(filepath) {\n  const outURL = new URL('file://');\n  if (isWindows && StringPrototypeStartsWith(filepath\x2C '\\\\\\\\')) {\n    // UNC path format: \\\\server\\share\\resource\n    const hostnameEndIndex = StringPrototypeIndexOf(filepath\x2C '\\\\'\x2C 2);\n    if (hostnameEndIndex === -1) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'filepath'\x2C\n        filepath\x2C\n        'Missing UNC resource path'\x2C\n      );\n    }\n    if (hostnameEndIndex === 2) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'filepath'\x2C\n        filepath\x2C\n        'Empty UNC servername'\x2C\n      );\n    }\n    const hostname = StringPrototypeSlice(filepath\x2C 2\x2C hostnameEndIndex);\n    outURL.hostname = domainToASCII(hostname);\n    outURL.pathname = encodePathChars(\n      RegExpPrototypeSymbolReplace(backslashRegEx\x2C StringPrototypeSlice(filepath\x2C hostnameEndIndex)\x2C '/'));\n  } else {\n    let resolved = path.resolve(filepath);\n    // path.resolve strips trailing slashes so we must add them back\n    const filePathLast = StringPrototypeCharCodeAt(filepath\x2C\n                                                   filepath.length - 1);\n    if ((filePathLast === CHAR_FORWARD_SLASH ||\n         (isWindows && filePathLast === CHAR_BACKWARD_SLASH)) &&\n        resolved[resolved.length - 1] !== path.sep)\n      resolved += '/';\n    outURL.pathname = encodePathChars(resolved);\n  }\n  return outURL;\n}\n\nfunction toPathIfFileURL(fileURLOrPath) {\n  if (!isURL(fileURLOrPath))\n    return fileURLOrPath;\n  return fileURLToPath(fileURLOrPath);\n}\n\nmodule.exports = {\n  toUSVString\x2C\n  fileURLToPath\x2C\n  pathToFileURL\x2C\n  toPathIfFileURL\x2C\n  URL\x2C\n  URLSearchParams\x2C\n  domainToASCII\x2C\n  domainToUnicode\x2C\n  urlToHttpOptions\x2C\n  encodeStr\x2C\n  isURL\x2C\n\n  urlUpdateActions: updateActions\x2C\n};\n
code-source-info,0x1fa4d1d76d90,77,41289,41402,C0O41309C3O41314C9O41340C11O41361C12O41364C15O41371C19O41400,,
code-creation,LazyCompile,10,122167,0x1fa4d1d79d68,22,isURL node:internal/url:594:15,0x28e4ce8f4630,~
code-source-info,0x1fa4d1d79d68,77,16262,16343,C0O16273C3O16285C8O16296C13O16332C16O16296C21O16341,,
code-creation,LazyCompile,10,122209,0x1fa4d1d79ec0,81, node:internal/fs/utils:694:38,0x25dc1a849f90,~
code-source-info,0x1fa4d1d79ec0,80,18872,19142,C14O18905C22O18938C25O18938C31O18964C36O18995C49O18970C54O18964C55O19060C68O19060C74O19097C76O19126C78O19126C80O19141,,
code-creation,LazyCompile,10,122250,0x1fa4d1d7a0d8,110, node:internal/fs/utils:363:35,0x25dc1a849590,~
code-source-info,0x1fa4d1d7a0d8,80,8769,9359,C16O8833C21O8886C26O8886C31O8980C37O9003C41O9031C45O9048C51O9048C60O9099C64O9120C69O9120C76O9165C77O9172C78O9192C94O9192C100O9307C104O9329C106O9329C107O9346C109O9357,,
tick,0x195a849cc,122292,0,0x0,3,0x0,0x1fa4d1d6dfc6,0x1fa4d1d6d773,0x1fa4d1d6d001,0x1fa4d1d6ca1e,0x1fa4d1d6c5c9,0x202f0287621a
tick,0x195a4aa2c,122375,0,0x0,3,0x0,0x1fa4d1d6dfd2,0x1fa4d1d6d773,0x1fa4d1d6d001,0x1fa4d1d6ca1e,0x1fa4d1d6c5c9,0x202f0287621a
tick,0x195a4aa2c,122375,0,0x0,3,0x0,0x1fa4d1d6dfd2,0x1fa4d1d6d773,0x1fa4d1d6d001,0x1fa4d1d6ca1e,0x1fa4d1d6c5c9,0x202f0287621a
code-creation,LazyCompile,10,122417,0x1fa4d1d7a250,16,isUint8Array node:internal/util/types:13:22,0x1012a394d190,~
script-source,23,node:internal/util/types,'use strict';\n\nconst {\n  ArrayBufferIsView\x2C\n  ObjectDefineProperties\x2C\n  TypedArrayPrototypeGetSymbolToStringTag\x2C\n} = primordials;\n\nfunction isTypedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) !== undefined;\n}\n\nfunction isUint8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8Array';\n}\n\nfunction isUint8ClampedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8ClampedArray';\n}\n\nfunction isUint16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint16Array';\n}\n\nfunction isUint32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint32Array';\n}\n\nfunction isInt8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int8Array';\n}\n\nfunction isInt16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int16Array';\n}\n\nfunction isInt32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int32Array';\n}\n\nfunction isFloat32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float32Array';\n}\n\nfunction isFloat64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float64Array';\n}\n\nfunction isBigInt64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigInt64Array';\n}\n\nfunction isBigUint64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigUint64Array';\n}\n\nmodule.exports = {\n  ...internalBinding('types')\x2C\n  isArrayBufferView: ArrayBufferIsView\x2C\n  isTypedArray\x2C\n  isUint8Array\x2C\n  isUint8ClampedArray\x2C\n  isUint16Array\x2C\n  isUint32Array\x2C\n  isInt8Array\x2C\n  isInt16Array\x2C\n  isInt32Array\x2C\n  isFloat32Array\x2C\n  isFloat64Array\x2C\n  isBigInt64Array\x2C\n  isBigUint64Array\x2C\n};\n\nlet isCryptoKey;\nlet isKeyObject;\n\nObjectDefineProperties(module.exports\x2C {\n  isKeyObject: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n\n      if (!isKeyObject) {\n        ({ isKeyObject } = require('internal/crypto/keys'));\n      }\n\n      return isKeyObject(obj);\n    }\x2C\n  }\x2C\n  isCryptoKey: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n\n      if (!isCryptoKey) {\n        ({ isCryptoKey } = require('internal/crypto/keys'));\n      }\n\n      return isCryptoKey(obj);\n    }\x2C\n  }\x2C\n});\n
code-source-info,0x1fa4d1d7a250,23,257,342,C0O269C5O276C12O323C15O340,,
code-creation,LazyCompile,10,122625,0x1fa4d1d7a6d8,61,splitRoot node:fs:2533:33,0x28e4ce8e7788,~
code-source-info,0x1fa4d1d7a6d8,76,67925,68117,C0O67950C2O67961C6O67955C11O67982C16O67986C24O68024C26O68020C31O68052C44O68059C49O68091C50O67971C55O67937C58O68102C60O68113,,
code-creation,LazyCompile,10,122667,0x1fa4d1d7a810,20,nextPart node:fs:2566:31,0x28e4ce8e7828,~
code-source-info,0x1fa4d1d7a810,76,68832,68890,C0O68845C14O68852C19O68886,,
code-creation,LazyCompile,10,122709,0x1fa4d1d7a918,63,handleErrorFromBinding node:internal/fs/utils:346:32,0x25dc1a849540,~
code-source-info,0x1fa4d1d7a918,80,8130,8628,C0O8148C6O8211C11O8211C16O8233C24O8233C29O8290C31O8290C32O8315C38O8543C43O8570C51O8543C56O8616C60O8606C62O8627,,
code-creation,LazyCompile,10,122709,0x1fa4d1d7aa68,34,isFileType node:fs:217:20,0x28e4ce8e59d0,~
code-source-info,0x1fa4d1d7aa68,76,5468,5709,C0O5602C2O5607C6O5614C10O5648C15O5655C20O5671C22O5686C24O5684C30O5694C33O5707,,
code-creation,LazyCompile,10,122834,0x1fa4d1d7ac88,72,encodeRealpathResult node:fs:2542:30,0x28e4ce8e77d8,~
code-source-info,0x1fa4d1d7ac88,76,68151,68409,C0O68173C4O68198C10O68218C17O68227C22O68243C24O68257C25O68277C30O68284C35O68284C41O68312C48O68321C53O68341C55O68357C56O68380C61O68397C66O68380C71O68407,,
code-creation,LazyCompile,10,122875,0x1fa4d1d7ae18,118,shouldUseESMLoader node:internal/modules/run_main:30:28,0x1fa4d1d6b620,~
code-source-info,0x1fa4d1d7ae18,489,841,1564,C0O1026C8O1026C13O1085C19O1092C24O1101C25O1113C26O1156C34O1156C39O1213C41O1245C46O1261C47O1273C48O1321C54O1337C60O1337C67O1384C68O1396C69O1399C75O1416C81O1416C88O1463C89O1476C90O1491C95O1491C100O1521C102O1539C107O1544C114O1549C117O1562,,
code-creation,LazyCompile,10,123042,0x1fa4d1d7b048,131,readPackageScope node:internal/modules/cjs/loader:406:26,0x2b3d46cdf680,~
code-source-info,0x1fa4d1d7b048,465,11264,11783,C0O11307C7O11341C10O11307C16O11353C18O11380C25O11435C28O11397C34O11445C47O11457C54O11513C61O11552C66O11556C70O11517C77O11581C78O11594C79O11613C86O11638C88O11636C92O11613C97O11648C99O11659C106O11680C112O11699C118O11716C119O11743C121O11743C126O11371C129O11768C130O11781,,
code-creation,LazyCompile,10,123125,0x1fa4d1d7b378,202,readPackage node:internal/modules/cjs/loader:364:21,0x2b3d46cdf630,~
code-source-info,0x1fa4d1d7b378,465,10219,10951,C0O10254C5O10259C13O10259C20O10317C25O10334C30O10334C36O10351C38O10379C40O10395C41O10414C46O10432C51O10432C57O10470C63O10483C72O10509C77O10519C79O10549C84O10566C91O10566C97O10592C98O10605C102O10640C109O10660C112O10660C122O10640C128O10767C133O10784C138O10784C144O10813C146O10829C158O10850C163O10857C167O10873C175O10902C181O10913C188O10924C192O10920C195O10883C199O10937C201O10937,,
code-creation,LazyCompile,10,123209,0x1fa4d1d7b658,199,read node:internal/modules/package_json_reader:16:14,0x2b3d46ce5f20,~
code-source-info,0x1fa4d1d7b658,466,292,955,C0O307C5O317C10O317C17O338C22O351C27O351C32O365C33O412C40O440C43O440C48O412C53O384C59O395C66O490C73O492C79O500C86O545C92O545C97O526C102O576C106O608C112O644C115O655C127O705C132O739C142O653C148O775C154O822C159O822C164O853C169O862C174O862C180O908C185O914C190O914C196O939C198O953,,
code-creation,LazyCompile,10,123334,0x1fa4d1d7c890,61,filterOwnProperties node:internal/util:529:29,0x1012a3947858,~
code-source-info,0x1fa4d1d7c890,21,14672,14915,C0O14708C7O14708C12O14743C14O14755C18O14748C23O14786C25O14790C29O14799C34O14803C41O14855C43O14877C46O14869C50O14764C55O14730C58O14897C60O14913,,
code-creation,LazyCompile,10,123417,0x1fa4d1d7cb58,690,Module._load node:internal/modules/cjs/loader:888:24,0x2b3d46ce03c0,~
code-source-info,0x1fa4d1d7cb58,465,27343,30489,C0O27377C2O27406C6O27424C14O27484C23O27424C28O27714C42O27725C47O27757C54O27777C58O27810C61O27810C65O27849C69O27906C72O27913C79O27919C83O27937C85O27979C97O27979C102O28049C108O28067C111O28074C115O28117C116O28146C120O28154C121O28169C128O28197C130O28238C138O28242C145O28332C153O28332C159O28386C164O28386C170O28422C175O28433C184O28465C191O28471C196O28465C197O28537C201O28545C202O28570C205O28577C219O28577C225O28643C228O28650C235O28656C239O28670C241O28708C253O28708C258O28774C264O28816C269O28830C274O28830C280O28855C282O28899C288O28915C291O28922C295O28965C296O28972C297O28997C303O29044C307O29052C308O29078C313O29078C319O29118C324O29125C335O29157C338O29171C343O29171C350O29226C354O29234C355O29324C370O29340C376O29373C380O29391C394O29391C399O29442C404O29464C416O29489C422O29442C427O29506C429O29516C433O29530C436O29530C440O29568C443O29575C450O29592C454O29604C458O29636C465O29684C469O29715C474O29740C480O29740C485O29760C497O29766C498O29793C503O29812C507O29826C515O29833C517O29850C521O29886C529O29914C531O29967C538O29973C546O29993C552O29997C558O30047C564O30047C570O30098C572O30108C577O30130C593O30130C600O30224C608O30251C612O30266C618O30251C626O30293C630O30321C636O30293C644O30351C646O30330C651O30397C657O30425C665O30434C669O30397C685O30479C689O30487,,
code-creation,LazyCompile,10,123542,0x1fa4d1d7d368,919,Module._resolveFilename node:internal/modules/cjs/loader:986:35,0x2b3d46ce0448,~
code-source-info,0x1fa4d1d7d368,465,30526,33718,C0O30565C10O30582C19O30635C23O30649C31O30670C39O30670C46O30649C55O30721C59O30735C65O30735C74O30774C78O30788C84O30788C91O30840C93O30855C94O30867C96O30877C106O30936C112O30961C118O30940C124O30996C134O30996C143O31050C151O31050C160O31107C166O31120C174O31120C183O31176C191O31176C197O31228C199O31270C206O31319C219O31319C225O31350C228O31384C230O31399C236O31405C240O31389C245O31451C253O31456C257O31471C261O31497C267O31497C272O31488C276O31551C280O31558C286O31558C293O31624C296O31643C300O31629C305O31670C313O31716C318O31675C325O31736C333O31773C338O31736C343O31652C349O31611C352O31414C357O31371C362O31832C368O31861C372O31876C378O31876C387O31933C397O31990C405O31939C410O31933C413O32019C417O32034C423O32034C430O32079C431O32090C438O32094C450O32112C466O32132C477O32137C482O32177C489O32183C504O32205C510O32205C518O32213C522O32218C526O32211C530O32239C534O32239C542O32287C550O32291C563O32332C569O32372C575O32403C579O32403C587O32462C594O32372C601O32504C610O32339C615O32510C629O32539C633O32545C641O32550C646O32588C652O32594C656O32588C657O32633C659O32633C660O32720C664O32720C669O32770C673O32770C679O32802C681O32843C683O32851C688O32878C696O32885C702O32898C709O32904C717O32904C722O32860C726O32944C730O32951C738O32972C742O32992C744O33012C745O33098C749O33105C764O33105C770O33142C772O33156C774O33172C775O33196C778O33220C783O33232C787O33290C793O33330C802O33349C808O33290C813O33251C819O33271C825O33271C831O33202C834O33374C840O33397C852O33428C859O33435C864O33446C866O33464C873O33505C881O33505C886O33489C890O33616C898O33616C904O33638C906O33647C910O33671C912O33688C916O33706C918O33706,,
code-creation,LazyCompile,10,123625,0x1fa4d1d7d9b8,28,canBeRequiredByUsers node:internal/bootstrap/loaders:249:30,0x41ccf058dd8,~
code-source-info,0x1fa4d1d7d9b8,15,7551,7648,C0O7574C5O7588C10O7592C15O7592C21O7605C23O7623C27O7644,,
code-creation,LazyCompile,10,123709,0x1fa4d1d7dc98,408,Module._resolveLookupPaths node:internal/modules/cjs/loader:787:38,0x2b3d46ce0290,~
code-source-info,0x1fa4d1d7dc98,465,23803,25253,C0O23825C8O23835C17O23886C20O23900C27O23921C33O23921C39O23900C48O23968C51O23982C56O23982C65O24019C68O24033C73O24033C80O24080C88O24080C93O24124C94O24136C95O24179C102O24183C110O24217C115O24243C122O24250C129O24263C135O24263C143O24297C150O24314C156O24314C164O24348C171O24367C177O24380C183O24380C191O24414C196O24437C198O24448C205O24458C212O24465C221O24483C228O24511C231O24491C236O24531C241O24572C246O24531C253O24599C258O24631C272O24631C277O24695C283O24702C293O24721C294O24768C298O24791C304O24805C310O24976C315O24988C329O24988C334O25043C336O25060C337O25068C345O25135C353O25068C358O25161C367O25162C370O25167C375O25182C380O25167C392O25196C400O25196C405O25234C407O25251,,
code-creation,LazyCompile,10,123750,0x1fa4d1d7dfd8,89,logger node:internal/util/debuglog:101:18,0x1012a3968a78,~
code-source-info,0x1fa4d1d7dfd8,28,2980,3175,C0O2980C3O3012C24O3036C30O3053C34O3043C38O3058C39O3073C45O3090C51O3099C55O3080C60O3104C61O3120C65O3127C72O3140C77O3136C83O3127C88O3165,,
code-creation,LazyCompile,10,123792,0x1fa4d1d7e148,140,debug node:internal/util/debuglog:82:15,0x1012a39689d8,~
code-source-info,0x1fa4d1d7e148,28,2468,2862,C0O2468C3O2487C6O2487C9O2595C16O2616C22O2603C30O2601C36O2635C42O2671C47O2674C50O2671C54O2699C75O2723C81O2740C85O2730C89O2745C90O2760C96O2777C102O2786C106O2767C111O2791C112O2807C116O2814C123O2827C128O2823C134O2814C139O2852,,
code-creation,LazyCompile,10,123834,0x1fa4d1d7e2f8,41,init node:internal/util/debuglog:78:16,0x1012a3968988,~
code-source-info,0x1fa4d1d7e2f8,28,2370,2453,C0O2379C10O2385C14O2383C16O2422C26O2432C33O2430C40O2452,,
code-creation,LazyCompile,10,123834,0x1fa4d1d7e3f0,2,testEnabled node:internal/util/debuglog:32:19,0x30e76770e8c0,~
code-source-info,0x1fa4d1d7e3f0,28,973,984,C0O979C1O984,,
code-creation,LazyCompile,10,123875,0x1fa4d1d7e570,116,debuglogImpl node:internal/util/debuglog:55:22,0x1012a3968738,~
code-source-info,0x1fa4d1d7e570,28,1569,2106,C0O1569C9O1588C18O1602C23O1629C34O1662C39O1670C43O1662C45O1681C55O1681C59O1713C71O1724C75O1729C83O2045C97O2063C99O2061C103O2081C112O2098C115O2104,,
code-creation,LazyCompile,10,123917,0x1fa4d1d7e728,10, node:internal/modules/cjs/loader:346:66,0x2b3d46cdfff0,~
code-source-info,0x1fa4d1d7e728,465,9826,9851,C0O9838C2O9844C9O9850,,
code-creation,LazyCompile,10,123917,0x1fa4d1d7e7e0,2,noop node:internal/util/debuglog:47:14,0x1012a3968698,~
code-source-info,0x1fa4d1d7e7e0,28,1419,1427,C1O1426,,
code-creation,LazyCompile,10,123959,0x1fa4d1d7e910,76,trySelfParentPath node:internal/modules/cjs/loader:512:27,0x2b3d46cdf860,~
code-source-info,0x1fa4d1d7e910,465,14621,14884,C0O14634C4O14647C5O14660C6O14675C12O14705C16O14714C17O14735C24O14738C29O14761C36O14764C44O14806C47O14821C52O14821C59O14829C62O14834C66O14827C69O14838C72O14859C73O14872C75O14883,,
code-creation,LazyCompile,10,124000,0x1fa4d1d7eb50,232,trySelf node:internal/modules/cjs/loader:526:17,0x2b3d46cdf8b0,~
code-source-info,0x1fa4d1d7eb50,465,14902,15726,C0O14928C4O14945C5O14958C6O14999C9O14999C17O14976C22O14987C27O15037C31O15053C37O15076C38O15089C39O15107C47O15126C48O15139C49O15147C51O15180C55O15172C60O15192C65O15218C70O15264C82O15222C89O15280C94O15298C97O15332C102O15337C107O15298C112O15296C118O15361C119O15374C123O15392C128O15421C133O15450C138O15472C142O15450C149O15514C152O15514C159O15541C168O15421C180O15399C185O15578C197O15599C200O15605C207O15610C212O15644C219O15688C223O15650C228O15644C229O15712C231O15712,,
code-creation,LazyCompile,10,124042,0x1fa4d1d7ee58,62,loadBuiltinModule node:internal/modules/cjs/helpers:51:27,0x30e767715bd8,~
code-source-info,0x1fa4d1d7ee58,453,1298,1581,C0O1334C5O1348C10O1352C15O1352C21O1369C26O1376C35O1406C43O1406C48O1534C53O1534C57O1564C59O1575C61O1580,,
tick,0x100f24b60,124084,0,0x0,3,0x0,0x1fa4d1d7b0a4,0x1fa4d1d7ae77,0x1fa4d1d6c5d1,0x202f0287621a
code-creation,LazyCompile,10,124167,0x1fa4d1d7f810,223,Module node:internal/modules/cjs/loader:225:16,0x2b3d46cdf540,~
code-source-info,0x1fa4d1d7f810,465,6579,7297,C14O6601C16O6609C20O6617C22O6629C25O6634C30O6634C35O6627C39O6649C52O6649C57O6688C62O6706C67O6706C73O6727C84O6727C89O6766C90O6780C94O6790C95O6802C99O6813C101O6827C105O6839C107O6852C114O6862C123O6898C128O6898C133O6921C138O6940C143O6949C148O6949C154O7045C164O7077C167O7077C176O7045C181O7161C186O7181C196O7203C199O7203C205O7161C210O7248C212O7253C217O7277C222O7296,,
code-creation,LazyCompile,10,124375,0x1fa4d1d7fb08,162,dirname node:path:1274:10,0x28e4ce8cd2b0,~
code-source-info,0x1fa4d1d7fb08,74,38785,39454,C0O38798C8O38798C13O38841C19O38848C24O38861C26O38872C27O38893C34O38893C42O38932C44O38928C48O38966C51O38993C53O39021C57O39028C61O39035C63O39035C68O39054C73O39058C81O39097C83O39093C88O39127C92O39158C97O39177C101O39264C103O39043C108O39003C111O39305C113O39313C118O39327C128O39354C129O39359C135O39378C140O39391C142O39403C143O39408C156O39415C161O39450,,
code-creation,LazyCompile,10,124542,0x1fa4d1d7fd40,28,setOwnProperty node:internal/util:548:24,0x1012a39478a8,~
code-source-info,0x1fa4d1d7fd40,21,15106,15273,C0O15128C5O15161C12O15239C22O15135C27O15271,,
tick,0x19594dca4,124625,0,0x0,3,0x0,0x1fa4d1d7f82e,0x1fa4d1d7ccca,0x1fa4d1d6c5f9,0x202f0287621a
code-creation,LazyCompile,10,124667,0x1fa4d1d7fe50,45,updateChildren node:internal/modules/cjs/loader:206:24,0x2b3d46cdf450,~
code-source-info,0x1fa4d1d7fe50,465,5949,6122,C0O5992C7O5998C15O6012C19O6030C23O6038C26O6038C33O6084C38O6084C44O6121,,
new,MemoryChunk,0x1a7a75880000,262144
code-creation,LazyCompile,10,124750,0x1a7a75881168,54,reportModuleToWatchMode node:internal/modules/cjs/loader:212:33,0x2b3d46cdf4a0,~
code-source-info,0x1a7a75881168,465,6156,6278,C0O6171C9O6214C15O6226C18O6234C28O6258C37O6259C47O6234C53O6277,,
code-creation,LazyCompile,10,124792,0x1a7a75881358,246,Module.load node:internal/modules/cjs/loader:1107:33,0x2b3d46ce04d8,~
code-source-info,0x1a7a75881358,465,34608,35421,C0O34623C8O34669C16O34623C21O34677C26O34690C32O34677C36O34701C38O34715C42O34729C45O34749C52O34766C55O34771C60O34771C66O34749C71O34740C75O34812C78O34812C83O34889C91O34893C101O34946C106O34957C112O34971C124O34977C129O34971C130O35017C133O35024C140O35035C144O35046C150O35066C151O35078C155O35107C160O35116C165O35218C170O35253C175O35264C187O35304C192O35311C197O35311C204O35325C206O35323C211O35357C216O35366C221O35366C228O35391C233O35400C238O35400C245O35420,,
code-creation,LazyCompile,10,124834,0x1a7a75881710,183,Module._nodeModulePaths node:internal/modules/cjs/loader:749:37,0x2b3d46ce0200,~
code-source-info,0x1a7a75881710,465,22629,23761,C0O22684C5O22696C10O22696C17O22875C19O22884C24O22899C28O22924C29O23139C32O23165C36O23172C40O23181C42O23196C47O23206C48O23206C53O23238C58O23238C64O23280C66O23293C68O23289C73O23323C75O23333C77O23329C82O23350C89O23401C100O23401C108O23437C112O23350C117O23477C120O23495C124O23515C126O23521C131O23539C138O23550C144O23554C149O23576C156O23608C159O23214C164O23147C167O23695C175O23695C180O23744C182O23757,,
code-creation,Function,11,124917,0x110051e20,1736,Module._nodeModulePaths node:internal/modules/cjs/loader:749:37,0x2b3d46ce0200,^
code-source-info,0x110051e20,465,22629,23761,,,
code-creation,Function,11,124959,0x110052560,216, node:internal/modules/cjs/loader:255:41,0x2b3d46cdfcd0,^
code-source-info,0x110052560,465,7589,7615,,,
code-creation,Function,11,124959,0x1100526a0,344,validateString node:internal/validators:160:24,0x1012a394bc20,^
code-source-info,0x1100526a0,22,4120,4229,,,
code-creation,Function,11,125000,0x110052860,1584,resolve node:path:1091:10,0x28e4ce8cd0d0,^
code-source-info,0x110052860,74,33819,34735,,,
code-creation,Function,11,125000,0x110052f00,64,toNamespacedPath node:path:1265:19,0x28e4ce8cd260,^
code-source-info,0x110052f00,74,38652,38712,,,
code-creation,Function,11,125000,0x110052fa0,216,nextPart node:fs:2566:31,0x28e4ce8e7828,^
code-source-info,0x110052fa0,76,68832,68890,,,
code-creation,Function,11,125042,0x1100530e0,376,isFileType node:fs:217:20,0x28e4ce8e59d0,^
code-source-info,0x1100530e0,76,5468,5709,,,
code-creation,Function,11,125084,0x1100532c0,1552,dirname node:path:1274:10,0x28e4ce8cd2b0,^
code-source-info,0x1100532c0,74,38785,39454,,,
code-creation,LazyCompile,10,125125,0x1a7a75881c50,98,findLongestRegisteredExtension node:internal/modules/cjs/loader:498:40,0x2b3d46cdf810,~
code-source-info,0x1a7a75881c50,465,14164,14593,C0O14192C5O14197C10O14197C16O14223C18O14247C20O14273C22O14341C36O14294C44O14341C49O14355C51O14374C55O14383C56O14393C61O14400C63O14447C68O14466C74O14505C77O14516C84O14527C89O14547C91O14571C92O14278C95O14578C97O14591,,
code-creation,LazyCompile,10,125167,0x1a7a75881e50,353,basename node:path:1305:11,0x28e4ce8cd300,~
code-source-info,0x1a7a75881e50,74,39558,41977,C0O39579C4O39611C12O39611C17O39646C25O39646C30O39693C32O39710C35O39737C37O39748C41O39783C47O39790C52O39804C57O39819C61O39811C66O39835C68O39846C73O39864C75O39874C76O39901C80O39908C84O39942C87O39970C91O39977C95O39984C96O39984C101O40018C106O40018C112O40062C114O40075C116O40071C121O40245C125O40278C127O40288C131O40305C135O40351C137O40372C142O40538C144O40572C146O40593C150O40620C151O40631C156O40702C158O40715C161O40715C166O40711C171O40774C178O40787C183O40923C190O41086C193O41113C198O39992C203O39952C206O41188C208O41198C213O41215C220O41250C222O41258C227O41285C232O41299C246O41306C251O41345C252O41374C256O41381C260O41388C261O41388C266O41407C271O41411C279O41450C281O41446C286O41614C290O41645C292O41655C296O41670C300O41700C302O41708C307O41828C309O41858C311O41866C315O41396C320O41356C323O41890C325O41898C330O41912C332O41922C333O41927C347O41934C352O41973,,
code-creation,LazyCompile,10,125292,0x1a7a758822f8,485,Module._extensions..js node:internal/modules/cjs/loader:1265:37,0x2b3d46ce0678,~
code-source-info,0x1a7a758822f8,465,39650,41402,C0O39749C5O39763C10O39763C16O39782C18O39793C25O39803C34O39836C39O39848C40O39862C46O39890C51O39903C60O39903C67O39941C76O39945C83O40005C86O40005C91O40094C96O40101C103O40107C113O40114C118O40151C123O40169C128O40169C134O40207C139O40213C147O40255C152O40260C157O40272C167O40260C174O40317C179O40317C184O40358C203O40358C209O40529C212O40540C219O40546C224O40574C229O40612C235O40630C244O40630C254O40625C257O40743C261O40789C268O40823C271O40848C279O40855C283O40897C293O40855C300O40823C314O40789C321O40925C325O40982C335O40982C345O40951C352O40960C359O41045C365O41057C367O41092C376O41092C384O41138C387O41132C391O41170C403O41187C416O41196C429O41223C438O41254C443O41223C459O41277C464O41277C469O41342C471O41342C472O41372C477O41372C484O41401,,
code-creation,LazyCompile,10,125375,0x1a7a75882740,376,readFileSync node:fs:468:22,0x28e4ce8e5e30,~
code-source-info,0x1a7a75882740,76,12012,13389,C0O12032C5O12053C10O12042C17O12097C22O12097C27O12151C35O12169C38O12172C43O12195C56O12172C62O12226C65O12226C71O12268C76O12286C79O12268C88O12302C95O12323C97O12332C99O12378C101O12423C102O12432C107O12445C112O12474C124O12483C130O12531C132O12545C133O12554C138O12578C143O12634C159O12590C165O12648C167O12655C174O12695C175O12689C182O12702C187O12567C192O12826C197O12842C207O12842C213O12867C232O12879C238O12929C239O12943C244O12960C249O12995C256O12995C263O12960C268O13031C270O13038C277O13072C278O13072C283O12726C286O13087C290O13106C295O13109C300O13109C305O13127C306O13136C311O13198C316O13214C321O13214C330O13245C332O13253C337O13283C344O13283C351O13317C357O13343C362O13360C367O13343C373O13373C375O13387,,
tick,0x1010dcb8c,125584,0,0x0,3,0x0,0x1fa4d1d76c86,0x1fa4d1d74c60,0x1a7a7588274a,0x1a7a75882334,0x1a7a758813e8,0x1fa4d1d7cd38,0x1fa4d1d6c5f9,0x202f0287621a
code-creation,LazyCompile,10,125625,0x1a7a75882a60,30,isEncoding node:buffer:582:40,0x1012a397fc78,~
script-source,30,node:buffer,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIndexOf\x2C\n  MathFloor\x2C\n  MathMin\x2C\n  MathTrunc\x2C\n  NumberIsNaN\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeTrim\x2C\n  SymbolSpecies\x2C\n  SymbolToPrimitive\x2C\n  TypedArrayPrototypeGetBuffer\x2C\n  TypedArrayPrototypeGetByteLength\x2C\n  TypedArrayPrototypeGetByteOffset\x2C\n  TypedArrayPrototypeFill\x2C\n  TypedArrayPrototypeGetLength\x2C\n  TypedArrayPrototypeSet\x2C\n  TypedArrayPrototypeSlice\x2C\n  Uint8Array\x2C\n  Uint8ArrayPrototype\x2C\n} = primordials;\n\nconst {\n  byteLengthUtf8\x2C\n  compare: _compare\x2C\n  compareOffset\x2C\n  createFromString\x2C\n  fill: bindingFill\x2C\n  isAscii: bindingIsAscii\x2C\n  isUtf8: bindingIsUtf8\x2C\n  indexOfBuffer\x2C\n  indexOfNumber\x2C\n  indexOfString\x2C\n  swap16: _swap16\x2C\n  swap32: _swap32\x2C\n  swap64: _swap64\x2C\n  kMaxLength\x2C\n  kStringMaxLength\x2C\n} = internalBinding('buffer');\nconst {\n  constants: {\n    ALL_PROPERTIES\x2C\n    ONLY_ENUMERABLE\x2C\n  }\x2C\n  getOwnNonIndexProperties\x2C\n} = internalBinding('util');\nconst {\n  customInspectSymbol\x2C\n  isInsideNodeModules\x2C\n  lazyDOMException\x2C\n  normalizeEncoding\x2C\n  kIsEncodingSymbol\x2C\n} = require('internal/util');\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n  isUint8Array\x2C\n  isTypedArray\x2C\n} = require('internal/util/types');\nconst {\n  inspect: utilInspect\x2C\n} = require('internal/util/inspect');\nconst { encodings } = internalBinding('string_decoder');\n\nconst {\n  codes: {\n    ERR_BUFFER_OUT_OF_BOUNDS\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_BUFFER_SIZE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_UNKNOWN_ENCODING\x2C\n  }\x2C\n  genericNodeError\x2C\n  hideStackFrames\x2C\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateBuffer\x2C\n  validateNumber\x2C\n  validateInteger\x2C\n  validateString\x2C\n} = require('internal/validators');\n// Provide validateInteger() but with kMaxLength as the default maximum value.\nconst validateOffset = (value\x2C name\x2C min = 0\x2C max = kMaxLength) =>\n  validateInteger(value\x2C name\x2C min\x2C max);\n\nconst {\n  FastBuffer\x2C\n  markAsUntransferable\x2C\n  addBufferPrototypeMethods\x2C\n  createUnsafeBuffer\x2C\n} = require('internal/buffer');\n\nconst {\n  Blob\x2C\n  resolveObjectURL\x2C\n} = require('internal/blob');\n\nconst {\n  File\x2C\n} = require('internal/file');\n\nFastBuffer.prototype.constructor = Buffer;\nBuffer.prototype = FastBuffer.prototype;\naddBufferPrototypeMethods(Buffer.prototype);\n\nconst constants = ObjectDefineProperties({}\x2C {\n  MAX_LENGTH: {\n    __proto__: null\x2C\n    value: kMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\x2C\n  }\x2C\n  MAX_STRING_LENGTH: {\n    __proto__: null\x2C\n    value: kStringMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\x2C\n  }\x2C\n});\n\nBuffer.poolSize = 8 * 1024;\nlet poolSize\x2C poolOffset\x2C allocPool;\n\nconst encodingsMap = ObjectCreate(null);\nfor (let i = 0; i < encodings.length; ++i)\n  encodingsMap[encodings[i]] = i;\n\nfunction createPool() {\n  poolSize = Buffer.poolSize;\n  allocPool = createUnsafeBuffer(poolSize).buffer;\n  markAsUntransferable(allocPool);\n  poolOffset = 0;\n}\ncreatePool();\n\nfunction alignPool() {\n  // Ensure aligned slices\n  if (poolOffset & 0x7) {\n    poolOffset |= 0x7;\n    poolOffset++;\n  }\n}\n\nlet bufferWarningAlreadyEmitted = false;\nlet nodeModulesCheckCounter = 0;\nconst bufferWarning = 'Buffer() is deprecated due to security and usability ' +\n                      'issues. Please use the Buffer.alloc()\x2C ' +\n                      'Buffer.allocUnsafe()\x2C or Buffer.from() methods instead.';\n\nfunction showFlaggedDeprecation() {\n  if (bufferWarningAlreadyEmitted ||\n      ++nodeModulesCheckCounter > 10000 ||\n      (!require('internal/options').getOptionValue('--pending-deprecation') &&\n       isInsideNodeModules())) {\n    // We don't emit a warning\x2C because we either:\n    // - Already did so\x2C or\n    // - Already checked too many times whether a call is coming\n    //   from node_modules and want to stop slowing down things\x2C or\n    // - We aren't running with `--pending-deprecation` enabled\x2C\n    //   and the code is inside `node_modules`.\n    return;\n  }\n\n  process.emitWarning(bufferWarning\x2C 'DeprecationWarning'\x2C 'DEP0005');\n  bufferWarningAlreadyEmitted = true;\n}\n\nfunction toInteger(n\x2C defaultVal) {\n  n = +n;\n  if (!NumberIsNaN(n) &&\n      n >= NumberMIN_SAFE_INTEGER &&\n      n <= NumberMAX_SAFE_INTEGER) {\n    return ((n % 1) === 0 ? n : MathFloor(n));\n  }\n  return defaultVal;\n}\n\nfunction _copy(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (!isUint8Array(source))\n    throw new ERR_INVALID_ARG_TYPE('source'\x2C ['Buffer'\x2C 'Uint8Array']\x2C source);\n  if (!isUint8Array(target))\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n\n  if (targetStart === undefined) {\n    targetStart = 0;\n  } else {\n    targetStart = toInteger(targetStart\x2C 0);\n    if (targetStart < 0)\n      throw new ERR_OUT_OF_RANGE('targetStart'\x2C '>= 0'\x2C targetStart);\n  }\n\n  if (sourceStart === undefined) {\n    sourceStart = 0;\n  } else {\n    sourceStart = toInteger(sourceStart\x2C 0);\n    if (sourceStart < 0 || sourceStart > source.length)\n      throw new ERR_OUT_OF_RANGE('sourceStart'\x2C `>= 0 && <= ${source.length}`\x2C sourceStart);\n  }\n\n  if (sourceEnd === undefined) {\n    sourceEnd = source.length;\n  } else {\n    sourceEnd = toInteger(sourceEnd\x2C 0);\n    if (sourceEnd < 0)\n      throw new ERR_OUT_OF_RANGE('sourceEnd'\x2C '>= 0'\x2C sourceEnd);\n  }\n\n  if (targetStart >= target.length || sourceStart >= sourceEnd)\n    return 0;\n\n  return _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n}\n\nfunction _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (sourceEnd - sourceStart > target.length - targetStart)\n    sourceEnd = sourceStart + target.length - targetStart;\n\n  let nb = sourceEnd - sourceStart;\n  const sourceLen = source.length - sourceStart;\n  if (nb > sourceLen)\n    nb = sourceLen;\n\n  if (sourceStart !== 0 || sourceEnd < source.length)\n    source = new Uint8Array(source.buffer\x2C source.byteOffset + sourceStart\x2C nb);\n\n  TypedArrayPrototypeSet(target\x2C source\x2C targetStart);\n\n  return nb;\n}\n\n/**\n * The Buffer() constructor is deprecated in documentation and should not be\n * used moving forward. Rather\x2C developers should use one of the three new\n * factory APIs: Buffer.from()\x2C Buffer.allocUnsafe() or Buffer.alloc() based on\n * their specific needs. There is no runtime deprecation because of the extent\n * to which the Buffer constructor is used in the ecosystem currently -- a\n * runtime deprecation would introduce too much breakage at this time. It's not\n * likely that the Buffer constructors would ever actually be removed.\n * Deprecation Code: DEP0005\n */\nfunction Buffer(arg\x2C encodingOrOffset\x2C length) {\n  showFlaggedDeprecation();\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new ERR_INVALID_ARG_TYPE('string'\x2C 'string'\x2C arg);\n    }\n    return Buffer.alloc(arg);\n  }\n  return Buffer.from(arg\x2C encodingOrOffset\x2C length);\n}\n\nObjectDefineProperty(Buffer\x2C SymbolSpecies\x2C {\n  __proto__: null\x2C\n  enumerable: false\x2C\n  configurable: true\x2C\n  get() { return FastBuffer; }\x2C\n});\n\n/**\n * Functionally equivalent to Buffer(arg\x2C encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[\x2C encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[\x2C byteOffset[\x2C length]])\n */\nBuffer.from = function from(value\x2C encodingOrOffset\x2C length) {\n  if (typeof value === 'string')\n    return fromString(value\x2C encodingOrOffset);\n\n  if (typeof value === 'object' && value !== null) {\n    if (isAnyArrayBuffer(value))\n      return fromArrayBuffer(value\x2C encodingOrOffset\x2C length);\n\n    const valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null &&\n        valueOf !== value &&\n        (typeof valueOf === 'string' || typeof valueOf === 'object')) {\n      return from(valueOf\x2C encodingOrOffset\x2C length);\n    }\n\n    const b = fromObject(value);\n    if (b)\n      return b;\n\n    if (typeof value[SymbolToPrimitive] === 'function') {\n      const primitive = value[SymbolToPrimitive]('string');\n      if (typeof primitive === 'string') {\n        return fromString(primitive\x2C encodingOrOffset);\n      }\n    }\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'first argument'\x2C\n    ['string'\x2C 'Buffer'\x2C 'ArrayBuffer'\x2C 'Array'\x2C 'Array-like Object']\x2C\n    value\x2C\n  );\n};\n\n/**\n * Creates the Buffer as a copy of the underlying ArrayBuffer of the view\n * rather than the contents of the view.\n * @param {TypedArray} view\n * @param {number} [offset]\n * @param {number} [length]\n * @returns {Buffer}\n */\nBuffer.copyBytesFrom = function copyBytesFrom(view\x2C offset\x2C length) {\n  if (!isTypedArray(view)) {\n    throw new ERR_INVALID_ARG_TYPE('view'\x2C [ 'TypedArray' ]\x2C view);\n  }\n\n  const viewLength = TypedArrayPrototypeGetLength(view);\n  if (viewLength === 0) {\n    return Buffer.alloc(0);\n  }\n\n  if (offset !== undefined || length !== undefined) {\n    if (offset !== undefined) {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n      if (offset >= viewLength) return Buffer.alloc(0);\n    } else {\n      offset = 0;\n    }\n    let end;\n    if (length !== undefined) {\n      validateInteger(length\x2C 'length'\x2C 0);\n      end = offset + length;\n    } else {\n      end = viewLength;\n    }\n\n    view = TypedArrayPrototypeSlice(view\x2C offset\x2C end);\n  }\n\n  return fromArrayLike(new Uint8Array(\n    TypedArrayPrototypeGetBuffer(view)\x2C\n    TypedArrayPrototypeGetByteOffset(view)\x2C\n    TypedArrayPrototypeGetByteLength(view)));\n};\n\n// Identical to the built-in %TypedArray%.of()\x2C but avoids using the deprecated\n// Buffer() constructor. Must use arrow function syntax to avoid automatically\n// adding a `prototype` property and making the function a constructor.\n//\n// Refs: https://tc39.github.io/ecma262/#sec-%typedarray%.of\n// Refs: https://esdiscuss.org/topic/isconstructor#content-11\nconst of = (...items) => {\n  const newObj = createUnsafeBuffer(items.length);\n  for (let k = 0; k < items.length; k++)\n    newObj[k] = items[k];\n  return newObj;\n};\nBuffer.of = of;\n\nObjectSetPrototypeOf(Buffer\x2C Uint8Array);\n\n// The 'assertSize' method will remove itself from the callstack when an error\n// occurs. This is done simply to keep the internal details of the\n// implementation from bleeding out to users.\nconst assertSize = hideStackFrames((size) => {\n  validateNumber(size\x2C 'size');\n  if (!(size >= 0 && size <= kMaxLength)) {\n    throw new ERR_INVALID_ARG_VALUE.RangeError('size'\x2C size);\n  }\n});\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[\x2C fill[\x2C encoding]])\n */\nBuffer.alloc = function alloc(size\x2C fill\x2C encoding) {\n  assertSize(size);\n  if (fill !== undefined && fill !== 0 && size > 0) {\n    const buf = createUnsafeBuffer(size);\n    return _fill(buf\x2C fill\x2C 0\x2C buf.length\x2C encoding);\n  }\n  return new FastBuffer(size);\n};\n\n/**\n * Equivalent to Buffer(num)\x2C by default creates a non-zero-filled Buffer\n * instance. If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafe = function allocUnsafe(size) {\n  assertSize(size);\n  return allocate(size);\n};\n\n/**\n * Equivalent to SlowBuffer(num)\x2C by default creates a non-zero-filled\n * Buffer instance that is not allocated off the pre-initialized pool.\n * If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafeSlow = function allocUnsafeSlow(size) {\n  assertSize(size);\n  return createUnsafeBuffer(size);\n};\n\n// If --zero-fill-buffers command line argument is set\x2C a zero-filled\n// buffer is returned.\nfunction SlowBuffer(length) {\n  assertSize(length);\n  return createUnsafeBuffer(length);\n}\n\nObjectSetPrototypeOf(SlowBuffer.prototype\x2C Uint8ArrayPrototype);\nObjectSetPrototypeOf(SlowBuffer\x2C Uint8Array);\n\nfunction allocate(size) {\n  if (size <= 0) {\n    return new FastBuffer();\n  }\n  if (size < (Buffer.poolSize >>> 1)) {\n    if (size > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C size);\n    poolOffset += size;\n    alignPool();\n    return b;\n  }\n  return createUnsafeBuffer(size);\n}\n\nfunction fromStringFast(string\x2C ops) {\n  const length = ops.byteLength(string);\n\n  if (length >= (Buffer.poolSize >>> 1))\n    return createFromString(string\x2C ops.encodingVal);\n\n  if (length > (poolSize - poolOffset))\n    createPool();\n  let b = new FastBuffer(allocPool\x2C poolOffset\x2C length);\n  const actual = ops.write(b\x2C string\x2C 0\x2C length);\n  if (actual !== length) {\n    // byteLength() may overestimate. That's a rare case\x2C though.\n    b = new FastBuffer(allocPool\x2C poolOffset\x2C actual);\n  }\n  poolOffset += actual;\n  alignPool();\n  return b;\n}\n\nfunction fromString(string\x2C encoding) {\n  let ops;\n  if (typeof encoding !== 'string' || encoding.length === 0) {\n    if (string.length === 0)\n      return new FastBuffer();\n    ops = encodingOps.utf8;\n    encoding = undefined;\n  } else {\n    ops = getEncodingOps(encoding);\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (string.length === 0)\n      return new FastBuffer();\n  }\n  return fromStringFast(string\x2C ops);\n}\n\nfunction fromArrayBuffer(obj\x2C byteOffset\x2C length) {\n  // Convert byteOffset to integer\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  } else {\n    byteOffset = +byteOffset;\n    if (NumberIsNaN(byteOffset))\n      byteOffset = 0;\n  }\n\n  const maxLength = obj.byteLength - byteOffset;\n\n  if (maxLength < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('offset');\n\n  if (length === undefined) {\n    length = maxLength;\n  } else {\n    // Convert length to non-negative integer.\n    length = +length;\n    if (length > 0) {\n      if (length > maxLength)\n        throw new ERR_BUFFER_OUT_OF_BOUNDS('length');\n    } else {\n      length = 0;\n    }\n  }\n\n  return new FastBuffer(obj\x2C byteOffset\x2C length);\n}\n\nfunction fromArrayLike(obj) {\n  if (obj.length <= 0)\n    return new FastBuffer();\n  if (obj.length < (Buffer.poolSize >>> 1)) {\n    if (obj.length > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C obj.length);\n    TypedArrayPrototypeSet(b\x2C obj\x2C 0);\n    poolOffset += obj.length;\n    alignPool();\n    return b;\n  }\n  return new FastBuffer(obj);\n}\n\nfunction fromObject(obj) {\n  if (obj.length !== undefined || isAnyArrayBuffer(obj.buffer)) {\n    if (typeof obj.length !== 'number') {\n      return new FastBuffer();\n    }\n    return fromArrayLike(obj);\n  }\n\n  if (obj.type === 'Buffer' && ArrayIsArray(obj.data)) {\n    return fromArrayLike(obj.data);\n  }\n}\n\n// Static methods\n\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer;\n};\n\nBuffer.compare = function compare(buf1\x2C buf2) {\n  if (!isUint8Array(buf1)) {\n    throw new ERR_INVALID_ARG_TYPE('buf1'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf1);\n  }\n\n  if (!isUint8Array(buf2)) {\n    throw new ERR_INVALID_ARG_TYPE('buf2'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf2);\n  }\n\n  if (buf1 === buf2) {\n    return 0;\n  }\n\n  return _compare(buf1\x2C buf2);\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  return typeof encoding === 'string' && encoding.length !== 0 &&\n         normalizeEncoding(encoding) !== undefined;\n};\nBuffer[kIsEncodingSymbol] = Buffer.isEncoding;\n\nBuffer.concat = function concat(list\x2C length) {\n  validateArray(list\x2C 'list');\n\n  if (list.length === 0)\n    return new FastBuffer();\n\n  if (length === undefined) {\n    length = 0;\n    for (let i = 0; i < list.length; i++) {\n      if (list[i].length) {\n        length += list[i].length;\n      }\n    }\n  } else {\n    validateOffset(length\x2C 'length');\n  }\n\n  const buffer = Buffer.allocUnsafe(length);\n  let pos = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    if (!isUint8Array(buf)) {\n      // TODO(BridgeAR): This should not be of type ERR_INVALID_ARG_TYPE.\n      // Instead\x2C find the proper error code for this.\n      throw new ERR_INVALID_ARG_TYPE(\n        `list[${i}]`\x2C ['Buffer'\x2C 'Uint8Array']\x2C list[i]);\n    }\n    pos += _copyActual(buf\x2C buffer\x2C pos\x2C 0\x2C buf.length);\n  }\n\n  // Note: `length` is always equal to `buffer.length` at this point\n  if (pos < length) {\n    // Zero-fill the remaining bytes if the specified `length` was more than\n    // the actual total length\x2C i.e. if we have some remaining allocated bytes\n    // there were not initialized.\n    TypedArrayPrototypeFill(buffer\x2C 0\x2C pos\x2C length);\n  }\n\n  return buffer;\n};\n\nfunction base64ByteLength(str\x2C bytes) {\n  // Handle padding\n  if (StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n  if (bytes > 1 && StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n\n  // Base64 ratio: 3/4\n  return (bytes * 3) >>> 2;\n}\n\nconst encodingOps = {\n  utf8: {\n    encoding: 'utf8'\x2C\n    encodingVal: encodingsMap.utf8\x2C\n    byteLength: byteLengthUtf8\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.utf8Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.utf8Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf8\x2C dir)\x2C\n  }\x2C\n  ucs2: {\n    encoding: 'ucs2'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\x2C\n  }\x2C\n  utf16le: {\n    encoding: 'utf16le'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\x2C\n  }\x2C\n  latin1: {\n    encoding: 'latin1'\x2C\n    encodingVal: encodingsMap.latin1\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.latin1Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.latin1Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.latin1\x2C dir)\x2C\n  }\x2C\n  ascii: {\n    encoding: 'ascii'\x2C\n    encodingVal: encodingsMap.ascii\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.asciiWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.asciiSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.ascii)\x2C\n                    byteOffset\x2C\n                    encodingsMap.ascii\x2C\n                    dir)\x2C\n  }\x2C\n  base64: {\n    encoding: 'base64'\x2C\n    encodingVal: encodingsMap.base64\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.base64Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64\x2C\n                    dir)\x2C\n  }\x2C\n  base64url: {\n    encoding: 'base64url'\x2C\n    encodingVal: encodingsMap.base64url\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) =>\n      buf.base64urlWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64urlSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64url)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64url\x2C\n                    dir)\x2C\n  }\x2C\n  hex: {\n    encoding: 'hex'\x2C\n    encodingVal: encodingsMap.hex\x2C\n    byteLength: (string) => string.length >>> 1\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.hexWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.hexSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.hex)\x2C\n                    byteOffset\x2C\n                    encodingsMap.hex\x2C\n                    dir)\x2C\n  }\x2C\n};\nfunction getEncodingOps(encoding) {\n  encoding += '';\n  switch (encoding.length) {\n    case 4:\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      break;\n    case 5:\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      break;\n    case 7:\n      if (encoding === 'utf16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf16le')\n        return encodingOps.utf16le;\n      break;\n    case 8:\n      if (encoding === 'utf-16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf-16le')\n        return encodingOps.utf16le;\n      break;\n    case 6:\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      break;\n    case 3:\n      if (encoding === 'hex' || StringPrototypeToLowerCase(encoding) === 'hex')\n        return encodingOps.hex;\n      break;\n    case 9:\n      if (encoding === 'base64url' ||\n          StringPrototypeToLowerCase(encoding) === 'base64url')\n        return encodingOps.base64url;\n      break;\n  }\n}\n\nfunction byteLength(string\x2C encoding) {\n  if (typeof string !== 'string') {\n    if (isArrayBufferView(string) || isAnyArrayBuffer(string)) {\n      return string.byteLength;\n    }\n\n    throw new ERR_INVALID_ARG_TYPE(\n      'string'\x2C ['string'\x2C 'Buffer'\x2C 'ArrayBuffer']\x2C string\x2C\n    );\n  }\n\n  const len = string.length;\n  if (len === 0)\n    return 0;\n\n  if (encoding) {\n    const ops = getEncodingOps(encoding);\n    if (ops) {\n      return ops.byteLength(string);\n    }\n  }\n  return byteLengthUtf8(string);\n}\n\nBuffer.byteLength = byteLength;\n\n// For backwards compatibility.\nObjectDefineProperty(Buffer.prototype\x2C 'parent'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.buffer;\n  }\x2C\n});\nObjectDefineProperty(Buffer.prototype\x2C 'offset'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.byteOffset;\n  }\x2C\n});\n\nBuffer.prototype.copy =\n  function copy(target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n    return _copy(this\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n  };\n\n// No need to verify that "buf.length <= MAX_UINT32" since it's a read-only\n// property of a typed array.\n// This behaves neither like String nor Uint8Array in that we set start/end\n// to their upper/lower bounds if the value passed is out of range.\nBuffer.prototype.toString = function toString(encoding\x2C start\x2C end) {\n  if (arguments.length === 0) {\n    return this.utf8Slice(0\x2C this.length);\n  }\n\n  const len = this.length;\n\n  if (start <= 0)\n    start = 0;\n  else if (start >= len)\n    return '';\n  else\n    start |= 0;\n\n  if (end === undefined || end > len)\n    end = len;\n  else\n    end |= 0;\n\n  if (end <= start)\n    return '';\n\n  if (encoding === undefined)\n    return this.utf8Slice(start\x2C end);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n\n  return ops.slice(this\x2C start\x2C end);\n};\n\nBuffer.prototype.equals = function equals(otherBuffer) {\n  if (!isUint8Array(otherBuffer)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'otherBuffer'\x2C ['Buffer'\x2C 'Uint8Array']\x2C otherBuffer);\n  }\n\n  if (this === otherBuffer)\n    return true;\n\n  if (this.byteLength !== otherBuffer.byteLength)\n    return false;\n\n  return this.byteLength === 0 || _compare(this\x2C otherBuffer) === 0;\n};\n\nlet INSPECT_MAX_BYTES = 50;\n// Override how buffers are presented by util.inspect().\nBuffer.prototype[customInspectSymbol] = function inspect(recurseTimes\x2C ctx) {\n  const max = INSPECT_MAX_BYTES;\n  const actualMax = MathMin(max\x2C this.length);\n  const remaining = this.length - max;\n  let str = StringPrototypeTrim(RegExpPrototypeSymbolReplace(\n    /(.{2})/g\x2C this.hexSlice(0\x2C actualMax)\x2C '$1 '));\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  // Inspect special properties as well\x2C if possible.\n  if (ctx) {\n    let extras = false;\n    const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n    const obj = ObjectCreate(null);\n    ArrayPrototypeForEach(getOwnNonIndexProperties(this\x2C filter)\x2C\n                          (key) => {\n                            extras = true;\n                            obj[key] = this[key];\n                          });\n    if (extras) {\n      if (this.length !== 0)\n        str += '\x2C ';\n      // '[Object: null prototype] {'.length === 26\n      // This is guarded with a test.\n      str += StringPrototypeSlice(utilInspect(obj\x2C {\n        ...ctx\x2C\n        breakLength: Infinity\x2C\n        compact: true\x2C\n      })\x2C 27\x2C -2);\n    }\n  }\n  return `<${this.constructor.name} ${str}>`;\n};\nBuffer.prototype.inspect = Buffer.prototype[customInspectSymbol];\n\nBuffer.prototype.compare = function compare(target\x2C\n                                            targetStart\x2C\n                                            targetEnd\x2C\n                                            sourceStart\x2C\n                                            sourceEnd) {\n  if (!isUint8Array(target)) {\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n  }\n  if (arguments.length === 1)\n    return _compare(this\x2C target);\n\n  if (targetStart === undefined)\n    targetStart = 0;\n  else\n    validateOffset(targetStart\x2C 'targetStart');\n\n  if (targetEnd === undefined)\n    targetEnd = target.length;\n  else\n    validateOffset(targetEnd\x2C 'targetEnd'\x2C 0\x2C target.length);\n\n  if (sourceStart === undefined)\n    sourceStart = 0;\n  else\n    validateOffset(sourceStart\x2C 'sourceStart');\n\n  if (sourceEnd === undefined)\n    sourceEnd = this.length;\n  else\n    validateOffset(sourceEnd\x2C 'sourceEnd'\x2C 0\x2C this.length);\n\n  if (sourceStart >= sourceEnd)\n    return (targetStart >= targetEnd ? 0 : -1);\n  if (targetStart >= targetEnd)\n    return 1;\n\n  return compareOffset(this\x2C target\x2C targetStart\x2C sourceStart\x2C targetEnd\x2C\n                       sourceEnd);\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`\x2C\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string\x2C Buffer\x2C or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding\x2C relevant if val is a string\n// - dir - true for indexOf\x2C false for lastIndexOf\nfunction bidirectionalIndexOf(buffer\x2C val\x2C byteOffset\x2C encoding\x2C dir) {\n  validateBuffer(buffer);\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = undefined;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  // Coerce to Number. Values like null and [] become 0.\n  byteOffset = +byteOffset;\n  // If the offset is undefined\x2C "foo"\x2C {}\x2C coerces to NaN\x2C search whole buffer.\n  if (NumberIsNaN(byteOffset)) {\n    byteOffset = dir ? 0 : (buffer.length || buffer.byteLength);\n  }\n  dir = !!dir;  // Cast to bool.\n\n  if (typeof val === 'number')\n    return indexOfNumber(buffer\x2C val >>> 0\x2C byteOffset\x2C dir);\n\n  let ops;\n  if (encoding === undefined)\n    ops = encodingOps.utf8;\n  else\n    ops = getEncodingOps(encoding);\n\n  if (typeof val === 'string') {\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    return ops.indexOf(buffer\x2C val\x2C byteOffset\x2C dir);\n  }\n\n  if (isUint8Array(val)) {\n    const encodingVal =\n      (ops === undefined ? encodingsMap.utf8 : ops.encodingVal);\n    return indexOfBuffer(buffer\x2C val\x2C byteOffset\x2C encodingVal\x2C dir);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'value'\x2C ['number'\x2C 'string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C val\x2C\n  );\n}\n\nBuffer.prototype.indexOf = function indexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C false);\n};\n\nBuffer.prototype.includes = function includes(val\x2C byteOffset\x2C encoding) {\n  return this.indexOf(val\x2C byteOffset\x2C encoding) !== -1;\n};\n\n// Usage:\n//    buffer.fill(number[\x2C offset[\x2C end]])\n//    buffer.fill(buffer[\x2C offset[\x2C end]])\n//    buffer.fill(string[\x2C offset[\x2C end]][\x2C encoding])\nBuffer.prototype.fill = function fill(value\x2C offset\x2C end\x2C encoding) {\n  return _fill(this\x2C value\x2C offset\x2C end\x2C encoding);\n};\n\nfunction _fill(buf\x2C value\x2C offset\x2C end\x2C encoding) {\n  if (typeof value === 'string') {\n    if (offset === undefined || typeof offset === 'string') {\n      encoding = offset;\n      offset = 0;\n      end = buf.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = buf.length;\n    }\n\n    const normalizedEncoding = normalizeEncoding(encoding);\n    if (normalizedEncoding === undefined) {\n      validateString(encoding\x2C 'encoding');\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    }\n\n    if (value.length === 0) {\n      // If value === '' default to zero.\n      value = 0;\n    } else if (value.length === 1) {\n      // Fast path: If `value` fits into a single byte\x2C use that numeric value.\n      if (normalizedEncoding === 'utf8') {\n        const code = StringPrototypeCharCodeAt(value\x2C 0);\n        if (code < 128) {\n          value = code;\n        }\n      } else if (normalizedEncoding === 'latin1') {\n        value = StringPrototypeCharCodeAt(value\x2C 0);\n      }\n    }\n  } else {\n    encoding = undefined;\n  }\n\n  if (offset === undefined) {\n    offset = 0;\n    end = buf.length;\n  } else {\n    validateOffset(offset\x2C 'offset');\n    // Invalid ranges are not set to a default\x2C so can range check early.\n    if (end === undefined) {\n      end = buf.length;\n    } else {\n      validateOffset(end\x2C 'end'\x2C 0\x2C buf.length);\n    }\n    if (offset >= end)\n      return buf;\n  }\n\n\n  if (typeof value === 'number') {\n    // OOB check\n    const byteLen = TypedArrayPrototypeGetByteLength(buf);\n    const fillLength = end - offset;\n    if (offset > end || fillLength + offset > byteLen)\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n    TypedArrayPrototypeFill(buf\x2C value\x2C offset\x2C end);\n  } else {\n    const res = bindingFill(buf\x2C value\x2C offset\x2C end\x2C encoding);\n    if (res < 0) {\n      if (res === -1)\n        throw new ERR_INVALID_ARG_VALUE('value'\x2C value);\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n    }\n  }\n\n  return buf;\n}\n\nBuffer.prototype.write = function write(string\x2C offset\x2C length\x2C encoding) {\n  // Buffer#write(string);\n  if (offset === undefined) {\n    return this.utf8Write(string\x2C 0\x2C this.length);\n  }\n  // Buffer#write(string\x2C encoding)\n  if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n\n  // Buffer#write(string\x2C offset[\x2C length][\x2C encoding])\n  } else {\n    validateOffset(offset\x2C 'offset'\x2C 0\x2C this.length);\n\n    const remaining = this.length - offset;\n\n    if (length === undefined) {\n      length = remaining;\n    } else if (typeof length === 'string') {\n      encoding = length;\n      length = remaining;\n    } else {\n      validateOffset(length\x2C 'length'\x2C 0\x2C this.length);\n      if (length > remaining)\n        length = remaining;\n    }\n  }\n\n  if (!encoding)\n    return this.utf8Write(string\x2C offset\x2C length);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  return ops.write(this\x2C string\x2C offset\x2C length);\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  if (this.length > 0) {\n    const data = new Array(this.length);\n    for (let i = 0; i < this.length; ++i)\n      data[i] = this[i];\n    return { type: 'Buffer'\x2C data };\n  }\n  return { type: 'Buffer'\x2C data: [] };\n};\n\nfunction adjustOffset(offset\x2C length) {\n  // Use Math.trunc() to convert offset to an integer value that can be larger\n  // than an Int32. Hence\x2C don't use offset | 0 or similar techniques.\n  offset = MathTrunc(offset);\n  if (offset === 0) {\n    return 0;\n  }\n  if (offset < 0) {\n    offset += length;\n    return offset > 0 ? offset : 0;\n  }\n  if (offset < length) {\n    return offset;\n  }\n  return NumberIsNaN(offset) ? 0 : length;\n}\n\nBuffer.prototype.subarray = function subarray(start\x2C end) {\n  const srcLength = this.length;\n  start = adjustOffset(start\x2C srcLength);\n  end = end !== undefined ? adjustOffset(end\x2C srcLength) : srcLength;\n  const newLength = end > start ? end - start : 0;\n  return new FastBuffer(this.buffer\x2C this.byteOffset + start\x2C newLength);\n};\n\nBuffer.prototype.slice = function slice(start\x2C end) {\n  return this.subarray(start\x2C end);\n};\n\nfunction swap(b\x2C n\x2C m) {\n  const i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  // For Buffer.length < 128\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 2 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('16-bits');\n  if (len < 128) {\n    for (let i = 0; i < len; i += 2)\n      swap(this\x2C i\x2C i + 1);\n    return this;\n  }\n  return _swap16(this);\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 4 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('32-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 4) {\n      swap(this\x2C i\x2C i + 3);\n      swap(this\x2C i + 1\x2C i + 2);\n    }\n    return this;\n  }\n  return _swap32(this);\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 8 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('64-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 8) {\n      swap(this\x2C i\x2C i + 7);\n      swap(this\x2C i + 1\x2C i + 6);\n      swap(this\x2C i + 2\x2C i + 5);\n      swap(this\x2C i + 3\x2C i + 4);\n    }\n    return this;\n  }\n  return _swap64(this);\n};\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\nlet transcode;\nif (internalBinding('config').hasIntl) {\n  const {\n    icuErrName\x2C\n    transcode: _transcode\x2C\n  } = internalBinding('icu');\n\n  // Transcodes the Buffer from one encoding to another\x2C returning a new\n  // Buffer instance.\n  transcode = function transcode(source\x2C fromEncoding\x2C toEncoding) {\n    if (!isUint8Array(source)) {\n      throw new ERR_INVALID_ARG_TYPE('source'\x2C\n                                     ['Buffer'\x2C 'Uint8Array']\x2C source);\n    }\n    if (source.length === 0) return Buffer.alloc(0);\n\n    fromEncoding = normalizeEncoding(fromEncoding) || fromEncoding;\n    toEncoding = normalizeEncoding(toEncoding) || toEncoding;\n    const result = _transcode(source\x2C fromEncoding\x2C toEncoding);\n    if (typeof result !== 'number')\n      return result;\n\n    const code = icuErrName(result);\n    const err = genericNodeError(\n      `Unable to transcode Buffer [${code}]`\x2C\n      { code: code\x2C errno: result }\x2C\n    );\n    throw err;\n  };\n}\n\nfunction btoa(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('input');\n  }\n  input = `${input}`;\n  for (let n = 0; n < input.length; n++) {\n    if (input[n].charCodeAt(0) > 0xff)\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n  }\n  const buf = Buffer.from(input\x2C 'latin1');\n  return buf.toString('base64');\n}\n\n// Refs: https://infra.spec.whatwg.org/#forgiving-base64-decode\nconst kForgivingBase64AllowedChars = [\n  // ASCII whitespace\n  // Refs: https://infra.spec.whatwg.org/#ascii-whitespace\n  0x09\x2C 0x0A\x2C 0x0C\x2C 0x0D\x2C 0x20\x2C\n\n  // Uppercase letters\n  ...ArrayFrom({ length: 26 }\x2C (_\x2C i) => StringPrototypeCharCodeAt('A') + i)\x2C\n\n  // Lowercase letters\n  ...ArrayFrom({ length: 26 }\x2C (_\x2C i) => StringPrototypeCharCodeAt('a') + i)\x2C\n\n  // Decimal digits\n  ...ArrayFrom({ length: 10 }\x2C (_\x2C i) => StringPrototypeCharCodeAt('0') + i)\x2C\n\n  0x2B\x2C // +\n  0x2F\x2C // /\n  0x3D\x2C // =\n];\nconst kEqualSignIndex = ArrayPrototypeIndexOf(kForgivingBase64AllowedChars\x2C\n                                              0x3D);\n\nfunction atob(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('input');\n  }\n\n  input = `${input}`;\n  let nonAsciiWhitespaceCharCount = 0;\n  let equalCharCount = 0;\n\n  for (let n = 0; n < input.length; n++) {\n    const index = ArrayPrototypeIndexOf(\n      kForgivingBase64AllowedChars\x2C\n      StringPrototypeCharCodeAt(input\x2C n));\n\n    if (index > 4) {\n      // The first 5 elements of `kForgivingBase64AllowedChars` are\n      // ASCII whitespace char codes.\n      nonAsciiWhitespaceCharCount++;\n\n      if (index === kEqualSignIndex) {\n        equalCharCount++;\n      } else if (equalCharCount) {\n        // The `=` char is only allowed at the end.\n        throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n      }\n\n      if (equalCharCount > 2) {\n        // Only one more `=` is permitted after the first equal sign.\n        throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n      }\n    } else if (index === -1) {\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n    }\n  }\n\n  let reminder = nonAsciiWhitespaceCharCount % 4;\n\n  // See #2\x2C #3\x2C #4 - https://infra.spec.whatwg.org/#forgiving-base64\n  if (!reminder) {\n    // Remove all trailing `=` characters and get the new reminder.\n    reminder = (nonAsciiWhitespaceCharCount - equalCharCount) % 4;\n  } else if (equalCharCount) {\n    // `=` should not in the input if there's a reminder.\n    throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n  }\n\n  // See #3 - https://infra.spec.whatwg.org/#forgiving-base64\n  if (reminder === 1) {\n    throw lazyDOMException(\n      'The string to be decoded is not correctly encoded.'\x2C\n      'InvalidCharacterError');\n  }\n\n  return Buffer.from(input\x2C 'base64').toString('latin1');\n}\n\nfunction isUtf8(input) {\n  if (isTypedArray(input) || isAnyArrayBuffer(input)) {\n    return bindingIsUtf8(input);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE('input'\x2C ['TypedArray'\x2C 'Buffer']\x2C input);\n}\n\nfunction isAscii(input) {\n  if (isTypedArray(input) || isAnyArrayBuffer(input)) {\n    return bindingIsAscii(input);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE('input'\x2C ['ArrayBuffer'\x2C 'Buffer'\x2C 'TypedArray']\x2C input);\n}\n\nmodule.exports = {\n  Blob\x2C\n  File\x2C\n  resolveObjectURL\x2C\n  Buffer\x2C\n  SlowBuffer\x2C\n  transcode\x2C\n  isUtf8\x2C\n  isAscii\x2C\n\n  // Legacy\n  kMaxLength\x2C\n  kStringMaxLength\x2C\n  btoa\x2C\n  atob\x2C\n};\n\nObjectDefineProperties(module.exports\x2C {\n  constants: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\x2C\n  }\x2C\n  INSPECT_MAX_BYTES: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() { return INSPECT_MAX_BYTES; }\x2C\n    set(val) { INSPECT_MAX_BYTES = val; }\x2C\n  }\x2C\n});\n
code-source-info,0x1a7a75882a60,30,16166,16298,C0O16181C6O16229C12O16236C20O16254C23O16254C28O16282C29O16296,,
tick,0x195959bbc,128125,0,0x0,3,0x0,0x1fa4d1d76c86,0x1fa4d1d74c60,0x1a7a7588274a,0x1a7a75882334,0x1a7a758813e8,0x1fa4d1d7cd38,0x1fa4d1d6c5f9,0x202f0287621a
tick,0x1011451f8,128167,0,0x0,2,0x0,0x1a7a75882a77,0x1fa4d1d76c86,0x1fa4d1d74c60,0x1a7a7588274a,0x1a7a75882334,0x1a7a758813e8,0x1fa4d1d7cd38,0x1fa4d1d6c5f9,0x202f0287621a
code-creation,LazyCompile,10,128209,0x1a7a758857b8,30,normalizeEncoding node:internal/util:175:27,0x1012a3946920,~
code-source-info,0x1a7a758857b8,21,4500,4605,C0O4510C7O4533C14O4551C19O4564C21O4578C22O4581C25O4588C29O4603,,
code-creation,LazyCompile,10,128209,0x1a7a758858a0,9,isUint32 node:internal/validators:51:18,0x1012a394ba90,~
code-source-info,0x1a7a758858a0,22,963,1008,C0O975C2O999C5O988C8O1006,,
code-creation,LazyCompile,10,128250,0x1a7a75885a00,113,openSync node:fs:594:18,0x28e4ce8e5fc0,~
code-source-info,0x1a7a75885a00,76,15083,15462,C0O15107C5O15114C11O15160C16O15160C21O15184C37O15191C44O15242C51O15244C58O15269C63O15277C70O15282C73O15293C78O15293C95O15277C101O15415C106O15415C110O15446C112O15460,,
code-creation,LazyCompile,10,128292,0x1a7a75885b88,37, node:internal/fs/utils:706:42,0x25dc1a849fe0,~
code-source-info,0x1a7a75885b88,80,19187,19322,C14O19242C19O19242C24O19276C29O19276C34O19308C36O19320,,
code-creation,LazyCompile,10,128334,0x1a7a75885f78,515,stringToFlags node:internal/fs/utils:581:23,0x25dc1a849e00,~
code-source-info,0x1a7a75885f78,80,15776,17010,C14O15804C20O15841C25O15841C30O15873C32O15886C33O15894C38O15919C42O15935C43O15943C202O15975C206O15991C207O16041C214O16059C216O16057C219O16066C220O16083C224O16097C225O16149C232O16165C234O16163C237O16172C238O16189C245O16206C247O16204C253O16216C255O16214C258O16225C259O16275C266O16292C268O16290C274O16302C276O16300C282O16313C284O16311C287O16320C288O16338C295O16355C297O16353C303O16365C305O16363C308O16372C309O16422C316O16439C318O16437C324O16449C326O16447C332O16458C334O16456C337O16465C338O16482C345O16500C347O16498C353O16510C355O16508C358O16519C359O16569C366O16587C368O16585C374O16597C376O16595C382O16608C384O16606C387O16615C388O16665C395O16683C397O16681C403O16693C405O16691C411O16704C413O16702C416O16711C417O16729C424O16747C426O16745C432O16757C434O16755C437O16764C438O16814C445O16832C447O16830C453O16842C455O16840C461O16851C463O16849C466O16858C467O16908C474O16926C476O16924C482O16936C484O16934C490O16945C492O16943C495O16952C496O16960C509O16966C514O16960,,
code-creation,LazyCompile,10,128375,0x1a7a75886350,86,parseFileMode node:internal/validators:69:23,0x1012a394bae0,~
code-source-info,0x1a7a75886350,22,1651,1940,C0O1674C11O1691C17O1728C24O1752C27O1732C34O1787C41O1832C52O1793C57O1787C58O1853C66O1861C73O1894C78O1894C83O1925C85O1938,,
code-creation,LazyCompile,10,128417,0x1a7a758864c0,66,tryStatSync node:fs:422:21,0x28e4ce8e5d40,~
code-source-info,0x1a7a758864c0,76,10987,11197,C0O11018C2O11038C7O11046C22O11046C28O11090C36O11114C38O11130C43O11133C48O11133C53O11152C58O11158C62O11152C63O11182C65O11195,,
code-creation,LazyCompile,10,128459,0x1a7a75886640,96,tryCreateBuffer node:fs:432:25,0x28e4ce8e5d90,~
code-source-info,0x1a7a75886640,76,11223,11510,C0O11260C2O11272C7O11292C9O11303C11O11301C16O11325C23O11331C28O11325C29O11374C34O11390C39O11390C45O11413C57O11419C58O11446C65O11460C67O11470C72O11473C77O11473C93O11494C95O11508,,
code-creation,LazyCompile,10,128500,0x1a7a75886798,17,allocUnsafe node:buffer:425:42,0x1012a397f578,~
code-source-info,0x1a7a75886798,30,12263,12318,C0O12274C5O12274C9O12294C12O12301C16O12316,,
code-creation,LazyCompile,10,128542,0x1a7a758868a8,54, node:buffer:401:36,0x1012a397f4d8,~
code-source-info,0x1a7a758868a8,30,11561,11716,C0O11575C8O11575C13O11607C14O11618C21O11634C23O11631C28O11653C33O11685C46O11659C51O11653C53O11715,,
code-creation,LazyCompile,10,128584,0x1a7a75886a30,177,validateNumber node:internal/validators:175:24,0x1012a394bd58,~
code-source-info,0x1a7a75886a30,22,4453,4898,C19O4493C25O4528C41O4534C46O4528C47O4586C54O4612C66O4644C83O4693C86O4693C92O4720C110O4789C136O4821C151O4865C169O4726C174O4720C176O4897,,
code-creation,LazyCompile,10,128625,0x1a7a75886c00,119,allocate node:buffer:450:18,0x1012a397f668,~
code-source-info,0x1a7a75886c00,30,12965,13280,C0O12976C1O12985C6O12997C11O13004C16O13021C17O13028C20O13047C24O13056C27O13037C32O13070C34O13082C39O13093C41O13091C44O13079C49O13112C52O13112C55O13140C62O13155C67O13166C75O13140C81O13189C88O13203C94O13200C100O13213C103O13213C106O13230C108O13239C109O13246C114O13253C118O13278,,
code-creation,LazyCompile,10,128667,0x1a7a75886dc0,86,tryReadSync node:fs:447:21,0x28e4ce8e5de0,~
code-source-info,0x1a7a75886dc0,76,11532,11767,C0O11581C2O11593C7O11616C12O11631C29O11631C35O11667C47O11673C48O11700C55O11714C57O11724C62O11727C67O11727C83O11748C85O11765,,
code-creation,LazyCompile,10,128709,0x1a7a75886fb0,251,readSync node:fs:708:18,0x28e4ce8e6090,~
code-source-info,0x1a7a75886fb0,76,18148,19132,C0O18148C2O18191C7O18196C13O18219C18O18219C22O18260C29O18267C34O18342C40O18352C43O18380C55O18398C61O18414C68O18425C73O18441C82O18483C87O18509C92O18536C105O18536C110O18581C117O18597C118O18608C123O18621C124O18630C125O18649C131O18660C136O18673C152O18679C157O18673C158O18801C163O18849C174O18801C179O18865C184O18891C188O18909C196O18909C201O18964C203O18985C208O18993C233O18993C239O19085C244O19085C248O19116C250O19130,,
code-creation,LazyCompile,10,128750,0x1a7a75887218,52, node:internal/fs/utils:712:40,0x25dc1a84a030,~
code-source-info,0x1a7a75887218,80,19365,19486,C14O19394C22O19398C29O19422C30O19431C31O19439C44O19439C49O19474C51O19484,,
code-creation,LazyCompile,10,128792,0x1a7a75887360,155, node:internal/validators:114:3,0x1012a394bb80,~
code-source-info,0x1a7a75887360,22,2811,3274,C36O2952C42O2991C58O2997C63O2991C64O3056C69O3061C75O3093C91O3099C96O3093C97O3158C99O3168C106O3183C111O3198C121O3237C134O3250C147O3204C152O3198C154O3273,,
code-creation,LazyCompile,10,128834,0x1a7a75887550,51, node:internal/validators:373:40,0x1012a394c0c8,~
code-source-info,0x1a7a75887550,22,9948,10178,C14O9981C19O9986C25O10019C30O10050C43O10025C48O10019C50O10177,,
code-creation,LazyCompile,10,128834,0x1a7a758876a8,151, node:internal/validators:93:3,0x1012a394bb30,~
code-source-info,0x1a7a758876a8,22,2186,2567,C12O2206C25O2236C32O2269C38O2306C54O2312C59O2306C60O2365C65O2370C71O2400C87O2406C92O2400C93O2459C95O2469C102O2484C107O2497C117O2536C130O2549C143O2503C148O2497C150O2566,,
code-creation,LazyCompile,10,128875,0x1a7a75887898,103, node:internal/fs/utils:662:3,0x25dc1a849ef0,~
code-source-info,0x1a7a75887898,80,17987,18366,C0O18027C1O18038C6O18051C22O18057C27O18051C28O18115C29O18126C34O18139C50O18145C55O18139C56O18203C58O18214C64O18223C69O18247C82O18336C95O18253C100O18247C102O18365,,
code-creation,LazyCompile,10,128917,0x1a7a75887b98,148, node:internal/fs/utils:922:42,0x25dc1a84a3a0,~
code-source-info,0x1a7a75887b98,80,25065,25535,C0O25089C6O25129C11O25129C18O25171C24O25211C29O25234C32O25229C34O25226C44O25260C50O25267C53O25254C58O25282C71O25359C74O25354C92O25379C98O25386C114O25288C119O25282C122O25459C127O25490C140O25465C145O25459C147O25534,,
code-creation,LazyCompile,10,128959,0x1a7a75887d58,47,closeSync node:fs:544:19,0x28e4ce8e5f20,~
code-source-info,0x1a7a75887d58,76,13952,14074,C0O13961C5O13966C11O14001C13O14007C18O14015C31O14015C36O14044C41O14044C46O14073,,
code-creation,LazyCompile,10,129000,0x1a7a75887ea0,162,toString node:buffer:836:46,0x2da83afffaa0,~
code-source-info,0x1a7a75887ea0,30,24554,25116,C0O24554C2O24595C8O24602C13O24627C20O24645C25O24627C31O24653C32O24678C37O24689C38O24699C43O24709C48O24727C50O24737C55O24749C57O24759C58O24771C65O24786C71O24815C76O24826C83O24848C90O24861C92O24869C97O24883C99O24893C100O24897C104O24941C109O24941C115O24963C116O24979C119O24979C124O25007C126O25034C133O25040C138O25034C139O25090C156O25090C161O25114,,
code-creation,LazyCompile,10,129084,0x1a7a75888168,499,getEncodingOps node:buffer:731:24,0x2da83afff910,~
code-source-info,0x1a7a75888168,30,21332,23133,C0O21347C10O21382C62O21410C64O21423C69O21435C74O21454C78O21459C79O21466C81O21479C86O21491C91O21510C95O21515C96O21522C101O21533C107O21577C109O21590C114O21602C119O21621C123O21626C124O21633C126O21646C131O21658C136O21677C140O21682C141O21689C143O21714C145O21727C150O21740C155O21759C159O21764C160O21771C162O21784C167O21797C172O21816C176O21822C177O21829C179O21842C184O21855C189O21874C193O21879C194O21886C199O21897C205O21941C207O21954C212O21967C217O21986C221O21991C222O21998C224O22011C229O22024C234O22043C238O22049C239O22056C241O22069C246O22082C251O22101C255O22106C256O22113C258O22138C260O22151C267O22178C270O22178C277O22215C282O22238C287O22257C291O22265C292O22272C294O22297C296O22310C303O22338C306O22338C313O22375C318O22399C323O22418C327O22426C328O22433C330O22458C332O22471C339O22496C344O22518C349O22537C353O22544C354O22551C356O22564C361O22578C366O22597C370O22604C371O22611C376O22622C382O22666C384O22679C391O22704C396O22726C401O22745C405O22752C406O22759C408O22772C413O22786C418O22805C422O22812C423O22819C425O22844C427O22857C434O22870C437O22870C444O22907C449O22926C454O22945C458O22949C459O22956C461O22981C463O22994C470O23023C473O23023C480O23060C485O23085C490O23104C494O23114C495O23121C498O23132,,
code-creation,LazyCompile,10,129167,0x1a7a75888550,12,slice node:buffer:646:12,0x1012a397fed0,~
code-source-info,0x1a7a75888550,30,17994,18040,C0O18019C5O18019C11O18040,,
code-creation,LazyCompile,10,129292,0x1a7a75888798,462,Module._compile node:internal/modules/cjs/loader:1210:37,0x2b3d46ce05e8,~
code-source-info,0x1a7a75888798,465,37775,39583,C0O37803C2O37820C4O37850C11O37856C19O37870C21O37890C26O37902C31O37952C36O37952C42O37997C47O37997C53O38065C65O38065C71O38126C73O38134C81O38138C90O38181C97O38202C103O38296C106O38308C113O38312C121O38343C124O38365C132O38390C139O38394C148O38365C156O38356C166O38587C173O38594C178O38607C184O38607C189O38594C194O38587C200O38671C205O38684C211O38751C219O38772C225O38803C227O38799C232O38825C236O38840C242O38854C248O38873C253O38901C258O38951C263O38956C268O38956C274O38993C279O38993C285O39037C287O39068C292O39097C293O39123C296O39131C302O39148C307O39155C312O39167C320O39165C326O39184C330O39212C351O39221C359O39357C364O39396C373O39434C382O39443C391O39452C400O39460C409O39470C422O39366C428O39487C432O39513C438O39523C444O39540C449O39547C453O39557C459O39567C461O39581,,
tick,0x1010d8fac,129417,0,0x0,2,0x0,0x1a7a758887d9,0x1a7a758824d5,0x1a7a758813e8,0x1fa4d1d7cd38,0x1fa4d1d6c5f9,0x202f0287621a
code-creation,LazyCompile,10,129459,0x1a7a75888df8,252,wrapSafe node:internal/modules/cjs/loader:1154:18,0x2b3d46cdfa90,~
code-source-info,0x1a7a75888df8,465,36115,37567,C0O36115C9O36158C17O36193C22O36200C27O36200C33O36234C40O36245C47O36262C51O36324C64O36234C70O36619C76O36641C90O36711C101O36641C106O36751C116O36751C121O36804C125O36837C132O36861C144O36976C148O36992C159O36837C165O37301C171O37323C185O37393C196O37323C201O37433C205O37442C217O37465C222O37477C229O37488C234O37517C244O37517C249O37551C251O37551,,
code-creation,LazyCompile,10,129709,0x1a7a758895b8,444,internalCompileFunction node:internal/vm:31:33,0x25dc1a85dff0,~
script-source,90,node:internal/vm,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n} = primordials;\n\nconst {\n  compileFunction\x2C\n  isContext: _isContext\x2C\n} = internalBinding('contextify');\nconst {\n  validateArray\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateFunction\x2C\n  validateObject\x2C\n  validateString\x2C\n  validateStringArray\x2C\n  validateUint32\x2C\n} = require('internal/validators');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n} = require('internal/errors').codes;\n\nfunction isContext(object) {\n  validateObject(object\x2C 'object'\x2C { __proto__: null\x2C allowArray: true });\n\n  return _isContext(object);\n}\n\nfunction internalCompileFunction(code\x2C params\x2C options) {\n  validateString(code\x2C 'code');\n  if (params !== undefined) {\n    validateStringArray(params\x2C 'params');\n  }\n\n  const {\n    filename = ''\x2C\n    columnOffset = 0\x2C\n    lineOffset = 0\x2C\n    cachedData = undefined\x2C\n    produceCachedData = false\x2C\n    parsingContext = undefined\x2C\n    contextExtensions = []\x2C\n    importModuleDynamically\x2C\n  } = options;\n\n  validateString(filename\x2C 'options.filename');\n  validateUint32(columnOffset\x2C 'options.columnOffset');\n  validateUint32(lineOffset\x2C 'options.lineOffset');\n  if (cachedData !== undefined)\n    validateBuffer(cachedData\x2C 'options.cachedData');\n  validateBoolean(produceCachedData\x2C 'options.produceCachedData');\n  if (parsingContext !== undefined) {\n    if (\n      typeof parsingContext !== 'object' ||\n      parsingContext === null ||\n      !isContext(parsingContext)\n    ) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.parsingContext'\x2C\n        'Context'\x2C\n        parsingContext\x2C\n      );\n    }\n  }\n  validateArray(contextExtensions\x2C 'options.contextExtensions');\n  ArrayPrototypeForEach(contextExtensions\x2C (extension\x2C i) => {\n    const name = `options.contextExtensions[${i}]`;\n    validateObject(extension\x2C name\x2C { __proto__: null\x2C nullable: true });\n  });\n\n  const result = compileFunction(\n    code\x2C\n    filename\x2C\n    lineOffset\x2C\n    columnOffset\x2C\n    cachedData\x2C\n    produceCachedData\x2C\n    parsingContext\x2C\n    contextExtensions\x2C\n    params\x2C\n  );\n\n  if (produceCachedData) {\n    result.function.cachedDataProduced = result.cachedDataProduced;\n  }\n\n  if (result.cachedData) {\n    result.function.cachedData = result.cachedData;\n  }\n\n  if (typeof result.cachedDataRejected === 'boolean') {\n    result.function.cachedDataRejected = result.cachedDataRejected;\n  }\n\n  if (importModuleDynamically !== undefined) {\n    validateFunction(importModuleDynamically\x2C\n                     'options.importModuleDynamically');\n    const { importModuleDynamicallyWrap } =\n      require('internal/vm/module');\n    const { callbackMap } = internalBinding('module_wrap');\n    const wrapped = importModuleDynamicallyWrap(importModuleDynamically);\n    const func = result.function;\n    callbackMap.set(result.cacheKey\x2C {\n      importModuleDynamically: (s\x2C _k\x2C i) => wrapped(s\x2C func\x2C i)\x2C\n    });\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  internalCompileFunction\x2C\n  isContext\x2C\n};\n
code-source-info,0x1a7a758895b8,90,588,2868,C0O616C8O616C13O648C17O680C25O680C30O738C42O757C50O779C58O799C66O827C74O858C82O890C91O918C96O961C104O961C109O1009C117O1009C122O1065C130O1065C135O1117C139O1151C147O1151C152O1203C160O1203C165O1270C169O1310C182O1399C188O1439C204O1445C209O1439C210O1569C218O1569C223O1634C228O1656C233O1634C238O1845C270O1845C276O2022C280O2058C285O2095C289O2086C293O2133C299O2158C304O2187C308O2178C312O2224C320O2271C325O2308C329O2299C333O2335C337O2363C347O2384C357O2384C362O2533C370O2533C375O2495C380O2592C388O2592C393O2576C398O2644C402O2644C404O2722C408O2715C410O2748C415O2759C425O2802C433O2748C441O2852C443O2866,,
code-creation,LazyCompile,10,129875,0x1a7a75889d40,68,validateStringArray node:internal/validators:305:29,0x1012a394bf88,~
code-source-info,0x1a7a75889d40,22,8246,8387,C0O8264C5O8264C10O8307C12O8320C16O8312C21O8339C26O8359C32O8367C42O8375C53O8339C58O8329C63O8294C67O8386,,
code-creation,LazyCompile,10,129917,0x1a7a75889ee8,95, node:internal/validators:287:39,0x1012a394bf38,~
code-source-info,0x1a7a75889ee8,22,7775,8053,C16O7811C21O7816C27O7843C43O7849C48O7843C49O7913C56O7920C61O7954C66O7977C71O7994C87O8000C92O7994C94O8052,,
code-creation,Eval,10,130000,0x1a7a7588a5d0,5, /Users/miriam/m_documents/repos/tax-column/node_modules/jest-worker/build/workers/processChild.js:1:1,0x1a7a7588a388,~
script-source,490,/Users/miriam/m_documents/repos/tax-column/node_modules/jest-worker/build/workers/processChild.js,'use strict';\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n  _jestUtil = function () {\n    return data;\n  };\n  return data;\n}\nvar _types = require('../types');\n/**\n * Copyright (c) Meta Platforms\x2C Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nlet file = null;\nlet setupArgs = [];\nlet initialized = false;\n\n/**\n * This file is a small bootstrapper for workers. It sets up the communication\n * between the worker and the parent process\x2C interpreting parent messages and\n * sending results back.\n *\n * The file loaded will be lazily initialized the first time any of the workers\n * is called. This is done for optimal performance: if the farm is initialized\x2C\n * but no call is made to it\x2C child Node processes will be consuming the least\n * possible amount of memory.\n *\n * If an invalid message is detected\x2C the child will exit (by throwing) with a\n * non-zero exit code.\n */\nconst messageListener = request => {\n  switch (request[0]) {\n    case _types.CHILD_MESSAGE_INITIALIZE:\n      const init = request;\n      file = init[2];\n      setupArgs = init[3];\n      break;\n    case _types.CHILD_MESSAGE_CALL:\n      const call = request;\n      execMethod(call[2]\x2C call[3]);\n      break;\n    case _types.CHILD_MESSAGE_END:\n      end();\n      break;\n    case _types.CHILD_MESSAGE_MEM_USAGE:\n      reportMemoryUsage();\n      break;\n    case _types.CHILD_MESSAGE_CALL_SETUP:\n      if (initialized) {\n        reportSuccess(void 0);\n      } else {\n        const main = require(file);\n        initialized = true;\n        if (main.setup) {\n          execFunction(\n            main.setup\x2C\n            main\x2C\n            setupArgs\x2C\n            reportSuccess\x2C\n            reportInitializeError\n          );\n        } else {\n          reportSuccess(void 0);\n        }\n      }\n      break;\n    default:\n      throw new TypeError(\n        `Unexpected request from parent process: ${request[0]}`\n      );\n  }\n};\nprocess.on('message'\x2C messageListener);\nfunction reportSuccess(result) {\n  if (!process || !process.send) {\n    throw new Error('Child can only be used on a forked process');\n  }\n  process.send([_types.PARENT_MESSAGE_OK\x2C result]);\n}\nfunction reportClientError(error) {\n  return reportError(error\x2C _types.PARENT_MESSAGE_CLIENT_ERROR);\n}\nfunction reportInitializeError(error) {\n  return reportError(error\x2C _types.PARENT_MESSAGE_SETUP_ERROR);\n}\nfunction reportMemoryUsage() {\n  if (!process || !process.send) {\n    throw new Error('Child can only be used on a forked process');\n  }\n  const msg = [_types.PARENT_MESSAGE_MEM_USAGE\x2C process.memoryUsage().heapUsed];\n  process.send(msg);\n}\nfunction reportError(error\x2C type) {\n  if (!process || !process.send) {\n    throw new Error('Child can only be used on a forked process');\n  }\n  if (error == null) {\n    error = new Error('"null" or "undefined" thrown');\n  }\n  process.send([\n    type\x2C\n    error.constructor && error.constructor.name\x2C\n    error.message\x2C\n    error.stack\x2C\n    typeof error === 'object'\n      ? {\n          ...error\n        }\n      : error\n  ]);\n}\nfunction end() {\n  const main = require(file);\n  if (!main.teardown) {\n    exitProcess();\n    return;\n  }\n  execFunction(main.teardown\x2C main\x2C []\x2C exitProcess\x2C exitProcess);\n}\nfunction exitProcess() {\n  // Clean up open handles so the process ideally exits gracefully\n  process.removeListener('message'\x2C messageListener);\n}\nfunction execMethod(method\x2C args) {\n  const main = require(file);\n  let fn;\n  if (method === 'default') {\n    fn = main.__esModule ? main.default : main;\n  } else {\n    fn = main[method];\n  }\n  function execHelper() {\n    execFunction(fn\x2C main\x2C args\x2C reportSuccess\x2C reportClientError);\n  }\n  if (initialized || !main.setup) {\n    execHelper();\n    return;\n  }\n  initialized = true;\n  execFunction(main.setup\x2C main\x2C setupArgs\x2C execHelper\x2C reportInitializeError);\n}\nfunction execFunction(fn\x2C ctx\x2C args\x2C onResult\x2C onError) {\n  let result;\n  try {\n    result = fn.apply(ctx\x2C args);\n  } catch (err) {\n    onError(err);\n    return;\n  }\n  if ((0\x2C _jestUtil().isPromise)(result)) {\n    result.then(onResult\x2C onError);\n  } else {\n    onResult(result);\n  }\n}\n
code-source-info,0x1a7a7588a5d0,490,0,4196,C0O0C4O4196,,
code-creation,Function,10,130209,0x1a7a7588aa80,132, /Users/miriam/m_documents/repos/tax-column/node_modules/jest-worker/build/workers/processChild.js:1:1,0x1a7a7588a548,~
code-source-info,0x1a7a7588aa80,490,0,4196,C0O0C81O155C87O155C91O155C93O379C94O379C96O401C98O401C100O423C101O423C103O1023C107O1023C109O2014C113O2022C124O2022C131O4195,,
code-creation,LazyCompile,10,130250,0x1a7a7588b380,19,importModuleDynamicallyWrap node:internal/vm/module:427:37,0x1fa4d1d5e3b8,~
code-source-info,0x1a7a7588b380,488,11477,11920,C0O11477C13O11546C18O11918,,
code-creation,LazyCompile,10,130334,0x1a7a7588c520,174,makeRequireFunction node:internal/modules/cjs/helpers:65:29,0x30e767715c28,~
code-source-info,0x1a7a7588c520,453,1858,3968,C0O1858C22O1894C25O1898C29O1894C31O1918C33O1929C53O1961C58O1965C69O1981C73O1961C75O2008C81O2008C83O2035C89O2044C95O2072C104O3276C109O3585C111O3601C115O3741C117O3755C121O3767C136O3807C144O3767C149O3873C152O3901C156O3892C160O3917C163O3940C167O3931C171O3951C173O3966,,
code-creation,LazyCompile,10,130375,0x1a7a7588c928,14,require node:internal/modules/cjs/helpers:108:31,0x1a7a7588c3e8,~
code-source-info,0x1a7a7588c928,453,3302,3426,C0O3395C3O3406C8O3406C13O3420,,
code-creation,LazyCompile,10,130375,0x1a7a7588caa0,127,Module.require node:internal/modules/cjs/loader:1135:36,0x2b3d46ce0560,~
code-source-info,0x1a7a7588caa0,465,35628,35919,C0O35637C8O35637C13O35665C15O35672C20O35686C36O35692C41O35686C42O35801C51O35813C60O35829C63O35843C76O35843C93O35898C102O35910C126O35918,,
code-creation,LazyCompile,10,130459,0x1a7a7588cd50,159,normalize node:path:1126:12,0x28e4ce8cd120,~
code-source-info,0x1a7a7588cd50,74,34810,35414,C0O34823C8O34823C13O34867C19O34874C24O34887C26O34898C27O34929C34O34929C42O34968C44O34964C48O35024C53O35061C57O35068C61O35024C69O35077C71O35073C75O35128C80O35158C91O35135C98O35212C104O35219C109O35234C113O35258C115O35269C116O35276C126O35314C127O35325C131O35354C141O35372C150O35396C158O35410,,
code-creation,LazyCompile,10,130542,0x1a7a7588cfe0,199,resolveExports node:internal/modules/cjs/loader:557:24,0x2b3d46cdf900,~
code-source-info,0x1a7a7588cfe0,465,15910,16596,C0O16048C7O16068C10O16048C19O16097C22O16016C29O16025C40O16113C44O16128C45O16135C46O16154C51O16159C56O16159C63O16196C68O16196C73O16221C78O16228C91O16265C96O16294C101O16325C106O16347C110O16325C120O16371C128O16403C134O16294C145O16272C150O16434C162O16459C165O16465C172O16470C177O16506C184O16550C188O16512C193O16506C194O16576C196O16576C198O16595,,
code-creation,LazyCompile,10,130584,0x1a7a7588d1e0,44,tryExtensions node:internal/modules/cjs/loader:485:23,0x2b3d46cdf7c0,~
code-source-info,0x1a7a7588d1e0,465,13852,14036,C0O13887C2O13899C6O13892C11O13935C16O13951C19O13945C23O13935C29O13970C31O13992C33O14008C34O13908C39O13874C42O14021C43O14034,,
code-creation,LazyCompile,10,130625,0x1a7a7588d318,52,tryFile node:internal/modules/cjs/loader:469:17,0x2b3d46cdf720,~
code-source-info,0x1a7a7588d318,465,13426,13621,C0O13463C5O13463C10O13485C11O13492C16O13499C17O13506C18O13509C26O13534C28O13548C33O13560C38O13560C43O13581C44O13588C47O13595C51O13619,,
tick,0x1014e06f4,130709,0,0x0,0,0x110052d24,0x1fa4d1d6dffc,0x1fa4d1d6d773,0x1a7a7588d347,0x1a7a7588d1f7,0x1fa4d1d6d02e,0x1fa4d1d7d664,0x1fa4d1d7cc33,0x1a7a7588caec,0x1a7a7588c930,0x1a7a7588aad7,0x1a7a7588893e,0x1a7a758824d5,0x1a7a758813e8,0x1fa4d1d7cd38,0x1fa4d1d6c5f9,0x202f0287621a
code-creation,Eval,10,130875,0x1a7a7588db08,5, /Users/miriam/m_documents/repos/tax-column/node_modules/jest-worker/build/types.js:1:1,0x1a7a7588d930,~
script-source,491,/Users/miriam/m_documents/repos/tax-column/node_modules/jest-worker/build/types.js,'use strict';\n\nObject.defineProperty(exports\x2C '__esModule'\x2C {\n  value: true\n});\nexports.WorkerStates =\n  exports.WorkerEvents =\n  exports.PARENT_MESSAGE_SETUP_ERROR =\n  exports.PARENT_MESSAGE_OK =\n  exports.PARENT_MESSAGE_MEM_USAGE =\n  exports.PARENT_MESSAGE_CUSTOM =\n  exports.PARENT_MESSAGE_CLIENT_ERROR =\n  exports.CHILD_MESSAGE_MEM_USAGE =\n  exports.CHILD_MESSAGE_INITIALIZE =\n  exports.CHILD_MESSAGE_END =\n  exports.CHILD_MESSAGE_CALL_SETUP =\n  exports.CHILD_MESSAGE_CALL =\n    void 0;\n/**\n * Copyright (c) Meta Platforms\x2C Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// Because of the dynamic nature of a worker communication process\x2C all messages\n// coming from any of the other processes cannot be typed. Thus\x2C many types\n// include "unknown" as a TS type\x2C which is (unfortunately) correct here.\n\nconst CHILD_MESSAGE_INITIALIZE = 0;\nexports.CHILD_MESSAGE_INITIALIZE = CHILD_MESSAGE_INITIALIZE;\nconst CHILD_MESSAGE_CALL = 1;\nexports.CHILD_MESSAGE_CALL = CHILD_MESSAGE_CALL;\nconst CHILD_MESSAGE_END = 2;\nexports.CHILD_MESSAGE_END = CHILD_MESSAGE_END;\nconst CHILD_MESSAGE_MEM_USAGE = 3;\nexports.CHILD_MESSAGE_MEM_USAGE = CHILD_MESSAGE_MEM_USAGE;\nconst CHILD_MESSAGE_CALL_SETUP = 4;\nexports.CHILD_MESSAGE_CALL_SETUP = CHILD_MESSAGE_CALL_SETUP;\nconst PARENT_MESSAGE_OK = 0;\nexports.PARENT_MESSAGE_OK = PARENT_MESSAGE_OK;\nconst PARENT_MESSAGE_CLIENT_ERROR = 1;\nexports.PARENT_MESSAGE_CLIENT_ERROR = PARENT_MESSAGE_CLIENT_ERROR;\nconst PARENT_MESSAGE_SETUP_ERROR = 2;\nexports.PARENT_MESSAGE_SETUP_ERROR = PARENT_MESSAGE_SETUP_ERROR;\nconst PARENT_MESSAGE_CUSTOM = 3;\nexports.PARENT_MESSAGE_CUSTOM = PARENT_MESSAGE_CUSTOM;\nconst PARENT_MESSAGE_MEM_USAGE = 4;\n\n// Option objects.\n\n// Messages passed from the parent to the children.\n\n// Messages passed from the children to the parent.\n\n// Queue types.\nexports.PARENT_MESSAGE_MEM_USAGE = PARENT_MESSAGE_MEM_USAGE;\nlet WorkerStates = /*#__PURE__*/ (function (WorkerStates) {\n  WorkerStates['STARTING'] = 'starting';\n  WorkerStates['OK'] = 'ok';\n  WorkerStates['OUT_OF_MEMORY'] = 'oom';\n  WorkerStates['RESTARTING'] = 'restarting';\n  WorkerStates['SHUTTING_DOWN'] = 'shutting-down';\n  WorkerStates['SHUT_DOWN'] = 'shut-down';\n  return WorkerStates;\n})({});\nexports.WorkerStates = WorkerStates;\nlet WorkerEvents = /*#__PURE__*/ (function (WorkerEvents) {\n  WorkerEvents['STATE_CHANGE'] = 'state-change';\n  return WorkerEvents;\n})({});\nexports.WorkerEvents = WorkerEvents;\n
code-source-info,0x1a7a7588db08,491,0,2526,C0O0C4O2526,,
code-creation,Function,10,131000,0x1a7a7588dca8,225, /Users/miriam/m_documents/repos/tax-column/node_modules/jest-worker/build/types.js:1:1,0x1a7a7588da80,~
code-source-info,0x1a7a7588dca8,491,0,2526,C0O15C4O22C12O37C21O22C26O80C29O477C35O446C41O409C47O379C53O342C59O306C65O266C71O232C77O195C83O165C89O126C95O101C99O948C101O951C103O984C107O1039C110O1042C112O1069C116O1117C119O1120C121O1146C125O1199C128O1202C130O1234C134O1294C137O1297C139O1330C143O1384C145O1387C147O1413C151O1470C154O1473C156O1509C160O1575C163O1578C165O1613C169O1673C172O1676C174O1706C178O1764C181O1910C183O1943C187O2004C194O2306C199O2312C201O2333C205O2382C212O2483C217O2489C219O2510C224O2525,,
code-creation,Function,10,131042,0x1a7a7588deb0,9, /Users/miriam/m_documents/repos/tax-column/node_modules/jest-worker/build/types.js:68:44,0x1a7a7588db70,~
code-source-info,0x1a7a7588deb0,491,2392,2482,C0O2411C2O2440C6O2460C8O2480,,
code-creation,Function,10,131084,0x1a7a7588dfa0,39, /Users/miriam/m_documents/repos/tax-column/node_modules/jest-worker/build/types.js:58:44,0x1a7a7588db38,~
code-source-info,0x1a7a7588dfa0,491,2014,2305,C0O2033C2O2058C6O2074C8O2093C12O2103C14O2133C18O2144C20O2171C24O2189C26O2219C30O2240C32O2266C36O2283C38O2303,,
code-creation,LazyCompile,10,131167,0x1a7a7588e370,5,get node:internal/bootstrap/node:411:8,0x41ccf05d810,~
code-source-info,0x1a7a7588e370,16,13758,13791,C0O13769C4O13785,,
code-creation,LazyCompile,10,131209,0x1a7a7588e430,44,refCounted node:internal/child_process:537:13,0x30e7677288a8,~
code-source-info,0x1a7a7588e430,457,14088,14186,C0O14097C3O14107C9O14108C15O14114C22O14129C27O14156C29O14161C33O14170C38O14170C43O14185,,
code-creation,LazyCompile,10,131250,0x1a7a7588e5f0,318,processTicksAndRejections node:internal/process/task_queues:67:35,0x35d29719b8f0,~
code-source-info,0x1a7a7588e5f0,39,1479,2424,C0O1490C2O1537C7O1528C12O1528C19O1571C21O1576C23O1575C27O1600C34O1625C36O1624C46O1600C54O1701C59O1728C65O1760C70O1817C75O1846C110O1876C111O1889C115O1876C119O1895C121O1922C122O1935C128O1944C132O1922C137O1950C139O1977C140O1990C146O1999C152O2008C156O1977C161O2014C163O2041C164O2054C170O2063C176O2072C182O2081C186O2041C191O2087C193O2115C198O2115C215O2182C220O2186C225O2217C230O2217C245O2254C250O2254C256O2284C261O2284C264O2329C269O2319C274O2319C282O2332C285O2332C290O1498C296O2363C301O2363C305O2393C312O2393C317O2423,,
code-creation,LazyCompile,10,131334,0x1a7a7588e8c0,48,shift node:internal/fixed_queue:108:8,0x35d2971a08f8,~
code-source-info,0x1a7a7588e8c0,41,3954,4204,C0O3981C5O4009C10O4009C15O4031C20O4031C26O4049C32O4148C36O4141C40O4160C41O4170C45O4188C47O4200,,
code-creation,LazyCompile,10,131375,0x1a7a7588ea08,54,shift node:internal/fixed_queue:80:8,0x35d2971a0698,~
code-source-info,0x1a7a7588ea08,41,3300,3510,C0O3331C5O3341C9O3335C13O3354C15O3388C16O3400C17O3410C22O3420C28O3428C32O3465C36O3472C42O3479C44O3477C47O3457C51O3490C53O3506,,
code-creation,LazyCompile,10,131417,0x1a7a7588eb40,42,emitBeforeScript node:internal/async_hooks:508:26,0x2da83affcf18,~
code-source-info,0x1a7a7588eb40,19,16825,16976,C0O16865C12O16865C17O16921C22O16934C25O16925C31O16948C36O16948C41O16975,,
code-creation,LazyCompile,10,131459,0x1a7a7588ec98,180,pushAsyncContext node:internal/async_hooks:538:26,0x2da83affd058,~
code-source-info,0x1a7a7588ec98,19,17469,18014,C0O17524C7O17542C9O17541C13O17559C20O17593C24O17607C26O17618C32O17625C35O17636C40O17652C44O17622C49O17664C54O17671C59O17714C60O17717C65O17728C72O17751C78O17758C83O17774C85O17773C88O17756C92O17796C97O17807C104O17830C107O17834C113O17841C118O17857C120O17856C123O17839C127O17877C134O17895C142O17908C146O17914C153O17930C158O17949C162O17962C169O17978C174O17995C179O18013,,
code-creation,LazyCompile,10,131500,0x1a7a7588eeb0,125, node:internal/child_process:707:22,0x2b3d46cd8ce0,~
code-source-info,0x1a7a7588eeb0,457,19334,19698,C0O19348C3O19360C12O19379C20O19379C27O19413C28O19420C29O19445C32O19452C41O19460C43O19459C47O19493C52O19520C54O19533C55O19540C56O19561C58O19566C60O19566C65O19591C75O19611C85O19633C89O19591C94O19577C99O19548C102O19654C105O19661C114O19669C119O19687C124O19697,,
code-creation,LazyCompile,10,131542,0x1a7a7588f088,117,listenerCount node:events:842:23,0x1012a3972f00,~
code-source-info,0x1a7a7588f088,29,24222,24869,C0O24263C5O24275C7O24326C9O24332C13O24345C17O24391C22O24423C24O24439C34O24462C35O24478C37O24487C38O24499C42O24537C47O24584C49O24609C51O24627C56O24637C58O24637C63O24659C65O24673C71O24677C78O24703C82O24707C89O24716C94O24744C99O24643C104O24596C107O24787C109O24803C110O24837C114O24844C115O24858C116O24867,,
code-creation,LazyCompile,10,131584,0x1a7a7588f220,13,destroyHooksExist node:internal/async_hooks:485:27,0x2da83affce28,~
code-source-info,0x1a7a7588f220,19,16274,16309,C0O16281C5O16297C8O16288C12O16307,,
code-creation,LazyCompile,10,131584,0x1a7a7588f310,32,emitAfterScript node:internal/async_hooks:516:25,0x2da83affcf68,~
code-source-info,0x1a7a7588f310,19,17003,17099,C0O17017C5O17030C8O17021C14O17043C19O17043C23O17072C26O17072C31O17098,,
code-creation,LazyCompile,10,131625,0x1a7a7588f478,167,popAsyncContext node:internal/async_hooks:552:25,0x2da83affd0a8,~
code-source-info,0x1a7a7588f478,19,18103,18690,C0O18137C7O18155C9O18154C13O18172C14O18188C19O18195C20O18208C21O18212C24O18216C31O18239C36O18255C38O18254C44O18274C49O18356C54O18363C58O18389C59O18412C61O18424C65O18431C72O18447C77O18468C80O18479C87O18497C90O18494C93O18466C97O18510C104O18526C109O18545C112O18556C119O18574C122O18583C125O18571C128O18543C132O18591C137O18617C142O18617C146O18626C153O18644C158O18658C162O18670C163O18684C166O18688,,
code-creation,LazyCompile,10,131667,0x1a7a7588f658,13,enabledHooksExist node:internal/async_hooks:473:27,0x2da83affcd38,~
code-source-info,0x1a7a7588f658,19,16097,16130,C0O16104C5O16120C8O16111C12O16128,,
code-creation,LazyCompile,10,131792,0x1a7a7588f968,627,processPromiseRejections node:internal/process/promises:220:34,0x35d29719ef20,~
script-source,40,node:internal/process/promises,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  Error\x2C\n  ObjectDefineProperty\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  SafeWeakMap\x2C\n} = primordials;\n\nconst {\n  tickInfo\x2C\n  promiseRejectEvents: {\n    kPromiseRejectWithNoHandler\x2C\n    kPromiseHandlerAddedAfterReject\x2C\n    kPromiseResolveAfterResolved\x2C\n    kPromiseRejectAfterResolved\x2C\n  }\x2C\n  setPromiseRejectCallback\x2C\n} = internalBinding('task_queue');\n\nconst { deprecate } = require('internal/util');\n\nconst {\n  noSideEffectsToString\x2C\n  triggerUncaughtException\x2C\n} = internalBinding('errors');\n\nconst {\n  pushAsyncContext\x2C\n  popAsyncContext\x2C\n  symbols: {\n    async_id_symbol: kAsyncIdSymbol\x2C\n    trigger_async_id_symbol: kTriggerAsyncIdSymbol\x2C\n  }\x2C\n} = require('internal/async_hooks');\nconst { isErrorStackTraceLimitWritable } = require('internal/errors');\n\n// *Must* match Environment::TickInfo::Fields in src/env.h.\nconst kHasRejectionToWarn = 1;\n\nconst maybeUnhandledPromises = new SafeWeakMap();\nconst pendingUnhandledRejections = [];\nconst asyncHandledRejections = [];\nlet lastPromiseId = 0;\n\n// --unhandled-rejections=none:\n// Emit 'unhandledRejection'\x2C but do not emit any warning.\nconst kIgnoreUnhandledRejections = 0;\n\n// --unhandled-rejections=warn:\n// Emit 'unhandledRejection'\x2C then emit 'UnhandledPromiseRejectionWarning'.\nconst kAlwaysWarnUnhandledRejections = 1;\n\n// --unhandled-rejections=strict:\n// Emit 'uncaughtException'. If it's not handled\x2C print the error to stderr\n// and exit the process.\n// Otherwise\x2C emit 'unhandledRejection'. If 'unhandledRejection' is not\n// handled\x2C emit 'UnhandledPromiseRejectionWarning'.\nconst kStrictUnhandledRejections = 2;\n\n// --unhandled-rejections=throw:\n// Emit 'unhandledRejection'\x2C if it's unhandled\x2C emit\n// 'uncaughtException'. If it's not handled\x2C print the error to stderr\n// and exit the process.\nconst kThrowUnhandledRejections = 3;\n\n// --unhandled-rejections=warn-with-error-code:\n// Emit 'unhandledRejection'\x2C if it's unhandled\x2C emit\n// 'UnhandledPromiseRejectionWarning'\x2C then set process exit code to 1.\n\nconst kWarnWithErrorCodeUnhandledRejections = 4;\n\nlet unhandledRejectionsMode;\n\nfunction setHasRejectionToWarn(value) {\n  tickInfo[kHasRejectionToWarn] = value ? 1 : 0;\n}\n\nfunction hasRejectionToWarn() {\n  return tickInfo[kHasRejectionToWarn] === 1;\n}\n\nfunction isErrorLike(o) {\n  return typeof o === 'object' &&\n         o !== null &&\n         ObjectPrototypeHasOwnProperty(o\x2C 'stack');\n}\n\nfunction getUnhandledRejectionsMode() {\n  const { getOptionValue } = require('internal/options');\n  switch (getOptionValue('--unhandled-rejections')) {\n    case 'none':\n      return kIgnoreUnhandledRejections;\n    case 'warn':\n      return kAlwaysWarnUnhandledRejections;\n    case 'strict':\n      return kStrictUnhandledRejections;\n    case 'throw':\n      return kThrowUnhandledRejections;\n    case 'warn-with-error-code':\n      return kWarnWithErrorCodeUnhandledRejections;\n    default:\n      return kThrowUnhandledRejections;\n  }\n}\n\nfunction promiseRejectHandler(type\x2C promise\x2C reason) {\n  if (unhandledRejectionsMode === undefined) {\n    unhandledRejectionsMode = getUnhandledRejectionsMode();\n  }\n  switch (type) {\n    case kPromiseRejectWithNoHandler:\n      unhandledRejection(promise\x2C reason);\n      break;\n    case kPromiseHandlerAddedAfterReject:\n      handledRejection(promise);\n      break;\n    case kPromiseResolveAfterResolved:\n      resolveError('resolve'\x2C promise\x2C reason);\n      break;\n    case kPromiseRejectAfterResolved:\n      resolveError('reject'\x2C promise\x2C reason);\n      break;\n  }\n}\n\nconst multipleResolvesDeprecate = deprecate(\n  () => {}\x2C\n  'The multipleResolves event has been deprecated.'\x2C\n  'DEP0160'\x2C\n);\nfunction resolveError(type\x2C promise\x2C reason) {\n  // We have to wrap this in a next tick. Otherwise the error could be caught by\n  // the executed promise.\n  process.nextTick(() => {\n    if (process.emit('multipleResolves'\x2C type\x2C promise\x2C reason)) {\n      multipleResolvesDeprecate();\n    }\n  });\n}\n\nfunction unhandledRejection(promise\x2C reason) {\n  const emit = (reason\x2C promise\x2C promiseInfo) => {\n    if (promiseInfo.domain) {\n      return promiseInfo.domain.emit('error'\x2C reason);\n    }\n    return process.emit('unhandledRejection'\x2C reason\x2C promise);\n  };\n\n  maybeUnhandledPromises.set(promise\x2C {\n    reason\x2C\n    uid: ++lastPromiseId\x2C\n    warned: false\x2C\n    domain: process.domain\x2C\n    emit\x2C\n  });\n  // This causes the promise to be referenced at least for one tick.\n  ArrayPrototypePush(pendingUnhandledRejections\x2C promise);\n  setHasRejectionToWarn(true);\n}\n\nfunction handledRejection(promise) {\n  const promiseInfo = maybeUnhandledPromises.get(promise);\n  if (promiseInfo !== undefined) {\n    maybeUnhandledPromises.delete(promise);\n    if (promiseInfo.warned) {\n      const { uid } = promiseInfo;\n      // Generate the warning object early to get a good stack trace.\n      // eslint-disable-next-line no-restricted-syntax\n      const warning = new Error('Promise rejection was handled ' +\n                                `asynchronously (rejection id: ${uid})`);\n      warning.name = 'PromiseRejectionHandledWarning';\n      warning.id = uid;\n      ArrayPrototypePush(asyncHandledRejections\x2C { promise\x2C warning });\n      setHasRejectionToWarn(true);\n      return;\n    }\n  }\n  if (maybeUnhandledPromises.size === 0 && asyncHandledRejections.length === 0)\n    setHasRejectionToWarn(false);\n}\n\nconst unhandledRejectionErrName = 'UnhandledPromiseRejectionWarning';\nfunction emitUnhandledRejectionWarning(uid\x2C reason) {\n  const warning = getErrorWithoutStack(\n    unhandledRejectionErrName\x2C\n    'Unhandled promise rejection. This error originated either by ' +\n      'throwing inside of an async function without a catch block\x2C ' +\n      'or by rejecting a promise which was not handled with .catch(). ' +\n      'To terminate the node process on unhandled promise ' +\n      'rejection\x2C use the CLI flag `--unhandled-rejections=strict` (see ' +\n      'https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). ' +\n      `(rejection id: ${uid})`\x2C\n  );\n  try {\n    if (isErrorLike(reason)) {\n      warning.stack = reason.stack;\n      process.emitWarning(reason.stack\x2C unhandledRejectionErrName);\n    } else {\n      process.emitWarning(\n        noSideEffectsToString(reason)\x2C unhandledRejectionErrName);\n    }\n  } catch {\n    try {\n      process.emitWarning(\n        noSideEffectsToString(reason)\x2C unhandledRejectionErrName);\n    } catch {\n      // Ignore.\n    }\n  }\n\n  process.emitWarning(warning);\n}\n\n// If this method returns true\x2C we've executed user code or triggered\n// a warning to be emitted which requires the microtask and next tick\n// queues to be drained again.\nfunction processPromiseRejections() {\n  let maybeScheduledTicksOrMicrotasks = asyncHandledRejections.length > 0;\n\n  while (asyncHandledRejections.length > 0) {\n    const { promise\x2C warning } = ArrayPrototypeShift(asyncHandledRejections);\n    if (!process.emit('rejectionHandled'\x2C promise)) {\n      process.emitWarning(warning);\n    }\n  }\n\n  let len = pendingUnhandledRejections.length;\n  while (len--) {\n    const promise = ArrayPrototypeShift(pendingUnhandledRejections);\n    const promiseInfo = maybeUnhandledPromises.get(promise);\n    if (promiseInfo === undefined) {\n      continue;\n    }\n    promiseInfo.warned = true;\n    const { reason\x2C uid\x2C emit } = promiseInfo;\n\n    let needPop = true;\n    const {\n      [kAsyncIdSymbol]: promiseAsyncId\x2C\n      [kTriggerAsyncIdSymbol]: promiseTriggerAsyncId\x2C\n    } = promise;\n    // We need to check if async_hooks are enabled\n    // don't use enabledHooksExist as a Promise could\n    // come from a vm.* context and not have an async id\n    if (typeof promiseAsyncId !== 'undefined') {\n      pushAsyncContext(\n        promiseAsyncId\x2C\n        promiseTriggerAsyncId\x2C\n        promise\x2C\n      );\n    }\n    try {\n      switch (unhandledRejectionsMode) {\n        case kStrictUnhandledRejections: {\n          const err = isErrorLike(reason) ?\n            reason : generateUnhandledRejectionError(reason);\n          // This destroys the async stack\x2C don't clear it after\n          triggerUncaughtException(err\x2C true /* fromPromise */);\n          if (typeof promiseAsyncId !== 'undefined') {\n            pushAsyncContext(\n              promise[kAsyncIdSymbol]\x2C\n              promise[kTriggerAsyncIdSymbol]\x2C\n              promise\x2C\n            );\n          }\n          const handled = emit(reason\x2C promise\x2C promiseInfo);\n          if (!handled) emitUnhandledRejectionWarning(uid\x2C reason);\n          break;\n        }\n        case kIgnoreUnhandledRejections: {\n          emit(reason\x2C promise\x2C promiseInfo);\n          break;\n        }\n        case kAlwaysWarnUnhandledRejections: {\n          emit(reason\x2C promise\x2C promiseInfo);\n          emitUnhandledRejectionWarning(uid\x2C reason);\n          break;\n        }\n        case kThrowUnhandledRejections: {\n          const handled = emit(reason\x2C promise\x2C promiseInfo);\n          if (!handled) {\n            const err = isErrorLike(reason) ?\n              reason : generateUnhandledRejectionError(reason);\n              // This destroys the async stack\x2C don't clear it after\n            triggerUncaughtException(err\x2C true /* fromPromise */);\n            needPop = false;\n          }\n          break;\n        }\n        case kWarnWithErrorCodeUnhandledRejections: {\n          const handled = emit(reason\x2C promise\x2C promiseInfo);\n          if (!handled) {\n            emitUnhandledRejectionWarning(uid\x2C reason);\n            process.exitCode = 1;\n          }\n          break;\n        }\n      }\n    } finally {\n      if (needPop) {\n        if (typeof promiseAsyncId !== 'undefined') {\n          popAsyncContext(promiseAsyncId);\n        }\n      }\n    }\n    maybeScheduledTicksOrMicrotasks = true;\n  }\n  return maybeScheduledTicksOrMicrotasks ||\n         pendingUnhandledRejections.length !== 0;\n}\n\nfunction getErrorWithoutStack(name\x2C message) {\n  // Reset the stack to prevent any overhead.\n  const tmp = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmp;\n  ObjectDefineProperty(err\x2C 'name'\x2C {\n    __proto__: null\x2C\n    value: name\x2C\n    enumerable: false\x2C\n    writable: true\x2C\n    configurable: true\x2C\n  });\n  return err;\n}\n\nfunction generateUnhandledRejectionError(reason) {\n  const message =\n    'This error originated either by ' +\n    'throwing inside of an async function without a catch block\x2C ' +\n    'or by rejecting a promise which was not handled with .catch().' +\n    ' The promise rejected with the reason ' +\n    `"${noSideEffectsToString(reason)}".`;\n\n  const err = getErrorWithoutStack('UnhandledPromiseRejection'\x2C message);\n  err.code = 'ERR_UNHANDLED_REJECTION';\n  return err;\n}\n\nfunction listenForRejections() {\n  setPromiseRejectCallback(promiseRejectHandler);\n}\nmodule.exports = {\n  hasRejectionToWarn\x2C\n  setHasRejectionToWarn\x2C\n  listenForRejections\x2C\n  processPromiseRejections\x2C\n};\n
code-source-info,0x1a7a7588f968,40,6669,9797,C0O6714C6O6737C13O6744C17O6789C23O6782C30O6789C35O6829C43O6849C47O6829C53O6808C58O6817C64O6878C68O6891C78O6891C86O6934C90O6942C96O6942C101O6752C104O6987C110O7014C115O7034C126O7034C128O7060C136O7080C140O7060C145O7133C151O7156C157O7156C163O7174C165O7213C167O7233C168O7252C172O7272C177O7280C182O7285C187O7326C189O7446C198O7342C203O7368C215O7415C227O7621C233O7672C248O7672C256O7793C264O7841C273O8497C282O8613C291O8787C300O9231C309O7893C313O7893C327O7936C332O8052C341O8052C346O8117C352O8174C360O8214C362O8213C369O8253C371O8252C379O8174C384O8353C393O8353C399O8399C401O8413C405O8413C410O8467C412O8537C421O8537C426O8583C428O8657C437O8657C442O8703C446O8703C451O8757C453O8842C462O8842C468O8888C470O8928C474O8928C488O8973C493O9095C502O9095C507O9162C509O9201C511O9298C520O9298C526O9344C528O9372C532O9372C537O9428C543O9445C547O9472C564O9519C570O9542C576O9597C582O9597C597O9658C599O7024C605O9704C611O9755C615O9782C622O9789C626O9795,,
code-creation,LazyCompile,10,132292,0x1a7a75890910,25,setHasRejectionToWarn node:internal/process/promises:77:31,0x35d29719e908,~
code-source-info,0x1a7a75890910,40,2149,2209,C0O2161C7O2170C12O2193C19O2191C24O2208,,
tick,0x195a4aa2c,132334,0,0x0,3,0x0,0x1a7a7588e70d
code-creation,LazyCompile,10,132375,0x1a7a75890b08,383,channel.onread node:internal/child_process:600:28,0x2b3d46cd1030,~
code-source-info,0x1a7a75890b08,457,15602,16773,C0O15641C3O15649C8O15668C12O15690C16O15702C20O15741C31O15757C33O15756C37O15798C48O15814C50O15813C54O15854C72O15854C78O15904C82O15928C84O15942C90O15985C98O15985C128O15974C156O15974C159O16252C164O16256C173O16301C180O16305C185O16338C190O16361C200O16338C205O16395C209O16409C217O16448C229O16448C236O16528C248O16528C253O15963C319O16607C320O16622C324O16637C327O16644C332O16644C336O16664C343O16681C345O16679C349O16692C352O16700C357O16700C361O16715C365O16730C369O16744C377O16744C382O16772,,
code-creation,LazyCompile,10,132459,0x1a7a75890e60,277,parseChannelMessages node:internal/child_process/serialization:137:24,0x2b3d46cd4920,~
code-source-info,0x1a7a75890e60,464,4386,5149,C10O4386C15O4386C35O4386C39O4425C45O4432C50O4439C51O4446C52O4452C54O4464C56O4463C61O4501C63O4509C68O4531C76O4527C81O4525C85O4579C92O4608C94O4607C98O4624C103O4624C112O4579C118O4685C122O4692C126O4775C128O4781C132O4806C133O4828C138O4843C140O4851C149O4867C152O4864C158O4903C162O4923C164O4922C169O4944C172O4936C175O4913C179O4968C181O4973C183O4973C188O5007C195O5029C199O5013C210O5007C230O5007C234O4995C239O4955C242O5041C244O5049C249O5062C253O5091C255O5119C257O5118C261O5132C267O5139C271O5109C276O5148,,
code-creation,LazyCompile,10,132500,0x1a7a75891110,71,StringDecoder node:string_decoder:82:23,0x26f398afa70,~
script-source,66,node:string_decoder,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayBufferIsView\x2C\n  ObjectDefineProperties\x2C\n  Symbol\x2C\n  TypedArrayPrototypeSubarray\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst {\n  kIncompleteCharactersStart\x2C\n  kIncompleteCharactersEnd\x2C\n  kMissingBytes\x2C\n  kBufferedBytes\x2C\n  kEncodingField\x2C\n  kSize\x2C\n  decode\x2C\n  flush\x2C\n  encodings\x2C\n} = internalBinding('string_decoder');\nconst internalUtil = require('internal/util');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_THIS\x2C\n  ERR_UNKNOWN_ENCODING\x2C\n} = require('internal/errors').codes;\nconst isEncoding = Buffer[internalUtil.kIsEncodingSymbol];\n\nconst kNativeDecoder = Symbol('kNativeDecoder');\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\n/**\n * Normalize encoding notation\n * @param {string} enc\n * @returns {"utf8" | "utf16le" | "hex" | "ascii"\n *           | "base64" | "latin1" | "base64url"}\n * @throws {TypeError} Throws an error when encoding is invalid\n */\nfunction normalizeEncoding(enc) {\n  const nenc = internalUtil.normalizeEncoding(enc);\n  if (nenc === undefined) {\n    if (Buffer.isEncoding === isEncoding || !Buffer.isEncoding(enc))\n      throw new ERR_UNKNOWN_ENCODING(enc);\n    return enc;\n  }\n  return nenc;\n}\n\nconst encodingsMap = {};\nfor (let i = 0; i < encodings.length; ++i)\n  encodingsMap[encodings[i]] = i;\n\n/**\n * StringDecoder provides an interface for efficiently splitting a series of\n * buffers into a series of JS strings without breaking apart multi-byte\n * characters.\n * @param {string} [encoding=utf-8]\n */\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  this[kNativeDecoder] = Buffer.alloc(kSize);\n  this[kNativeDecoder][kEncodingField] = encodingsMap[this.encoding];\n}\n\n/**\n * Returns a decoded string\x2C omitting any incomplete multi-bytes\n * characters at the end of the Buffer\x2C or TypedArray\x2C or DataView\n * @param {string | Buffer | TypedArray | DataView} buf\n * @returns {string}\n * @throws {TypeError} Throws when buf is not in one of supported types\n */\nStringDecoder.prototype.write = function write(buf) {\n  if (typeof buf === 'string')\n    return buf;\n  if (!ArrayBufferIsView(buf))\n    throw new ERR_INVALID_ARG_TYPE('buf'\x2C\n                                   ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n                                   buf);\n  if (!this[kNativeDecoder]) {\n    throw new ERR_INVALID_THIS('StringDecoder');\n  }\n  return decode(this[kNativeDecoder]\x2C buf);\n};\n\n/**\n * Returns any remaining input stored in the internal buffer as a string.\n * After end() is called\x2C the stringDecoder object can be reused for new\n * input.\n * @param {string | Buffer | TypedArray | DataView} [buf]\n * @returns {string}\n */\nStringDecoder.prototype.end = function end(buf) {\n  let ret = '';\n  if (buf !== undefined)\n    ret = this.write(buf);\n  if (this[kNativeDecoder][kBufferedBytes] > 0)\n    ret += flush(this[kNativeDecoder]);\n  return ret;\n};\n\n/* Everything below this line is undocumented legacy stuff. */\n/**\n *\n * @param {string | Buffer | TypedArray | DataView} buf\n * @param {number} offset\n * @returns {string}\n */\nStringDecoder.prototype.text = function text(buf\x2C offset) {\n  this[kNativeDecoder][kMissingBytes] = 0;\n  this[kNativeDecoder][kBufferedBytes] = 0;\n  return this.write(buf.slice(offset));\n};\n\nObjectDefineProperties(StringDecoder.prototype\x2C {\n  lastChar: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      return TypedArrayPrototypeSubarray(this[kNativeDecoder]\x2C\n                                         kIncompleteCharactersStart\x2C\n                                         kIncompleteCharactersEnd);\n    }\x2C\n  }\x2C\n  lastNeed: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      return this[kNativeDecoder][kMissingBytes];\n    }\x2C\n  }\x2C\n  lastTotal: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      return this[kNativeDecoder][kBufferedBytes] +\n             this[kNativeDecoder][kMissingBytes];\n    }\x2C\n  }\x2C\n});\n\nexports.StringDecoder = StringDecoder;\n
code-source-info,0x1a7a75891110,66,2727,2904,C0O2742C3O2758C7O2756C11O2789C13O2794C18O2812C21O2819C28O2825C31O2819C36O2810C40O2835C42O2840C44O2839C50O2856C55O2874C58O2892C62O2886C65O2872C70O2903,,
code-creation,LazyCompile,10,132750,0x1a7a758917e0,73,normalizeEncoding node:string_decoder:62:27,0x26f398af8a8,~
code-source-info,0x1a7a758917e0,66,2155,2391,C0O2178C5O2191C10O2191C16O2217C18O2247C23O2258C30O2273C32O2269C39O2288C42O2295C47O2295C54O2318C61O2324C66O2318C67O2359C69O2370C70O2377C72O2389,,
code-creation,LazyCompile,10,132792,0x1a7a75891980,73,alloc node:buffer:412:30,0x1012a397f528,~
code-source-info,0x1a7a75891980,30,11833,12064,C0O11860C5O11860C9O11880C14O11911C20O11925C25O11948C30O11948C35O11978C40O12009C54O11985C59O12027C60O12034C67O12041C72O12062,,
code-creation,LazyCompile,10,132834,0x1a7a75891b38,88,write node:string_decoder:95:47,0x26f398afac0,~
code-source-info,0x1a7a75891b38,66,3241,3612,C0O3251C6O3284C8O3295C9O3298C14O3303C20O3331C38O3337C43O3331C44O3485C46O3495C48O3494C53O3518C63O3524C68O3518C69O3569C76O3588C78O3587C82O3576C87O3610,,
code-creation,LazyCompile,10,132875,0x1a7a75891ca8,80,isInternal node:internal/child_process:961:20,0x30e767728108,~
code-source-info,0x1a7a75891ca8,457,26881,27172,C0O26895C3O26911C12O26989C20O27027C25O27031C32O27040C35O27056C39O27038C46O27076C49O27105C58O27113C61O27129C66O27076C74O27153C76O27137C79O27170,,
code-creation,LazyCompile,10,132875,0x1a7a75891e08,51,handleMessage node:internal/child_process:947:25,0x2b3d46cd0f40,~
code-source-info,0x1a7a75891e08,457,26587,26783,C0O26621C3O26633C9O26648C10O26655C11O26679C22O26728C27O26736C44O26736C50O26782,,
code-creation,LazyCompile,10,132959,0x1a7a75891ff8,115,emit node:internal/child_process:935:16,0x2b3d46cd0ef0,~
code-source-info,0x1a7a75891ff8,457,26290,26561,C0O26321C5O26343C13O26363C21O26363C28O26397C31O26404C45O26404C50O26440C51O26447C52O26459C62O26492C71O26500C73O26499C86O26526C95O26533C104O26542C108O26459C114O26560,,
code-creation,LazyCompile,10,133000,0x1a7a758921d0,276,messageListener /Users/miriam/m_documents/repos/tax-column/node_modules/jest-worker/build/workers/processChild.js:35:25,0x1a7a7588a968,~
code-source-info,0x1a7a758921d0,490,1023,2012,C1O1053C9O1038C12O1076C27O1208C39O1321C51O1382C63O1463C74O1121C77O1136C83O1147C89O1141C95O1158C101O1174C107O1168C113O1185C115O1247C118O1262C123O1273C127O1277C133O1282C137O1286C141O1262C146O1298C148O1346C151O1346C154O1359C156O1413C159O1413C162O1440C164O1495C170O1522C175O1522C181O1581C186O1589C189O1581C194O1604C198O1616C204O1641C210O1660C213O1691C220O1728C232O1660C239O1840C244O1840C248O1887C250O1913C258O1992C268O1919C273O1913C275O2011,,
code-creation,LazyCompile,10,158834,0x1a7a75892468,54,end /Users/miriam/m_documents/repos/tax-column/node_modules/jest-worker/build/workers/processChild.js:116:13,0x1a7a7588a800,~
code-source-info,0x1a7a75892468,490,3136,3298,C0O3156C5O3164C8O3156C13O3183C19O3199C22O3199C25O3218C26O3225C27O3232C30O3250C35O3260C47O3232C53O3297,,
tick,0x195a516c0,159209,0,0x0,8
code-creation,Eval,10,159292,0x1a7a75893450,5, /Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/worker.js:1:1,0x1a7a75893228,~
script-source,492,/Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/worker.js,'use strict';\n\nObject.defineProperty(exports\x2C '__esModule'\x2C {\n  value: true\n});\nexports.getSha1 = getSha1;\nexports.worker = worker;\nfunction _crypto() {\n  const data = require('crypto');\n  _crypto = function () {\n    return data;\n  };\n  return data;\n}\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n  path = function () {\n    return data;\n  };\n  return data;\n}\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n  fs = function () {\n    return data;\n  };\n  return data;\n}\nfunction _jestUtil() {\n  const data = require('jest-util');\n  _jestUtil = function () {\n    return data;\n  };\n  return data;\n}\nvar _blacklist = _interopRequireDefault(require('./blacklist'));\nvar _constants = _interopRequireDefault(require('./constants'));\nvar _dependencyExtractor = require('./lib/dependencyExtractor');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj\x2C nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj\x2C key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj\x2C key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj\x2C key\x2C desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj\x2C newObj);\n  }\n  return newObj;\n}\n/**\n * Copyright (c) Meta Platforms\x2C Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst PACKAGE_JSON = `${path().sep}package.json`;\nlet hasteImpl = null;\nlet hasteImplModulePath = null;\nfunction sha1hex(content) {\n  return (0\x2C _crypto().createHash)('sha1').update(content).digest('hex');\n}\nasync function worker(data) {\n  if (\n    data.hasteImplModulePath &&\n    data.hasteImplModulePath !== hasteImplModulePath\n  ) {\n    if (hasteImpl) {\n      throw new Error('jest-haste-map: hasteImplModulePath changed');\n    }\n    hasteImplModulePath = data.hasteImplModulePath;\n    hasteImpl = require(hasteImplModulePath);\n  }\n  let content;\n  let dependencies;\n  let id;\n  let module;\n  let sha1;\n  const {computeDependencies\x2C computeSha1\x2C rootDir\x2C filePath} = data;\n  const getContent = () => {\n    if (content === undefined) {\n      content = fs().readFileSync(filePath\x2C 'utf8');\n    }\n    return content;\n  };\n  if (filePath.endsWith(PACKAGE_JSON)) {\n    // Process a package.json that is returned as a PACKAGE type with its name.\n    try {\n      const fileData = JSON.parse(getContent());\n      if (fileData.name) {\n        const relativeFilePath = path().relative(rootDir\x2C filePath);\n        id = fileData.name;\n        module = [relativeFilePath\x2C _constants.default.PACKAGE];\n      }\n    } catch (err) {\n      throw new Error(`Cannot parse ${filePath} as JSON: ${err.message}`);\n    }\n  } else if (\n    !_blacklist.default.has(filePath.substring(filePath.lastIndexOf('.')))\n  ) {\n    // Process a random file that is returned as a MODULE.\n    if (hasteImpl) {\n      id = hasteImpl.getHasteName(filePath);\n    }\n    if (computeDependencies) {\n      const content = getContent();\n      const extractor = data.dependencyExtractor\n        ? await (0\x2C _jestUtil().requireOrImportModule)(\n            data.dependencyExtractor\x2C\n            false\n          )\n        : _dependencyExtractor.extractor;\n      dependencies = Array.from(\n        extractor.extract(\n          content\x2C\n          filePath\x2C\n          _dependencyExtractor.extractor.extract\n        )\n      );\n    }\n    if (id) {\n      const relativeFilePath = path().relative(rootDir\x2C filePath);\n      module = [relativeFilePath\x2C _constants.default.MODULE];\n    }\n  }\n\n  // If a SHA-1 is requested on update\x2C compute it.\n  if (computeSha1) {\n    sha1 = sha1hex(content || fs().readFileSync(filePath));\n  }\n  return {\n    dependencies\x2C\n    id\x2C\n    module\x2C\n    sha1\n  };\n}\nasync function getSha1(data) {\n  const sha1 = data.computeSha1\n    ? sha1hex(fs().readFileSync(data.filePath))\n    : null;\n  return {\n    dependencies: undefined\x2C\n    id: undefined\x2C\n    module: undefined\x2C\n    sha1\n  };\n}\n
code-source-info,0x1a7a75893450,492,0,4942,C0O0C4O4942,,
code-creation,Function,10,159834,0x1a7a75893988,186, /Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/worker.js:1:1,0x1a7a758933c8,~
code-source-info,0x1a7a75893988,492,0,4942,C0O0C75O15C79O22C87O37C95O22C100O80C102O96C106O107C108O122C112O673C118O696C123O673C127O673C129O738C135O761C140O738C144O738C146O813C152O813C156O813C158O2405C161O2408C165O2414C176O2405C178O2450C179O2450C181O2482C182O2482C185O4941,,
code-creation,RegExp,3,160250,0x110053940,2016,^((?:@[^/\\\\%]+\\/)?[^./\\\\%][^/\\\\%]*)(\\/.*)?$
tick,0x100cd637c,160375,1,0x100b28fb8,2,0x0,0x1a7a758896c6,0x1a7a75888e97,0x1a7a758887d9,0x1a7a758824d5,0x1a7a758813e8,0x1fa4d1d7cd38,0x1a7a7588caec,0x1a7a7588c930,0x1a7a75892470,0x1a7a75892267,0x1012a3972274,0x1a7a75892025,0x1a7a7588e68c
code-creation,Function,11,160667,0x110054180,8312,realpathSync node:fs:2577:22,0x28e4ce8e7878,^
code-source-info,0x110054180,76,69085,72976,,,
code-creation,Function,11,160709,0x110056260,312,SafeSet node:internal/per_context/primordials:420:16,0x41ccf052c88,^
code-source-info,0x110056260,12,11953,11970,,,
code-creation,Function,11,160834,0x110056400,1432,readPackageScope node:internal/modules/cjs/loader:406:26,0x2b3d46cdf680,^
code-source-info,0x110056400,465,11264,11783,,,
code-creation,Function,11,160875,0x110056a00,616,validateStringArray node:internal/validators:305:29,0x1012a394bf88,^
code-source-info,0x110056a00,22,8246,8387,,,
code-creation,Function,11,160917,0x110056ce0,184,hasHooks node:internal/async_hooks:469:18,0x2da83affcce8,^
code-source-info,0x110056ce0,19,16023,16069,,,
tick,0x1958ee4b4,161000,0,0x0,0,0x0,0x1fa4d1d6e3d1,0x1fa4d1d6d773,0x1a7a7588d347,0x1a7a7588d1f7,0x1fa4d1d6d02e,0x1fa4d1d7d664,0x1fa4d1d7cc33,0x1a7a7588caec,0x1a7a7588c930,0x1a7a758939fe,0x1a7a7588893e,0x1a7a758824d5,0x1a7a758813e8,0x1fa4d1d7cd38,0x1a7a7588caec,0x1a7a7588c930,0x1a7a75892470,0x1a7a75892267,0x1012a3972274,0x1a7a75892025,0x1a7a7588e68c
code-creation,Function,11,161042,0x110056e00,136,isEmpty node:internal/fixed_queue:67:10,0x35d2971a05a8,^
code-source-info,0x110056e00,41,3084,3129,,,
code-creation,Function,11,161042,0x110056f00,64,noop node:internal/util/debuglog:47:14,0x1012a3968698,^
code-source-info,0x110056f00,28,1419,1427,,,
code-creation,Eval,10,161209,0x1a7a75895118,5, /Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/blacklist.js:1:1,0x1a7a75894fd0,~
script-source,493,/Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/blacklist.js,'use strict';\n\nObject.defineProperty(exports\x2C '__esModule'\x2C {\n  value: true\n});\nexports.default = void 0;\n/**\n * Copyright (c) Meta Platforms\x2C Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This list is compiled after the MDN list of the most common MIME types (see\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/\n// Complete_list_of_MIME_types).\n//\n// Only MIME types starting with "image/"\x2C "video/"\x2C "audio/" and "font/" are\n// reflected in the list. Adding "application/" is too risky since some text\n// file formats (like ".js" and ".json") have an "application/" MIME type.\n//\n// Feel free to add any extensions that cannot be a Haste module.\n\nconst extensions = new Set([\n  // JSONs are never haste modules\x2C except for "package.json"\x2C which is handled.\n  '.json'\x2C\n  // Image extensions.\n  '.bmp'\x2C\n  '.gif'\x2C\n  '.ico'\x2C\n  '.jpeg'\x2C\n  '.jpg'\x2C\n  '.png'\x2C\n  '.svg'\x2C\n  '.tiff'\x2C\n  '.tif'\x2C\n  '.webp'\x2C\n  // Video extensions.\n  '.avi'\x2C\n  '.mp4'\x2C\n  '.mpeg'\x2C\n  '.mpg'\x2C\n  '.ogv'\x2C\n  '.webm'\x2C\n  '.3gp'\x2C\n  '.3g2'\x2C\n  // Audio extensions.\n  '.aac'\x2C\n  '.midi'\x2C\n  '.mid'\x2C\n  '.mp3'\x2C\n  '.oga'\x2C\n  '.wav'\x2C\n  '.3gp'\x2C\n  '.3g2'\x2C\n  // Font extensions.\n  '.eot'\x2C\n  '.otf'\x2C\n  '.ttf'\x2C\n  '.woff'\x2C\n  '.woff2'\n]);\nvar _default = extensions;\nexports.default = _default;\n
code-source-info,0x1a7a75895118,493,0,1382,C0O0C4O1382,,
code-creation,Function,10,161334,0x1a7a75895318,56, /Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/blacklist.js:1:1,0x1a7a75895090,~
code-source-info,0x1a7a75895318,493,0,1382,C0O15C4O22C12O37C20O22C25O80C26O96C30O812C41O812C47O1342C48O1354C50O1370C55O1381,,
code-creation,LazyCompile,10,161417,0x1a7a75895708,28,_interopRequireDefault /Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/worker.js:39:32,0x1a7a75893660,~
code-source-info,0x1a7a75895708,492,882,946,C0O892C4O910C14O923C21O939C27O944,,
code-creation,Eval,10,161625,0x1a7a75895eb0,5, /Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/constants.js:1:1,0x1a7a75895d68,~
script-source,494,/Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/constants.js,'use strict';\n\nObject.defineProperty(exports\x2C '__esModule'\x2C {\n  value: true\n});\nexports.default = void 0;\n/**\n * Copyright (c) Meta Platforms\x2C Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/*\n * This file exports a set of constants that are used for Jest's haste map\n * serialization. On very large repositories\x2C the haste map cache becomes very\n * large to the point where it is the largest overhead in starting up Jest.\n *\n * This constant key map allows to keep the map smaller without having to build\n * a custom serialization library.\n */\n\n/* eslint-disable sort-keys */\nconst constants = {\n  /* dependency serialization */\n  DEPENDENCY_DELIM: '\\0'\x2C\n  /* file map attributes */\n  ID: 0\x2C\n  MTIME: 1\x2C\n  SIZE: 2\x2C\n  VISITED: 3\x2C\n  DEPENDENCIES: 4\x2C\n  SHA1: 5\x2C\n  /* module map attributes */\n  PATH: 0\x2C\n  TYPE: 1\x2C\n  /* module types */\n  MODULE: 0\x2C\n  PACKAGE: 1\x2C\n  /* platforms */\n  GENERIC_PLATFORM: 'g'\x2C\n  NATIVE_PLATFORM: 'native'\n};\n/* eslint-enable */\nvar _default = constants;\nexports.default = _default;\n
code-source-info,0x1a7a75895eb0,494,0,1116,C0O0C4O1116,,
code-creation,Function,10,161667,0x1a7a75896068,44, /Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/constants.js:1:1,0x1a7a75895e28,~
code-source-info,0x1a7a75896068,494,0,1116,C0O15C4O22C12O37C20O22C25O80C26O96C30O703C35O1077C36O1088C38O1104C43O1115,,
code-creation,Eval,10,162209,0x1a7a75896c20,5, /Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/lib/dependencyExtractor.js:1:1,0x1a7a75896a38,~
script-source,495,/Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/lib/dependencyExtractor.js,'use strict';\n\nObject.defineProperty(exports\x2C '__esModule'\x2C {\n  value: true\n});\nexports.extractor = void 0;\n/**\n * Copyright (c) Meta Platforms\x2C Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst NOT_A_DOT = '(?<!\\\\.\\\\s*)';\nconst CAPTURE_STRING_LITERAL = pos => `([\\`'"])([^'"\\`]*?)(?:\\\\${pos})`;\nconst WORD_SEPARATOR = '\\\\b';\nconst LEFT_PARENTHESIS = '\\\\(';\nconst RIGHT_PARENTHESIS = '\\\\)';\nconst WHITESPACE = '\\\\s*';\nconst OPTIONAL_COMMA = '(:?\x2C\\\\s*)?';\nfunction createRegExp(parts\x2C flags) {\n  return new RegExp(parts.join('')\x2C flags);\n}\nfunction alternatives(...parts) {\n  return `(?:${parts.join('|')})`;\n}\nfunction functionCallStart(...names) {\n  return [\n    NOT_A_DOT\x2C\n    WORD_SEPARATOR\x2C\n    alternatives(...names)\x2C\n    WHITESPACE\x2C\n    LEFT_PARENTHESIS\x2C\n    WHITESPACE\n  ];\n}\nconst BLOCK_COMMENT_RE = /\\/\\*[^]*?\\*\\//g;\nconst LINE_COMMENT_RE = /\\/\\/.*/g;\nconst REQUIRE_OR_DYNAMIC_IMPORT_RE = createRegExp(\n  [\n    ...functionCallStart('require'\x2C 'import')\x2C\n    CAPTURE_STRING_LITERAL(1)\x2C\n    WHITESPACE\x2C\n    OPTIONAL_COMMA\x2C\n    RIGHT_PARENTHESIS\n  ]\x2C\n  'g'\n);\nconst IMPORT_OR_EXPORT_RE = createRegExp(\n  [\n    '\\\\b(?:import|export)\\\\s+(?!type(?:of)?\\\\s+)(?:[^\\'"]+\\\\s+from\\\\s+)?'\x2C\n    CAPTURE_STRING_LITERAL(1)\n  ]\x2C\n  'g'\n);\nconst JEST_EXTENSIONS_RE = createRegExp(\n  [\n    ...functionCallStart(\n      'jest\\\\s*\\\\.\\\\s*(?:requireActual|requireMock|genMockFromModule|createMockFromModule)'\n    )\x2C\n    CAPTURE_STRING_LITERAL(1)\x2C\n    WHITESPACE\x2C\n    OPTIONAL_COMMA\x2C\n    RIGHT_PARENTHESIS\n  ]\x2C\n  'g'\n);\nconst extractor = {\n  extract(code) {\n    const dependencies = new Set();\n    const addDependency = (match\x2C _\x2C dep) => {\n      dependencies.add(dep);\n      return match;\n    };\n    code\n      .replace(BLOCK_COMMENT_RE\x2C '')\n      .replace(LINE_COMMENT_RE\x2C '')\n      .replace(IMPORT_OR_EXPORT_RE\x2C addDependency)\n      .replace(REQUIRE_OR_DYNAMIC_IMPORT_RE\x2C addDependency)\n      .replace(JEST_EXTENSIONS_RE\x2C addDependency);\n    return dependencies;\n  }\n};\nexports.extractor = extractor;\n
code-source-info,0x1a7a75896c20,495,0,2099,C0O0C4O2099,,
code-creation,Function,10,162334,0x1a7a75896f88,319, /Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/lib/dependencyExtractor.js:1:1,0x1a7a75896b98,~
code-source-info,0x1a7a75896f88,495,0,2099,C0O0C48O15C52O22C60O37C68O22C73O80C74O98C78O318C80O318C82O365C87O430C89O430C91O462C93O462C95O495C98O521C100O521C102O552C105O919C109O919C111O961C115O961C117O1009C123O1034C128O1034C138O1078C153O1109C164O1125C175O1145C185O1009C190O1009C192O1205C203O1302C217O1205C222O1205C224O1369C227O1394C231O1394C241O1516C256O1547C267O1563C278O1583C288O1369C293O1369C295O1633C300O1637C311O2068C313O2086C318O2098,,
tick,0x100c8caec,162375,0,0x0,0,0x0,0x1a7a758828a5,0x1a7a75882334,0x1a7a758813e8,0x1fa4d1d7cd38,0x1a7a7588caec,0x1a7a7588c930,0x1a7a75893a20,0x1a7a7588893e,0x1a7a758824d5,0x1a7a758813e8,0x1fa4d1d7cd38,0x1a7a7588caec,0x1a7a7588c930,0x1a7a75892470,0x1a7a75892267,0x1012a3972274,0x1a7a75892025,0x1a7a7588e68c
code-creation,LazyCompile,10,162459,0x1a7a75897618,85,functionCallStart /Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/lib/dependencyExtractor.js:27:27,0x1a7a75896cf0,~
code-source-info,0x1a7a75897618,495,747,893,C0O747C3O762C12O775C23O790C40O810C54O838C65O854C76O876C84O891,,
code-creation,LazyCompile,10,162500,0x1a7a75897780,30,alternatives /Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/lib/dependencyExtractor.js:24:22,0x1a7a75896ca0,~
code-source-info,0x1a7a75897780,495,671,720,C0O671C3O686C6O705C14O705C29O718,,
code-creation,LazyCompile,10,162542,0x1a7a75897880,16,CAPTURE_STRING_LITERAL /Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/lib/dependencyExtractor.js:15:32,0x1a7a75896d40,~
code-source-info,0x1a7a75897880,495,365,405,C0O372C5O399C15O405,,
code-creation,LazyCompile,10,162542,0x1a7a75897978,29,createRegExp /Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/lib/dependencyExtractor.js:21:22,0x1a7a75896c50,~
code-source-info,0x1a7a75897978,495,587,649,C0O606C4O630C12O630C23O613C28O647,,
code-creation,LazyCompile,10,162625,0x1a7a75897ae0,43,path /Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/worker.js:15:14,0x1a7a758934f8,~
code-source-info,0x1a7a75897ae0,492,265,388,C0O265C8O285C21O309C26O285C30O285C32O329C36O334C40O374C42O386,,
code-creation,LazyCompile,10,162625,0x1a7a75897c88,10, node:internal/modules/cjs/helpers:36:66,0x30e767715df8,~
code-source-info,0x1a7a75897c88,453,956,981,C0O968C2O974C9O980,,
code-creation,LazyCompile,10,162667,0x1a7a75897e00,129,compileForPublicLoader node:internal/bootstrap/loaders:265:25,0x41ccf058ec8,~
code-source-info,0x1a7a75897e00,15,8056,8728,C0O8075C6O8219C16O8262C33O8225C38O8219C39O8299C44O8299C48O8341C54O8530C61O8561C69O8530C75O8585C80O8603C90O8619C93O8635C98O8619C102O8601C106O8660C111O8660C115O8685C120O8685C124O8716C128O8724,,
code-creation,LazyCompile,10,162709,0x1a7a758980b0,170,getESMFacade node:internal/bootstrap/loaders:283:15,0x41ccf058f18,~
code-source-info,0x1a7a758980b0,15,8744,9494,C0O8744C8O8762C14O8782C18O8789C19O8817C29O8817C34O8802C39O8935C46O8967C53O8935C58O9001C61O9014C70O9040C72O9040C74O9070C81O9095C86O9070C91O9112C101O9112C106O9160C108O9212C121O9174C126O9172C130O9408C135O9415C140O9415C144O9439C149O9446C159O9446C165O9483C169O9490,,
code-creation,LazyCompile,10,162750,0x1a7a758984b8,40, node:internal/bootstrap/loaders:294:15,0x1a7a75897f98,~
code-source-info,0x1a7a758984b8,15,9239,9334,C0O9252C5O9260C10O9260C14O9288C24O9309C27O9317C32O9288C39O9333,,
code-creation,LazyCompile,10,162834,0x1a7a758985f0,89,syncExports node:internal/bootstrap/loaders:308:14,0x41ccf058f90,~
code-source-info,0x1a7a758985f0,15,9801,10134,C0O9829C5O9854C11O9883C13O9896C17O9888C22O9938C24O9943C28O9956C30O9971C35O9986C37O10009C42O10016C51O10068C54O10080C59O10106C67O10068C73O10016C79O9905C84O9870C88O10133,,
code-creation,LazyCompile,10,162834,0x1a7a75898760,35,getOwn node:internal/bootstrap/loaders:189:16,0x41ccf058ad0,~
code-source-info,0x1a7a75898760,15,5686,5840,C0O5722C5O5729C14O5783C26O5783C34O5838,,
code-creation,Function,11,162959,0x110056fa0,384,getOwn node:internal/bootstrap/loaders:189:16,0x41ccf058ad0,^
code-source-info,0x110056fa0,15,5686,5840,,,
code-creation,Function,11,162959,0x110057180,272,setOwnProperty node:internal/util:548:24,0x1012a39478a8,^
code-source-info,0x110057180,21,15106,15273,,,
code-creation,Function,11,162959,0x110057300,352,isURL node:internal/url:594:15,0x28e4ce8f4630,^
code-source-info,0x110057300,77,16262,16343,,,
code-creation,Function,11,163000,0x1100574c0,200,isUint8Array node:internal/util/types:13:22,0x1012a394d190,^
code-source-info,0x1100574c0,23,257,342,,,
code-creation,Function,11,163000,0x110057600,304,canBeRequiredByUsers node:internal/bootstrap/loaders:249:30,0x41ccf058dd8,^
code-source-info,0x110057600,15,7551,7648,,,
code-creation,Function,11,163042,0x1100577a0,3040,basename node:path:1305:11,0x28e4ce8cd300,^
code-source-info,0x1100577a0,74,39558,41977,,,
code-creation,Function,11,163084,0x1100583e0,496, node:internal/fs/utils:712:40,0x25dc1a84a030,^
code-source-info,0x1100583e0,80,19365,19486,,,
code-creation,Function,11,163084,0x110058640,696,splitRoot node:fs:2533:33,0x28e4ce8e7788,^
code-source-info,0x110058640,76,67925,68117,,,
code-creation,LazyCompile,10,163167,0x1a7a75898c48,263,_interopRequireWildcard /Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/worker.js:50:33,0x1a7a75893728,~
code-source-info,0x1a7a75898c48,492,1305,2191,C0O1328C6O1348C8O1359C14O1377C16O1388C17O1395C33O1477C40O1494C46O1499C47O1518C50O1518C55O1559C57O1578C62O1578C69O1607C74O1607C79O1616C80O1636C82O1674C86O1681C92O1699C96O1706C101O1750C114O1743C127O1743C128O1761C130O1769C135O1786C139O1793C144O1803C149O1818C154O1818C162O1853C166O1885C170O1892C175O1892C185O1949C187O1967C193O1979C199O1995C203O2002C217O2002C224O2060C226O2077C229O2072C236O1734C239O2104C241O2119C245O2128C249O2151C254O2151C260O2175C262O2189,,
code-creation,LazyCompile,10,163250,0x1a7a75898f30,50,_getRequireWildcardCache /Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/worker.js:42:34,0x1a7a758936b0,~
code-source-info,0x1a7a75898f30,492,980,1272,C0O980C5O998C12O1033C13O1045C14O1072C18O1072C23O1072C25O1112C29O1112C34O1112C36O1129C40O1162C45O1256C49O1270,,
code-creation,LazyCompile,10,163292,0x1a7a75899070,11,_getRequireWildcardCache /Users/miriam/m_documents/repos/tax-column/node_modules/jest-haste-map/build/worker.js:46:47,0x1a7a75898e80,~
code-source-info,0x1a7a75899070,492,1173,1255,C0O1193C10O1251,,
tick,0x195a849cc,163334,0,0x0,3,0x0,0x1a7a75898c7a,0x1a7a75897afa,0x1a7a75893a29,0x1a7a7588893e,0x1a7a758824d5,0x1a7a758813e8,0x1fa4d1d7cd38,0x1a7a7588caec,0x1a7a7588c930,0x1a7a75892470,0x1a7a75892267,0x1012a3972274,0x1a7a75892025,0x1a7a7588e68c
code-creation,LazyCompile,10,163375,0x1a7a75899150,25,exitProcess /Users/miriam/m_documents/repos/tax-column/node_modules/jest-worker/build/workers/processChild.js:124:21,0x1a7a7588a850,~
code-source-info,0x1a7a75899150,490,3319,3446,C0O3393C4O3401C14O3427C17O3401C24O3445,,
code-creation,LazyCompile,10,163542,0x1a7a75899290,307,removeListener node:events:676:28,0x1012a3972ce0,~
code-source-info,0x1a7a75899290,29,19689,20960,C0O19714C3O19714C7O19766C12O19781C14O19815C16O19827C17O19848C19O19854C23O19868C25O19900C27O19912C28O19920C30O19929C35O19950C42O19959C47O19983C54O19994C59O20007C64O20024C66O20039C71O20039C75O20037C81O20084C83O20098C85O20126C91O20159C99O20193C114O20159C121O20239C127O20296C130O20327C134O20334C138O20341C139O20341C144O20364C146O20372C152O20376C159O20396C163O20400C170O20409C175O20437C180O20463C182O20348C187O20309C190O20501C191O20514C196O20529C198O20541C199O20551C200O20564C205O20586C210O20586C216O20620C222O20661C228O20673C233O20697C240O20671C246O20719C251O20719C256O20774C263O20781C268O20798C269O20817C272O20811C276O20842C282O20887C299O20887C304O20942C306O20954,,
code-creation,LazyCompile,10,163625,0x1a7a75899570,64,stopListeningIfSignal node:internal/process/signal:43:31,0x3ff6535f8fd8,~
script-source,133,node:internal/process/signal,'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  SafeMap\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n} = require('internal/errors');\n\nconst { signals } = internalBinding('constants').os;\n\nlet Signal;\nconst signalWraps = new SafeMap();\n\nfunction isSignal(event) {\n  return typeof event === 'string' && signals[event] !== undefined;\n}\n\n// Detect presence of a listener for the special signal types\nfunction startListeningIfSignal(type) {\n  if (isSignal(type) && !signalWraps.has(type)) {\n    if (Signal === undefined)\n      Signal = internalBinding('signal_wrap').Signal;\n    const wrap = new Signal();\n\n    wrap.unref();\n\n    wrap.onsignal = FunctionPrototypeBind(process.emit\x2C process\x2C type\x2C type);\n\n    const signum = signals[type];\n    const err = wrap.start(signum);\n    if (err) {\n      wrap.close();\n      throw errnoException(err\x2C 'uv_signal_start');\n    }\n\n    signalWraps.set(type\x2C wrap);\n  }\n}\n\nfunction stopListeningIfSignal(type) {\n  const wrap = signalWraps.get(type);\n  if (wrap !== undefined && process.listenerCount(type) === 0) {\n    wrap.close();\n    signalWraps.delete(type);\n  }\n}\n\nmodule.exports = {\n  startListeningIfSignal\x2C\n  stopListeningIfSignal\x2C\n};\n
code-source-info,0x1a7a75899570,133,936,1101,C0O960C5O972C10O972C16O985C21O1019C26O1019C33O1039C38O1057C43O1057C47O1070C52O1082C57O1088C63O1100,,
code-creation,LazyCompile,10,163667,0x1a7a75899880,30,onRemoveListener node:child_process:182:57,0x2b3d46cd0af0,~
code-source-info,0x1a7a75899880,456,5441,5530,C0O5454C2O5463C9O5485C14O5503C19O5511C24O5511C29O5529,,
code-creation,LazyCompile,10,163709,0x1a7a75899988,56,unrefCounted node:internal/child_process:543:15,0x30e7677288f8,~
code-source-info,0x1a7a75899988,457,14202,14328,C0O14211C3O14221C9O14222C14O14228C21O14243C26O14270C28O14275C32O14284C37O14284C41O14304C49O14304C55O14327,,
profiler,end
delete,MemoryChunk,0x2da83afc0000
delete,MemoryChunk,0x41ccf040000
delete,MemoryChunk,0x1012a3940000
delete,MemoryChunk,0x35d297180000
delete,MemoryChunk,0x26f39880000
delete,MemoryChunk,0x28e4ce8c0000
delete,MemoryChunk,0x25dc1a840000
delete,MemoryChunk,0x250200ac0000
delete,MemoryChunk,0x3ff6535c0000
delete,MemoryChunk,0x201f74140000
delete,MemoryChunk,0x2b072d780000
delete,MemoryChunk,0x12324f080000
delete,MemoryChunk,0x176e57340000
delete,MemoryChunk,0x202f02840000
delete,MemoryChunk,0x30e767700000
delete,MemoryChunk,0x2b3d46cc0000
delete,MemoryChunk,0x1fa4d1d40000
delete,MemoryChunk,0x1a7a75880000
delete,MemoryChunk,0x110000000
delete,MemoryChunk,0x110040000
delete,MemoryChunk,0x13b39800000
delete,MemoryChunk,0x30b515080000
delete,MemoryChunk,0x3c2d33740000
delete,MemoryChunk,0x2edda4b00000
delete,MemoryChunk,0x1efde4180000
delete,MemoryChunk,0x1c4d73ac0000
delete,MemoryChunk,0x2c33bd9c0000
